<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Matlab微分和导数</h1><div style="width:100%;float:left;" class="article-content">   
 <p>MATLAB提供用于计算符号导数的<code>diff</code>命令。 以最简单的形式，将要微分的功能传递给<code>diff</code>命令作为参数。</p> 
 <p>例如，计算函数的导数的方程式 - </p> 
 <p><img src="http://www.yiibai.com/uploads/images/201710/0810/733161015_55975.png" alt=""></p> 
 <p><strong>例子</strong></p> 
 <p>创建脚本文件并在其中键入以下代码 -</p> 
 <pre><code class="lang-matlab">syms t
f = 3*t^2 + 2*t^(-2);
diff(f)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">Trial&gt;&gt; syms t
f = 3*t^2 + 2*t^(-2);
diff(f)

ans =

6*t - 4/t^3
</code></pre> 
 <p>以下是使用Octave 计算的写法 -</p> 
 <pre><code class="lang-matlab">pkg load symbolic
symbols

t = sym("t");
f = 3*t^2 + 2*t^(-2);
differentiate(f,t)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">ans =

6*t - 4/t^3
</code></pre> 
 <h2 id="h2-u57FAu672Cu5FAEu5206u89C4u5219u7684u9A8Cu8BC1"><a name="基本微分规则的验证" class="reference-link"></a><span class="header-link octicon octicon-link"></span>基本微分规则的验证</h2>
 <p>下面简要说明微分规则的各种方程或规则，并验证这些规则。 为此，我们将写一个第一阶导数<code>f'(x)</code>和二阶导数<code>f“(x)</code>。</p> 
 <p>以下是微分的规则 -</p> 
 <p><strong>规则 - 1</strong></p> 
 <p>对于任何函数<code>f</code>和<code>g</code>，任何实数<code>a</code>和<code>b</code>是函数的导数：</p> 
 <p><em>h(x) = af(x) + bg(x)</em>相对于<code>x</code>，由<em>h’(x) = af’(x) + bg’(x)</em>给出。</p> 
 <p><strong>规则 - 2</strong></p> 
 <p><strong>sum</strong>和<em>subtraction</em>规则表述为：如果<code>f</code>和<code>g</code>是两个函数，则<code>f'</code>和<code>g'</code>分别是它们的导数，如下 - </p> 
 <pre><code>(f + g)' = f' + g'

(f - g)' = f' - g'
</code></pre>
 <p><strong>规则 - 3</strong></p> 
 <p><em>product</em>规则表述为：如果<code>f</code>和<code>g</code>是两个函数，则<code>f'</code>和<code>g'</code>分别是它们的导数，如下 - </p> 
 <pre><code>(f.g)' = f'.g + g'.f
</code></pre>
 <p><strong>规则 - 4</strong></p> 
 <p><em>quotient</em>规则表明，如果<code>f</code>和<code>g</code>是两个函数，则<code>f'</code>和<code>g'</code>分别是它们的导数，那么 -</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201710/0810/411161027_29927.png" alt=""></p> 
 <p><strong>规则 - 5</strong></p> 
 <p>多项式或基本次幂规则表述为：如果<code>y = f(x)= x^n</code>，则 - </p> 
 <p><img src="http://www.yiibai.com/uploads/images/201710/0810/486161028_91312.png" alt=""></p> 
 <p>这个规则的直接结果是任何常数的导数为零，即如果<code>y = k</code>，那么为任何常数 - </p> 
 <pre><code>f' = 0
</code></pre>
 <p><strong>规则 - 5</strong></p> 
 <p><em>chain</em>规则表述为 - 相对于<code>x</code>的函数<code>h(x)= f(g(x))</code>的函数的导数是 - </p> 
 <pre><code class="lang-matlab">h'(x)= f'(g(x)).g'(x)
</code></pre> 
 <p><strong>例子</strong><br>创建脚本文件并在其中键入以下代码 -</p> 
 <pre><code class="lang-matlab">syms x
syms t
f = (x + 2)*(x^2 + 3)
der1 = diff(f)
f = (t^2 + 3)*(sqrt(t) + t^3)
der2 = diff(f)
f = (x^2 - 2*x + 1)*(3*x^3 - 5*x^2 + 2)
der3 = diff(f)
f = (2*x^2 + 3*x)/(x^3 + 1)
der4 = diff(f)
f = (x^2 + 1)^17
der5 = diff(f)
f = (t^3 + 3* t^2 + 5*t -9)^(-6)
der6 = diff(f)
</code></pre> 
 <p>执行上面示例代码，得到 以下结果 - </p> 
 <pre><code class="lang-shell">f =
 (x^2 + 3)*(x + 2)

 der1 =
 2*x*(x + 2) + x^2 + 3

f =
 (t^(1/2) + t^3)*(t^2 + 3)

 der2 =
 (t^2 + 3)*(3*t^2 + 1/(2*t^(1/2))) + 2*t*(t^(1/2) + t^3)

f =
 (x^2 - 2*x + 1)*(3*x^3 - 5*x^2 + 2)

der3 =
 (2*x - 2)*(3*x^3 - 5*x^2 + 2) - (- 9*x^2 + 10*x)*(x^2 - 2*x + 1)

 f =
 (2*x^2 + 3*x)/(x^3 + 1)

der4 =
 (4*x + 3)/(x^3 + 1) - (3*x^2*(2*x^2 + 3*x))/(x^3 + 1)^2

f =
 (x^2 + 1)^17

der5 =
 34*x*(x^2 + 1)^16

f =
1/(t^3 + 3*t^2 + 5*t - 9)^6

der6 =
 -(6*(3*t^2 + 6*t + 5))/(t^3 + 3*t^2 + 5*t - 9)^7
</code></pre> 
 <p>以下是对上面示例的Octave写法 -</p> 
 <pre><code class="lang-matlab">pkg load symbolic
symbols
x=sym("x");
t=sym("t");
f = (x + 2)*(x^2 + 3) 
der1 = differentiate(f,x) 
f = (t^2 + 3)*(t^(1/2) + t^3) 
der2 = differentiate(f,t) 
f = (x^2 - 2*x + 1)*(3*x^3 - 5*x^2 + 2) 
der3 = differentiate(f,x) 
f = (2*x^2 + 3*x)/(x^3 + 1) 
der4 = differentiate(f,x) 
f = (x^2 + 1)^17 
der5 = differentiate(f,x) 
f = (t^3 + 3* t^2 + 5*t -9)^(-6) 
der6 = differentiate(f,t)
</code></pre> 
 <h2 id="h2--"><a name="指数，对数和三角函数的导数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>指数，对数和三角函数的导数</h2>
 <p>下表提供了常用指数，对数和三角函数的导数，</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201710/0810/558161043_36740.png" alt=""></p> 
 <p><strong>例子</strong><br>创建脚本文件并在其中键入以下代码 -</p> 
 <pre><code class="lang-matlab">syms x
y = exp(x)
diff(y)
y = x^9
diff(y)
y = sin(x)
diff(y)
y = tan(x)
diff(y)
y = cos(x)
diff(y)
y = log(x)
diff(y)
y = log10(x)
diff(y)
y = sin(x)^2
diff(y)
y = cos(3*x^2 + 2*x + 1)
diff(y)
y = exp(x)/sin(x)
diff(y)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">y =
 exp(x)
 ans =
 exp(x)


y =
x^9
 ans =
 9*x^8

y =
 sin(x)
 ans =
 cos(x)

y =
 tan(x)
ans =
 tan(x)^2 + 1

 y =
 cos(x)
 ans =
 -sin(x)

y =
 log(x)
 ans =
 1/x

y =
 log(x)/log(10)
 ans =
 1/(x*log(10))

y =
 sin(x)^2
  ans =
 2*cos(x)*sin(x)

 y =

cos(3*x^2 + 2*x + 1)
 ans =
 -sin(3*x^2 + 2*x + 1)*(6*x + 2)

y =
 exp(x)/sin(x)
 ans =
 exp(x)/sin(x) - (exp(x)*cos(x))/sin(x)^2
</code></pre> 
 <p>以下代码是上面代码的Octave写法 - </p> 
 <pre><code class="lang-shell">pkg load symbolic
symbols

x = sym("x");
y = Exp(x)
differentiate(y,x)

y = x^9
differentiate(y,x)

y = Sin(x)
differentiate(y,x)

y = Tan(x)
differentiate(y,x)

y = Cos(x)
differentiate(y,x)

y = Log(x)
differentiate(y,x)

% symbolic packages does not have this support
%y = Log10(x)
%differentiate(y,x)

y = Sin(x)^2
differentiate(y,x)

y = Cos(3*x^2 + 2*x + 1)
differentiate(y,x)

y = Exp(x)/Sin(x)
differentiate(y,x)
</code></pre> 
 <h2 id="h2-u8BA1u7B97u9AD8u9636u5BFCu6570"><a name="计算高阶导数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>计算高阶导数</h2>
 <p>要计算函数<code>f</code>的较高导数，可使用<code>diff(f，n)</code>。</p> 
 <p>计算函数的二阶导数公式为 - </p> 
 <p><img src="http://www.yiibai.com/uploads/images/201710/0810/299161046_24666.png" alt=""></p> 
 <pre><code class="lang-matlab">f = x*exp(-3*x);
diff(f, 2)
</code></pre> 
 <p>MATLAB执行上面代码将返回以下结果 -</p> 
 <pre><code class="lang-shell">ans =
9*x*exp(-3*x) - 6*exp(-3*x)
</code></pre> 
 <p>以下是使用Octave重写上面示例，代码如下 - </p> 
 <pre><code class="lang-matlab">pkg load symbolic
symbols

x = sym("x");
f = x*Exp(-3*x);

differentiate(f, x, 2)
</code></pre> 
 <p><strong>例子</strong><br>在这个例子中，要解决一个问题。由给定函数<code>y = f(x)= 3sin(x)+ 7cos(5x)</code>，来找出方程<code>f“+ f = -5cos(2x)</code>是否成立。</p> 
 <p>创建脚本文件并在其中键入以下代码 -</p> 
 <pre><code class="lang-matlab">syms x
y = 3*sin(x)+7*cos(5*x);  % defining the function
lhs = diff(y,2)+y;        %evaluting the lhs of the equation
rhs = -5*cos(2*x);        %rhs of the equation
if(isequal(lhs,rhs))
    disp('Yes, the equation holds true');
else
    disp('No, the equation does not hold true');
end
disp('Value of LHS is: '), disp(lhs);
</code></pre> 
 <p>运行文件时，会显示以下结果 -</p> 
 <pre><code class="lang-shell">No, the equation does not hold true
Value of LHS is: 
-168*cos(5*x)
</code></pre> 
 <p>以上是上面示例的Octave写法 - </p> 
 <pre><code class="lang-matlab">pkg load symbolic
symbols

x = sym("x");
y = 3*Sin(x)+7*Cos(5*x);           % defining the function
lhs = differentiate(y, x, 2) + y;  %evaluting the lhs of the equation
rhs = -5*Cos(2*x);                 %rhs of the equation

if(lhs == rhs)
    disp('Yes, the equation holds true');
else
    disp('No, the equation does not hold true');
end
disp('Value of LHS is: '), disp(lhs);
</code></pre> 
 <h2 id="h2-u67E5u627Eu66F2u7EBFu7684u6700u5927u548Cu6700u5C0Fu503C"><a name="查找曲线的最大和最小值" class="reference-link"></a><span class="header-link octicon octicon-link"></span>查找曲线的最大和最小值</h2>
 <p>如果正在搜索图形的局部最大值和最小值，基本上是在特定地点的函数图上或符号变量的特定值范围内查找最高点或最低点。</p> 
 <p>对于函数<code>y = f(x)</code>，图形具有零斜率的图上的点称为固定点。 换句话说，固定点是<code>f'(x)= 0</code>。</p> 
 <p>要找到微分的函数的固定点，需要将导数设置为零并求解方程。</p> 
 <p><strong>示例</strong></p> 
 <p>要找到函数<code>f(x)= 2x3 + 3x2 - 12x + 17</code>的固定点</p> 
 <p>可参考以下步骤 - </p> 
 <p>首先输入函数并绘制图，代码如下 - </p>   
 <pre><code class="lang-matlab">syms x
y = 2*x^3 + 3*x^2 - 12*x + 17;  % defining the function
ezplot(y)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <p><img src="http://www.yiibai.com/uploads/images/201710/0810/245161054_81290.png" alt=""></p> 
 <p>以上是上面示例的Octave写法 - </p> 
 <pre><code class="lang-matlab">pkg load symbolic
symbols

x = sym('x');
y = inline("2*x^3 + 3*x^2 - 12*x + 17");

ezplot(y)
print -deps graph.eps
</code></pre> 
 <p>我们的目标是在图上找到一些局部最大值和最小值，假设要找到图中间隔在<code>[-2,2]</code>的局部最大值和最小值。参考以下示例代码 -</p> 
 <pre><code class="lang-matlab">syms x
y = 2*x^3 + 3*x^2 - 12*x + 17;  % defining the function
ezplot(y, [-2, 2])
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <p><img src="http://www.yiibai.com/uploads/images/201710/0810/332161057_95069.png" alt=""></p> 
 <p>以下是上面示例的Octave写法 - </p> 
 <pre><code class="lang-matlab">pkg load symbolic
symbols

x = sym('x');
y = inline("2*x^3 + 3*x^2 - 12*x + 17");

ezplot(y, [-2, 2])
print -deps graph.eps
</code></pre> 
 <p>接下来，需要计算导数。</p> 
 <pre><code class="lang-matlab">g = diff(y)
</code></pre> 
 <p>MATLAB执行代码并返回以下结果 -</p> 
 <pre><code class="lang-shell">g =

6*x^2 + 6*x - 12
</code></pre> 
 <p>以下是上面示例的Octave写法 - </p> 
 <pre><code class="lang-matlab">pkg load symbolic
symbols

x = sym("x");

y = 2*x^3 + 3*x^2 - 12*x + 17;
g = differentiate(y,x)
</code></pre> 
 <p>接下来求解导数函数<code>g</code>，得到它变为零的值。</p> 
 <pre><code class="lang-matlab">s = solve(g)
</code></pre> 
 <p>MATLAB执行代码并返回以下结果 -</p> 
 <pre><code class="lang-shell">s = 
     1
    -2
</code></pre> 
 <p>以下是上面示例的Octave写法 - </p> 
 <pre><code class="lang-matlab">pkg load symbolic
symbols

x = sym("x");

y = 2*x^3 + 3*x^2 - 12*x + 17;
g = differentiate(y,x)
roots([6, 6, -12])
</code></pre> 
 <p>这与我们设想情节一致。 因此，要评估临界点<code>x = 1，-2</code>处的函数<code>f</code>。可以使用<code>subs</code>命令替换符号函数中的值。</p> 
 <pre><code class="lang-matlab">subs(y, 1), subs(y, -2)
</code></pre> 
 <p>MATLAB执行代码并返回以下结果 -</p> 
 <pre><code class="lang-shell">ans =
 10
ans =
 37
</code></pre> 
 <p>以下是上面示例的Octave写法 - </p> 
 <pre><code class="lang-matlab">pkg load symbolic
symbols

x = sym("x");

y = 2*x^3 + 3*x^2 - 12*x + 17;
g = differentiate(y,x)

roots([6, 6, -12])

subs(y, x, 1), subs(y, x, -2)
</code></pre> 
 <p>因此，在间隔<code>[-2,2]</code>中函数<code>f(x)= 2x^3 + 3x^2 - 12x + 17</code>的最小值和最大值分别为<code>10</code>和<code>37</code>。</p> 
 <h2 id="h2-u6C42u89E3u5FAEu5206u65B9u7A0B"><a name="求解微分方程" class="reference-link"></a><span class="header-link octicon octicon-link"></span>求解微分方程</h2>
 <p>MATLAB提供了用于求解微分方程的<code>dsolve</code>命令。</p> 
 <p>找到单个方程的解的最基本的<code>dsolve</code>命令形式是 - </p> 
 <pre><code class="lang-matlab">dsolve('eqn')
</code></pre> 
 <p>其中<code>eqn</code>是用于输入方程式的文本串。</p> 
 <p>它返回一个符号解，其中包含一组任意常量，<code>MATLAB</code>标记<code>C1</code>，<code>C2</code>等等。<br>还可以为问题指定初始和边界条件，以逗号分隔的列表遵循以下公式：</p> 
 <pre><code>dsolve('eqn','cond1', 'cond2',…)
</code></pre>
 <p>为了使用<code>dsolve</code>命令，导数用<code>D</code>表示。例如，像<code>f'(t)= -2 * f + cost(t)</code>这样的等式输入为 -</p> 
 <pre><code>'Df = -2*f + cos(t)'
</code></pre>
 <p>较高阶导数由<code>D</code>导数的顺序表示。</p> 
 <p>例如，方程<code>f"(x) + 2f'(x) = 5sin3x</code>应输入为 -</p> 
 <pre><code>'D2y + 2Dy = 5*sin(3*x)'
</code></pre>
 <p>下面来看一个一阶微分方程的简单例子：<code>y'= 5y</code>。</p> 
 <pre><code>s = dsolve('Dy = 5*y')
</code></pre>
 <p>MATLAB执行代码并返回以下结果 -</p> 
 <pre><code class="lang-shell">s =
 C2*exp(5*t)
</code></pre> 
 <p>再来一个二阶微分方程的例子：<code>y“-y = 0，y(0)= -1，y'(0)= 2</code>。</p> 
 <pre><code class="lang-matlab">dsolve('D2y - y = 0','y(0) = -1','Dy(0) = 2')
</code></pre> 
 <p>MATLAB执行代码并返回以下结果 -</p> 
 <pre><code class="lang-shell">ans =
 exp(t)/2 - (3*exp(-t))/2
</code></pre>
 <br>      
</div></body></html>