<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Scala提取器</h1><div style="width:100%;float:left;" class="article-content">   
 <p>Scala中的提取器是一个拥有称为<code>unapply</code>方法，并使用<code>unapply</code>方法作为其成员之一的对象。 该<code>unapply</code>方法的目的是匹配一个值并将其分开。 通常，提取器对象还定义了一种用于构建值的双重方法，但这不是必需的。</p> 
 <p><strong>示例</strong></p> 
 <p>下面举个例子来定义<code>apply</code>和<code>unapply</code>方法。<code>apply</code>方法与<code>Test</code>转换为可应用于括号中的参数的对象，与<code>apply</code>方法相同。所以可以写<code>Test(“Maxsu”，“gmail.com”)</code>来构造字符串<code>“<a target="_blank" href="mailto:Maxsu@gmail.com">Maxsu@gmail.com</a>”</code>。</p> 
 <p><code>unapply</code>方法是将<code>Test</code>类转换为提取器，并反转了应用的构建过程。在应用两个字符串，并形成一个电子邮件地址字符串，取消应用接收电子邮件地址并返回潜在的两个字符串：地址的用户和域。</p> 
 <p><strong>语法</strong></p> 
 <pre><code class="lang-scala">unapply("Maxsu@gmail.com") equals Some("Maxsu", "gmail.com")
unapply("Maxsu Ali") equals None
</code></pre> 
 <p>以下示例程序显示电子邮件地址的提取对象。</p> 
 <pre><code class="lang-scala">object Demo {
   def main(args: Array[String]) {
      println ("Apply method : " + apply("Maxsu", "gmail.com"));
      println ("Unapply method : " + unapply("Maxsu@gmail.com"));
      println ("Unapply method : " + unapply("Maxsu Ali"));
   }

   // The injection method (optional)
   def apply(user: String, domain: String) = {
      user +"@"+ domain
   }

   // The extraction method (mandatory)
   def unapply(str: String): Option[(String, String)] = {
      val parts = str split "@"

      if (parts.length == 2){
         Some(parts(0), parts(1)) 
      } else {
         None
      }
   }
}
</code></pre> 
 <p>将上述程序保存在源文件：<em>Demo.scala</em>中，使用以下命令编译和执行此程序。</p> 
 <pre><code class="lang-shell">D:\&gt;scalac Demo.scala
D:\&gt;scala Demo
Apply method : Maxsu@gmail.com
Unapply method : Some((Maxsu,gmail.com))
Unapply method : None
</code></pre> 
 <h2 id="h2-u62BDu53D6u5668u6A21u5F0Fu5339u914D"><a name="抽取器模式匹配" class="reference-link"></a><span class="header-link octicon octicon-link"></span>抽取器模式匹配</h2>
 <p>当一个类的实例后跟括号为零个或多个参数的列表时，编译器会调用该实例上的<code>apply</code>方法。 可以在对象和类中定义<code>apply</code>方法。</p> 
 <p>如上所述，<code>unapply</code>方法的目的是提取正在寻找的特定值。当使用<code>match</code>语句比较提取器对象时，将自动执行<code>unapply</code>方法。</p> 
 <p>尝试以下示例程序 - </p>   
 <pre><code class="lang-scala">object Demo {
   def main(args: Array[String]) {
      val x = Demo(5)
      println(x)

      x match {
         case Demo(num) =&gt; println(x+" is bigger two times than "+num)

         //unapply is invoked
         case _ =&gt; println("i cannot calculate")
      }
   }
   def apply(x: Int) = x*2
   def unapply(z: Int): Option[Int] = if (z%2==0) Some(z/2) else None
}
</code></pre> 
 <p>将上述程序保存在源文件：<em>Demo.scala</em>中，使用以下命令编译和执行此程序。</p> 
 <pre><code class="lang-shell">D:\&gt;scalac Demo.scala
D:\&gt;scala Demo
10
10 is bigger two times than 5
</code></pre>
 <br>      
</div></body></html>