<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Scala类和对象</h1><div style="width:100%;float:left;" class="article-content">   
 <p>本章将介绍如何在Scala编程中使用类和对象。类是对象的蓝图(或叫模板)。定义一个类后，可以使用关键字<code>new</code>来创建一个类的对象。 通过对象可以使用定义的类的所有功能。</p> 
 <p>下面的图通过一个包含成员变量(<code>name</code> 和 <code>rollNo</code>)和成员方法(<code>setName()</code>和<code>setRollNo()</code>)的<code>Student</code>类的例子来演示类和对象。最后都是类的成员。类是一个模板的东西，而对象是真实存在的。 在下图中，<code>Student</code>是一个类，而具体学生：<em>Harini</em>, <em>John</em>, 和 <em>Maria</em> 是学生类的对象，这此对象有是名字和注册号。</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201708/2908/637160858_62598.jpg" alt=""></p> 
 <h2 id="h2-u7C7Bu57FAu7840"><a name="类基础" class="reference-link"></a><span class="header-link octicon octicon-link"></span>类基础</h2>
 <p>以下是在<code>Scala</code>中定义类的简单语法。这个类定义了两个变量<code>x</code>和<code>y</code>以及一个<code>move</code>方法，它没有返回值。</p> 
 <p>使用类的名称作为一个类构造函数，构造函数可以使用多个参数。 上面的代码定义了两个构造函数参数<code>xc</code>和<code>yc</code>; 它们在类的整个定义中都是可见的。</p> 
 <p><strong>语法</strong></p> 
 <pre><code class="lang-scala">class Point(xc: Int, yc: Int) {
   var x: Int = xc
   var y: Int = yc

   def move(dx: Int, dy: Int) {
      x = x + dx
      y = y + dy
      println ("Point x location : " + x);
      println ("Point y location : " + y);
   }
}
</code></pre> 
 <p>如本章前面所述，您可以使用关键字<code>new</code>来创建对象，然后访问类字段和方法，如下例所示：</p> 
 <pre><code class="lang-scala">import java.io._

class Point(val xc: Int, val yc: Int) {
   var x: Int = xc
   var y: Int = yc

   def move(dx: Int, dy: Int) {
      x = x + dx
      y = y + dy
      println ("Point x location : " + x);
      println ("Point y location : " + y);
   }
}

object Demo {
   def main(args: Array[String]) {
      val pt = new Point(10, 20);

      // Move to a new location
      pt.move(10, 10);
   }
}
</code></pre> 
 <p>将上述程序保存在<em>Demo.scala</em>中，并使用以下命令编译和执行此程序。</p> 
 <pre><code class="lang-shell">D:\software\scala-2.12.3\bin&gt;scalac Demo.scala

D:\software\scala-2.12.3\bin&gt;scala Demo
Point x location : 20
Point y location : 30

D:\software\scala-2.12.3\bin&gt;
</code></pre> 
 <h2 id="h2-u6269u5C55u7C7B"><a name="扩展类" class="reference-link"></a><span class="header-link octicon octicon-link"></span>扩展类</h2>
 <p>在Scala中，我们可以扩展一个Scala类，使用与Java中相同的方式设计继承的类(使用<code>extends</code>关键字)，但有两个限制：方法重写需要<code>override</code>关键字，只有主构造函数可以通过参数调用基类构造函数。让我们扩展上面的类，并增加一个类的方法。</p> 
 <p><strong>例子</strong></p> 
 <p>让我们使用两个类<code>Point</code>作为一个例子(与上面一样)和<code>Location</code>类，<code>Location</code>类是一个使用<code>extends</code>关键字创建的继承类。 这样的“扩展”子句有两个效果：它使得<code>Location</code>类从<code>Point</code>类继承所有非私有成员，并且使类型<code>Location</code>成为<code>Point</code>类类型的子类型。 所以<code>Point</code>类被称为超类(父类)，<code>Location</code>类被称为子类。扩展一个类并继承父类的所有功能称为继承，但Scala允许只从一个类继承(不支持多继承)。</p> 
 <blockquote> 
  <p>注意 - 在<code>Point</code>类中的<code>move()</code>方法和<code>Location</code>类中的<code>move()</code>方法不会覆盖<code>move</code>的相应定义，因为它们是不同的定义(例如，前者采用两个参数，后者采用三个参数)。</p> 
 </blockquote> 
 <p>参考以下示例程序来实现继承 - </p> 
 <pre><code class="lang-scala">import java.io._

class Point(val xc: Int, val yc: Int) {
   var x: Int = xc
   var y: Int = yc

   def move(dx: Int, dy: Int) {
      x = x + dx
      y = y + dy
      println ("Point x location : " + x);
      println ("Point y location : " + y);
   }
}

class Location(override val xc: Int, override val yc: Int,
   val zc :Int) extends Point(xc, yc){
   var z: Int = zc

   def move(dx: Int, dy: Int, dz: Int) {
      x = x + dx
      y = y + dy
      z = z + dz
      println ("Point x location : " + x);
      println ("Point y location : " + y);
      println ("Point z location : " + z);
   }
}

object Demo {
   def main(args: Array[String]) {
      val loc = new Location(10, 20, 15);

      // Move to a new location
      loc.move(10, 10, 5);
   }
}
</code></pre> 
 <p>将上述程序保存在源文件：<em>Demo.scala</em>中，并使用以下命令编译和执行此程序，输出结果如下 - </p> 
 <pre><code class="lang-shell">D:\software\scala-2.12.3\bin&gt;scalac Demo.scala

D:\software\scala-2.12.3\bin&gt;scala Demo
Point x location : 20
Point y location : 30
Point z location : 20

D:\software\scala-2.12.3\bin&gt;
</code></pre> 
 <h2 id="h2-u9690u6027u7C7B"><a name="隐性类" class="reference-link"></a><span class="header-link octicon octicon-link"></span>隐性类</h2>
 <p>当类在范围内时，隐式类允许与类的主构造函数进行隐式对话。隐式类是一个标有<code>'implicit'</code>关键字的类。此功能在<em>Scala 2.10</em>中引入。</p> 
 <blockquote> 
  <p>语法 - 以下是隐式类的语法。这里，隐式类始终位于对象范围内，所有方法定义都被允许，因为隐式类不能是顶级类。</p> 
 </blockquote> 
 <p><strong>语法</strong></p>   
 <pre><code class="lang-scala">object &lt;object name&gt; {
   implicit class &lt;class name&gt;(&lt;Variable&gt;: Data type) {
      def &lt;method&gt;(): Unit =
   }
}
</code></pre> 
 <p><strong>例子</strong></p> 
 <p>下面演示如何使用隐式类，创建一个名称为<em>IntTimes</em>的隐式类，并定义一个<code>times()</code>方法。<code>times()</code>包含一个循环事务，它将按给定的次数执行语句。假设要执行<code>4</code>次<code>println(“”Hello“)</code>语句。</p> 
 <p>以下是示例程序代码。在这个例子中，使用了两个对象类(<em>Run</em> 和 <em>Demo</em>)，将这两个类保存在不同的文件中，名称如下 - </p> 
 <p><em>Run.scala</em> - 将以下程序保存在源文件：<em>Run.scala</em> 中 </p> 
 <pre><code class="lang-scala">object Run {
   implicit class IntTimes(x: Int) {
      def times [A](f: =&gt;A): Unit = {
         def loop(current: Int): Unit =

         if(current &gt; 0){
            f
            loop(current - 1)
         }
         loop(x)
      }
   }
}
</code></pre> 
 <p><strong>Demo.scala</strong> - 将以下程序保存在源文件：<em>Demo.scala</em> 中 -</p> 
 <pre><code class="lang-scala">import Run._

object Demo {
   def main(args: Array[String]) {
      4 times println("hello")
   }
}
</code></pre> 
 <p>用于以下命令编译和执行这两个程序，输出结果如下 - </p> 
 <pre><code class="lang-shell">D:\software\scala-2.12.3\bin&gt;scalac Demo.scala

D:\software\scala-2.12.3\bin&gt;scala Demo
hello
hello
hello
hello

D:\software\scala-2.12.3\bin&gt;
</code></pre> 
 <p><strong>注 </strong>- </p> 
 <ul> 
  <li>隐式类必须在另一个类/对象/特征中定义(不在顶层)。</li>
  <li>隐式类在其构造函数中只能使用一个非默认参数。</li>
  <li>隐式类作用域中不可以具有与隐式类相同名称的的任何方法，成员或对象。</li>
 </ul> 
 <h2 id="h2-u5355u4F8Bu5BF9u8C61"><a name="单例对象" class="reference-link"></a><span class="header-link octicon octicon-link"></span>单例对象</h2>
 <p>Scala比Java更面向对象，因为在Scala中不能拥有静态成员，Scala它使用单例对象。单例是一种只能有一个实例的对象。使用<code>object</code>关键字对象而不是类关键字创建单例。由于无法实例化单例对象，因此无法将参数传递给主构造函数。下面列出Scala使用单例对象的所有示例。</p> 
 <p>以下是实现单例的示例程序 - </p> 
 <pre><code class="lang-scala">import java.io._

class Point(val xc: Int, val yc: Int) {
   var x: Int = xc
   var y: Int = yc

   def move(dx: Int, dy: Int) {
      x = x + dx
      y = y + dy
   }
}

object Demo {
   def main(args: Array[String]) {
      val point = new Point(10, 20)
      printPoint

      def printPoint{
         println ("Point x location : " + point.x);
         println ("Point y location : " + point.y);
      }
   }
}
</code></pre> 
 <p>将上述程序保存在源文件：<em>Demo.scala</em> 中，使用以下命令编译和执行此程序，输出结果如下 - </p> 
 <pre><code class="lang-shell">D:\software\scala-2.12.3\bin&gt;scalac Demo.scala

D:\software\scala-2.12.3\bin&gt;scala Demo
Point x location : 10
Point y location : 20
</code></pre>
 <br>      
</div></body></html>