<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Scala运算符</h1><div style="width:100%;float:left;" class="article-content">   
 <p>在Scala语言中，运算符是一个符号，告诉编译器执行特定的数学或逻辑函数。Scala语言提供丰富的内置运算符，并提供以下类型的运算符 - </p> 
 <ul> 
  <li>算术运算符</li>
  <li>关系运算符</li>
  <li>逻辑运算符</li>
  <li>按位运算符</li>
  <li>赋值运算符</li>
  <li>其它运算符</li>
 </ul> 
 <p>在本章中，我们将学习每个运算符的工作方式。</p> 
 <h2 id="h2-1-"><a name="1.算术运算符" class="reference-link"></a><span class="header-link octicon octicon-link"></span>1.算术运算符</h2>
 <p>下表显示了Scala支持的所有算术运算符。假设变量<code>A</code>的值是<code>10</code>，变量<code>B</code>的值是<code>20</code>，那么 -</p> 
 <table> 
  <thead> 
   <tr> 
    <th>运算符</th> 
    <th>描述</th> 
    <th>示例</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td><code>+</code></td> 
    <td>将两个操作数相加</td> 
    <td><code>A + B = 30</code></td> 
   </tr> 
   <tr> 
    <td><code>-</code></td> 
    <td>从第一个操作数减去第二个操作数</td> 
    <td><code>A − B = -10</code></td> 
   </tr> 
   <tr> 
    <td><code>*</code></td> 
    <td>将两个操作数相乘</td> 
    <td><code>A * B = 200</code></td> 
   </tr> 
   <tr> 
    <td><code>/</code></td> 
    <td>将第一个操作数除以第二个操作数</td> 
    <td></td> 
   </tr> 
   <tr> 
    <td><code>%</code></td> 
    <td>模数运算符和整数除法后的余数。</td> 
    <td><code>B % A = 0</code></td> 
   </tr> 
   <tr> 
    <td><code>++</code></td> 
    <td>递增运算符将整数值增加<code>1</code>。</td> 
    <td><code>A++ = 11</code></td> 
   </tr> 
   <tr> 
    <td><code>--</code></td> 
    <td>递减运算符将整数值减1。</td> 
    <td><code>A-- = 9</code></td> 
   </tr> 
  </tbody> 
 </table> 
 <p>创建一个源代码文件：<em>Demo.scala</em>，如下代码 - </p> 
 <pre><code class="lang-scala">object Demo {
   def main(args: Array[String]) {
      var a = 10;
      var b = 20;
      var c = 25;
      var d = 25;

      println("a + b = " + (a + b) );
      println("a - b = " + (a - b) );
      println("a * b = " + (a * b) );
      println("b / a = " + (b / a) );
      println("b % a = " + (b % a) );
      println("c % a = " + (c % a) );
   }
}
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">a + b = 30
a - b = -10
a * b = 200
b / a = 2
b % a = 0
c % a = 5
</code></pre> 
 <h2 id="h2-2-"><a name="2.关系运算符" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2.关系运算符</h2>
 <p>下表显示了Scala语言支持的关系运算符。假设变量<code>A=10</code>，变量<code>B=20</code>，则 -</p> 
 <table> 
  <thead> 
   <tr> 
    <th>运算符</th> 
    <th>描述</th> 
    <th>示例</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td><code>==</code></td> 
    <td>检查两个操作数的值是否相等。 如果相等，则条件成立。</td> 
    <td><code>(A == B)</code>结果为<code>false</code></td> 
   </tr> 
   <tr> 
    <td><code>!=</code></td> 
    <td>检查两个操作数的值是否相等。 如果值不相等，则条件成立。</td> 
    <td><code>(A != B)</code> 结果为<code>true</code></td> 
   </tr> 
   <tr> 
    <td><code>&gt;</code></td> 
    <td>检查左操作数的值是否大于右操作数的值。 如果是，则条件成立。</td> 
    <td><code>(A &gt; B)</code> 结果为<code>false</code></td> 
   </tr> 
   <tr> 
    <td><code>&lt;</code></td> 
    <td>检查左操作数的值是否小于右操作数的值。 如果是，则条件成立。</td> 
    <td><code>(A &lt; B)</code>结果为<code>true</code></td> 
   </tr> 
   <tr> 
    <td><code>&gt;=</code></td> 
    <td>检查左操作数的值是否大于等于右操作数的值。 如果是，则条件成立。</td> 
    <td><code>(A &gt;= B)</code> 结果为<code>false</code></td> 
   </tr> 
   <tr> 
    <td><code>&lt;=</code></td> 
    <td>检查左操作数的值是否小于等于右操作数的值。 如果是，则条件成立。</td> 
    <td><code>(A &lt;= B)</code>结果为<code>true</code></td> 
   </tr> 
  </tbody> 
 </table> 
 <p>创建一个源代码文件：<em>Demo.scala</em>，如下代码 - </p> 
 <pre><code class="lang-scala">object Demo {
   def main(args: Array[String]) {
      var a = 10;
      var b = 20;

      println("a == b = " + (a == b) );
      println("a != b = " + (a != b) );
      println("a &gt; b = " + (a &gt; b) );
      println("a &lt; b = " + (a &lt; b) );
      println("b &gt;= a = " + (b &gt;= a) );
      println("b &lt;= a = " + (b &lt;= a) );
   }
}
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">a == b = false
a != b = true
a &gt; b = false
a &lt; b = true
b &gt;= a = true
b &lt;= a = false
</code></pre> 
 <h2 id="h2-3-"><a name="3.逻辑运算符" class="reference-link"></a><span class="header-link octicon octicon-link"></span>3.逻辑运算符</h2>
 <p>下表显示了Scala支持的所有逻辑运算符。 假设变量<code>A=1</code>，变量<code>B=0</code>，则 -</p> 
 <table> 
  <thead> 
   <tr> 
    <th>运算符</th> 
    <th>描述</th> 
    <th>示例</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td><code>&amp;&amp;</code></td> 
    <td>逻辑与运算符。 如果两个操作数都不为零，则条件成立。</td> 
    <td><code>(A &amp;&amp; B)</code>结果为<code>false</code></td> 
   </tr> 
   <tr> 
    <td><img src="http://www.yiibai.com/uploads/images/201708/1408/134080847_73961.png" alt=""></td> 
    <td>称为逻辑或运算符。如果两个操作数中的任何一个非零，则条件成立。</td> 
    <td>(A<img src="http://www.yiibai.com/uploads/images/201708/1408/134080847_73961.png" alt=""> B)结果为<code>true</code></td> 
   </tr> 
   <tr> 
    <td><code>!</code></td> 
    <td>称为逻辑非运算符，它用于反转其操作数的逻辑状态。如果条件为真，则逻辑<code>NOT</code>运算符将使其结果为<code>false</code>。</td> 
   </tr> 
  </tbody> 
 </table> 
 <p><strong>示例：</strong>创建一个源文件：<code>Demo.scala</code>，代码如下 - </p> 
 <pre><code class="lang-scala">object Demo {
   def main(args: Array[String]) {
      var a = true;
      var b = false;

      println("a &amp;&amp; b = " + (a&amp;&amp;b) );

      println("a || b = " + (a||b) );

      println("!(a &amp;&amp; b) = " + !(a &amp;&amp; b) );
   }
}
</code></pre> 
 <p>执行上面代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">a &amp;&amp; b = false
a || b = true
!(a &amp;&amp; b) = true
</code></pre> 
 <h2 id="h2-4-"><a name="4.按位运算符" class="reference-link"></a><span class="header-link octicon octicon-link"></span>4.按位运算符</h2>
 <p>按位运算符对位进行操作，并执行逐位运算。 <code>＆</code>，<code>|</code>和<code>^</code>的真值表如下 -</p> 
 <table> 
  <thead> 
   <tr> 
    <th>p</th> 
    <th>q</th> 
    <th>p &amp; q</th> 
    <th>p/q</th> 
    <th>p ^ q</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>0</td> 
    <td>0</td> 
    <td>0</td> 
    <td>0</td> 
    <td>0</td> 
   </tr> 
   <tr> 
    <td>0</td> 
    <td>1</td> 
    <td>0</td> 
    <td>1</td> 
    <td>1</td> 
   </tr> 
   <tr> 
    <td>1</td> 
    <td>1</td> 
    <td>1</td> 
    <td>1</td> 
    <td>0</td> 
   </tr> 
   <tr> 
    <td>1</td> 
    <td>0</td> 
    <td>0</td> 
    <td>1</td> 
    <td>1</td> 
   </tr> 
  </tbody> 
 </table> 
 <p>假设<code>A = 60</code>，<code>B = 13</code>，二进制格式如下：</p> 
 <pre><code class="lang-shell">A = 0011 1100

B = 0000 1101

-----------------

A&amp;B = 0000 1100

A|B = 0011 1101

A^B = 0011 0001

~A = 1100 0011
</code></pre> 
 <p>下表列出了Scala支持的按位运算符。假设变量<code>A=60</code>，变量<code>B=13</code>，则 -</p> 
 <table> 
  <thead> 
   <tr> 
    <th>运算符</th> 
    <th>描述</th> 
    <th>示例</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td><code>&amp;</code></td> 
    <td>如果二进制AND运算符存在于两个操作数中，则二进制AND运算符将对结果复制一位。</td> 
    <td><code>(A&amp;B)= 12</code>，即<code>0000 1100</code></td> 
   </tr> 
   <tr> 
    <td><img src="http://www.yiibai.com/uploads/images/201708/1408/441090814_80736.png" alt=""></td> 
    <td>二进制OR运算符如果存在于任一操作数中，则复制一位。</td> 
    <td>(A <img src="http://www.yiibai.com/uploads/images/201708/1408/441090814_80736.png" alt=""> B) = 61, 即 <code>0011 1101</code></td> 
   </tr> 
   <tr> 
    <td><code>^</code></td> 
    <td>二进制XOR操作符复制该位，如果它设置在一个操作数中，而不是两者。</td> 
    <td><code>(A ^ B) = 49</code>, 即, <code>0011 0001</code></td> 
   </tr> 
   <tr> 
    <td><code>~</code></td> 
    <td>二进制补码运算符是一元的，具有“翻转”位的作用。</td> 
    <td><code>(~A)= -61</code>，即 <code>1100 0011</code>的补码形式。</td> 
   </tr> 
   <tr> 
    <td><code>&lt;&lt;</code></td> 
    <td>二进制左移操作符，左操作数值左移由右操作数指定的位数。</td> 
    <td><code>A &lt;&lt; 2 = 240</code> 即, <code>1111 0000</code></td> 
   </tr> 
   <tr> 
    <td><code>&gt;&gt;</code></td> 
    <td>二进制右移操作符，左操作数值被右操作数指定的位移动。</td> 
    <td><code>A &gt;&gt; 2 = 15</code> 即,<code>0000 1111</code></td> 
   </tr> 
  </tbody> 
 </table> 
 <p><strong>示例：</strong> 创建一个源代码文件：<code>Demo.scala</code>，代码如下所示 - </p> 
 <pre><code class="lang-scala">object Demo {
   def main(args: Array[String]) {
      var a = 60;           /* 60 = 0011 1100 */  
      var b = 13;           /* 13 = 0000 1101 */
      var c = 0;

      c = a &amp; b;            /* 12 = 0000 1100 */ 
      println("a &amp; b = " + c );

      c = a | b;            /* 61 = 0011 1101 */
      println("a | b = " + c );

      c = a ^ b;            /* 49 = 0011 0001 */
      println("a ^ b = " + c );

      c = ~a;               /* -61 = 1100 0011 */
      println("~a = " + c );

      c = a &lt;&lt; 2;           /* 240 = 1111 0000 */
      println("a &lt;&lt; 2 = " + c );

      c = a &gt;&gt; 2;           /* 215 = 1111 */
      println("a &gt;&gt; 2  = " + c );

      c = a &gt;&gt;&gt; 2;          /* 215 = 0000 1111 */
      println("a &gt;&gt;&gt; 2 = " + c );
   }
}
</code></pre> 
 <p>执行上面代码，得到以下结果 - </p>   
 <pre><code class="lang-shell">a &amp; b = 12
a | b = 61
a ^ b = 49
~a = -61
a &lt;&lt; 2 = 240
a &gt;&gt; 2 = 15
a &gt;&gt;&gt; 2 = 15
</code></pre> 
 <h2 id="h2-5-"><a name="5.赋值运算符" class="reference-link"></a><span class="header-link octicon octicon-link"></span>5.赋值运算符</h2>
 <p>下表列出了Scala语言支持的赋值运算符 -</p> 
 <table> 
  <thead> 
   <tr> 
    <th>运算符</th> 
    <th>描述</th> 
    <th>示例</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td><code>=</code></td> 
    <td>简单赋值运算符，将右侧操作数的值分配给左侧操作数</td> 
    <td><code>C = A + B</code>，将<code>A + B</code>的值分配给<code>C</code></td> 
   </tr> 
   <tr> 
    <td><code>+=</code></td> 
    <td>相加与赋值运算符。它将右操作数添加到左操作数，并将结果分配给左操作数。</td> 
    <td><code>C + = A</code>等价于<code>C = C + A</code></td> 
   </tr> 
   <tr> 
    <td><code>-=</code></td> 
    <td>相减与赋值运算符。它从左操作数中减去右操作数，并将结果分配给左操作数。</td> 
    <td><code>C -= A</code>等价于 <code>C = C - A</code></td> 
   </tr> 
   <tr> 
    <td><code>*=</code></td> 
    <td>乘以与赋值运算符。它将右操作数与左操作数相乘，并将结果分配给左操作数。</td> 
    <td><code>C * = A</code>等价于<code>C = C * A</code></td> 
   </tr> 
   <tr> 
    <td><code>/=</code></td> 
    <td>除以与赋值运算符。它将左操作数与右操作数分开，并将结果分配给左操作数。</td> 
    <td><code>C /= A</code>等价于<code>C = C / A</code></td> 
   </tr> 
   <tr> 
    <td><code>%=</code></td> 
    <td>模数与赋值运算符。它需要使用两个操作数的模数，并将结果分配给左操作数。</td> 
    <td><code>C %= A</code>等价于<code>C = C % A</code></td> 
   </tr> 
   <tr> 
    <td><code>&lt;&lt;=</code></td> 
    <td>左移与赋值运算符</td> 
    <td><code>C &lt;&lt;= 2</code>等价于<code>C = C &lt;&lt; 2</code></td> 
   </tr> 
   <tr> 
    <td><code>&gt;&gt;=</code></td> 
    <td>右移与赋值运算符</td> 
    <td><code>C &gt;&gt; = 2</code>等价于<code>C = C &gt;&gt; 2</code></td> 
   </tr> 
   <tr> 
    <td><code>&amp;=</code></td> 
    <td>按位与赋值运算符</td> 
    <td><code>C &amp;= 2</code>等价于<code>C = C &amp; 2</code></td> 
   </tr> 
   <tr> 
    <td><code>^=</code></td> 
    <td>按位异或运算符和赋值运算符。</td> 
    <td><code>C ^= 2</code>等价于<code>C = C ^ 2</code></td> 
   </tr> 
   <tr> 
    <td><img src="http://www.yiibai.com/uploads/images/201708/1408/812090837_38533.png" alt=""></td> 
    <td>按位包含OR和赋值运算符。</td> 
    <td><img src="http://www.yiibai.com/uploads/images/201708/1408/330090851_37216.png" alt=""></td> 
   </tr> 
  </tbody> 
 </table> 
 <p><strong>示例：</strong> 创建一个源文件：<em>Demo.scala</em> ，其代码如下 - </p> 
 <pre><code class="lang-scala">object Demo {
   def main(args: Array[String]) {
      var a = 10;    
      var b = 20;
      var c = 0;

      c = a + b;
      println("c = a + b  = " + c );

      c += a ;
      println("c += a  = " + c );

      c -= a ;
      println("c -= a = " + c );

      c *= a ;
      println("c *= a = " + c );

      a = 10;
      c = 15;
      c /= a ;
      println("c /= a  = " + c );

      a = 10;
      c = 15;
      c %= a ;
      println("c %= a  = " + c );

      c &lt;&lt;= 2 ;
      println("c &lt;&lt;= 2  = " + c );

      c &gt;&gt;= 2 ;
      println("c &gt;&gt;= 2  = " + c );

      c &gt;&gt;= 2 ;
      println("c &gt;&gt;= 2  = " + c );

      c &amp;= a ;
      println("c &amp;= a  = " + c );

      c ^= a ;
      println("c ^= a  = " + c );

      c |= a ;
      println("c |= a  = " + c );
   }
}
</code></pre> 
 <p>执行上面代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">c = a + b  = 30
c += a  = 40
c -= a  = 30
c *= a  = 300
c /= a  = 1
c %= a  = 5
c &lt;&lt;= 2  = 20
c &gt;&gt;= 2  = 5
c &gt;&gt;= 2  = 1
c &amp;= a  = 0
c ^= a  = 10
c |= a  = 10
</code></pre> 
 <h2 id="h2-6-"><a name="6.运算符优先级" class="reference-link"></a><span class="header-link octicon octicon-link"></span>6.运算符优先级</h2>
 <p>运算符优先级决定表达式中术语的分组，并决定如何评估计算表达式。 某些运算符的优先级高于其他运营商; 例如，乘法运算符的优先级高于加法运算符，则先要执行乘法运算符的运算。</p> 
 <p>让我们通过下面的例子了解优先级：</p> 
 <pre><code class="lang-c">int value = 10 + 20 * 10;
</code></pre> 
 <p><code>value</code>变量计算结果为：<code>210</code>，因为<code>*</code>(乘法运算符)的优先级比<code>+</code>(加法运算符)高，所以在<code>+</code>(加法运算符)之前进行求值。</p> 
 <p>C语言运算符的优先级和关联性如下：</p> 
 <table> 
  <thead> 
   <tr> 
    <th>分类</th> 
    <th>运算符</th> 
    <th>关联性</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>后缀</td> 
    <td><code>() [] -&gt; . ++ - -</code></td> 
    <td>左到右</td> 
   </tr> 
   <tr> 
    <td>一元</td> 
    <td><code>+ - ! ~ ++ - - (type)* &amp; sizeof</code></td> 
    <td>右到左</td> 
   </tr> 
   <tr> 
    <td>乘法</td> 
    <td><code>* / %</code></td> 
    <td>左到右</td> 
   </tr> 
   <tr> 
    <td>加法</td> 
    <td><code>+ -</code></td> 
    <td>左到右</td> 
   </tr> 
   <tr> 
    <td>位移</td> 
    <td><code>&lt;&lt; &gt;&gt;</code></td> 
    <td>左到右</td> 
   </tr> 
   <tr> 
    <td>关系</td> 
    <td><code>&lt; &lt;= &gt; &gt;=</code></td> 
    <td>左到右</td> 
   </tr> 
   <tr> 
    <td>等于</td> 
    <td><code>== !=</code></td> 
    <td>左到右</td> 
   </tr> 
   <tr> 
    <td>按位与</td> 
    <td><code>&amp;</code></td> 
    <td>左到右</td> 
   </tr> 
   <tr> 
    <td>位异或</td> 
    <td><code>^</code></td> 
    <td>左到右</td> 
   </tr> 
   <tr> 
    <td>按位或</td> 
    <td><code>/</code></td> 
    <td>左到右</td> 
   </tr> 
   <tr> 
    <td>逻辑与</td> 
    <td><code>&amp;&amp;</code></td> 
    <td>左到右</td> 
   </tr> 
   <tr> 
    <td>逻辑或</td> 
    <td><code>//</code></td> 
    <td>左到右</td> 
   </tr> 
   <tr> 
    <td>条件</td> 
    <td><code>?:</code></td> 
    <td>右到左</td> 
   </tr> 
   <tr> 
    <td>赋值</td> 
    <td><code>= += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= /=</code></td> 
    <td>右到左</td> 
   </tr> 
   <tr> 
    <td>逗号</td> 
    <td><code>,</code></td> 
    <td>左到右</td> 
   </tr> 
  </tbody> 
 </table>
 <br>      
</div></body></html>