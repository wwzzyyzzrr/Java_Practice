<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">linux环境下编译C++ 程序</h1><div style="width:100%;float:left;" class="article-content">   
 <p>GCC(GNU Compiler Collection)是Linux下最主要的编译工具，GCC不仅功能非常强大，结构也异常灵活。它可以通过不同的前端模块来支持各种语言，如：Java、Fortran、Pascal、Modula-3和Ada。</p> 
 <p><strong>安装Gcc和g++：</strong></p> 
 <pre><code class="lang-shell">yum -y install gcc automake autoconf libtool make
</code></pre> 
 <p><strong>安装g++:</strong></p> 
 <pre><code class="lang-shell">yum install gcc gcc-c++
</code></pre> 
 <p>g++是GCC中的一个工具，专门来编译C++语言的。<br>GCC的参数有：( 也是分步实现)</p> 
 <ul> 
  <li><code>-E</code> 让GCC在预处理结束后停止编译。<pre><code class="lang-shell">g++ -E hello.cpp  -o  hello.i
</code></pre> </li>
  <li><code>-c</code> 将<code>hello.i</code>编译成目标代码<pre><code class="lang-shell">g++  -c  hello.i  -o  hello.o
</code></pre> 将目标文件连接成可执行文件<pre><code class="lang-shell">g++ hell.o   -o   hello
</code></pre> 可以一步实现<pre><code class="lang-shell">g++  hello.cpp  -o  hello
</code></pre> </li>
 </ul> 
 <p><strong>假如有两个以上源文件应该一下编译</strong></p> 
 <p>一步就实现:</p> 
 <pre><code class="lang-shell">g++   foo1.cpp   foo2.cpp   -o   foo
</code></pre> 
 <p>也可以分步实现:</p> 
 <pre><code class="lang-shell">g++   -c   foo1.cpp  -o   foo1.o
g++   -c    foo2.cpp  -o   foo2.o
g++   foo1.o  foo2.o    -o    foo
</code></pre> 
 <p><strong>GCC一些常用选项</strong></p> 
 <p>1、产生警告信息的选项大多数以<code>-W</code>开头 其中有<code>-Wall</code></p> 
 <pre><code class="lang-shell">g++  -Wall  hello.cpp   -o   hello
</code></pre> 
 <p>2、将所有的警告当成错误的选项<code>-Werror</code></p> 
 <pre><code class="lang-shell">g++ -Werror  hello.cpp  -o  hello
</code></pre> 
 <p>3、寻找头文件选项 </p> 
 <ul> 
  <li><code>-I</code> (linux默认路径：头文件在<code>/usr/include/</code>下)，不在这个路径下就要用<code>-I</code>指定。<pre><code class="lang-shell">gcc  foo.cpp  -I/home/include   -o  foo
</code></pre> 4、 库依赖选项 </li>
  <li><code>-L</code> (linux默认路径：库文件在<code>/usr/lib/</code>下)，不在这个路径下就要用<code>-L</code>指定。<pre><code class="lang-shell">g++  foo.cpp  -L/home/lib  -lfoo  -o   foo
</code></pre> </li>
 </ul> 
 <p>库就是将源文件编译之后生成的目标文件的集合。库命名以lib开头。库有静态库(通常以<code>.a</code>结尾)和动态库(通常以<code>.so</code>结尾)默认情况下，g++以动态库形式连接。如果要静态库连接则要用<code>-static</code>指定(<code>g++ foo.cpp -L/home/lib -static -lfoo -o foo</code>)</p> 
 <h2 id="h2-u5355u4E2Au6E90u6587u4EF6u751Fu6210u53EFu6267u884Cu7A0Bu5E8F"><a name="单个源文件生成可执行程序" class="reference-link"></a><span class="header-link octicon octicon-link"></span>单个源文件生成可执行程序</h2>
 <p>下面是一个保存在文件 <code>helloworld.cpp</code> 中一个简单的 C++ 程序的代码： 单个源文件生成可执行程序。</p> 
 <pre><code class="lang-cpp">/* helloworld.cpp */
#include &lt;iostream&gt;
int main(int argc,char *argv[])
{
    std::cout &lt;&lt; "hello, world" &lt;&lt; std::endl;
    return(0);
}
</code></pre> 
 <p>程序使用定义在头文件 <code>iostream</code> 中的 <code>cout</code>，向标准输出写入一个简单的字符串。该代码可用以下命令编译为可执行文件：</p> 
 <pre><code class="lang-shell">[root@localhost cpp]# g++ helloworld.cpp
[root@localhost cpp]# ll
total 16
-rwxr-xr-x. 1 root   root   9136 Mar  8 03:31 a.out
-rw-rw-r--. 1 yiibai yiibai  138 Mar  8 03:24 helloworld.cpp
[root@localhost cpp]#
</code></pre> 
 <p>编译器 g++ 通过检查命令行中指定的文件的后缀名可识别其为 C++ 源代码文件。<br><strong> 编译器默认的动作：</strong> 编译源代码文件生成对象文件(object file)，链接对象文件和 libstd c++ 库中的函数得到可执行程序。然后删除对象文件。由于命令行中未指定可执行程序的文件名，编译器采用默认的<code>a.out</code>。程序可以这样来运行：</p> 
 <pre><code class="lang-shell">[yiibai@localhost cpp]$ ./a.out
hello, world
[yiibai@localhost cpp]$
</code></pre> 
 <p>更普遍的做法是通过 <code>-o</code> 选项指定可执行程序的文件名。下面的命令将产生名为 <code>helloworld</code> 的可执行文件：</p> 
 <pre><code class="lang-shell">[yiibai@localhost cpp]$  g++ helloworld.cpp -o helloworld
[yiibai@localhost cpp]$ ll
total 28
-rwxr-xr-x. 1 root   root   9136 Mar  8 03:31 a.out
-rwxrwxr-x. 1 yiibai yiibai 9136 Mar  8 03:32 helloworld
-rw-rw-r--. 1 yiibai yiibai  138 Mar  8 03:24 helloworld.cpp
[yiibai@localhost cpp]$
</code></pre> 
 <p>在命令行中输入程序名可使之运行：</p> 
 <pre><code class="lang-shell">[yiibai@localhost cpp]$  ./helloworld
hello, world
[yiibai@localhost cpp]$
</code></pre> 
 <p>程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本，链接时它自动使用 C++ 标准库而不用 C 标准库。通过遵循源码的命名规范并指定对应库的名字，用 gcc 来编译链接 C++ 程序是可行的，如下例所示：</p> 
 <pre><code class="lang-shell">[yiibai@localhost cpp]$ gcc helloworld.cpp -lstdc++ -o helloworld
</code></pre> 
 <p>选项 -l (ell)通过添加前缀 lib 和后缀 <code>.a</code> 将跟随它的名字变换为库的名字<code>libstdc++.a</code>。而后它在标准库路径中查找该库。gcc 的编译过程和输出文件与 g++ 是完全相同的。</p> 
 <p>在大多数系统中，GCC 安装时会安装一名为 c++ 的程序。如果被安装，它和 g++ 是等同，如下例所示，用法也一致：</p> 
 <pre><code class="lang-shell">[yiibai@localhost cpp]$ c++ helloworld.cpp -o helloworld
</code></pre> 
 <h2 id="h2-u591Au4E2Au6E90u6587u4EF6u751Fu6210u53EFu6267u884Cu7A0Bu5E8F"><a name="多个源文件生成可执行程序" class="reference-link"></a><span class="header-link octicon octicon-link"></span>多个源文件生成可执行程序</h2>
 <p>如果多于一个的源码文件在 g++ 命令中指定，它们都将被编译并被链接成一个单一的可执行文件。下面是一个名为 <code>speak.h</code> 的头文件；它包含一个仅含有一个函数的类的定义：</p> 
 <pre><code class="lang-cpp">/* speak.h */
#include &lt;iostream&gt;
class Speak
{
    public:
        void sayHello(const char *);
};
</code></pre> 
 <p>下面列出的是文件 <code>speak.cpp</code> 的内容：包含 <code>sayHello()</code>函数的函数体：</p> 
 <pre><code class="lang-cpp">/* speak.cpp */
#include "speak.h"
void Speak::sayHello(const char *str)
{
    std::cout &lt;&lt; "Hello " &lt;&lt; str &lt;&lt; "\n";
}
</code></pre> 
 <p>文件<code>hellospeak.cpp</code>内是一个使用 <code>Speak</code> 类的程序：</p> 
 <pre><code class="lang-cpp">/* hellospeak.cpp */
#include "speak.h"
int main(int argc,char *argv[])
{
    Speak speak;
    speak.sayHello("world");
    return(0);
}
</code></pre> 
 <p>下面这条命令将上述两个源码文件编译链接成一个单一的可执行程序：</p> 
 <pre><code class="lang-shell">$ g++ hellospeak.cpp speak.cpp -o hellospeak
</code></pre> 
 <blockquote> 
  <p>提示： 这里说一下为什么在命令中没有提到“<code>speak.h</code>“文件(原因是：在“<code>speak.cpp</code>“中包含有”<code>#include"speak.h</code>““这句代码，它的意思是搜索系统头文件目录之前将先在当前目录中搜索文件“<code>speak.h</code>“。而”<code>speak.h</code>“正在该目录中，不用再在命令中指定了)。</p> 
 </blockquote> 
 <h2 id="h2-u6E90u6587u4EF6u751Fu6210u5BF9u8C61u6587u4EF6"><a name="源文件生成对象文件" class="reference-link"></a><span class="header-link octicon octicon-link"></span>源文件生成对象文件</h2>
 <p>选项 <code>-c</code> 用来告诉编译器编译源代码但不要执行链接，输出结果为对象文件。文件默认名与源码文件名相同，只是将其后缀变为<code>.o</code>。例如，下面的命令将编译源码文件 <code>hellospeak.cpp</code>并生成对象文件 <code>hellospeak.o</code>：</p> 
 <pre><code class="lang-shell">$ g++ -c hellospeak.cpp
</code></pre> 
 <p>命令 g++ 也能识别 <code>.o</code> 文件并将其作为输入文件传递给链接器。下列命令将编译源码文件为对象文件并将其链接成单一的可执行程序：</p>   
 <pre><code class="lang-shell">$ g++ -c hellospeak.cpp 
$ g++ -c speak.cpp 
$ g++ hellospeak.o speak.o -o hellospeak
</code></pre> 
 <p>选项 <code>-o</code> 不仅仅能用来命名可执行文件。它也用来命名编译器输出的其他文件。例如：除了中间的对象文件有不同的名字外，下列命令生将生成和上面完全相同的可执行文件：</p> 
 <pre><code class="lang-shell">$ g++ -c hellospeak.cpp -o hspk1.o 
$ g++ -c speak.cpp -o hspk2.o 
$ g++ hspk1.o hspk2.o -o hellospeak
</code></pre> 
 <h2 id="h2-u7F16u8BD1u9884u5904u7406"><a name="编译预处理" class="reference-link"></a><span class="header-link octicon octicon-link"></span>编译预处理</h2>
 <p>选项 <code>-E</code> 使 g++ 将源代码用编译预处理器处理后不再执行其他动作。下面的命令预处理源码文件 <code>helloworld.cpp</code> 并将结果显示在标准输出中：</p> 
 <pre><code class="lang-shell">$ g++ -E helloworld.cpp
</code></pre> 
 <p>本文前面所列出的 <code>helloworld.cpp</code> 的源代码，仅仅有六行，而且该程序除了显示一行文字外什么都不做，但是，预处理后的版本将超过 <code>1200</code> 行。这主要是因为头文件 iostream 被包含进来，而且它又包含了其他的头文件，除此之外，还有若干个处理输入和输出的类的定义。<br>预处理过的文件的 GCC 后缀为<code>.ii</code>，它可以通过<code>-o</code> 选项来生成，例如：</p> 
 <pre><code class="lang-shell">$ gcc -E helloworld.cpp -o helloworld.ii
</code></pre> 
 <h2 id="h2-u751Fu6210u6C47u7F16u4EE3u7801"><a name="生成汇编代码" class="reference-link"></a><span class="header-link octicon octicon-link"></span>生成汇编代码</h2>
 <p>选项 -S指示编译器将程序编译成汇编语言，输出汇编语言代码而后结束。下面的命令将由 C++ 源码文件生成汇编语言文件 <code>helloworld.s</code>：</p> 
 <pre><code class="lang-shell">$ g++ -S helloworld.cpp
</code></pre> 
 <p>生成的汇编语言依赖于编译器的目标平台。</p> 
 <h2 id="h2-u521Bu5EFAu9759u6001u5E93"><a name="创建静态库" class="reference-link"></a><span class="header-link octicon octicon-link"></span>创建静态库</h2>
 <p>静态库是编译器生成的一系列对象文件的集合。链接一个程序时用库中的对象文件还是目录中的对象文件都是一样的。库中的成员包括普通函数，类定义，类的对象实例等等。静态库的另一个名字叫归档文件(archive)，管理这种归档文件的工具叫 <code>ar</code> 。<br>在下面的例子中，我们先创建两个对象模块，然后用其生成静态库。<br>头文件 <code>say.h</code>包含函数 <code>sayHello()</code>的原型和类 <code>Say</code> 的定义：</p> 
 <pre><code class="lang-cpp">/* say.h */
#include &lt;iostream&gt;
void sayhello(void);
class Say {
    private:
        char *string;
    public:
        Say(char *str)
        {
            string = str;
        }
        void sayThis(const char *str)
        {
            std::cout &lt;&lt; str &lt;&lt; " from a static library\n";
        }
        void sayString(void);
};
</code></pre> 
 <p>下面是文件<code>say.cpp</code>是我们要加入到静态库中的两个对象文件之一的源码。它包含 <code>Say</code> 类中 <code>sayString()</code>函数的定义体；类 <code>Say</code> 的一个实例 <code>librarysay</code>的声明也包含在内：</p> 
 <pre><code class="lang-cpp">/* say.cpp */
#include "say.h"
void Say::sayString()
{
    std::cout &lt;&lt; string &lt;&lt; "\n";
}
</code></pre> 
 <p><code>Say librarysay("Library instance of Say");</code><br>源码文件 <code>syshello.cpp</code> 是我们要加入到静态库中的第二个对象文件的源码。它包含函数 <code>sayhello()</code> 的定义：</p> 
 <pre><code class="lang-cpp">/* sayhello.cpp */
#include "say.h"
void sayhello()
{
    std::cout &lt;&lt; "hello from a static library\n";
}
</code></pre> 
 <p>下面的命令序列将源码文件编译成对象文件，命令 ar 将其存进库中：</p> 
 <pre><code class="lang-shell">$ g++ -c sayhello.cpp
$ g++ -c say.cpp
$ ar -r libsay.a sayhello.o say.o
</code></pre> 
 <p>程序 <code>ar</code> 配合参数 <code>-r</code> 创建一个新库 <code>libsay.a</code> 并将命令行中列出的对象文件插入。采用这种方法，如果库不存在的话，参数 <code>-r</code> 将创建一个新的库，而如果库存在的话，将用新的模块替换原来的模块。<br>下面是主程序 <code>saymain.cpp</code>，它调用库 <code>libsay.a</code> 中的代码：</p> 
 <pre><code class="lang-cpp">/* saymain.cpp */
#include "say.h"
int main(int argc,char *argv[])
{
    extern Say librarysay;
    Say localsay = Say("Local instance of Say");
    sayhello();
    librarysay.sayThis("howdy");
    librarysay.sayString();
    localsay.sayString();
    return(0);
}
</code></pre> 
 <p>该程序可以下面的命令来编译和链接：</p> 
 <pre><code>$ g++ saymain.cpp libsay.a -o saymain
</code></pre>
 <p>程序运行时，产生以下输出：</p> 
 <pre><code>hello from a static library
howdy from a static library
Library instance of SayLocal instance of Say
</code></pre>
 <p>参考：<a target="_blank" href="http://www.cnblogs.com/ucas/p/5778664.html">http://www.cnblogs.com/ucas/p/5778664.html</a></p>
 <br>      
</div></body></html>