<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Go闭包（匿名函数）实例</h1><div style="width:100%;float:left;" class="article-content">   
 <p>Go语言支持匿名函数，可以形成闭包。匿名函数在想要定义函数而不必命名时非常有用。</p> 
 <blockquote> 
  <p>所有的示例代码，都放在 <code>F:\worksp\golang</code> 目录下。安装Go编程环境请参考：<a target="_blank" href="http://www.yiibai.com/go/go_environment.html">http://www.yiibai.com/go/go_environment.html</a> </p> 
 </blockquote> 
 <p>函数<code>intSeq()</code>返回另一个函数，它在<code>intSeq()</code>函数的主体中匿名定义。返回的函数闭合变量<code>i</code>以形成闭包。<br>当调用<code>intSeq()</code>函数，将结果(一个函数)分配给<code>nextInt</code>。这个函数捕获它自己的<code>i</code>值，每当调用<code>nextInt</code>时，它的<code>i</code>值将被更新。</p> 
 <p>通过调用<code>nextInt</code>几次来查看闭包的效果。</p> 
 <p>要确认状态对于该特定函数是唯一的，请创建并测试一个新函数。</p> 
 <p>接下来我们来看看函数的最后一个特性是：递归。</p> 
 <p><code>closures.go</code>的完整代码如下所示 -</p> 
 <pre><code class="lang-go">package main

import "fmt"

// This function `intSeq` returns another function, which
// we define anonymously in the body of `intSeq`. The
// returned function _closes over_ the variable `i` to
// form a closure.
func intSeq() func() int {
    i := 0
    return func() int {
        i += 1
        return i
    }
}

func main() {

    // We call `intSeq`, assigning the result (a function)
    // to `nextInt`. This function value captures its
    // own `i` value, which will be updated each time
    // we call `nextInt`.
    nextInt := intSeq()

    // See the effect of the closure by calling `nextInt`
    // a few times.
    fmt.Println(nextInt())
    fmt.Println(nextInt())
    fmt.Println(nextInt())

    // To confirm that the state is unique to that
    // particular function, create and test a new one.
    newInts := intSeq()
    fmt.Println(newInts())
}
</code></pre> 
 <p>执行上面代码，将得到以下输出结果 - </p>   
 <pre><code class="lang-go">F:\worksp\golang&gt;go run closures.go
1
2
3
1
</code></pre>
 <br>      
</div></body></html>