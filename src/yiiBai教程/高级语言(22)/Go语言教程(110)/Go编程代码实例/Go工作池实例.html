<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Go工作池实例</h1><div style="width:100%;float:left;" class="article-content">   
 <p>在这个例子中，我们将看看如何使用<code>goroutines</code>和<code>channel</code>实现一个工作池。</p> 
 <p>这里是工作程序(<code>worker</code>)，我们将运行几个并发实例。这些工作程序(<code>worker</code>)将在工作渠道上接收工作，并将结果发送相应的结果。将每个工作程序(<code>worker</code>)睡一秒钟，用来模拟执行的任务。</p> 
 <p>为了使用工作程序(<code>worker</code>)池，需要向它们发送工作(或作业)并收集的结果。为此做<code>2</code>个通道。</p> 
 <p>这启动了<code>3</code>个工作程序(<code>worker</code>)，最初被阻止，因为还没有作业。</p> 
 <p>然后，我们再发送<code>5</code>个作业，然后关闭该通道，以指示这是所有的工作。</p> 
 <p>最后，收集作业的所有结果。</p> 
 <p>运行程序显示了<code>5</code>个作业正在由各种工作程序执行。该程序只需要约<code>2</code>秒的时间，尽管做了大约<code>5</code>秒的总工作，因为有<code>3</code>个工作程序同时操作。</p> 
 <blockquote> 
  <p>所有的示例代码，都放在 <code>F:\worksp\golang</code> 目录下。安装Go编程环境请参考：<a target="_blank" href="http://www.yiibai.com/go/go_environment.html">http://www.yiibai.com/go/go_environment.html</a> </p> 
 </blockquote> 
 <p><code>timers.go</code>的完整代码如下所示 -</p> 
 <pre><code class="lang-go">package main

import "fmt"
import "time"

// Here's the worker, of which we'll run several
// concurrent instances. These workers will receive
// work on the `jobs` channel and send the corresponding
// results on `results`. We'll sleep a second per job to
// simulate an expensive task.
func worker(id int, jobs &lt;-chan int, results chan&lt;- int) {
    for j := range jobs {
        fmt.Println("worker", id, "started  job", j)
        time.Sleep(time.Second)
        fmt.Println("worker", id, "finished job", j)
        results &lt;- j * 2
    }
}

func main() {

    // In order to use our pool of workers we need to send
    // them work and collect their results. We make 2
    // channels for this.
    jobs := make(chan int, 100)
    results := make(chan int, 100)

    // This starts up 3 workers, initially blocked
    // because there are no jobs yet.
    for w := 1; w &lt;= 3; w++ {
        go worker(w, jobs, results)
    }

    // Here we send 5 `jobs` and then `close` that
    // channel to indicate that's all the work we have.
    for j := 1; j &lt;= 5; j++ {
        jobs &lt;- j
    }
    close(jobs)

    // Finally we collect all the results of the work.
    for a := 1; a &lt;= 5; a++ {
        &lt;-results
    }
}
</code></pre> 
 <p>执行上面代码，将得到以下输出结果 - </p>   
 <pre><code class="lang-go">F:\worksp\golang&gt;go run worker-pools.go
worker 3 started  job 2
worker 1 started  job 1
worker 2 started  job 3
worker 3 finished job 2
worker 3 started  job 4
worker 1 finished job 1
worker 1 started  job 5
worker 2 finished job 3
worker 3 finished job 4
worker 1 finished job 5
</code></pre>
 <br>      
</div></body></html>