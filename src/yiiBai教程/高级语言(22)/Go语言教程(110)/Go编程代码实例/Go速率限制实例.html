<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Go速率限制实例</h1><div style="width:100%;float:left;" class="article-content">   
 <p>速率限制是控制资源利用和维持服务质量的重要机制。通过<code>goroutines</code>，<code>channel</code>和<code>ticker</code>都可以优雅地支持速率限制。</p> 
 <p>首先我们来看一下基本速率限制。假设想限制对传入请求的处理。我们会在相同名称的通道上放送这些要求。</p> 
 <p>这个限制器通道将每<code>200</code>毫秒接收一个值。这是速率限制方案中的调节器。</p> 
 <p>通过在服务每个请求之前阻塞来自限制器信道的接收，我们限制自己每<code>200</code>毫秒接收<code>1</code>个请求。</p> 
 <p>我们可能希望在速率限制方案中允许短脉冲串请求，同时保持总体速率限制。可以通过缓冲的限制器通道来实现。这个<code>burstyLimiter</code>通道将允许最多<code>3</code>个事件的突发。</p> 
 <p>填充通道以表示允许突发。</p> 
 <p>每<code>200</code>毫秒，将尝试向<code>burstyLimiter</code>添加一个新值，最大限制为<code>3</code>。现在模拟<code>5</code>个更多的传入请求。这些传入请求中的前<code>3</code>个未超过<code>burstyLimiter</code>值。</p> 
 <p>运行程序后，就会看到第一批请求每<code>〜200</code>毫秒处理一次。</p> 
 <p>对于第二批请求，程序会立即服务前<code>3</code>个，因为突发速率限制，然后剩余<code>2</code>服务都具有<code>〜200ms</code>延迟。</p> 
 <blockquote> 
  <p>所有的示例代码，都放在 <code>F:\worksp\golang</code> 目录下。安装Go编程环境请参考：<a target="_blank" href="http://www.yiibai.com/go/go_environment.html">http://www.yiibai.com/go/go_environment.html</a> </p> 
 </blockquote> 
 <p><code>rate-limiting.go</code>的完整代码如下所示 -</p> 
 <pre><code class="lang-go">package main

import "time"
import "fmt"

func main() {

    // First we'll look at basic rate limiting. Suppose
    // we want to limit our handling of incoming requests.
    // We'll serve these requests off a channel of the
    // same name.
    requests := make(chan int, 5)
    for i := 1; i &lt;= 5; i++ {
        requests &lt;- i
    }
    close(requests)

    // This `limiter` channel will receive a value
    // every 200 milliseconds. This is the regulator in
    // our rate limiting scheme.
    limiter := time.Tick(time.Millisecond * 200)

    // By blocking on a receive from the `limiter` channel
    // before serving each request, we limit ourselves to
    // 1 request every 200 milliseconds.
    for req := range requests {
        &lt;-limiter
        fmt.Println("request", req, time.Now())
    }

    // We may want to allow short bursts of requests in
    // our rate limiting scheme while preserving the
    // overall rate limit. We can accomplish this by
    // buffering our limiter channel. This `burstyLimiter`
    // channel will allow bursts of up to 3 events.
    burstyLimiter := make(chan time.Time, 3)

    // Fill up the channel to represent allowed bursting.
    for i := 0; i &lt; 3; i++ {
        burstyLimiter &lt;- time.Now()
    }

    // Every 200 milliseconds we'll try to add a new
    // value to `burstyLimiter`, up to its limit of 3.
    go func() {
        for t := range time.Tick(time.Millisecond * 200) {
            burstyLimiter &lt;- t
        }
    }()

    // Now simulate 5 more incoming requests. The first
    // 3 of these will benefit from the burst capability
    // of `burstyLimiter`.
    burstyRequests := make(chan int, 5)
    for i := 1; i &lt;= 5; i++ {
        burstyRequests &lt;- i
    }
    close(burstyRequests)
    for req := range burstyRequests {
        &lt;-burstyLimiter
        fmt.Println("request", req, time.Now())
    }
}
</code></pre> 
 <p>执行上面代码，将得到以下输出结果 - </p>   
 <pre><code class="lang-go">F:\worksp\golang&gt;go run rate-limiting.go
request 1 2017-01-21 14:43:39.1445218 +0800 CST
request 2 2017-01-21 14:43:39.345767 +0800 CST
request 3 2017-01-21 14:43:39.5460635 +0800 CST
request 4 2017-01-21 14:43:39.7441739 +0800 CST
request 5 2017-01-21 14:43:39.9444929 +0800 CST
request 1 2017-01-21 14:43:39.9464898 +0800 CST
request 2 2017-01-21 14:43:39.9504928 +0800 CST
request 3 2017-01-21 14:43:39.9544955 +0800 CST
request 4 2017-01-21 14:43:40.1467214 +0800 CST
request 5 2017-01-21 14:43:40.3469624 +0800 CST
</code></pre>
 <br>      
</div></body></html>