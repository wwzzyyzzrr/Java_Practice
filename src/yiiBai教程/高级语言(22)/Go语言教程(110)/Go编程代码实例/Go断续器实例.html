<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Go断续器实例</h1><div style="width:100%;float:left;" class="article-content">   
 <p><a target="_blank" href="http://www.yiibai.com/go/golang-timers.html" title="计时器">计时器</a>是当想在未来做一些事情 - <code>tickers</code>是用于定期做一些事情。 这里是一个例行程序，周期性执行直到停止。</p> 
 <p>代码机使用与计时器的机制类似：发送值到通道。 这里我们将使用通道上的一个范围内来迭代值，这此值每<code>500ms</code>到达。</p> 
 <p>代码可以像计时器一样停止。当代码停止后，它不会在其通道上接收任何更多的值。我们将在<code>1600ms</code>后停止。</p> 
 <p>当运行这个程序时，<code>ticker</code>应该在我们停止之前打<code>3</code>次。</p> 
 <blockquote> 
  <p>所有的示例代码，都放在 <code>F:\worksp\golang</code> 目录下。安装Go编程环境请参考：<a target="_blank" href="http://www.yiibai.com/go/go_environment.html">http://www.yiibai.com/go/go_environment.html</a> </p> 
 </blockquote> 
 <p><code>timers.go</code>的完整代码如下所示 -</p> 
 <pre><code class="lang-go">package main

import "time"
import "fmt"

func main() {

    // Tickers use a similar mechanism to timers: a
    // channel that is sent values. Here we'll use the
    // `range` builtin on the channel to iterate over
    // the values as they arrive every 500ms.
    ticker := time.NewTicker(time.Millisecond * 500)
    go func() {
        for t := range ticker.C {
            fmt.Println("Tick at", t)
        }
    }()

    // Tickers can be stopped like timers. Once a ticker
    // is stopped it won't receive any more values on its
    // channel. We'll stop ours after 1600ms.
    time.Sleep(time.Millisecond * 1600)
    ticker.Stop()
    fmt.Println("Ticker stopped")
}
</code></pre> 
 <p>执行上面代码，将得到以下输出结果 - </p>   
 <pre><code class="lang-go">F:\worksp\golang&gt;go run tickers.go
Tick at 2017-01-21 14:24:48.8807832 +0800 CST
Tick at 2017-01-21 14:24:49.380263 +0800 CST
Tick at 2017-01-21 14:24:49.882174 +0800 CST
Ticker stopped
</code></pre>
 <br>      
</div></body></html>