<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Go信号实例</h1><div style="width:100%;float:left;" class="article-content">   
 <p>有时我们希望Go程序能够智能地处理Unix信号。 例如，可能希望服务器在接收到<code>SIGTERM</code>时正常关闭，或者在收到<code>SIGINT</code>时使用命令行工具停止处理输入。下面介绍如何使用Go语言处理信号。</p> 
 <p>Go信号通知通过在通道上发送<code>os.Signal</code>值来工作。创建一个通道来接收这些通知(还会在程序退出时通知我们)。</p> 
 <blockquote> 
  <p>所有的示例代码，都放在 <code>F:\worksp\golang</code> 目录下。安装Go编程环境请参考：<a target="_blank" href="http://www.yiibai.com/go/go_environment.html">http://www.yiibai.com/go/go_environment.html</a> </p> 
 </blockquote> 
 <p><code>signal.go</code>的完整代码如下所示 -</p> 
 <pre><code class="lang-go">package main

import "fmt"
import "os"
import "os/signal"
import "syscall"

func main() {

    // Go signal notification works by sending `os.Signal`
    // values on a channel. We'll create a channel to
    // receive these notifications (we'll also make one to
    // notify us when the program can exit).
    sigs := make(chan os.Signal, 1)
    done := make(chan bool, 1)

    // `signal.Notify` registers the given channel to
    // receive notifications of the specified signals.
    signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

    // This goroutine executes a blocking receive for
    // signals. When it gets one it'll print it out
    // and then notify the program that it can finish.
    go func() {
        sig := &lt;-sigs
        fmt.Println()
        fmt.Println(sig)
        done &lt;- true
    }()

    // The program will wait here until it gets the
    // expected signal (as indicated by the goroutine
    // above sending a value on `done`) and then exit.
    fmt.Println("awaiting signal")
    &lt;-done
    fmt.Println("exiting")
}
</code></pre> 
 <p>执行上面代码，将得到以下输出结果 - </p>   
 <pre><code class="lang-bash">F:\worksp\golang&gt;go run signal.go
awaiting signal
[Ctl+C]
interrupt
exiting
</code></pre>
 <br>      
</div></body></html>