<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Go通道同步实例</h1><div style="width:100%;float:left;" class="article-content">   
 <p>我们可以使用通道在<code>goroutine</code>上同步执行程序。这里有一个使用阻塞接收等待<code>goroutine</code>完成的示例。</p> 
 <p>这是将在<code>goroutine</code>中运行的函数。 <code>done</code>通道将用来通知另一个<code>goroutine</code>这个函数的工作已经完成，发送值以通知已经完成。</p> 
 <p>启动一个<code>goroutine</code>工作程序，给它一个通知通道。如果从此程序中删除 <code>&lt;-done</code> 行，程序将在工作程序(<code>worker</code>)启动之前退出。</p> 
 <p>阻止，直到在通道上收到工作程序的通知。</p> 
 <blockquote> 
  <p>所有的示例代码，都放在 <code>F:\worksp\golang</code> 目录下。安装Go编程环境请参考：<a target="_blank" href="http://www.yiibai.com/go/go_environment.html">http://www.yiibai.com/go/go_environment.html</a> </p> 
 </blockquote> 
 <p><code>channel-synchronization.go</code>的完整代码如下所示 -</p> 
 <pre><code class="lang-go">package main

import "fmt"
import "time"

// This is the function we'll run in a goroutine. The
// `done` channel will be used to notify another
// goroutine that this function's work is done.
func worker(done chan bool) {
    fmt.Print("working...")
    time.Sleep(time.Second)
    fmt.Println("done")

    // Send a value to notify that we're done.
    done &lt;- true
}

func main() {

    // Start a worker goroutine, giving it the channel to
    // notify on.
    done := make(chan bool, 1)
    go worker(done)

    // Block until we receive a notification from the
    // worker on the channel.
    &lt;-done
}
</code></pre> 
 <p>执行上面代码，将得到以下输出结果 - </p>   
 <pre><code class="lang-go">F:\worksp\golang&gt;go run channel-synchronization.go
working...done
</code></pre>
 <br>      
</div></body></html>