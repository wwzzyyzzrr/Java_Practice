<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Go切片实例</h1><div style="width:100%;float:left;" class="article-content">   
 <p>切片是<strong>Go</strong>语言中的关键数据类型，为序列提供了比数组更强大的接口。</p> 
 <blockquote> 
  <p>所有的示例代码，都放在 <code>F:\worksp\golang</code> 目录下。安装Go编程环境请参考：<a target="_blank" href="http://www.yiibai.com/go/go_environment.html">http://www.yiibai.com/go/go_environment.html</a> </p> 
 </blockquote> 
 <p>与数组不同，切片(slice)只是由它们包含的元素(而不是元素的数量)键入。要创建非零长度的空切片，请使用内置<code>make()</code>函数。这里创建一个长度为<code>3</code>的字符串(初始为零值)。</p> 
 <p>我们可以像数组一样设置和获取字符串的子串值。<code>len()</code>函数返回切片的长度。<br>除了这些基本操作之外，切片还支持更多，使它们比数组更丰富。一个是内置 <code>append()</code>函数，它返回包含一个或多个新值的切片。注意，需要接收<code>append()</code>函数的返回值，因为可能得到一个新的<code>slice</code>值。</p> 
 <p>也可以复制切片。这里创建一个与切片<code>s</code>相同长度的空切片<code>c</code>，并从切片<code>s</code>复制到<code>c</code>中。切片支持具有语法为<code>slice[low:high]</code>的切片运算符。 例如，这获得元素<code>s[2]</code>，<code>s[3]</code>和<code>s[4]</code>的切片。</p> 
 <p>这切片到(但不包括)<code>s[5]</code>。这切片从(包括)<code>s[2]</code>。可以在一行中声明并初始化<code>slice</code>的变量。<br>切片可以组成多维数据结构。内切片的长度可以变化，与多维数组不同。</p> 
 <p>看看这个<a target="_blank" href="http://blog.golang.org/2011/01/go-slices-usage-and-internals.html" title="博客文章">博客文章</a>了解Go团队的设计和切片在<code>Go</code>的实现的更多细节。</p> 
 <p>现在已经看到了数组和切片，看看<code>Go</code>编程的其他关键内置数据结构：<code>maps</code>。</p> 
 <p><code>slices.go</code>的完整代码如下所示 -</p> 
 <pre><code class="lang-go">package main

import "fmt"

func main() {

    // Unlike arrays, slices are typed only by the
    // elements they contain (not the number of elements).
    // To create an empty slice with non-zero length, use
    // the builtin `make`. Here we make a slice of
    // `string`s of length `3` (initially zero-valued).
    s := make([]string, 3)
    fmt.Println("emp:", s)

    // We can set and get just like with arrays.
    s[0] = "a"
    s[1] = "b"
    s[2] = "c"
    fmt.Println("set:", s)
    fmt.Println("get:", s[2])

    // `len` returns the length of the slice as expected.
    fmt.Println("len:", len(s))

    // In addition to these basic operations, slices
    // support several more that make them richer than
    // arrays. One is the builtin `append`, which
    // returns a slice containing one or more new values.
    // Note that we need to accept a return value from
    // append as we may get a new slice value.
    s = append(s, "d")
    s = append(s, "e", "f")
    fmt.Println("apd:", s)

    // Slices can also be `copy`'d. Here we create an
    // empty slice `c` of the same length as `s` and copy
    // into `c` from `s`.
    c := make([]string, len(s))
    copy(c, s)
    fmt.Println("cpy:", c)

    // Slices support a "slice" operator with the syntax
    // `slice[low:high]`. For example, this gets a slice
    // of the elements `s[2]`, `s[3]`, and `s[4]`.
    l := s[2:5]
    fmt.Println("sl1:", l)

    // This slices up to (but excluding) `s[5]`.
    l = s[:5]
    fmt.Println("sl2:", l)

    // And this slices up from (and including) `s[2]`.
    l = s[2:]
    fmt.Println("sl3:", l)

    // We can declare and initialize a variable for slice
    // in a single line as well.
    t := []string{"g", "h", "i"}
    fmt.Println("dcl:", t)

    // Slices can be composed into multi-dimensional data
    // structures. The length of the inner slices can
    // vary, unlike with multi-dimensional arrays.
    twoD := make([][]int, 3)
    for i := 0; i &lt; 3; i++ {
        innerLen := i + 1
        twoD[i] = make([]int, innerLen)
        for j := 0; j &lt; innerLen; j++ {
            twoD[i][j] = i + j
        }
    }
    fmt.Println("2d: ", twoD)
}
</code></pre> 
 <p>执行上面代码，将得到以下输出结果 - </p>   
 <pre><code class="lang-go">F:\worksp\golang&gt;go run slices.go
emp: [  ]
set: [a b c]
get: c
len: 3
apd: [a b c d e f]
cpy: [a b c d e f]
sl1: [c d e]
sl2: [a b c d e]
sl3: [c d e f]
dcl: [g h i]
2d:  [[0] [1 2] [2 3 4]]
</code></pre>
 <br>      
</div></body></html>