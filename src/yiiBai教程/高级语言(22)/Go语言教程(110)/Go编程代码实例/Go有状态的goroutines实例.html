<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Go有状态的goroutines实例</h1><div style="width:100%;float:left;" class="article-content">   
 <p>在前面的示例中，我们使用显式锁定互斥体来同步对多个goroutine的共享状态的访问。 另一个选项是使用<code>goroutine</code>和通道的内置同步功能来实现相同的结果。这种基于通道的方法与Go的共享内存的想法一致，通过沟通，拥有每个数据的<code>goroutine</code>恰好只有<code>1</code>个。</p> 
 <p>在这个例子中，状态将由单个<code>goroutine</code>拥有。这将保证数据不会因并发访问而损坏。为了读或写状态，其他<code>goroutine</code>将发送消息到拥有的<code>goroutine</code>并接收相应的回复。这些<code>readOp</code>和<code>writeOp</code>结构封装了这些请求，并拥有一个<code>goroutine</code>响应的方法。</p> 
 <p>和以前一样，我们将计算执行的操作数。</p> 
 <p>读写通道将被其他<code>goroutine</code>分别用来发出读和写请求。</p> 
 <p>这里是拥有状态的<code>goroutine</code>，它是一个如前面示例中的映射，但现在对状态<code>goroutine</code>是私有的。这个<code>goroutine</code>在读取和写入通道时重复选择，在请求到达时响应请求。 通过首先执行所请求的操作，然后在响应信道上发送值以指示成功(以及在读取的情况下的期望值)来执行响应。</p> 
 <p>这里启动了<code>100</code>个<code>goroutine</code>来通过读取通道向状态拥有的<code>goroutine</code>发出读取。每次读取都需要构造一个<code>readOp</code>，通过读取通道发送<code>readOp</code>，并通过提供的<code>resp</code>通道接收结果。</p> 
 <p>也使用类似的方法开始<code>10</code>个写操作。让<code>goroutine</code>工作一秒钟。最后，捕获和报告操作计数。</p> 
 <p>运行程序显示，基于<code>goroutine</code>的状态管理示例程序，完成了大约<code>80,000</code>次操作。</p> 
 <p>对于这种特殊情况，基于<code>goroutine</code>的方法比基于互斥的方法更多一些。它在某些情况下可能是有用的，例如，当有其他通道涉及或管理多个此类互斥体将容易出错。应该使用最自然的方法，有助于理解程序。</p> 
 <blockquote> 
  <p>所有的示例代码，都放在 <code>F:\worksp\golang</code> 目录下。安装Go编程环境请参考：<a target="_blank" href="http://www.yiibai.com/go/go_environment.html">http://www.yiibai.com/go/go_environment.html</a> </p> 
 </blockquote> 
 <p><code>stateful-goroutines.go</code>的完整代码如下所示 -</p> 
 <pre><code class="lang-go">package main

import (
    "fmt"
    "math/rand"
    "sync/atomic"
    "time"
)

// In this example our state will be owned by a single
// goroutine. This will guarantee that the data is never
// corrupted with concurrent access. In order to read or
// write that state, other goroutines will send messages
// to the owning goroutine and receive corresponding
// replies. These `readOp` and `writeOp` `struct`s
// encapsulate those requests and a way for the owning
// goroutine to respond.
type readOp struct {
    key  int
    resp chan int
}
type writeOp struct {
    key  int
    val  int
    resp chan bool
}

func main() {

    // As before we'll count how many operations we perform.
    var readOps uint64 = 0
    var writeOps uint64 = 0

    // The `reads` and `writes` channels will be used by
    // other goroutines to issue read and write requests,
    // respectively.
    reads := make(chan *readOp)
    writes := make(chan *writeOp)

    // Here is the goroutine that owns the `state`, which
    // is a map as in the previous example but now private
    // to the stateful goroutine. This goroutine repeatedly
    // selects on the `reads` and `writes` channels,
    // responding to requests as they arrive. A response
    // is executed by first performing the requested
    // operation and then sending a value on the response
    // channel `resp` to indicate success (and the desired
    // value in the case of `reads`).
    go func() {
        var state = make(map[int]int)
        for {
            select {
            case read := &lt;-reads:
                read.resp &lt;- state[read.key]
            case write := &lt;-writes:
                state[write.key] = write.val
                write.resp &lt;- true
            }
        }
    }()

    // This starts 100 goroutines to issue reads to the
    // state-owning goroutine via the `reads` channel.
    // Each read requires constructing a `readOp`, sending
    // it over the `reads` channel, and the receiving the
    // result over the provided `resp` channel.
    for r := 0; r &lt; 100; r++ {
        go func() {
            for {
                read := &amp;readOp{
                    key:  rand.Intn(5),
                    resp: make(chan int)}
                reads &lt;- read
                &lt;-read.resp
                atomic.AddUint64(&amp;readOps, 1)
                time.Sleep(time.Millisecond)
            }
        }()
    }

    // We start 10 writes as well, using a similar
    // approach.
    for w := 0; w &lt; 10; w++ {
        go func() {
            for {
                write := &amp;writeOp{
                    key:  rand.Intn(5),
                    val:  rand.Intn(100),
                    resp: make(chan bool)}
                writes &lt;- write
                &lt;-write.resp
                atomic.AddUint64(&amp;writeOps, 1)
                time.Sleep(time.Millisecond)
            }
        }()
    }

    // Let the goroutines work for a second.
    time.Sleep(time.Second)

    // Finally, capture and report the op counts.
    readOpsFinal := atomic.LoadUint64(&amp;readOps)
    fmt.Println("readOps:", readOpsFinal)
    writeOpsFinal := atomic.LoadUint64(&amp;writeOps)
    fmt.Println("writeOps:", writeOpsFinal)
}
</code></pre> 
 <p>执行上面代码，将得到以下输出结果 - </p>   
 <pre><code class="lang-go">F:\worksp\golang&gt;go run mutexes.go
readOps: 84546
writeOps: 8473
state: map[0:99 3:3 4:62 1:18 2:89]
</code></pre>
 <br>      
</div></body></html>