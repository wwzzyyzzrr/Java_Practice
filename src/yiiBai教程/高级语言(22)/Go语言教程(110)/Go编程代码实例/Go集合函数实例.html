<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Go集合函数实例</h1><div style="width:100%;float:left;" class="article-content">   
 <p>我们经常需要在程序中对数据集合执行操作，例如选择满足给定谓词的所有项目，或将所有项目映射到具有自定义函数的新集合。</p> 
 <p>在某些语言中，通用数据结构和算法是惯用的。 Go不支持泛型; 在Go中，如果并且当它们对于程序和数据类型特别需要时，提供集合函数是很常见的。</p> 
 <p>这里是一些字符串切片的示例收集函数。可以使用这些示例来构建您自己的函数。注意，在某些情况下，直接内联集合操作代码可能是最清楚的，而不用创建和调用辅助函数。</p> 
 <p>参考示例代码中实现的功能如下：</p> 
 <p>返回目标字符串<code>t</code>的第一个索引，如果未找到匹配，则返回<code>-1</code>。如果目标字符串<code>t</code>在切片中，则返回<code>true</code>。</p> 
 <p>如果切片中的一个字符串满足谓词<code>f</code>，则返回<code>true</code>。</p> 
 <p>如果切片中的所有字符串都满足谓词<code>f</code>，则返回<code>true</code>。</p> 
 <p>返回包含切片中满足谓词<code>f</code>的所有字符串的新切片。</p> 
 <p>返回一个新的切片，包含将函数<code>f</code>应用于原始切片中的每个字符串的结果。</p> 
 <p>在这里试试各种集合函数。<br>下面的例子都使用匿名函数，但也可以使用正确类型的命名函数。</p> 
 <blockquote> 
  <p>所有的示例代码，都放在 <code>F:\worksp\golang</code> 目录下。安装Go编程环境请参考：<a target="_blank" href="http://www.yiibai.com/go/go_environment.html">http://www.yiibai.com/go/go_environment.html</a> </p> 
 </blockquote> 
 <p><code>collection-functions.go</code>的完整代码如下所示 -</p> 
 <pre><code class="lang-go">package main

import "strings"
import "fmt"

// Returns the first index of the target string `t`, or
// -1 if no match is found.
func Index(vs []string, t string) int {
    for i, v := range vs {
        if v == t {
            return i
        }
    }
    return -1
}

// Returns `true` if the target string t is in the
// slice.
func Include(vs []string, t string) bool {
    return Index(vs, t) &gt;= 0
}

// Returns `true` if one of the strings in the slice
// satisfies the predicate `f`.
func Any(vs []string, f func(string) bool) bool {
    for _, v := range vs {
        if f(v) {
            return true
        }
    }
    return false
}

// Returns `true` if all of the strings in the slice
// satisfy the predicate `f`.
func All(vs []string, f func(string) bool) bool {
    for _, v := range vs {
        if !f(v) {
            return false
        }
    }
    return true
}

// Returns a new slice containing all strings in the
// slice that satisfy the predicate `f`.
func Filter(vs []string, f func(string) bool) []string {
    vsf := make([]string, 0)
    for _, v := range vs {
        if f(v) {
            vsf = append(vsf, v)
        }
    }
    return vsf
}

// Returns a new slice containing the results of applying
// the function `f` to each string in the original slice.
func Map(vs []string, f func(string) string) []string {
    vsm := make([]string, len(vs))
    for i, v := range vs {
        vsm[i] = f(v)
    }
    return vsm
}

func main() {

    // Here we try out our various collection functions.
    var strs = []string{"peach", "apple", "pear", "plum"}

    fmt.Println(Index(strs, "pear"))

    fmt.Println(Include(strs, "grape"))

    fmt.Println(Any(strs, func(v string) bool {
        return strings.HasPrefix(v, "p")
    }))

    fmt.Println(All(strs, func(v string) bool {
        return strings.HasPrefix(v, "p")
    }))

    fmt.Println(Filter(strs, func(v string) bool {
        return strings.Contains(v, "e")
    }))

    // The above examples all used anonymous functions,
    // but you can also use named functions of the correct
    // type.
    fmt.Println(Map(strs, strings.ToUpper))

}
</code></pre> 
 <p>执行上面代码，将得到以下输出结果 - </p>   
 <pre><code class="lang-go">F:\worksp\golang&gt;go run collection-functions.go
2
false
true
false
[peach apple pear]
[PEACH APPLE PEAR PLUM]
</code></pre>
 <br>      
</div></body></html>