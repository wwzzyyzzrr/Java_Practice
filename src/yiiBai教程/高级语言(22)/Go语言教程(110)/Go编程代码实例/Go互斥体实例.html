<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Go互斥体实例</h1><div style="width:100%;float:left;" class="article-content">   
 <p>在前面的例子中，我们看到了如何使用原子操作来管理简单的计数器状态。对于更复杂的状态，可以使用互斥体来安全地访问多个<code>goroutine</code>中的数据。</p> 
 <p>在这个例子中，状态(state)是一个映射。<br>示例中的互斥将同步访问状态。</p> 
 <p>我们将跟踪执行的读写操作的数量。</p> 
 <p>这里将启动<code>100</code>个<code>goroutine</code>来对状态执行重复读取，每个<code>goroutine</code>中每毫秒读取一次。</p> 
 <p>对于每个读取，我们选择一个键来访问，<code>Lock()</code>互斥体以确保对状态的独占访问，读取所选键的值，<code>Unlock()</code>互斥体，并增加<code>readOps</code>计数。</p> 
 <p>我们还将启动<code>10</code>个<code>goroutine</code>来模拟写入，使用与读取相同的模式。</p> 
 <p>让<code>10</code>个<code>goroutine</code>在状态和互斥体上工作一秒钟。采集和报告最终操作计数。</p> 
 <p>收集和报告最终操作计数。用最后的锁状态，显示它是如何结束的。</p> 
 <p>运行程序显示，我们对互斥同步状态执行了大约<code>90,000</code>次的操作。</p> 
 <blockquote> 
  <p>所有的示例代码，都放在 <code>F:\worksp\golang</code> 目录下。安装Go编程环境请参考：<a target="_blank" href="http://www.yiibai.com/go/go_environment.html">http://www.yiibai.com/go/go_environment.html</a> </p> 
 </blockquote> 
 <p><code>mutexes.go</code>的完整代码如下所示 -</p> 
 <pre><code class="lang-go">package main

import (
    "fmt"
    "math/rand"
    "sync"
    "sync/atomic"
    "time"
)

func main() {

    // For our example the `state` will be a map.
    var state = make(map[int]int)

    // This `mutex` will synchronize access to `state`.
    var mutex = &amp;sync.Mutex{}

    // We'll keep track of how many read and write
    // operations we do.
    var readOps uint64 = 0
    var writeOps uint64 = 0

    // Here we start 100 goroutines to execute repeated
    // reads against the state, once per millisecond in
    // each goroutine.
    for r := 0; r &lt; 100; r++ {
        go func() {
            total := 0
            for {

                // For each read we pick a key to access,
                // `Lock()` the `mutex` to ensure
                // exclusive access to the `state`, read
                // the value at the chosen key,
                // `Unlock()` the mutex, and increment
                // the `readOps` count.
                key := rand.Intn(5)
                mutex.Lock()
                total += state[key]
                mutex.Unlock()
                atomic.AddUint64(&amp;readOps, 1)

                // Wait a bit between reads.
                time.Sleep(time.Millisecond)
            }
        }()
    }

    // We'll also start 10 goroutines to simulate writes,
    // using the same pattern we did for reads.
    for w := 0; w &lt; 10; w++ {
        go func() {
            for {
                key := rand.Intn(5)
                val := rand.Intn(100)
                mutex.Lock()
                state[key] = val
                mutex.Unlock()
                atomic.AddUint64(&amp;writeOps, 1)
                time.Sleep(time.Millisecond)
            }
        }()
    }

    // Let the 10 goroutines work on the `state` and
    // `mutex` for a second.
    time.Sleep(time.Second)

    // Take and report final operation counts.
    readOpsFinal := atomic.LoadUint64(&amp;readOps)
    fmt.Println("readOps:", readOpsFinal)
    writeOpsFinal := atomic.LoadUint64(&amp;writeOps)
    fmt.Println("writeOps:", writeOpsFinal)

    // With a final lock of `state`, show how it ended up.
    mutex.Lock()
    fmt.Println("state:", state)
    mutex.Unlock()
}
</code></pre> 
 <p>执行上面代码，将得到以下输出结果 - </p>   
 <pre><code class="lang-go">F:\worksp\golang&gt;go run mutexes.go
readOps: 84546
writeOps: 8473
state: map[0:99 3:3 4:62 1:18 2:89]
</code></pre>
 <br>      
</div></body></html>