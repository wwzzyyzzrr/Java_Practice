<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Go Select实例</h1><div style="width:100%;float:left;" class="article-content">   
 <p>Go语言的选择(<code>select</code>)可等待多个通道操作。将<code>goroutine</code>和<code>channel</code>与<code>select</code>结合是Go语言的一个强大功能。</p> 
 <p>对于这个示例，将选择两个通道。<br>每个通道将在一段时间后开始接收值，以模拟阻塞在并发<code>goroutines</code>中执行的<code>RPC</code>操作。我们将使用<code>select</code>同时等待这两个值，在每个值到达时打印它们。</p> 
 <p>执行实例程序得到的值是“<code>one</code>”，然后是“<code>two</code>”。注意，总执行时间只有<code>1〜2</code>秒，因为<code>1-2</code>秒<code>Sleeps</code>同时执行。</p> 
 <blockquote> 
  <p>所有的示例代码，都放在 <code>F:\worksp\golang</code> 目录下。安装Go编程环境请参考：<a target="_blank" href="http://www.yiibai.com/go/go_environment.html">http://www.yiibai.com/go/go_environment.html</a> </p> 
 </blockquote> 
 <p><code>select.go</code>的完整代码如下所示 -</p> 
 <pre><code class="lang-go">package main

import "time"
import "fmt"

func main() {

    // For our example we'll select across two channels.
    c1 := make(chan string)
    c2 := make(chan string)

    // Each channel will receive a value after some amount
    // of time, to simulate e.g. blocking RPC operations
    // executing in concurrent goroutines.
    go func() {
        time.Sleep(time.Second * 1)
        c1 &lt;- "one"
    }()
    go func() {
        time.Sleep(time.Second * 2)
        c2 &lt;- "two"
    }()

    // We'll use `select` to await both of these values
    // simultaneously, printing each one as it arrives.
    for i := 0; i &lt; 2; i++ {
        select {
        case msg1 := &lt;-c1:
            fmt.Println("received", msg1)
        case msg2 := &lt;-c2:
            fmt.Println("received", msg2)
        }
    }
}
</code></pre> 
 <p>执行上面代码，将得到以下输出结果 - </p>   
 <pre><code class="lang-go">F:\worksp\golang&gt;go run select.go
received one
received two
</code></pre>
 <br>      
</div></body></html>