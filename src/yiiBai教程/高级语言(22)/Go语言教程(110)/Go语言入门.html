<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Go语言入门</h1><div style="width:100%;float:left;" class="article-content">   
 <p>在学习Go语言编程之前，我们需要安装和配置好Go语言的开发环境。可以选择线上的编译器：<a target="_blank" href="http://tour.golang.org/welcome/1">http://tour.golang.org/welcome/1</a> 来直接执行代码。也可以在您自己的计算机上安装开发编译环境。</p> 
 <h2 id="h2-go-"><a name="Go本地环境设置" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Go本地环境设置</h2>
 <p>如果您愿意在本地环境安装和配置Go编程语言，则需要在计算机上提供以下两个软件：</p> 
 <ul> 
  <li>文本编辑器</li>
  <li>Go编译器</li>
 </ul> 
 <h3 id="h3-u6587u672Cu7F16u8F91u5668"><a name="文本编辑器" class="reference-link"></a><span class="header-link octicon octicon-link"></span>文本编辑器</h3>
 <p>这是用于编写您的程序代码。常见的几个编辑器包括Windows记事本，OS编辑命令，<code>Brief</code>，<code>Epsilon</code>，<code>EMACS</code>和<code>vim</code>(或<code>vi</code>)。</p> 
 <p>文本编辑器的名称和版本可能因不同的操作系统而异。例如，记事本只能在Windows上使用，vim(或vi)可以在Windows以及Linux或UNIX上使用。</p> 
 <p>使用编辑器创建的文件称为源文件，源文件中包含程序的源代码。Go程序的源文件通常使用扩展名“<code>.go</code>”来命名。</p> 
 <p>在开始编程之前，确保您安装好并熟练使用一个文本编辑器，并且有足够的经验来编写计算机程序代码，将代码保存在文件中，编译并最终执行它。</p> 
 <h3 id="h3-go-"><a name="Go编译器" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Go编译器</h3>
 <p>在源文件中编写的源代码是人类可读的源程序。 它需要“编译”变成机器语言，以便CPU可以根据给出的指令实际执行程序。</p> 
 <p>这个Go编程语言编译器用于将源代码编译成可执行程序。这里假设您知道或了解编程语言编译器的基本知识。</p> 
 <p>Go发行版本是FreeBSD(版本8及更高版本)，Linux，Mac OS X(Snow Leopard及更高版本)和具有<code>32</code>位(386)和<code>64</code>位(amd64)x86处理器架构的Windows操作系统的二进制安装版本 。</p> 
 <p>以下部分将演示如何在各种操作系统上安装<strong>Go语言</strong>环境的二进制分发包。</p> 
 <h3 id="h3--go-"><a name="下载Go存档文件" class="reference-link"></a><span class="header-link octicon octicon-link"></span>下载Go存档文件</h3>
 <p>从链接【<a target="_blank" href="http://golang.org/dl/" title="Go下载">Go下载</a>】中下载最新版本的Go可安装的归档文件。在写本教程的时候，选择的是<code>go1.7.4.windows-amd64.msi</code>并将下载到桌面上。</p> 
 <blockquote> 
  <p>注：写本教程的时，使用的电脑是：Windows 10 64bit 系统</p> 
 </blockquote> 
 <p>如果操作系统不一样，可选择对应版本下载安装。</p> 
 <table> 
  <thead> 
   <tr> 
    <th>操作系统</th> 
    <th>存档名称</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>Windows</td> 
    <td>go1.7.windows-amd64.msi</td> 
   </tr> 
   <tr> 
    <td>Linux</td> 
    <td>go1.7.linux-amd64.tar.gz</td> 
   </tr> 
   <tr> 
    <td>Mac</td> 
    <td>go1.7.4.darwin-amd64.pkg</td> 
   </tr> 
   <tr> 
    <td>FreeBSD</td> 
    <td>go1.7.freebsd-amd64.tar.gz</td> 
   </tr> 
  </tbody> 
 </table> 
 <h3 id="h3--unix-linux-mac-os-x-freebsd-"><a name="在UNIX/Linux/Mac OS X和FreeBSD上安装" class="reference-link"></a><span class="header-link octicon octicon-link"></span>在UNIX/Linux/Mac OS X和FreeBSD上安装</h3>
 <p>将下载归档文件解压缩到<code>/usr/local</code>目录中，在<code>/usr/local/go</code>目录创建一个Go树。 例如：</p> 
 <pre><code class="lang-bash">tar -C /usr/local -xzf go1.7.4.linux-amd64.tar.gz
</code></pre> 
 <p>将<code>/usr/local/go/bin</code>添加到<code>PATH</code>环境变量。</p> 
 <table> 
  <thead> 
   <tr> 
    <th>操作系统</th> 
    <th>输出</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>Linux</td> 
    <td>export PATH=$PATH:/usr/local/go/bin</td> 
   </tr> 
   <tr> 
    <td>Mac</td> 
    <td>export PATH=$PATH:/usr/local/go/bin</td> 
   </tr> 
   <tr> 
    <td>FreeBSD</td> 
    <td>export PATH=$PATH:/usr/local/go/bin</td> 
   </tr> 
  </tbody> 
 </table> 
 <h3 id="h3--windows-"><a name="在Windows上安装" class="reference-link"></a><span class="header-link octicon octicon-link"></span>在Windows上安装</h3>
 <p>使用MSI文件并按照提示安装Go工具。 默认情况下，安装程序使用<code>C:\Go</code>目录。安装程序应该在窗口的PATH环境变量中设置<code>C:\Go\bin</code>目录。重新启动后，打开的命令提示验证更改是否生效。</p> 
 <p><strong> 验证安装结果 </strong></p> 
 <p>在<code>F:\worksp\golang</code>中创建一个<code>test.go</code>的go文件。编写并保存以下代码到 <code>test.go</code> 文件中。</p> 
 <pre><code class="lang-go">package main

import "fmt"

func main() {
   fmt.Println("Hello, World!")
}
</code></pre> 
 <p>现在运行<code>test.go</code>查看结果并验证输出结果如下：</p> 
 <pre><code class="lang-bash">F:\worksp\golang&gt;go run test.go
Hello, World!
</code></pre> 
 <h2 id="h2-u5305u7684u4F7Fu7528"><a name="包的使用" class="reference-link"></a><span class="header-link octicon octicon-link"></span>包的使用</h2>
 <p>每个 Go 程序都是由包组成的。<br>程序运行的入口是包 <code>main</code> 。<br>这个程序使用并导入了包 “<code>fmt</code>“ 和 “<code>math/rand</code>“ 。<br>按照惯例，包名与导入路径的最后一个目录一致。例如，”<code>math/rand</code>“ 包由 <code>package rand</code> 语句开始。</p> 
 <blockquote> 
  <p>注意：这个程序的运行环境是确定性的，因此 rand.Intn 每次都会返回相同的数字。</p> 
 </blockquote> 
 <pre><code class="lang-go">package main

import (
    "fmt"
    "math/rand"
)

func main() {
    fmt.Println("My favorite number is", rand.Intn(10))
}
</code></pre> 
 <h3 id="h3-u5BFCu5165u5305"><a name="导入包" class="reference-link"></a><span class="header-link octicon octicon-link"></span>导入包</h3>
 <p>这个代码用圆括号组合了导入，这是“打包”导入语句。</p> 
 <p>同样可以编写多个导入语句，例如：</p> 
 <pre><code class="lang-go">import "fmt"
import "math"
</code></pre> 
 <p>不过使用打包的导入语句是更好的形式。</p> 
 <pre><code class="lang-go">package main

import (
    "fmt"
    "math"
)

func main() {
    fmt.Printf("Now you have %g problems.", math.Sqrt(7))
}
</code></pre> 
 <h3 id="h3-u5BFCu51FAu540Du79F0"><a name="导出名称" class="reference-link"></a><span class="header-link octicon octicon-link"></span>导出名称</h3>
 <p>在 <code>Go</code> 中，首字母大写的名称是被导出的。</p> 
 <p>在导入包之后，只能访问包所导出的名字，任何未导出的名字是不能被包外的代码访问的。</p> 
 <p><code>Foo</code> 和 <code>FOO</code> 都是被导出的名称。名称 <code>foo</code> 是不会被导出的。</p> 
 <p>执行代码，注意编译器报的错误。</p> 
 <p>然后将 <code>math.pi</code> 改名为 <code>math.Pi</code> 再试着执行一下。</p> 
 <pre><code class="lang-go">package main

import (
    "fmt"
    "math"
)

func main() {
    fmt.Println(math.pi)
}
</code></pre> 
 <h3 id="h3-u51FDu6570"><a name="函数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>函数</h3>
 <p>函数可以没有参数或接受多个参数。<br>在这个例子中， <code>add</code> 接受两个 <code>int</code> 类型的参数。<br>注意类型在变量名之后 。</p> 
 <pre><code class="lang-go">package main

import "fmt"

func add(x int, y int) int {
    return x + y
}

func main() {
    fmt.Println(add(42, 13))
}
</code></pre> 
 <p>当两个或多个连续的函数命名参数是同一类型，则除了最后一个类型之外，其他都可以省略。</p> 
 <p>在这个例子中 ，</p> 
 <pre><code class="lang-go">x int, y int
</code></pre> 
 <p>可缩写为：</p> 
 <pre><code class="lang-go">x, y int
</code></pre> 
 <h3 id="h3-u51FDu6570u591Au503Cu8FD4u56DE"><a name="函数多值返回" class="reference-link"></a><span class="header-link octicon octicon-link"></span>函数多值返回</h3>
 <p>函数可以返回任意数量的返回值。<br><code>swap</code> 函数返回了两个字符串。</p> 
 <pre><code class="lang-go">package main

import "fmt"

func swap(x, y string) (string, string) {
    return y, x
}

func main() {
    a, b := swap("hello", "world")
    fmt.Println(a, b)
}
</code></pre> 
 <h3 id="h3-u51FDu6570u4E2Du547Du540Du8FD4u56DEu503C"><a name="函数中命名返回值" class="reference-link"></a><span class="header-link octicon octicon-link"></span>函数中命名返回值</h3>
 <p>Go 的返回值可以被命名，并且就像在函数体开头声明的变量那样使用。<br>返回值的名称应当具有一定的意义，可以作为文档使用。<br>没有参数的 <code>return</code> 语句返回各个返回变量的当前值。这种用法被称作“裸”返回。<br>直接返回语句仅应当用在像下面这样的短函数中。在长的函数中它们会影响代码的可读性。</p> 
 <pre><code class="lang-go">package main

import "fmt"

func split(sum int) (x, y int) {
    x = sum * 4 / 9
    y = sum - x
    return
}

func main() {
    fmt.Println(split(17))
}
</code></pre> 
 <h3 id="h3-u53D8u91CF"><a name="变量" class="reference-link"></a><span class="header-link octicon octicon-link"></span>变量</h3>
 <p><code>var</code> 语句定义了一个变量的列表；跟函数的参数列表一样，类型在后面。就像在这个例子中看到的一样， <code>var</code> 语句可以定义在包或函数级别。</p> 
 <pre><code class="lang-go">package main

import "fmt"

var c, python, java bool

func main() {
    var i int
    fmt.Println(i, c, python, java)
}
</code></pre> 
 <h3 id="h3-u521Du59CBu5316u53D8u91CF"><a name="初始化变量" class="reference-link"></a><span class="header-link octicon octicon-link"></span>初始化变量</h3>
 <p>变量定义可以包含初始值，每个变量对应一个。如果初始化是使用表达式，则可以省略类型；变量从初始值中获得类型。</p> 
 <pre><code class="lang-go">package main

import "fmt"

var i, j int = 1, 2

func main() {
    var c, python, java = true, false, "no!"
    fmt.Println(i, j, c, python, java)
}
</code></pre> 
 <h3 id="h3-u77EDu58F0u660Eu53D8u91CF"><a name="短声明变量" class="reference-link"></a><span class="header-link octicon octicon-link"></span>短声明变量</h3>
 <p>在函数中， <code>:=</code> 简洁赋值语句在明确类型的地方，可以用于替代 <code>var</code> 定义。<br>函数外的每个语句都必须以关键字开始( <code>var</code> 、 <code>func</code> 、等等)， <code>:=</code>结构不能使用在函数外。</p> 
 <pre><code class="lang-go">package main

import "fmt"

func main() {
    var i, j int = 1, 2
    k := 3
    c, python, java := true, false, "no!"

    fmt.Println(i, j, k, c, python, java)
}
</code></pre> 
 <h2 id="h2-u57FAu672Cu6570u636Eu7C7Bu578B"><a name="基本数据类型" class="reference-link"></a><span class="header-link octicon octicon-link"></span>基本数据类型</h2>
 <p>Go 的基本类型有：</p> 
 <pre><code class="lang-go">bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // uint8 的别名

rune // int32 的别名
     // 代表一个Unicode码

float32 float64

complex64 complex128
</code></pre> 
 <p>这个例子演示了具有不同类型的变量。 同时与导入语句一样，变量的定义“打包”在一个语法块中。</p> 
 <p><code>int</code>，<code>uint</code> 和 <code>uintptr</code> 类型在32位的系统上一般是32位，而在64位系统上是64位。当你需要使用一个整数类型时，应该首选 <code>int</code>，仅当有特别的理由才使用定长整数类型或者无符号整数类型。</p> 
 <pre><code class="lang-go">package main

import (
    "fmt"
    "math/cmplx"
)

var (
    ToBe   bool       = false
    MaxInt uint64     = 1&lt;&lt;64 - 1
    z      complex128 = cmplx.Sqrt(-5 + 12i)
)

func main() {
    const f = "%T(%v)\n"
    fmt.Printf(f, ToBe, ToBe)
    fmt.Printf(f, MaxInt, MaxInt)
    fmt.Printf(f, z, z)
}
</code></pre> 
 <h2 id="h2-u96F6u503C"><a name="零值" class="reference-link"></a><span class="header-link octicon octicon-link"></span>零值</h2>
 <p>变量在定义时没有明确的初始化时会赋值为 零值 。</p> 
 <p>零值是：</p> 
 <p>数值类型为 <code>0</code> ，<br>布尔类型为 <code>false</code> ，<br>字符串为 “” (空字符串)。</p> 
 <pre><code class="lang-go">package main

import "fmt"

func main() {
    var i int
    var f float64
    var b bool
    var s string
    fmt.Printf("%v %v %v %q\n", i, f, b, s)
}
</code></pre> 
 <h3 id="h3-u7C7Bu578Bu8F6Cu6362"><a name="类型转换" class="reference-link"></a><span class="header-link octicon octicon-link"></span>类型转换</h3>
 <p>表达式<code>T(v)</code> 将值 <code>v</code> 转换为类型 <code>T</code> 。</p> 
 <p>一些关于数值的转换：</p> 
 <pre><code class="lang-go">var i int = 42
var f float64 = float64(i)
var u uint = uint(f)
</code></pre> 
 <p>或者，更加简单的形式：</p> 
 <pre><code class="lang-go">i := 42
f := float64(i)
u := uint(f)
</code></pre> 
 <p>与 C 不同的是 Go 的在不同类型之间的项目赋值时需要显式转换。 试着移除例子中 <code>float64</code> 或 <code>int</code> 的转换看看会发生什么。</p> 
 <pre><code class="lang-go">package main

import (
    "fmt"
    "math"
)

func main() {
    var x, y int = 3, 4
    var f float64 = math.Sqrt(float64(x*x + y*y))
    var z uint = uint(f)
    fmt.Println(x, y, z)
}
</code></pre> 
 <h3 id="h3-u7C7Bu578Bu63A8u5BFC"><a name="类型推导" class="reference-link"></a><span class="header-link octicon octicon-link"></span>类型推导</h3>
 <p>类型推导<br>在定义一个变量却并不显式指定其类型时(使用 <code>:=</code> 语法或者 <code>var =</code>表达式语法)， 变量的类型由(等号)右侧的值推导得出。</p> 
 <p>当右值定义了类型时，新变量的类型与其相同：</p> 
 <pre><code class="lang-go">var i int
j := i // j 也是一个 int
</code></pre> 
 <p>但是当右边包含了未指名类型的数字常量时，新的变量就可能是 <code>int</code> 、 <code>float64</code> 或 <code>complex128</code> 。 这取决于常量的精度：</p> 
 <pre><code class="lang-go">i := 42           // int
f := 3.142        // float64
g := 0.867 + 0.5i // complex128
</code></pre> 
 <p>尝试修改演示代码中 <code>v</code> 的初始值，并观察这是如何影响其类型的。</p> 
 <pre><code class="lang-go">package main

import "fmt"

func main() {
    v := 42 // change me!
    fmt.Printf("v is of type %T\n", v)
}
</code></pre> 
 <h2 id="h2-u5E38u91CF"><a name="常量" class="reference-link"></a><span class="header-link octicon octicon-link"></span>常量</h2>
 <p>常量的定义与变量类似，只不过使用 <code>const</code> 关键字。</p> 
 <p>常量可以是字符、字符串、布尔或数字类型的值。</p> 
 <p>常量不能使用 <code>:=</code> 语法定义。</p> 
 <pre><code class="lang-go">package main

import "fmt"

const Pi = 3.14

func main() {
    const World = "世界"
    fmt.Println("Hello", World)
    fmt.Println("Happy", Pi, "Day")

    const Truth = true
    fmt.Println("Go rules?", Truth)
}
</code></pre> 
 <h3 id="h3-u6570u503Cu5E38u91CF"><a name="数值常量" class="reference-link"></a><span class="header-link octicon octicon-link"></span>数值常量</h3>
 <p>数值常量是高精度的值 。<br>一个未指定类型的常量由上下文来决定其类型。<br>也尝试一下输出 <code>needInt(Big)</code> 吧。<br>(<code>int</code> 可以存放最大<code>64</code>位的整数，根据平台不同有时会更少。)</p> 
 <pre><code class="lang-go">package main

import "fmt"

const (
    Big   = 1 &lt;&lt; 100
    Small = Big &gt;&gt; 99
)

func needInt(x int) int { return x*10 + 1 }
func needFloat(x float64) float64 {
    return x * 0.1
}

func main() {
    fmt.Println(needInt(Small))
    fmt.Println(needFloat(Small))
    fmt.Println(needFloat(Big))
}
</code></pre> 
 <h2 id="h2-u63A7u5236u6D41"><a name="控制流" class="reference-link"></a><span class="header-link octicon octicon-link"></span>控制流</h2>
 <h3 id="h3-for"><a name="for" class="reference-link"></a><span class="header-link octicon octicon-link"></span>for</h3>
 <p>Go 只有一种循环结构 —— <code>for</code> 循环。</p> 
 <p>基本的 <code>for</code> 循环包含三个由分号分开的组成部分：</p> 
 <p>初始化语句：在第一次循环执行前被执行<br>循环条件表达式：每轮迭代开始前被求值<br>后置语句：每轮迭代后被执行<br>初始化语句一般是一个短变量声明，这里声明的变量仅在整个 <code>for</code> 循环语句可见。</p> 
 <p>如果条件表达式的值变为 <code>false</code>，那么迭代将终止。</p> 
 <p>注意：不像 C，Java，或者 Javascript 等其他语言，<code>for</code> 语句的三个组成部分 并不需要用括号括起来，但循环体必须用<code>{ }</code>括起来。</p> 
 <pre><code class="lang-go">package main

import "fmt"

func main() {
    sum := 0
    for i := 0; i &lt; 10; i++ {
        sum += i
    }
    fmt.Println(sum)
}
</code></pre> 
 <p>循环初始化语句和后置语句都是可选的，如下示例代码所示 - </p> 
 <pre><code class="lang-go">package main

import "fmt"

func main() {
    sum := 1
    for ; sum &lt; 1000; {
        sum += sum
    }
    fmt.Println(sum)
}
</code></pre> 
 <h3 id="h3-for-go-while-"><a name="for 是 Go 的 “while”" class="reference-link"></a><span class="header-link octicon octicon-link"></span>for 是 Go 的 “while”</h3>
 <p>基于此可以省略分号：C 的 <code>while</code> 在 Go 中叫做 <code>for</code> 。</p> 
 <pre><code class="lang-go">package main

import "fmt"

func main() {
    sum := 1
    for sum &lt; 1000 {
        sum += sum
    }
    fmt.Println(sum)
}
</code></pre> 
 <h3 id="h3-u6B7Bu5FAAu73AF"><a name="死循环" class="reference-link"></a><span class="header-link octicon octicon-link"></span>死循环</h3>
 <p>如果省略了循环条件，循环就不会结束，因此可以用更简洁地形式表达死循环。</p> 
 <pre><code class="lang-go">package main

func main() {
    for {// 无退出条件，变成死循环
    }
}
</code></pre> 
 <h3 id="h3-if"><a name="if" class="reference-link"></a><span class="header-link octicon octicon-link"></span>if</h3>
 <p>就像 <code>for</code> 循环一样，Go 的 <code>if</code> 语句也不要求用<code>( )</code> 将条件括起来，同时，<code>{ }</code>还是必须有的。</p> 
 <pre><code class="lang-go">package main

import (
    "fmt"
    "math"
)

func sqrt(x float64) string {
    if x &lt; 0 {
        return sqrt(-x) + "i"
    }
    return fmt.Sprint(math.Sqrt(x))
}

func main() {
    fmt.Println(sqrt(2), sqrt(-4))
}
</code></pre> 
 <h3 id="h3-if-"><a name="if 的便捷语句" class="reference-link"></a><span class="header-link octicon octicon-link"></span>if 的便捷语句</h3>
 <p>跟 <code>for</code> 语句一样， <code>if</code> 语句可以在条件之前执行一个简单语句。<br>由这个语句定义的变量的作用域仅在 <code>if</code> 范围之内。<br>(在最后的 <code>return</code> 语句处使用 <code>v</code> 看看。)</p> 
 <pre><code class="lang-go">package main

import (
    "fmt"
    "math"
)

func pow(x, n, lim float64) float64 {
    if v := math.Pow(x, n); v &lt; lim {
        return v
    }
    return lim
}

func main() {
    fmt.Println(
        pow(3, 2, 10),
        pow(3, 3, 20),
    )
}
</code></pre> 
 <h3 id="h3-if-else"><a name="if 和 else" class="reference-link"></a><span class="header-link octicon octicon-link"></span>if 和 else</h3>
 <p>在 <code>if</code> 的便捷语句定义的变量同样可以在任何对应的 <code>else</code> 块中使用。<br>(提示：两个 <code>pow</code> 调用都在 <code>main</code> 调用 <code>fmt.Println</code> 前执行完毕了。)</p> 
 <pre><code class="lang-go">package main

import (
    "fmt"
    "math"
)

func pow(x, n, lim float64) float64 {
    if v := math.Pow(x, n); v &lt; lim {
        return v
    } else {
        fmt.Printf("%g &gt;= %g\n", v, lim)
    }
    // 这里开始就不能使用 v 了
    return lim
}

func main() {
    fmt.Println(
        pow(3, 2, 10),
        pow(3, 3, 20),
    )
}
</code></pre> 
 <h3 id="h3-switch-"><a name="switch语句" class="reference-link"></a><span class="header-link octicon octicon-link"></span>switch语句</h3>
 <p>你可能已经知道 <code>switch</code> 语句会长什么样了。<br>除非以 <code>fallthrough</code> 语句结束，否则分支会自动终止。</p>   
 <pre><code class="lang-go">package main

import (
    "fmt"
    "runtime"
)

func main() {
    fmt.Print("Go runs on ")
    switch os := runtime.GOOS; os {
    case "darwin":
        fmt.Println("OS X.")
    case "linux":
        fmt.Println("Linux.")
    default:
        // freebsd, openbsd,
        // plan9, windows...
        fmt.Printf("%s.", os)
    }
}
</code></pre> 
 <h3 id="h3-switch-"><a name="switch 的执行顺序" class="reference-link"></a><span class="header-link octicon octicon-link"></span>switch 的执行顺序</h3>
 <p><code>switch</code> 的条件从上到下的执行，当匹配成功的时候停止。</p> 
 <p>(例如，</p> 
 <pre><code class="lang-go">switch i {
case 0:
case f():
}
</code></pre> 
 <p>当 <code>i==0</code> 时不会调用 <code>f</code> 。)</p> 
 <p>注意：Go playground 中的时间总是从 <code>2009-11-10 23:00:00 UTC</code> 开始， 如何校验这个值作为一个练习留给读者完成。</p> 
 <pre><code class="lang-go">package main

import (
    "fmt"
    "time"
)

func main() {
    fmt.Println("When's Saturday?")
    today := time.Now().Weekday()
    switch time.Saturday {
    case today + 0:
        fmt.Println("Today.")
    case today + 1:
        fmt.Println("Tomorrow.")
    case today + 2:
        fmt.Println("In two days.")
    default:
        fmt.Println("Too far away.")
    }
}
</code></pre> 
 <h3 id="h3--switch"><a name="没有条件的 switch" class="reference-link"></a><span class="header-link octicon octicon-link"></span>没有条件的 switch</h3>
 <p>没有条件的 <code>switch</code> 同 <code>switch true</code> 一样。<br>这一构造使得可以用更清晰的形式来编写长的 <code>if-then-else</code> 链。</p> 
 <pre><code class="lang-go">package main

import (
    "fmt"
    "time"
)

func main() {
    t := time.Now()
    switch {
    case t.Hour() &lt; 12:
        fmt.Println("Good morning!")
    case t.Hour() &lt; 17:
        fmt.Println("Good afternoon.")
    default:
        fmt.Println("Good evening.")
    }
}
</code></pre> 
 <h3 id="h3-defer-"><a name="defer语句" class="reference-link"></a><span class="header-link octicon octicon-link"></span>defer语句</h3>
 <p><code>defer</code> 语句会延迟函数的执行直到上层函数返回。<br>延迟调用的参数会立刻生成，但是在上层函数返回前函数都不会被调用。</p> 
 <pre><code class="lang-go">package main

import "fmt"

func main() {
    defer fmt.Println("world")

    fmt.Println("hello")
}
</code></pre> 
 <h3 id="h3-defer-"><a name="defer 栈" class="reference-link"></a><span class="header-link octicon octicon-link"></span>defer 栈</h3>
 <p>延迟的函数调用被压入一个栈中。当函数返回时， 会按照后进先出的顺序调用被延迟的函数调用。</p> 
 <pre><code class="lang-go">package main

import "fmt"

func main() {
    fmt.Println("counting")

    for i := 0; i &lt; 10; i++ {
        defer fmt.Println(i)
    }

    fmt.Println("done")
}
</code></pre> 
 <h2 id="h2-u6307u9488"><a name="指针" class="reference-link"></a><span class="header-link octicon octicon-link"></span>指针</h2>
 <p>Go 具有指针。 指针保存了变量的内存地址。</p> 
 <p>类型 <code>*T</code> 是指向类型 <code>T</code>的值的指针。其零值是 <code>nil</code> 。</p> 
 <pre><code class="lang-go">var p *int
</code></pre> 
 <p><code>&amp;</code> 符号会生成一个指向其作用对象的指针。</p> 
 <pre><code class="lang-go">i := 42
p = &amp;i
</code></pre> 
 <p><code>*</code>符号表示指针指向的底层的值。</p> 
 <pre><code class="lang-go">fmt.Println(*p) // 通过指针 p 读取 i
*p = 21         // 通过指针 p 设置 i
</code></pre> 
 <p>这也就是通常所说的“间接引用”或“非直接引用”。<br>与 C 不同，Go 没有指针运算。</p> 
 <pre><code class="lang-go">package main

import "fmt"

func main() {
    i, j := 42, 2701

    p := &amp;i         // point to i
    fmt.Println(*p) // read i through the pointer
    *p = 21         // set i through the pointer
    fmt.Println(i)  // see the new value of i

    p = &amp;j         // point to j
    *p = *p / 37   // divide j through the pointer
    fmt.Println(j) // see the new value of j
}
</code></pre> 
 <h3 id="h3-u7ED3u6784u4F53"><a name="结构体" class="reference-link"></a><span class="header-link octicon octicon-link"></span>结构体</h3>
 <p>一个结构体( <code>struct</code> )就是一个字段的集合。(而 type 的含义跟其字面意思相符。)</p> 
 <pre><code class="lang-go">package main

import "fmt"

type Vertex struct {
    X int
    Y int
}

func main() {
    fmt.Println(Vertex{1, 2})
}
</code></pre> 
 <h3 id="h3-u7ED3u6784u4F53u5B57u6BB5"><a name="结构体字段" class="reference-link"></a><span class="header-link octicon octicon-link"></span>结构体字段</h3>
 <p>结构体字段使用点号来访问。</p> 
 <pre><code class="lang-go">package main

import "fmt"

type Vertex struct {
    X int
    Y int
}

func main() {
    v := Vertex{1, 2}
    v.X = 4
    fmt.Println(v.X)
}
</code></pre> 
 <h3 id="h3-u7ED3u6784u4F53u6307u9488"><a name="结构体指针" class="reference-link"></a><span class="header-link octicon octicon-link"></span>结构体指针</h3>
 <p>结构体字段可以通过结构体指针来访问。<br>通过指针间接的访问是透明的。</p> 
 <pre><code class="lang-go">package main

import "fmt"

type Vertex struct {
    X int
    Y int
}

func main() {
    v := Vertex{1, 2}
    p := &amp;v
    p.X = 1e9
    fmt.Println(v)
}
</code></pre> 
 <h3 id="h3-u7ED3u6784u4F53u7B26u6587"><a name="结构体符文" class="reference-link"></a><span class="header-link octicon octicon-link"></span>结构体符文</h3>
 <p>结构体符文表示通过结构体字段的值作为列表来新分配一个结构体。<br>使用 <code>Name:</code> 语法可以仅列出部分字段。(字段名的顺序无关。)<br>特殊的前缀 <code>&amp;</code> 返回一个指向结构体的指针。</p> 
 <pre><code class="lang-go">package main

import "fmt"

type Vertex struct {
    X, Y int
}

var (
    v1 = Vertex{1, 2}  // 类型为 Vertex
    v2 = Vertex{X: 1}  // Y:0 被省略
    v3 = Vertex{}      // X:0 和 Y:0
    p  = &amp;Vertex{1, 2} // 类型为 *Vertex
)

func main() {
    fmt.Println(v1, p, v2, v3)
}
</code></pre> 
 <h3 id="h3-u6570u7EC4"><a name="数组" class="reference-link"></a><span class="header-link octicon octicon-link"></span>数组</h3>
 <p>类型 <code>[n]T</code> 是一个有 <code>n</code> 个类型为 <code>T</code> 的值的数组。</p> 
 <p>表达式</p> 
 <pre><code class="lang-go">var a [10]int
</code></pre> 
 <p>定义变量 <code>a</code> 是一个有十个整数的数组。</p> 
 <p>数组的长度是其类型的一部分，因此数组不能改变大小。这看起来是一个制约，但是请不要担心； Go 提供了更加便利的方式来使用数组。</p> 
 <h3 id="h3--slice-"><a name="切片(slice)" class="reference-link"></a><span class="header-link octicon octicon-link"></span>切片(slice)</h3>
 <p>一个 <code>slice</code> 会指向一个序列的值，并且包含了长度信息。</p> 
 <p><code>[]T</code> 是一个元素类型为 <code>T</code> 的 切片(<code>slice</code>)。</p> 
 <p><code>len(s)</code>返回 <code>slice s</code>的长度。</p> 
 <pre><code class="lang-go">package main

import "fmt"

func main() {
    s := []int{2, 3, 5, 7, 11, 13}
    fmt.Println("s ==", s)

    for i := 0; i &lt; len(s); i++ {
        fmt.Printf("s[%d] == %d\n", i, s[i])
    }
}
</code></pre> 
 <h3 id="h3--slice-"><a name="切片(slice)的切片" class="reference-link"></a><span class="header-link octicon octicon-link"></span>切片(slice)的切片</h3>
 <p>切片(slice)可以包含任意的类型，包括另一个 <code>slice</code>。</p> 
 <pre><code class="lang-go">package main

import (
    "fmt"
    "strings"
)

func main() {
    // Create a tic-tac-toe board.
    game := [][]string{
        []string{"_", "_", "_"},
        []string{"_", "_", "_"},
        []string{"_", "_", "_"},
    }

    // The players take turns.
    game[0][0] = "X"
    game[2][2] = "O"
    game[2][0] = "X"
    game[1][0] = "O"
    game[0][2] = "X"

    printBoard(game)
}

func printBoard(s [][]string) {
    for i := 0; i &lt; len(s); i++ {
        fmt.Printf("%s\n", strings.Join(s[i], " "))
    }
}
</code></pre> 
 <h3 id="h3--slice-"><a name="对 slice 切片" class="reference-link"></a><span class="header-link octicon octicon-link"></span>对 slice 切片</h3>
 <p><code>slice</code> 可以重新切片，创建一个新的 <code>slice</code> 值指向相同的数组。</p> 
 <p>表达式</p> 
 <pre><code class="lang-go">s[lo:hi]
</code></pre> 
 <p>表示从 <code>lo</code> 到 <code>hi-1</code> 的 <code>slice</code> 元素，含前端，不包含后端。因此</p> 
 <pre><code class="lang-go">s[lo:lo]
</code></pre> 
 <p>是空的，而</p> 
 <pre><code class="lang-go">s[lo:lo+1]
</code></pre> 
 <p>有一个元素。</p> 
 <pre><code class="lang-go">package main

import "fmt"

func main() {
    s := []int{2, 3, 5, 7, 11, 13}
    fmt.Println("s ==", s)
    fmt.Println("s[1:4] ==", s[1:4])

    // 省略下标代表从 0 开始
    fmt.Println("s[:3] ==", s[:3])

    // 省略上标代表到 len(s) 结束
    fmt.Println("s[4:] ==", s[4:])
}
</code></pre> 
 <h3 id="h3--slice"><a name="构造 slice" class="reference-link"></a><span class="header-link octicon octicon-link"></span>构造 slice</h3>
 <p><code>slice</code> 由函数 <code>make</code> 创建。这会分配一个全是零值的数组并且返回一个 <code>slice</code> 指向这个数组：</p> 
 <pre><code class="lang-go">a := make([]int, 5)  // len(a)=5
</code></pre> 
 <p>为了指定容量，可传递第三个参数到 <code>make</code>：</p> 
 <pre><code class="lang-go">b := make([]int, 0, 5) // len(b)=0, cap(b)=5

b = b[:cap(b)] // len(b)=5, cap(b)=5
b = b[1:]      // len(b)=4, cap(b)=4
</code></pre> 
 <p>参考以下示例代码 - </p> 
 <pre><code class="lang-go">package main

import "fmt"

func main() {
    a := make([]int, 5)
    printSlice("a", a)
    b := make([]int, 0, 5)
    printSlice("b", b)
    c := b[:2]
    printSlice("c", c)
    d := c[2:5]
    printSlice("d", d)
}

func printSlice(s string, x []int) {
    fmt.Printf("%s len=%d cap=%d %v\n",
        s, len(x), cap(x), x)
}
</code></pre> 
 <h3 id="h3-nil-slice"><a name="nil slice" class="reference-link"></a><span class="header-link octicon octicon-link"></span>nil slice</h3>
 <p><code>slice</code> 的零值是 <code>nil</code> 。</p> 
 <p>一个 <code>nil</code> 的 <code>slice</code> 的长度和容量是 <code>0</code>。</p> 
 <pre><code class="lang-go">package main

import "fmt"

func main() {
    var z []int
    fmt.Println(z, len(z), cap(z))
    if z == nil {
        fmt.Println("nil!")
    }
}
</code></pre> 
 <h3 id="h3--slice-"><a name="向 slice 添加元素" class="reference-link"></a><span class="header-link octicon octicon-link"></span>向 slice 添加元素</h3>
 <p>向 <code>slice</code> 的末尾添加元素是一种常见的操作，因此 Go 提供了一个内建函数 <code>append</code> 。 内建函数的文档对 <code>append</code> 有详细介绍。</p> 
 <pre><code class="lang-go">func append(s []T, vs ...T) []T
</code></pre> 
 <p><code>append</code> 的第一个参数 <code>s</code> 是一个元素类型为 <code>T</code> 的 <code>slice</code> ，其余类型为 <code>T</code> 的值将会附加到该 <code>slice</code> 的末尾。</p> 
 <p><code>append</code> 的结果是一个包含原 <code>slice</code> 所有元素加上新添加的元素的 <code>slice</code>。</p> 
 <p>如果 <code>s</code> 的底层数组太小，而不能容纳所有值时，会分配一个更大的数组。 返回的 <code>slice</code> 会指向这个新分配的数组。</p> 
 <pre><code class="lang-go">package main

import "fmt"

func main() {
    var a []int
    printSlice("a", a)

    // append works on nil slices.
    a = append(a, 0)
    printSlice("a", a)

    // the slice grows as needed.
    a = append(a, 1)
    printSlice("a", a)

    // we can add more than one element at a time.
    a = append(a, 2, 3, 4)
    printSlice("a", a)
}

func printSlice(s string, x []int) {
    fmt.Printf("%s len=%d cap=%d %v\n",
        s, len(x), cap(x), x)
}
</code></pre> 
 <h3 id="h3--range-"><a name="范围(range)" class="reference-link"></a><span class="header-link octicon octicon-link"></span>范围(range)</h3>
 <p><code>for</code> 循环的 <code>range</code> 格式可以对 <code>slice</code> 或者 <code>map</code> 进行迭代循环。</p> 
 <p>当使用 <code>for</code> 循环遍历一个 <code>slice</code> 时，每次迭代 <code>range</code> 将返回两个值。 第一个是当前下标(序号)，第二个是该下标所对应元素的一个拷贝。</p> 
 <pre><code class="lang-go">package main

import "fmt"

var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}

func main() {
    for i, v := range pow {
        fmt.Printf("2**%d = %d\n", i, v)
    }
}
</code></pre> 
 <p>可以通过赋值给 <code>_</code> 来忽略序号和值。</p> 
 <p>如果只需要索引值，去掉 “ , <code>value</code> ” 的部分即可。</p> 
 <pre><code class="lang-go">package main

import "fmt"

func main() {
    pow := make([]int, 10)
    for i := range pow {
        pow[i] = 1 &lt;&lt; uint(i)
    }
    for _, value := range pow {
        fmt.Printf("%d\n", value)
    }
}
</code></pre>
 <br>      
</div></body></html>