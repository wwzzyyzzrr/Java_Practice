<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Kotlin数据类型</h1><div style="width:100%;float:left;" class="article-content">   
 <p>在Kotlin中，一切都是一个对象，可以在任何变量上调用成员函数和属性。 一些类型是内置的，因为它们的实现被优化，但是它们看起来像普通类。 在本节中，我们将介绍描述Kotlin中的大多数类型：数字，字符，布尔和数组等等。</p> 
 <h2 id="h2-u6570u5B57u7C7Bu578B"><a name="数字类型" class="reference-link"></a><span class="header-link octicon octicon-link"></span>数字类型</h2>
 <p>Kotlin以接近Java的方式来处理数字，但不完全相同。 例如，数字没有隐含的扩展转换，在某些情况下，字面量略有不同。</p> 
 <p>Kotlin提供以下代表数字的内置类型(这接近Java)：</p> 
 <table> 
  <thead> 
   <tr> 
    <th>类型</th> 
    <th>位宽度</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>Double</td> 
    <td>64</td> 
   </tr> 
   <tr> 
    <td>Float</td> 
    <td>32</td> 
   </tr> 
   <tr> 
    <td>Long</td> 
    <td>64</td> 
   </tr> 
   <tr> 
    <td>Int</td> 
    <td>32</td> 
   </tr> 
   <tr> 
    <td>Short</td> 
    <td>16</td> 
   </tr> 
   <tr> 
    <td>Byte</td> 
    <td>8</td> 
   </tr> 
  </tbody> 
 </table> 
 <blockquote> 
  <p>注意，字符不是Kotlin中的数字。</p> 
 </blockquote> 
 <h3 id="h3--"><a name="字面常量/文字常量" class="reference-link"></a><span class="header-link octicon octicon-link"></span>字面常量/文字常量</h3>
 <p>对于整数值，有以下几种字面常量：</p> 
 <ul> 
  <li>整数：<code>123</code></li>
  <li>长整数由大写L标记：<code>123L</code></li>
  <li>十六进制：<code>0x0F</code></li>
  <li>二进制：<code>0b00001011</code></li>
 </ul> 
 <blockquote> 
  <p>注意：不支持八进制字面常量。</p> 
 </blockquote> 
 <p>Kotlin还支持一个常规的浮点数符号：</p> 
 <ul> 
  <li>默认为<code>Double</code>：<code>123.5</code>, <code>123.5e10</code></li>
  <li>浮点数标记为<code>f</code>或<code>F</code>：<code>123.5f</code></li>
 </ul> 
 <h3 id="h3-u6570u5B57u5B57u9762u5E38u91CFu7684u4E0Bu5212u7EBF"><a name="数字字面常量的下划线" class="reference-link"></a><span class="header-link octicon octicon-link"></span>数字字面常量的下划线</h3>
 <p>可以使用下划线使数字常量更易读：</p> 
 <pre><code class="lang-kt">val oneMillion = 1_000_000
val creditCardNumber = 1234_5678_9012_3456L
val socialSecurityNumber = 999_99_9999L
val hexBytes = 0xFF_EC_DE_5E
val bytes = 0b11010010_01101001_10010100_10010010
</code></pre> 
 <h3 id="h3-u8868u793A"><a name="表示" class="reference-link"></a><span class="header-link octicon octicon-link"></span>表示</h3>
 <p>在Java平台上，数字被物理存储为JVM原始类型，除非需要一个可空的数字引用(例如<code>Int?</code>)或涉及泛型。 在后一种情况下，数字是装箱的。</p> 
 <p>请注意，装箱数字不一定保持身份：</p> 
 <pre><code class="lang-kt">val a: Int = 10000
print(a === a) // Prints 'true'
val boxedA: Int? = a
val anotherBoxedA: Int? = a
print(boxedA === anotherBoxedA) // !!!Prints 'false'!!!
</code></pre> 
 <p>另一方面，它保持相等：</p> 
 <pre><code class="lang-kt">val a: Int = 10000
print(a == a) // Prints 'true'
val boxedA: Int? = a
val anotherBoxedA: Int? = a
print(boxedA == anotherBoxedA) // Prints 'true'
</code></pre> 
 <h4 id="h4-u663Eu5F0Fu8F6Cu6362"><a name="显式转换" class="reference-link"></a><span class="header-link octicon octicon-link"></span>显式转换</h4>
 <p>由于不同的表示，较小的类型不是较大的类型的子类型，就会有以下类型的麻烦：</p> 
 <pre><code class="lang-kt">// Hypothetical code, does not actually compile:
val a: Int? = 1 // A boxed Int (java.lang.Integer)
val b: Long? = a // implicit conversion yields a boxed Long (java.lang.Long)
print(a == b) // Surprise! This prints "false" as Long's equals() check for other part to be Long as well
</code></pre> 
 <p>因此，较小的类型不会被隐式转换为更大的类型。 这意味着不能在没有显式转换的情况下将<code>Byte</code>类型的值赋给<code>Int</code>类型的变量。</p> 
 <pre><code class="lang-kt">val b: Byte = 1 // OK, literals are checked statically
val i: Int = b // ERROR
</code></pre> 
 <p>可以使用显式转换来扩宽数字 - </p> 
 <pre><code class="lang-kt">val i: Int = b.toInt() // OK: explicitly widened
</code></pre> 
 <p>每个数字类型都支持以下转换：</p> 
 <ul> 
  <li><code>toByte(): Byte</code></li>
  <li><code>toShort(): Short</code></li>
  <li><code>toInt(): Int</code></li>
  <li><code>toLong(): Long</code></li>
  <li><code>toFloat(): Float</code></li>
  <li><code>toDouble(): Double</code></li>
  <li><code>toChar(): Char</code></li>
 </ul> 
 <p>缺少隐式转换是很少引人注意的，因为类型是从上下文推断出来的，而算术运算则被重载为适当的转换，例如 - </p> 
 <pre><code class="lang-kt">val l = 1L + 3 // Long + Int =&gt; Long
</code></pre> 
 <h3 id="h3-u64CDu4F5C"><a name="操作" class="reference-link"></a><span class="header-link octicon octicon-link"></span>操作</h3>
 <p>Kotlin支持对数字进行的算术运算的标准集合，它们被声明为适当类的成员(但编译器将调用优化为相应的指令)。请参阅<a target="_blank" href="http://www.yiibai.com/kotlin/operator-overloading.html" title="操作符重载">操作符重载</a>。</p> 
 <p>对于按位操作，它们没有特殊的字符，但是只能命名为可以以中缀形式调用的函数，例如：</p> 
 <pre><code class="lang-kt">val x = (1 shl 2) and 0x000FF000
</code></pre> 
 <p>以下是按位操作的完整列表(仅适用于<code>Int</code>和<code>Long</code>)：</p> 
 <ul> 
  <li><code>shl(bits)</code> – 有符号向左移 (Java的<code>&lt;&lt;</code>)</li>
  <li><code>shr(bits)</code> – 有符号向右移 (Java’s &gt;&gt;)</li>
  <li><code>ushr(bits)</code> – 无符号向右移 (Java’s &gt;&gt;&gt;)</li>
  <li><code>and(bits)</code> – 位运算符<code>and</code></li>
  <li><code>or(bits)</code> – 位运算符<code>or</code></li>
  <li><code>xor(bits)</code> – 位运算符<code>xor</code></li>
  <li><code>inv()</code> – 位运算符”取反”</li>
 </ul> 
 <h2 id="h2-u5B57u7B26"><a name="字符" class="reference-link"></a><span class="header-link octicon octicon-link"></span>字符</h2>
 <p>字符由Char类型表示，它们不能直接被视为数字</p> 
 <pre><code class="lang-kt">fun check(c: Char) {
    if (c == 1) { // ERROR: incompatible types
        // ...
    }
}
</code></pre> 
 <p>字符文字用单引号表示：<code>'1'</code>。 可以使用反斜杠转义特殊字符。 支持以下转义序列： <code>\t</code>, <code>\b</code>, <code>\n</code>, <code>\r</code>,<code>\'</code>, <code>\"</code>, <code>\\</code> 和 <code>\$</code>； 要编码任何其他字符，请使用Unicode转义序列语法：<code>'\uFF00'</code>。</p> 
 <p>可以将一个字符显式转换为一个<code>Int</code>类型数字：</p> 
 <pre><code class="lang-kt">fun decimalDigitValue(c: Char): Int {
    if (c !in '0'..'9')
        throw IllegalArgumentException("Out of range")
    return c.toInt() - '0'.toInt() // Explicit conversions to numbers
}
</code></pre> 
 <p>像数字一样，当需要可空引用时，字符将被包装。标识不能被装箱操作所保留。</p> 
 <h2 id="h2-u5E03u5C14u7C7Bu578B"><a name="布尔类型" class="reference-link"></a><span class="header-link octicon octicon-link"></span>布尔类型</h2>
 <p><code>Boolean</code>类型表示布尔值，并具有两个值：<code>true</code>和<code>false</code>。</p> 
 <p>如果需要可空引用，布尔值将可被装箱。</p> 
 <p>内置的布尔操作包括：</p> 
 <ul> 
  <li><code>||</code> – 懒分离</li>
  <li><code>&amp;&amp;</code> – 懒结合</li>
  <li><code>!</code> - 否定</li>
 </ul> 
 <h2 id="h2-u6570u7EC4"><a name="数组" class="reference-link"></a><span class="header-link octicon octicon-link"></span>数组</h2>
 <p>Kotlin中的数组由<code>Array</code>类表示，它有<code>get()</code>和<code>set()</code>函数(通过运算符重载约定转换为<code>[]</code>)，以及<code>size</code>属性以及其他一些有用的成员函数：</p>   
 <pre><code class="lang-kt">class Array&lt;T&gt; private constructor() {
    val size: Int
    operator fun get(index: Int): T
    operator fun set(index: Int, value: T): Unit

    operator fun iterator(): Iterator&lt;T&gt;
    // ...
}
</code></pre> 
 <p>要创建一个数组，我们可以使用一个库函数<code>arrayOf()</code>，并将数组的元素值传递给它，如：<code>arrayOf(1，2，3)</code>创建一个数组<code>[1，2，3]</code>。 或者<code>arrayOfNulls()</code>库函数可用于创建一个填充空(<code>null</code>)元素的给定大小的数组。</p> 
 <p>另一个选择是使用一个工厂函数，它使用数组大小和返回给定其索引的每个数组元素的初始值的函数：</p> 
 <pre><code class="lang-kt">// Creates an Array&lt;String&gt; with values ["0", "1", "4", "9", "16"]
val asc = Array(5, { i -&gt; (i * i).toString() })
</code></pre> 
 <p>如上所述，<code>[]</code>操作代表调用成员函数<code>get()</code>和<code>set()</code>。</p> 
 <p>注意：与Java不同，Kotlin中的数组是不变的。 这意味着Kotlin不允许将<code>Array &lt;String&gt;</code>分配给<code>Array &lt;Any&gt;</code>，这样可以防止可能的运行时故障(但可以使用<code>Array &lt;out Any&gt;</code>)，详细的可参考<a target="_blank" href="http://www.yiibai.com/kotlin/generics.html#type-projections" title="类型投影">类型投影</a>。</p> 
 <p>Kotlin还有专门的类来表示原始类型的数组，没有装箱开销，它们分别是：<code>ByteArray</code>, <code>ShortArray</code>, <code>IntArray</code>等等。</p> 
 <p>这些类与<code>Array</code>类没有继承关系，但它们具有相同的方法和属性集。它们也有相应的工厂函数：</p> 
 <pre><code class="lang-kt">val x: IntArray = intArrayOf(1, 2, 3)
x[0] = x[1] + x[2]
</code></pre> 
 <h2 id="h2-u5B57u7B26u4E32"><a name="字符串" class="reference-link"></a><span class="header-link octicon octicon-link"></span>字符串</h2>
 <p>字符串由<code>String</code>类型表示。字符串是不可变的。 字符串的元素可以通过索引操作的字符：<code>s[i]</code>来访问。可以使用<code>for</code>循环迭代字符串：</p> 
 <pre><code class="lang-kt">for (c in str) {
    println(c)
}
</code></pre> 
 <h3 id="h3-u5B57u7B26u4E32u5B57u9762u91CF"><a name="字符串字面量" class="reference-link"></a><span class="header-link octicon octicon-link"></span>字符串字面量</h3>
 <p>Kotlin有两种类型的字符串字面值：可以在其中转义字符的转义字符串，以及可以包含换行符和任意文本的原始字符串。 转义的字符串非常像Java字符串：</p> 
 <pre><code class="lang-kt">val s = "Hello, world!\n"
</code></pre> 
 <p>使用反斜杠以常规方式完成转义。 有关支持的转义序列的列表，请参阅上述<strong>字符</strong>。</p> 
 <p>原始字符串由三重引号(<code>"""</code>)分隔，不包含转义，并且可以包含换行符和任何其他字符：</p> 
 <pre><code class="lang-kt">val text = """
    for (c in "foo")
        print(c)
"""
</code></pre> 
 <p>可以使用<code>trimMargin()</code>函数删除前导空格：</p> 
 <pre><code class="lang-kt">val text = """
    |Tell me and I forget.
    |Teach me and I remember.
    |Involve me and I learn.
    |(Benjamin Franklin)
    """.trimMargin()
</code></pre> 
 <p>默认使用<code>|</code>作边距前缀，但您可以选择另一个字符，并将其作为参数传递：<code>trimMargin("&gt;")</code>。</p> 
 <h3 id="h3-u5B57u7B26u4E32u6A21u677F"><a name="字符串模板" class="reference-link"></a><span class="header-link octicon octicon-link"></span>字符串模板</h3>
 <p>字符串可以包含模板表达式，即被评估的代码片段，并且其结果被连接到字符串中。 模板表达式以美元符号(<code>$</code>)开头以及简单名称组成：</p> 
 <pre><code class="lang-kt">val i = 10
val s = "i = $i" // evaluates to "i = 10"
</code></pre> 
 <p>或大括号中的任意表达式：</p> 
 <pre><code class="lang-kt">val s = "abc"
val str = "$s.length is ${s.length}" // evaluates to "abc.length is 3"
</code></pre> 
 <p>原始字符串和转义字符串内部都支持模板。如果您需要在原始字符串(不支持反斜杠转义)中表示一个文字<code>$</code>字符，则可以使用以下语法：</p> 
 <pre><code class="lang-kt">val price = """
${'$'}9.99
"""
</code></pre>
 <br>      
</div></body></html>