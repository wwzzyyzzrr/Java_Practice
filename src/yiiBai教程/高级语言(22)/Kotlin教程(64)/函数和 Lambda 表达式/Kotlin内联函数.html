<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Kotlin内联函数</h1><div style="width:100%;float:left;" class="article-content">   
 <h1 id="h1-u5185u8054u51FDu6570"><a name="内联函数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>内联函数</h1>
 <p>使用<a target="_blank" href="lambdas.html">高阶函数</a>会带来一些运行时的效率损失：每一个函数都是一个对象，并且会捕获一个闭包。<br>即那些在函数体内会访问到的变量。<br>内存分配(对于函数对象和类)和虚拟调用会引入运行时间开销。</p> 
 <p>但是在许多情况下通过内联化 lambda 表达式可以消除这类的开销。<br>下述函数是这种情况的很好的例子。即 <code>lock()</code> 函数可以很容易地在调用处内联。<br>考虑下面的情况：</p> 
 <pre><code class="lang-kotlin">lock(l) { foo() }
</code></pre> 
 <p>编译器没有为参数创建一个函数对象并生成一个调用。取而代之，编译器可以生成以下代码：</p> 
 <pre><code class="lang-kotlin">l.lock()
try {
    foo()
}
finally {
    l.unlock()
}
</code></pre> 
 <p>这个不是我们从一开始就想要的吗？</p> 
 <p>为了让编译器这么做，我们需要使用 <code>inline</code> 修饰符标记 <code>lock()</code> 函数：</p> 
 <pre><code class="lang-kotlin">inline fun lock&lt;T&gt;(lock: Lock, body: () -&gt; T): T {
    // ……
}
</code></pre> 
 <p><code>inline</code> 修饰符影响函数本身和传给它的 lambda 表达式：所有这些都将内联<br>到调用处。</p> 
 <p>内联可能导致生成的代码增加，但是如果我们使用得当(不内联大函数)，它将在<br>性能上有所提升，尤其是在循环中的“超多态(megamorphic)”调用处。</p> 
 <h2 id="h2-u7981u7528u5185u8054"><a name="禁用内联" class="reference-link"></a><span class="header-link octicon octicon-link"></span>禁用内联</h2>
 <p>如果你只想被(作为参数)传给一个内联函数的 lamda 表达式中只有一些被内联，你可以用 <code>noinline</code> 修饰符标记<br>一些函数参数：</p> 
 <pre><code class="lang-kotlin">inline fun foo(inlined: () -&gt; Unit, noinline notInlined: () -&gt; Unit) {
    // ……
}
</code></pre> 
 <p>可以内联的 lambda 表达式只能在内联函数内部调用或者作为可内联的参数传递，<br>但是 <code>noinline</code> 的可以以任何我们喜欢的方式操作：存储在字段中、传送它等等。</p> 
 <p>需要注意的是，如果一个内联函数没有可内联的函数参数并且没有<br><a target="_blank" href="#具体化的类型参数">具体化的类型参数</a>，编译器会产生一个警告，因为内联这样的函数<br>很可能并无益处(如果你确认需要内联，则可以关掉该警告)。</p> 
 <h2 id="h2-u975Eu5C40u90E8u8FD4u56DE"><a name="非局部返回" class="reference-link"></a><span class="header-link octicon octicon-link"></span>非局部返回</h2>
 <p>在 Kotlin 中，我们可以只使用一个正常的、非限定的 <code>return</code> 来退出一个命名或匿名函数。<br>这意味着要退出一个 lambda 表达式，我们必须使用一个<a target="_blank" href="returns.html#标签处返回">标签</a>，并且<br>在 lambda 表达式内部禁止使用裸 <code>return</code>，因为 lambda 表达式不能使包含它的函数返回：</p> 
 <pre><code class="lang-kotlin">fun foo() {
    ordinaryFunction {
        return // 错误：不能使 `foo` 在此处返回
    }
}
</code></pre> 
 <p>但是如果 lambda 表达式传给的函数是内联的，该 return 也可以内联，所以它是允许的：</p> 
 <pre><code class="lang-kotlin">fun foo() {
    inlineFunction {
        return // OK：该 lambda 表达式是内联的
    }
}
</code></pre> 
 <p>这种返回(位于 lambda 表达式中，但退出包含它的函数)称为<em>非局部</em>返回。 我们习惯了<br>在循环中用这种结构，其内联函数通常包含：</p> 
 <pre><code class="lang-kotlin">fun hasZeros(ints: List&lt;Int&gt;): Boolean {
    ints.forEach {
        if (it == 0) return true // 从 hasZeros 返回
    }
    return false
}
</code></pre> 
 <p>请注意，一些内联函数可能调用传给它们的不是直接来自函数体、而是来自另一个执行<br>上下文的 lambda 表达式参数，例如来自局部对象或嵌套函数。在这种情况下，该 lambda 表达式中<br>也不允许非局部控制流。为了标识这种情况，该 lambda 表达式参数需要<br>用 <code>crossinline</code> 修饰符标记:</p> 
 <pre><code class="lang-kotlin">inline fun f(crossinline body: () -&gt; Unit) {
    val f = object: Runnable {
        override fun run() = body()
    }
    // ……
}
</code></pre> 
 <blockquote> 
  <p><code>break</code> 和 <code>continue</code> 在内联的 lambda 表达式中还不可用，但我们也计划支持它们</p> 
 </blockquote> 
 <h2 id="h2-u5177u4F53u5316u7684u7C7Bu578Bu53C2u6570"><a name="具体化的类型参数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>具体化的类型参数</h2>
 <p>有时候我们需要访问一个作为参数传给我们的一个类型：</p>   
 <pre><code class="lang-kotlin">fun &lt;T&gt; TreeNode.findParentOfType(clazz: Class&lt;T&gt;): T? {
    var p = parent
    while (p != null &amp;&amp; !clazz.isInstance(p)) {
        p = p.parent
    }
    @Suppress("UNCHECKED_CAST")
    return p as T?
}
</code></pre> 
 <p>在这里我们向上遍历一棵树并且检查每个节点是不是特定的类型。<br>这都没有问题，但是调用处不是很优雅：</p> 
 <pre><code class="lang-kotlin">treeNode.findParentOfType(MyTreeNode::class.java)
</code></pre> 
 <p>我们真正想要的只是传一个类型给该函数，即像这样调用它：</p> 
 <pre><code class="lang-kotlin">treeNode.findParentOfType&lt;MyTreeNode&gt;()
</code></pre> 
 <p>为能够这么做，内联函数支持<em>具体化的类型参数</em>，于是我们可以这样写：</p> 
 <pre><code class="lang-kotlin">inline fun &lt;reified T&gt; TreeNode.findParentOfType(): T? {
    var p = parent
    while (p != null &amp;&amp; p !is T) {
        p = p.parent
    }
    return p as T?
}
</code></pre> 
 <p>我们使用 <code>reified</code> 修饰符来限定类型参数，现在可以在函数内部访问它了，<br>几乎就像是一个普通的类一样。由于函数是内联的，不需要反射，正常的操作符如 <code>!is</code><br>和 <code>as</code> 现在都能用了。此外，我们还可以按照上面提到的方式调用它：<code>myTree.findParentOfType&lt;MyTreeNodeType&gt;()</code>。</p> 
 <p>虽然在许多情况下可能不需要反射，但我们仍然可以对一个具体化的类型参数使用它：</p> 
 <pre><code class="lang-kotlin">inline fun &lt;reified T&gt; membersOf() = T::class.members

fun main(s: Array&lt;String&gt;) {
    println(membersOf&lt;StringBuilder&gt;().joinToString("\n"))
}
</code></pre> 
 <p>普通的函数(未标记为内联函数的)不能有具体化参数。<br>不具有运行时表示的类型(例如非具体化的类型参数或者类似于<code>Nothing</code>的虚构类型)<br>不能用作具体化的类型参数的实参。</p> 
 <p>相关底层描述，请参见<a target="_blank" href="http://github.com/JetBrains/kotlin/blob/master/spec-docs/reified-type-parameters.md">规范文档</a>。</p> 
 <h2 id="h2--1-1-"><a name="内联属性(自 1.1 起)" class="reference-link"></a><span class="header-link octicon octicon-link"></span>内联属性(自 1.1 起)</h2>
 <p><code>inline</code> 修饰符可用于没有幕后字段的属性的访问器。<br>你可以标注独立的属性访问器：</p> 
 <pre><code class="lang-kotlin">val foo: Foo
    inline get() = Foo()

var bar: Bar
    get() = ……
    inline set(v) { …… }
</code></pre> 
 <p>你也可以标注整个属性，将它的两个访问器都标记为内联：</p> 
 <pre><code class="lang-kotlin">inline var bar: Bar
    get() = ……
    set(v) { …… }
</code></pre> 
 <p>在调用处，内联访问器如同内联函数一样内联。</p>
 <br>      
</div></body></html>