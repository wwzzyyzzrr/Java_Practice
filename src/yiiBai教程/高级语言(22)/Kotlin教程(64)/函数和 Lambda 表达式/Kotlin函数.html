<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Kotlin函数</h1><div style="width:100%;float:left;" class="article-content">   
 <h1 id="h1-u51FDu6570"><a name="函数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>函数</h1>
 <h2 id="h2-u51FDu6570u58F0u660E"><a name="函数声明" class="reference-link"></a><span class="header-link octicon octicon-link"></span>函数声明</h2>
 <p>Kotlin 中的函数使用 <em>fun</em>{: .keyword } 关键字声明</p> 
 <pre><code class="lang-kotlin">fun double(x: Int): Int {
}
</code></pre> 
 <h2 id="h2-u51FDu6570u7528u6CD5"><a name="函数用法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>函数用法</h2>
 <p>调用函数使用传统的方法</p> 
 <pre><code class="lang-kotlin">val result = double(2)
</code></pre> 
 <p>调用成员函数使用点表示法</p> 
 <pre><code class="lang-kotlin">Sample().foo() // 创建类 Sample 实例并调用 foo
</code></pre> 
 <h3 id="h3-u4E2Du7F00u8868u793Au6CD5"><a name="中缀表示法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>中缀表示法</h3>
 <p>函数还可以用中缀表示法调用，当</p> 
 <ul> 
  <li>他们是成员函数或<a target="_blank" href="http://www.yiibai.com/kotlin/extensions.html">扩展函数</a></li>
  <li>他们只有一个参数</li>
  <li>他们用 <code>infix</code> 关键字标注</li>
 </ul> 
 <pre><code class="lang-kotlin">// 给 Int 定义扩展
infix fun Int.shl(x: Int): Int {
……
}

// 用中缀表示法调用扩展函数

1 shl 2

// 等同于这样

1.shl(2)
</code></pre> 
 <h3 id="h3-u53C2u6570"><a name="参数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>参数</h3>
 <p>函数参数使用 Pascal 表示法定义，即 <em>name</em>: <em>type</em>。参数用逗号隔开。每个参数必须有显式类型。</p> 
 <pre><code class="lang-kotlin">fun powerOf(number: Int, exponent: Int) {
……
}
</code></pre> 
 <h3 id="h3-u9ED8u8BA4u53C2u6570"><a name="默认参数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>默认参数</h3>
 <p>函数参数可以有默认值，当省略相应的参数时使用默认值。与其他语言相比，这可以减少<br>重载数量。</p> 
 <pre><code class="lang-kotlin">fun read(b: Array&lt;Byte&gt;, off: Int = 0, len: Int = b.size()) {
……
}
</code></pre> 
 <p>默认值通过类型后面的 <strong>=</strong> 及给出的值来定义。</p> 
 <p>覆盖方法总是使用与基类型方法相同的默认参数值。<br>当覆盖一个带有默认参数值的方法时，必须从签名中省略默认参数值：</p> 
 <pre><code class="lang-kotlin">open class A {
    open fun foo(i: Int = 10) { …… }
}

class B : A() {
    override fun foo(i: Int) { …… }  // 不能有默认值
}
</code></pre> 
 <h3 id="h3-u547Du540Du53C2u6570"><a name="命名参数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>命名参数</h3>
 <p>可以在调用函数时使用命名的函数参数。当一个函数有大量的参数或默认参数时这会非常方便。</p> 
 <p>给定以下函数</p> 
 <pre><code class="lang-kotlin">fun reformat(str: String,
             normalizeCase: Boolean = true,
             upperCaseFirstLetter: Boolean = true,
             divideByCamelHumps: Boolean = false,
             wordSeparator: Char = ' ') {
……
}
</code></pre> 
 <p>我们可以使用默认参数来调用它</p> 
 <pre><code class="lang-kotlin">reformat(str)
</code></pre> 
 <p>然而，当使用非默认参数调用它时，该调用看起来就像</p> 
 <pre><code class="lang-kotlin">reformat(str, true, true, false, '_')
</code></pre> 
 <p>使用命名参数我们可以使代码更具有可读性</p> 
 <pre><code class="lang-kotlin">reformat(str,
    normalizeCase = true,
    upperCaseFirstLetter = true,
    divideByCamelHumps = false,
    wordSeparator = '_'
)
</code></pre> 
 <p>并且如果我们不需要所有的参数</p> 
 <pre><code class="lang-kotlin">reformat(str, wordSeparator = '_')
</code></pre> 
 <p>请注意，在调用 Java 函数时不能使用命名参数语法，因为 Java 字节码并不<br>总是保留函数参数的名称。</p> 
 <h3 id="h3--unit-"><a name="返回 Unit 的函数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>返回 Unit 的函数</h3>
 <p>如果一个函数不返回任何有用的值，它的返回类型是 <code>Unit</code>。<code>Unit</code> 是一种只有一个值——<code>Unit</code> 的类型。这个<br>值不需要显式返回</p> 
 <pre><code class="lang-kotlin">fun printHello(name: String?): Unit {
    if (name != null)
        println("Hello ${name}")
    else
        println("Hi there!")
    // `return Unit` 或者 `return` 是可选的
}
</code></pre> 
 <p><code>Unit</code> 返回类型声明也是可选的。上面的代码等同于</p> 
 <pre><code class="lang-kotlin">fun printHello(name: String?) {
    ……
}
</code></pre> 
 <h3 id="h3-u5355u8868u8FBEu5F0Fu51FDu6570"><a name="单表达式函数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>单表达式函数</h3>
 <p>当函数返回单个表达式时，可以省略花括号并且在 <strong>=</strong> 符号之后指定代码体即可</p> 
 <pre><code class="lang-kotlin">fun double(x: Int): Int = x * 2
</code></pre> 
 <p>当返回值类型可由编译器推断时，显式声明返回类型是<a target="_blank" href="#显式返回类型">可选</a>的</p> 
 <pre><code class="lang-kotlin">fun double(x: Int) = x * 2
</code></pre> 
 <h3 id="h3-u663Eu5F0Fu8FD4u56DEu7C7Bu578B"><a name="显式返回类型" class="reference-link"></a><span class="header-link octicon octicon-link"></span>显式返回类型</h3>
 <p>具有块代码体的函数必须始终显式指定返回类型，除非他们旨在返回 <code>Unit</code>，<a target="_blank" href="#返回-unit-的函数">在这种情况下它是可选的</a>。<br>Kotlin 不推断具有块代码体的函数的返回类型，因为这样的函数在代码体中可能有复杂的控制流，并且返回<br>类型对于读者(有时甚至对于编译器)是不明显的。</p> 
 <h3 id="h3--varargs-"><a name="可变数量的参数(Varargs)" class="reference-link"></a><span class="header-link octicon octicon-link"></span>可变数量的参数(Varargs)</h3>
 <p>函数的参数(通常是最后一个)可以用 <code>vararg</code> 修饰符标记：</p> 
 <pre><code class="lang-kotlin">fun &lt;T&gt; asList(vararg ts: T): List&lt;T&gt; {
    val result = ArrayList&lt;T&gt;()
    for (t in ts) // ts is an Array
        result.add(t)
    return result
}
</code></pre> 
 <p>允许将可变数量的参数传递给函数：</p> 
 <pre><code class="lang-kotlin">val list = asList(1, 2, 3)
</code></pre> 
 <p>在函数内部，类型 <code>T</code> 的 <code>vararg</code> 参数的可见方式是作为 <code>T</code> 数组，即上例中的 <code>ts</code> 变量具有类型 <code>Array &lt;out T&gt;</code>。</p> 
 <p>只有一个参数可以标注为 <code>vararg</code>。如果 <code>vararg</code> 参数不是列表中的最后一个参数， 可以使用<br>命名参数语法传递其后的参数的值，或者，如果参数具有函数类型，则通过在括号外部<br>传一个 lambda。</p> 
 <p>当我们调用 <code>vararg</code>-函数时，我们可以一个接一个地传参，例如 <code>asList(1, 2, 3)</code>，或者，如果我们已经有一个数组<br>并希望将其内容传给该函数，我们使用<strong>伸展(spread)</strong>操作符(在数组前面加 <code>*</code>)：</p>   
 <pre><code class="lang-kotlin">val a = arrayOf(1, 2, 3)
val list = asList(-1, 0, *a, 4)
</code></pre> 
 <h2 id="h2-u51FDu6570u4F5Cu7528u57DF"><a name="函数作用域" class="reference-link"></a><span class="header-link octicon octicon-link"></span>函数作用域</h2>
 <p>在 Kotlin 中函数可以在文件顶层声明，这意味着你不需要像一些语言如 Java、C# 或 Scala 那样创建一个类来保存一个函数。此外<br>除了顶层函数，Kotlin 中函数也可以声明在局部作用域、作为成员函数以及扩展函数。</p> 
 <h3 id="h3-u5C40u90E8u51FDu6570"><a name="局部函数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>局部函数</h3>
 <p>Kotlin 支持局部函数，即一个函数在另一个函数内部</p> 
 <pre><code class="lang-kotlin">fun dfs(graph: Graph) {
    fun dfs(current: Vertex, visited: Set&lt;Vertex&gt;) {
        if (!visited.add(current)) return
        for (v in current.neighbors)
            dfs(v, visited)
    }

    dfs(graph.vertices[0], HashSet())
}
</code></pre> 
 <p>局部函数可以访问外部函数(即闭包)的局部变量，所以在上例中，<em>visited</em> 可以是局部变量。</p> 
 <pre><code class="lang-kotlin">fun dfs(graph: Graph) {
    val visited = HashSet&lt;Vertex&gt;()
    fun dfs(current: Vertex) {
        if (!visited.add(current)) return
        for (v in current.neighbors)
            dfs(v)
    }

    dfs(graph.vertices[0])
}
</code></pre> 
 <h3 id="h3-u6210u5458u51FDu6570"><a name="成员函数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>成员函数</h3>
 <p>成员函数是在类或对象内部定义的函数</p> 
 <pre><code class="lang-kotlin">class Sample() {
    fun foo() { print("Foo") }
}
</code></pre> 
 <p>成员函数以点表示法调用</p> 
 <pre><code class="lang-kotlin">Sample().foo() // 创建类 Sample 实例并调用 foo
</code></pre> 
 <p>关于类和覆盖成员的更多信息参见<a target="_blank" href="http://www.yiibai.com/kotlin/classes.html">类</a>和<a target="_blank" href="http://www.yiibai.com/kotlin/classes.html#继承">继承</a></p> 
 <h2 id="h2-u6CDBu578Bu51FDu6570"><a name="泛型函数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>泛型函数</h2>
 <p>函数可以有泛型参数，通过在函数名前使用尖括号指定。</p> 
 <pre><code class="lang-kotlin">fun &lt;T&gt; singletonList(item: T): List&lt;T&gt; {
    // ……
}
</code></pre> 
 <p>关于泛型函数的更多信息参见<a target="_blank" href="http://www.yiibai.com/kotlin/generics.html">泛型</a></p> 
 <h2 id="h2-u5185u8054u51FDu6570"><a name="内联函数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>内联函数</h2>
 <p>内联函数在<a target="_blank" href="http://www.yiibai.com/kotlin/inline-functions.html">这里</a>讲述</p> 
 <h2 id="h2-u6269u5C55u51FDu6570"><a name="扩展函数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>扩展函数</h2>
 <p>扩展函数在<a target="_blank" href="http://www.yiibai.com/kotlin/extensions.html">其自有章节</a>讲述</p> 
 <h2 id="h2--lambda-"><a name="高阶函数和 Lambda 表达式" class="reference-link"></a><span class="header-link octicon octicon-link"></span>高阶函数和 Lambda 表达式</h2>
 <p>高阶函数和 Lambda 表达式在<a target="_blank" href="http://www.yiibai.com/kotlin/lambdas.html">其自有章节</a>讲述</p> 
 <h2 id="h2-u5C3Eu9012u5F52u51FDu6570"><a name="尾递归函数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>尾递归函数</h2>
 <p>Kotlin 支持一种称为<a target="_blank" href="http://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8">尾递归</a>的函数式编程风格。<br>这允许一些通常用循环写的算法改用递归函数来写，而无堆栈溢出的风险。<br>当一个函数用 <code>tailrec</code> 修饰符标记并满足所需的形式时，编译器会优化该递归，留下一个快速而高效的基于循环的版本。</p> 
 <pre><code class="lang-kotlin">tailrec fun findFixPoint(x: Double = 1.0): Double
        = if (x == Math.cos(x)) x else findFixPoint(Math.cos(x))
</code></pre> 
 <p>这段代码计算余弦的不动点(fixpoint of cosine)，这是一个数学常数。 它只是重复地从 1.0 开始调用 Math.cos，直到结果不再改变，产生0.7390851332151607的结果。最终代码相当于这种更传统风格的代码：</p> 
 <pre><code class="lang-kotlin">private fun findFixPoint(): Double {
    var x = 1.0
    while (true) {
        val y = Math.cos(x)
        if (x == y) return y
        x = y
    }
}
</code></pre> 
 <p>要符合 <code>tailrec</code> 修饰符的条件的话，函数必须将其自身调用作为它执行的最后一个操作。在递归调用后有更多代码时，不能使用尾递归，并且不能用在 try/catch/finally 块中。目前尾部递归只在 JVM 后端中支持。</p>
 <br>      
</div></body></html>