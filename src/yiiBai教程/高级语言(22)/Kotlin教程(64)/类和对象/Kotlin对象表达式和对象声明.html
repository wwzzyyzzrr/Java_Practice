<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Kotlin对象表达式和对象声明</h1><div style="width:100%;float:left;" class="article-content">   
 <h1 id="h1-u5BF9u8C61u8868u8FBEu5F0Fu548Cu5BF9u8C61u58F0u660E"><a name="对象表达式和对象声明" class="reference-link"></a><span class="header-link octicon octicon-link"></span>对象表达式和对象声明</h1>
 <p>有时候，我们需要创建一个对某个类做了轻微改动的类的对象，而不用为之显式声明新的子类。<br>Java 用<em>匿名内部类</em> 处理这种情况。<br>Kotlin 用<em>对象表达式</em>和<em>对象声明</em>对这个概念稍微概括了下。</p> 
 <h2 id="h2-u5BF9u8C61u8868u8FBEu5F0F"><a name="对象表达式" class="reference-link"></a><span class="header-link octicon octicon-link"></span>对象表达式</h2>
 <p>要创建一个继承自某个(或某些)类型的匿名类的对象，我们会这么写：</p> 
 <pre><code class="lang-kotlin">window.addMouseListener(object : MouseAdapter() {
    override fun mouseClicked(e: MouseEvent) {
        // ……
    }

    override fun mouseEntered(e: MouseEvent) {
        // ……
    }
})
</code></pre> 
 <p>如果超类型有一个构造函数，则必须传递适当的构造函数参数给它。<br>多个超类型可以由跟在冒号后面的逗号分隔的列表指定：</p> 
 <pre><code class="lang-kotlin">open class A(x: Int) {
    public open val y: Int = x
}

interface B {……}

val ab: A = object : A(1), B {
    override val y = 15
}
</code></pre> 
 <p>任何时候，如果我们只需要“一个对象而已”，并不需要特殊超类型，那么我们可以简单地写：</p> 
 <pre><code class="lang-kotlin">fun foo() {
    val adHoc = object {
        var x: Int = 0
        var y: Int = 0
    }
    print(adHoc.x + adHoc.y)
}
</code></pre> 
 <p>请注意，匿名对象可以用作只在本地和私有作用域中声明的类型。如果你使用匿名对象作为公有函数的<br>返回类型或者用作公有属性的类型，那么该函数或属性的实际类型<br>会是匿名对象声明的超类型，如果你没有声明任何超类型，就会是 <code>Any</code>。在匿名对象<br>中添加的成员将无法访问。</p> 
 <pre><code class="lang-kotlin">class C {
    // 私有函数，所以其返回类型是匿名对象类型
    private fun foo() = object {
        val x: String = "x"
    }

    // 公有函数，所以其返回类型是 Any
    fun publicFoo() = object {
        val x: String = "x"
    }

    fun bar() {
        val x1 = foo().x        // 没问题
        val x2 = publicFoo().x  // 错误：未能解析的引用“x”
    }
}
</code></pre> 
 <p>就像 Java 匿名内部类一样，对象表达式中的代码可以访问来自包含它的作用域的变量。<br>(与 Java 不同的是，这不仅限于 final 变量。)</p> 
 <pre><code class="lang-kotlin">fun countClicks(window: JComponent) {
    var clickCount = 0
    var enterCount = 0

    window.addMouseListener(object : MouseAdapter() {
        override fun mouseClicked(e: MouseEvent) {
            clickCount++
        }

        override fun mouseEntered(e: MouseEvent) {
            enterCount++
        }
    })
    // ……
}
</code></pre> 
 <h2 id="h2-u5BF9u8C61u58F0u660E"><a name="对象声明" class="reference-link"></a><span class="header-link octicon octicon-link"></span>对象声明</h2>
 <p><a target="_blank" href="http://en.wikipedia.org/wiki/Singleton_pattern">单例模式</a>是一种非常有用的模式，而 Kotlin(继 Scala 之后)使单例声明变得很容易：</p> 
 <pre><code class="lang-kotlin">object DataProviderManager {
    fun registerDataProvider(provider: DataProvider) {
        // ……
    }

    val allDataProviders: Collection&lt;DataProvider&gt;
        get() = // ……
}
</code></pre> 
 <p>这称为<em>对象声明</em>。并且它总是在 <em>object</em>{: .keyword } 关键字后跟一个名称。<br>就像变量声明一样，对象声明不是一个表达式，不能用在赋值语句的右边。</p> 
 <p>要引用该对象，我们直接使用其名称即可：</p> 
 <pre><code class="lang-kotlin">DataProviderManager.registerDataProvider(……)
</code></pre> 
 <p>这些对象可以有超类型：</p>   
 <pre><code class="lang-kotlin">object DefaultListener : MouseAdapter() {
    override fun mouseClicked(e: MouseEvent) {
        // ……
    }

    override fun mouseEntered(e: MouseEvent) {
        // ……
    }
}
</code></pre> 
 <p><strong>注意</strong>：对象声明不能在局部作用域(即直接嵌套在函数内部)，但是它们可以嵌套到其他对象声明或非内部类中。</p> 
 <h3 id="h3-u4F34u751Fu5BF9u8C61"><a name="伴生对象" class="reference-link"></a><span class="header-link octicon octicon-link"></span>伴生对象</h3>
 <p>类内部的对象声明可以用 <em>companion</em>{: .keyword } 关键字标记：</p> 
 <pre><code class="lang-kotlin">class MyClass {
    companion object Factory {
        fun create(): MyClass = MyClass()
    }
}
</code></pre> 
 <p>该伴生对象的成员可通过只使用类名作为限定符来调用：</p> 
 <pre><code class="lang-kotlin">val instance = MyClass.create()
</code></pre> 
 <p>可以省略伴生对象的名称，在这种情况下将使用名称 <code>Companion</code>：</p> 
 <pre><code class="lang-kotlin">class MyClass {
    companion object {
    }
}

val x = MyClass.Companion
</code></pre> 
 <p>请注意，即使伴生对象的成员看起来像其他语言的静态成员，在运行时他们<br>仍然是真实对象的实例成员，而且，例如还可以实现接口：</p> 
 <pre><code class="lang-kotlin">interface Factory&lt;T&gt; {
    fun create(): T
}


class MyClass {
    companion object : Factory&lt;MyClass&gt; {
        override fun create(): MyClass = MyClass()
    }
}
</code></pre> 
 <p>当然，在 JVM 平台，如果使用 <code><a target="_blank" href="https://github.com/JvmStatic" title="@JvmStatic" class="at-link">@JvmStatic</a></code> 注解，你可以将伴生对象的成员生成为真正的<br>静态方法和字段。更详细信息请参见<a target="_blank" href="java-to-kotlin-interop.html#静态字段">Java 互操作性</a>一节<br>。</p> 
 <h3 id="h3-u5BF9u8C61u8868u8FBEu5F0Fu548Cu5BF9u8C61u58F0u660Eu4E4Bu95F4u7684u8BEDu4E49u5DEEu5F02"><a name="对象表达式和对象声明之间的语义差异" class="reference-link"></a><span class="header-link octicon octicon-link"></span>对象表达式和对象声明之间的语义差异</h3>
 <p>对象表达式和对象声明之间有一个重要的语义差别：</p> 
 <ul> 
  <li>对象表达式是在使用他们的地方<strong>立即</strong>执行(及初始化)的</li>
  <li>对象声明是在第一次被访问到时<strong>延迟</strong>初始化的</li>
  <li>伴生对象的初始化是在相应的类被加载(解析)时，与 Java 静态初始化器的语义相匹配</li>
 </ul>
 <br>      
</div></body></html>