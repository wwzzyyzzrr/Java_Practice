<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Kotlin接口</h1><div style="width:100%;float:left;" class="article-content">   
 <p>Kotlin中的接口非常类似于Java 8。它们可以包含抽象方法的声明以及方法实现。 使它们与抽象类不同的是接口不能存储状态。 它们可以具有属性，但这些需要是抽象的或提供访问器实现。</p> 
 <p>使用关键字：<code>interface</code>定义接口</p> 
 <pre><code class="lang-kotlin">interface MyInterface {
    fun bar()
    fun foo() {
      // optional body
    }
}
</code></pre> 
 <h3 id="h3-u5B9Eu73B0u63A5u53E3"><a name="实现接口" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实现接口</h3>
 <p>类或对象可以实现一个或多个接口：</p> 
 <pre><code class="lang-kotlin">class Child : MyInterface {
    override fun bar() {
        // body
    }
}
</code></pre> 
 <h3 id="h3-u63A5u53E3u5C5Eu6027"><a name="接口属性" class="reference-link"></a><span class="header-link octicon octicon-link"></span>接口属性</h3>
 <p>您可以在接口中声明属性。 在接口中声明的属性可以是抽象的，也可以为访问者提供实现。 在接口中声明的属性不能具有后备字段，因此在接口中声明的访问器不能引用它们。</p> 
 <pre><code class="lang-kotlin">interface MyInterface {
    val prop: Int // abstract

    val propertyWithImplementation: String
        get() = "foo"

    fun foo() {
        print(prop)
    }
}

class Child : MyInterface {
    override val prop: Int = 29
}
</code></pre> 
 <h3 id="h3-u89E3u51B3u91CDu8F7Du51B2u7A81"><a name="解决重载冲突" class="reference-link"></a><span class="header-link octicon octicon-link"></span>解决重载冲突</h3>
 <p>当在超类型列表中声明很多类型时，可能会出现继承同一方法的多个实现。 例如 - </p> 
 <pre><code class="lang-kotlin">interface A {
    fun foo() { print("A") }
    fun bar()
}

interface B {
    fun foo() { print("B") }
    fun bar() { print("bar") }
}

class C : A {
    override fun bar() { print("bar") }
}

class D : A, B {
    override fun foo() {
        super&lt;A&gt;.foo()
        super&lt;B&gt;.foo()
    }

    override fun bar() {
        super&lt;B&gt;.bar()
    }
}
</code></pre> 
 <p>接口<code>A</code>和<code>B</code>都声明函数<code>foo()</code>和<code>bar()</code>。它们都实现了<code>foo()</code>，但只有<code>B</code>实现<code>bar()</code>，<code>bar()</code>在<code>A</code>中没有标记为<code>abstract</code>，因为这是接口的默认值，如果函数没有主体。 现在，如果类<code>C</code>类要实现<code>A</code>接口，显然必须重写<code>bar()</code>并提供一个实现。</p> 
 <p>然而，如果<code>D</code>类实现<code>A</code>和<code>B</code>的方法，需要实现从多个接口继承的所有方法，并指定<code>D</code>应该如何实现它们。此规则既适用于继承单个实现(<code>bar()</code>)和多个实现(<code>foo()</code>)的方法。</p>
 <br>      
</div></body></html>