<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Kotlin扩展</h1><div style="width:100%;float:left;" class="article-content">   
 <p>Kotlin与C＃和Go类似，提供了扩展一个新功能的类，而不必继承类或使用任何类型的设计模式，如<code>Decorator</code>。 这是通过称为扩展名的特殊声明完成的。 Kotlin支持扩展功能和扩展属性。</p> 
 <h2 id="h2-u6269u5C55u51FDu6570"><a name="扩展函数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>扩展函数</h2>
 <p>要声明一个扩展函数，需要用一个接收器类型，即被扩展的类型来加上它的名字。 以下为<code>MutableList &lt;Int&gt;</code>添加<code>swap</code>函数：</p> 
 <pre><code class="lang-kotlin">fun MutableList&lt;Int&gt;.swap(index1: Int, index2: Int) {
    val tmp = this[index1] // 'this' corresponds to the list
    this[index1] = this[index2]
    this[index2] = tmp
}
</code></pre> 
 <p>扩展函数中的<code>this</code>关键字对应于接收器对象(在点之前传递的对象)。 现在，可以在任何<code>MutableList &lt;Int&gt;</code>上调用这样一个函数：</p> 
 <pre><code class="lang-kotlin">val l = mutableListOf(1, 2, 3)
l.swap(0, 2) // 'this' inside 'swap()' will hold the value of 'l'
</code></pre> 
 <p>当然，这个函数对于任何<code>MutableList &lt;T&gt;</code>是有意义的，可以将它通用化：</p> 
 <pre><code class="lang-kotlin">fun &lt;T&gt; MutableList&lt;T&gt;.swap(index1: Int, index2: Int) {
    val tmp = this[index1] // 'this' corresponds to the list
    this[index1] = this[index2]
    this[index2] = tmp
}
</code></pre> 
 <p>在函数名称之前声明通用类型参数，使其在接收器类型表达式中可用。 请参阅<a target="_blank" href="http://www.yiibai.com/kotlin/generics.html" title="通用功能">通用功能</a>。</p> 
 <h2 id="h2-u6269u5C55u7A0Bu5E8Fu88ABu9759u6001u89E3u6790"><a name="扩展程序被静态解析" class="reference-link"></a><span class="header-link octicon octicon-link"></span>扩展程序被静态解析</h2>
 <p>扩展不会实际修改它们扩展的类。 通过定义扩展名，不将新成员插入到类中，而只能使用这种类型的变量上的点符号来调用新的函数。</p> 
 <p>扩展功能是静态调度的，即它们不是接收器类型的虚拟机。 这意味着被调用的扩展函数由调用该函数的表达式的类型决定，而不是在运行时评估该表达式的结果的类型。 例如：</p> 
 <pre><code class="lang-kotlin">open class C

class D: C()

fun C.foo() = "c"

fun D.foo() = "d"

fun printFoo(c: C) {
    println(c.foo())
}

printFoo(D())
</code></pre> 
 <p>此示例将打印“<code>c</code>”，因为被调用的扩展函数仅取决于参数<code>c</code>(<code>C</code>类)的声明类型。</p> 
 <p>该示例将打印“<code>c</code>”，因为类的<code>calleIf</code>的扩展函数具有成员函数，并且定义了扩展函数，其具有相同的接收器类型，相同的名称并且适用于给定的参数(该成员始终优先)。 例如：</p> 
 <pre><code class="lang-kotlin">class C {
    fun foo() { println("member") }
}

fun C.foo() { println("extension") }
</code></pre> 
 <p>如果调用<code>c</code>类型的<code>c.foo()</code>，它将打印“<code>member</code>”而不是“<code>extension</code>”。</p> 
 <p>但是，扩展函数可以重载具有相同名称但不同签名的成员函数，这是完全可行的：</p> 
 <pre><code class="lang-kotlin">class C {
    fun foo() { println("member") }
}

fun C.foo(i: Int) { println("extension") }
</code></pre> 
 <p>对<code>C().foo(1)</code>的调用将打印“<code>extension</code>”。</p> 
 <h2 id="h2--null-"><a name="可接受Null的接收器" class="reference-link"></a><span class="header-link octicon octicon-link"></span>可接受Null的接收器</h2>
 <p>请注意，可以使用可空(<code>null</code>)接收器类型定义扩展。 这样的扩展可以在一个对象变量上调用，即使它的值为<code>null</code>，并且可以在主体内检查<code>this == null</code>。 这样就可以在Kotlin中调用<code>toString()</code>，而无需检查<code>null</code>：检查发生在扩展函数内。</p> 
 <pre><code class="lang-kotlin">fun Any?.toString(): String {
    if (this == null) return "null"
    // after the null check, 'this' is autocast to a non-null type, so the toString() below
    // resolves to the member function of the Any class
    return toString()
}
</code></pre> 
 <h2 id="h2-u6269u5C55u5C5Eu6027"><a name="扩展属性" class="reference-link"></a><span class="header-link octicon octicon-link"></span>扩展属性</h2>
 <p>与函数类似，Kotlin支持扩展属性：</p> 
 <pre><code class="lang-kotlin">val &lt;T&gt; List&lt;T&gt;.lastIndex: Int
    get() = size - 1
</code></pre> 
 <p>请注意，由于扩展名实际上并不将成员插入到类中，因此扩展属性没有有效的方式来添加后备字段。 这就是为什么不允许扩展属性的初始化器。 它们的行为只能通过明确提供<code>getter</code> / <code>setter</code>来定义。</p> 
 <pre><code class="lang-kotlin">val Foo.bar = 1 // error: initializers are not allowed for extension properties
</code></pre> 
 <h2 id="h2-u4F34u968Fu5BF9u8C61u6269u5C55"><a name="伴随对象扩展" class="reference-link"></a><span class="header-link octicon octicon-link"></span>伴随对象扩展</h2>
 <p>如果一个类定义了一个伴随对象，那么还可以定义该对象的扩展函数和属性：</p> 
 <pre><code class="lang-kotlin">class MyClass {
    companion object { }  // will be called "Companion"
}

fun MyClass.Companion.foo() {
    // ...
}
</code></pre> 
 <p>就像伴随对象的常规成员一样，只能使用类名作为限定词：</p> 
 <pre><code class="lang-kotlin">MyClass.foo()
</code></pre> 
 <h2 id="h2-u6269u5C55u8303u56F4"><a name="扩展范围" class="reference-link"></a><span class="header-link octicon octicon-link"></span>扩展范围</h2>
 <p>大多数时候在顶层定义扩展，即直接在包下：</p>   
 <pre><code class="lang-kotlin">package foo.bar

fun Baz.goo() { ... }
</code></pre> 
 <p>要在其声明包之外使用这样的扩展，需要在调用时导入它：</p> 
 <pre><code class="lang-kotlin">package com.yiibai.usage

import foo.bar.goo // importing all extensions by name "goo"
                   // or
import foo.bar.*   // importing everything from "foo.bar"

fun usage(baz: Baz) {
    baz.goo()
)
</code></pre> 
 <p>有关详细信息，请参阅<a target="_blank" href="http://www.yiibai.com/kotlin/packages.html#imports" title="导入">导入</a>。</p> 
 <h2 id="h2-u58F0u660Eu6269u5C55u4F5Cu4E3Au6210u5458"><a name="声明扩展作为成员" class="reference-link"></a><span class="header-link octicon octicon-link"></span>声明扩展作为成员</h2>
 <p>在类中，可以为另一个类声明扩展名。 在这样的扩展中，有多个隐式接收器 - 可以在没有限定符的情况下访问对象成员。 声明扩展名的类的实例称为调度接收方，扩展方法的接收方型称为扩展接收方。</p> 
 <pre><code class="lang-kotlin">class D {
    fun bar() { ... }
}

class C {
    fun baz() { ... }

    fun D.foo() {
        bar()   // calls D.bar
        baz()   // calls C.baz
    }

    fun caller(d: D) {
        d.foo()   // call the extension function
    }
}
</code></pre> 
 <p>在发送接收器的成员与分发接收器之间发生名称冲突的情况下，分发接收器优先。 要引用发送接收器的成员，可以使用<a target="_blank" href="http://www.yiibai.com/kotlin/this-expressions.html#qualified" title="合格的this语法">合格的this语法</a>。</p> 
 <pre><code class="lang-kotlin">class C {
    fun D.foo() {
        toString()         // calls D.toString()
        this@C.toString()  // calls C.toString()
    }
</code></pre> 
 <p>声明为成员的扩展可以被声明为在子类中打开(<code>open</code>)和覆盖。 这意味着这种函数调度对于调度接收器类型是虚拟的，但是关于扩展接收器类型是静态的。</p> 
 <pre><code class="lang-kotlin">open class D {
}

class D1 : D() {
}

open class C {
    open fun D.foo() {
        println("D.foo in C")
    }

    open fun D1.foo() {
        println("D1.foo in C")
    }

    fun caller(d: D) {
        d.foo()   // call the extension function
    }
}

class C1 : C() {
    override fun D.foo() {
        println("D.foo in C1")
    }

    override fun D1.foo() {
        println("D1.foo in C1")
    }
}

C().caller(D())   // prints "D.foo in C"
C1().caller(D())  // prints "D.foo in C1" - dispatch receiver is resolved virtually
C().caller(D1())  // prints "D.foo in C" - extension receiver is resolved statically
</code></pre> 
 <h2 id="h2-u52A8u673A"><a name="动机" class="reference-link"></a><span class="header-link octicon octicon-link"></span>动机</h2>
 <p>在Java中，我们习惯使用名为“<code>*Utils</code>”的类：<code>FileUtils</code>，<code>StringUtils</code>等。<code>java.util.Collections</code>也属于这一类用法。 关于这些<code>Utils</code>类的令人不快的部分，如下代码所示：</p> 
 <pre><code class="lang-java">// Java
Collections.swap(list, Collections.binarySearch(list, Collections.max(otherList)), Collections.max(list))
</code></pre> 
 <p>这些类名总是要明确写出来，但是可以使用静态导入并得到：</p> 
 <pre><code class="lang-java">// Java
swap(list, binarySearch(list, max(otherList)), max(list))
</code></pre> 
 <p>上面代码是不是更好的一点，但一般我们没有或很少使用强大的IDE的代码完成功能来完成。</p>
 <br>      
</div></body></html>