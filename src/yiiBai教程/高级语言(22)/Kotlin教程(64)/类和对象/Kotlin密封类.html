<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Kotlin密封类</h1><div style="width:100%;float:left;" class="article-content">   
 <p>密封类用来表示受限的类继承结构：当一个值为有限集中的<br>类型、而不能有任何其他类型时。在某种意义上，他们是枚举类的扩展：枚举类型的值集合<br>也是受限的，但每个枚举常量只存在一个实例，而密封类<br>的一个子类可以有可包含状态的多个实例。</p> 
 <p>要声明一个密封类，需要在类名前面添加 <code>sealed</code> 修饰符。虽然密封类也可以<br>有子类，但是所有子类都必须在与密封类自身相同的文件中声明。(在 Kotlin 1.1 之前，<br>该规则更加严格：子类必须嵌套在密封类声明的内部)。</p> 
 <pre><code class="lang-kotlin">sealed class Expr
data class Const(val number: Double) : Expr()
data class Sum(val e1: Expr, val e2: Expr) : Expr()
object NotANumber : Expr()

fun eval(expr: Expr): Double = when (expr) {
    is Const -&gt; expr.number
    is Sum -&gt; eval(expr.e1) + eval(expr.e2)
    NotANumber -&gt; Double.NaN
}
</code></pre> 
 <p>(上文示例使用了 Kotlin 1.1 的一个额外的新功能：数据类扩展包括密封类在内的其他类的可能性。<br>)</p> 
 <p>请注意，扩展密封类子类的类(间接继承者)可以放在任何位置，而无需在<br>同一个文件中。</p> 
 <p>使用密封类的关键好处在于使用 <a target="_blank" href="http://www.yiibai.com/kotlin/control-flow.html#when-表达式"><code>when</code> 表达式</a> 的时候，如果能够<br>验证语句覆盖了所有情况，就不需要为该语句再添加一个 <code>else</code> 子句了。</p>   
 <pre><code class="lang-kotlin">fun eval(expr: Expr): Double = when(expr) {
    is Expr.Const -&gt; expr.number
    is Expr.Sum -&gt; eval(expr.e1) + eval(expr.e2)
    Expr.NotANumber -&gt; Double.NaN
    // 不再需要 `else` 子句，因为我们已经覆盖了所有的情况
}
</code></pre>
 <br>      
</div></body></html>