<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Kotlin类和继承</h1><div style="width:100%;float:left;" class="article-content">   
 <h3 id="h3-u7C7B"><a name="类" class="reference-link"></a><span class="header-link octicon octicon-link"></span>类</h3>
 <p>Kotlin中的类是使用<code>class</code>关键字来声明：</p> 
 <pre><code class="lang-kotlin">class Invoice {

}
</code></pre> 
 <p>类声明由类名，类头(指定类型参数，主构造函数等)和类体组成，由大括号括起来。类头和类主体都是可选的; 如果类没有主体，可以省略花括号。如下 - </p> 
 <pre><code class="lang-kotlin">class Empty
</code></pre> 
 <h3 id="h3-u6784u9020u51FDu6570"><a name="构造函数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>构造函数</h3>
 <p>Kotlin中的类可以有一个主构造函数和一个或多个辅助构造函数。 主构造函数是类头的一部分：它在类名后面(和可选的类型参数)。</p> 
 <pre><code class="lang-kotlin">class Person constructor(firstName: String) {
}
</code></pre> 
 <p>如果主构造函数没有任何注释或可见性修饰符，那么可以省略<code>constructor</code>关键字：</p> 
 <pre><code class="lang-kotlin">class Person(firstName: String) {
}
</code></pre> 
 <p>主构造函数不能包含任何代码。 初始化代码可以放在初始化程序块中，前缀为<code>init</code>关键字：</p> 
 <pre><code class="lang-kotlin">class Customer(name: String) {
    init {
        logger.info("Customer initialized with value ${name}")
    }
}
</code></pre> 
 <p>请注意，初始化程序块中可以使用主构造函数的参数。 它们也可以用在类体中声明属性的初始化器：</p> 
 <pre><code class="lang-kotlin">class Customer(name: String) {
    val customerKey = name.toUpperCase()
}
</code></pre> 
 <p>实际上，要声明属性并从主构造函数初始化它们，Kotlin有一个简洁的语法：</p> 
 <pre><code class="lang-kotlin">class Person(val firstName: String, val lastName: String, var age: Int) {
    // ...
}
</code></pre> 
 <p>与常规属性大体相同，主构造函数中声明的属性可以是多值(<code>var</code>)或只读(<code>val</code>)。<br>如果构造函数具有注释或可见性修饰符，则<code>constructor</code>关键字是必需的，修饰符将在它之前：</p> 
 <pre><code class="lang-kotlin">class Customer public @Inject constructor(name: String) { ... }
</code></pre> 
 <p>有关更多详细信息，请参阅<a target="_blank" href="http://www.yiibai.com/kotlin/visibility-modifiers.html#constructors" title="可见性修饰符">可见性修饰符</a>。</p> 
 <h2 id="h2-u8F85u52A9u6784u9020u51FDu6570"><a name="辅助构造函数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>辅助构造函数</h2>
 <p>类还可以声明辅助构造函数，它们以<code>constructor</code>关键字作为前缀：</p> 
 <pre><code class="lang-kotlin">class Person {
    constructor(parent: Person) {
        parent.children.add(this)
    }
}
</code></pre> 
 <p>如果类具有主构造函数，则每个辅助构造函数需要通过另一个辅助构造函数直接或间接地委派给主构造函数。 使用<code>this</code>关键字对同一类的另一个构造函数进行委派：</p> 
 <pre><code class="lang-kotlin">class Person(val name: String) {
    constructor(name: String, parent: Person) : this(name) {
        parent.children.add(this)
    }
}
</code></pre> 
 <p>如果一个非抽象类没有声明任何构造函数(主或辅助)，那么它将不使用参数来生成主构造函数。 构造函数的可见性将是公开的。 如果不希望类具有公共构造函数，则需要声明具有非默认可见性的空主构造函数：</p> 
 <pre><code class="lang-kotlin">class DontCreateMe private constructor () {
}
</code></pre> 
 <p>注意：在JVM上，如果主构造函数的所有参数都具有默认值，编译器将生成一个额外的无参数构造函数，它将使用默认值。 这使得更容易使用Kotlin与诸如Jackson或JPA的库，通过无参数构造函数创建类实例。</p> 
 <pre><code class="lang-kotlin">class Customer(val customerName: String = "")
</code></pre> 
 <h3 id="h3-u521Bu5EFAu7C7Bu7684u5B9Eu4F8B"><a name="创建类的实例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>创建类的实例</h3>
 <p>要创建一个类的实例，需要调用类的构造函数，就像它是一个常规函数一样：</p> 
 <pre><code class="lang-kotlin">val invoice = Invoice()

val customer = Customer("Joe Minsu")
</code></pre> 
 <blockquote> 
  <p>请注意，Kotlin创建对象并不使用<code>new</code>关键字。</p> 
 </blockquote> 
 <p>在<a target="_blank" href="http://www.yiibai.com/kotlin/nested-classes.html" title="嵌套类">嵌套类</a>中描述了创建嵌套，内部和匿名内部类的实例。</p> 
 <h3 id="h3-u7C7Bu6210u5458"><a name="类成员" class="reference-link"></a><span class="header-link octicon octicon-link"></span>类成员</h3>
 <p>类可以包含 - </p> 
 <ul> 
  <li>构造函数和初始化程序块</li>
  <li><a target="_blank" href="http://www.yiibai.com/kotlin/functions.html" title="函数">函数</a></li>
  <li><a target="_blank" href="http://www.yiibai.com/kotlin/properties.html" title="属性">属性</a></li>
  <li><a target="_blank" href="http://www.yiibai.com/kotlin/nested-classes.html" title="嵌套和内部类">嵌套和内部类</a></li>
  <li><a target="_blank" href="http://www.yiibai.com/kotlin/object-declarations.html" title="对象声明">对象声明</a></li>
 </ul> 
 <h2 id="h2-u7EE7u627F"><a name="继承" class="reference-link"></a><span class="header-link octicon octicon-link"></span>继承</h2>
 <p>Kotlin中的所有类都有一个通用的超类：<code>Any</code>，这是一个没有父类型的类的默认超类。</p> 
 <pre><code class="lang-kotlin">class Example // Implicitly inherits from Any
</code></pre> 
 <p><code>Any</code>不是<code>java.lang.Object</code>; 特别地要说明的是，除了<code>equals()</code>，<code>hashCode()</code>和<code>toString()</code>之外，它不具有其它任何成员函数。有关更多详细信息，请参阅<a target="_blank" href="http://www.yiibai.com/kotlin/java-interop.html#object-methods" title="Java互操作性">Java互操作性</a>部分。</p> 
 <p>要声明一个显式的超类型，将冒号后面的类型放在类头中：</p> 
 <pre><code class="lang-kotlin">open class Base(p: Int)

class Derived(p: Int) : Base(p)
</code></pre> 
 <p>如果类具有主构造函数，则可以使用主构造函数的参数(并且必须)初始化基类型。</p> 
 <p>如果类没有主构造函数，则每个辅助构造函数必须使用<code>super</code>关键字初始化基类型，或者委托给另一个构造函数。 请注意，在这种情况下，不同的辅助构造函数可以调用基类型的不同构造函数：</p> 
 <pre><code class="lang-kotlin">class MyView : View {
    constructor(ctx: Context) : super(ctx)

    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)
}
</code></pre> 
 <p>一个类的开放(<code>open</code>)注释与Java的最终结果相反：它允许其他人继承这个类。 默认情况下，Kotlin中的所有类都是<code>final</code>，它对应于<a target="_blank" href="http://www.oracle.com/technetwork/java/effectivejava-136174.html" title="有效Java用法">有效Java用法</a>，设计和继承的文档或者禁止它。</p> 
 <h3 id="h3-u91CDu8F7Du65B9u6CD5"><a name="重载方法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>重载方法</h3>
 <p>正如前面提到的，与Java不同的是，Kotlin需要对可覆盖成员进行显式注释(称之为<code>open</code>)和覆盖：</p>   
 <pre><code class="lang-kotlin">open class Base {
    open fun v() {}
    fun nv() {}
}
class Derived() : Base() {
    override fun v() {}
}
</code></pre> 
 <p><code>Derived.v()</code>需要覆盖(<code>override</code>)注释。 如果缺少(<code>override</code>)注释，编译器会抱错。 如果在一个函数上没有<code>open</code>注释，如在<code>Base.nv()</code>中，在子类中声明一个具有相同签名的方法是非法的，无论是否有覆盖(<code>override</code>)注释还是没有。 在<code>final</code>类(例如不使用<code>open</code>注释的类)中，则禁止覆盖成员。</p> 
 <p>标记为覆盖(<code>override</code>)的成员本身是打开的，即它可以在子类中被覆盖。 如果要禁止重新覆盖，请使用<code>final</code>关键字：</p> 
 <pre><code class="lang-kotlin">open class AnotherDerived() : Base() {
    final override fun v() {}
}
</code></pre> 
 <h3 id="h3-u8986u76D6u5C5Eu6027"><a name="覆盖属性" class="reference-link"></a><span class="header-link octicon octicon-link"></span>覆盖属性</h3>
 <p>覆盖属性的工作方式与覆盖方法类似; 在超类上声明，然后在派生类上重新声明的属性必须以<code>override</code>替代，并且它们必须具有兼容类型。 每个声明的属性可以被具有初始化器的属性或具有<code>getter</code>方法的属性覆盖。</p> 
 <pre><code class="lang-kotlin">open class Foo {
    open val x: Int get { ... }
}

class Bar1 : Foo() {
    override val x: Int = ...
}
</code></pre> 
 <p>还可以使用<code>var</code>属性覆盖<code>val</code>属性，反之亦然。 这是允许的，因为<code>val</code>属性基本上声明一个<code>getter</code>方法，并将其替换为<code>var</code>，另外在派生类中声明一个<code>setter</code>方法。</p> 
 <p>请注意，可以在主构造函数中使用<code>override</code>关键字作为属性声明的一部分。</p> 
 <pre><code class="lang-kotlin">interface Foo {
    val count: Int
}

class Bar1(override val count: Int) : Foo

class Bar2 : Foo {
    override var count: Int = 0
}
</code></pre> 
 <h3 id="h3-u8986u76D6u89C4u5219"><a name="覆盖规则" class="reference-link"></a><span class="header-link octicon octicon-link"></span>覆盖规则</h3>
 <p>在Kotlin中，实现继承由以下规则控制：如果类从其直接超类继承同一成员的多个实现，则它必须覆盖该成员并提供自己的实现(可能使用其中一个继承)。 要表示从其继承的实现的超类型，可在尖括号中使用超类型名称超级限定，例如，<code>super&lt;Base&gt;</code>。</p> 
 <pre><code class="lang-kotlin">open class A {
    open fun f() { print("A") }
    fun a() { print("a") }
}

interface B {
    fun f() { print("B") } // interface members are 'open' by default
    fun b() { print("b") }
}

class C() : A(), B {
    // The compiler requires f() to be overridden:
    override fun f() {
        super&lt;A&gt;.f() // call to A.f()
        super&lt;B&gt;.f() // call to B.f()
    }
}
</code></pre> 
 <p>从<code>B</code>继承<code>A</code>是没有问题的，对<code>a()</code>和<code>b()</code>函数也没有任何问题，因为<code>C</code>只继承每个这些函数的一个实现。 但是对于<code>f()</code>有两个由<code>C</code>继承的实现，因此必须在<code>C</code>中重写<code>f()</code>函数并提供自己的消除歧义的实现。</p> 
 <h2 id="h2-u62BDu8C61u7C7B"><a name="抽象类" class="reference-link"></a><span class="header-link octicon octicon-link"></span>抽象类</h2>
 <p>一个类和其一些成员可以被声明为抽象。 抽象成员在其类中没有实现。 请注意，不需要使用<code>open</code>来注释抽象类或函数。</p> 
 <p>可以用抽象来覆盖一个非抽象的<code>open</code>成员 - </p> 
 <pre><code class="lang-kotlin">open class Base {
    open fun f() {}
}

abstract class Derived : Base() {
    override abstract fun f()
}
</code></pre> 
 <h3 id="h3-u4F34u968Fu5BF9u8C61"><a name="伴随对象" class="reference-link"></a><span class="header-link octicon octicon-link"></span>伴随对象</h3>
 <p>在Kotlin中，与Java或C#不同，类没有静态(<code>static</code>)方法。 在大多数情况下，建议简单地使用包级别的功能。</p> 
 <p>如果需要编写一个可以调用的函数，而不需要一个类实例，但需要访问一个类的内部(例如，一个工厂方法)，则可以将其作为<a target="_blank" href="http://www.yiibai.com/kotlin/object-declarations.html" title="对象声明">对象声明</a>的一个成员编写。</p> 
 <p>更具体地说，如果在类中声明了一个<a target="_blank" href="http://www.yiibai.com/kotlin/object-declarations.html#companion-objects" title="伴随对象">伴随对象</a>，则可以使用类名作为限定符的Java/C＃中调用静态方法相同的语法来调用其成员。</p>
 <br>      
</div></body></html>