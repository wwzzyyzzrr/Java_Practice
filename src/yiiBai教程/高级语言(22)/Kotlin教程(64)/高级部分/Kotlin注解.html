<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Kotlin注解</h1><div style="width:100%;float:left;" class="article-content">   
 <h2 id="h2-u6CE8u89E3u58F0u660E"><a name="注解声明" class="reference-link"></a><span class="header-link octicon octicon-link"></span>注解声明</h2>
 <p>注解是将元数据附加到代码的方法。要声明注解，请将 <em>annotation</em>{: .keyword } 修饰符放在类的前面：</p> 
 <pre><code class="lang-kotlin">annotation class Fancy
</code></pre> 
 <p>注解的附加属性可以通过用元注解标注注解类来指定：</p> 
 <ul> 
  <li><a target="_blank" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-target/index.html" "><code>@Target</code></a> 指定可以用<br>该注解标注的元素的可能的类型(类、函数、属性、表达式等)；</li>
  <li><a target="_blank" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-retention/index.html" "><code>@Retention</code></a> 指定该注解是否<br>存储在编译后的 class 文件中，以及它在运行时能否通过反射可见<br>(默认都是 true)；</li>
  <li><a target="_blank" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-repeatable/index.html" "><code>@Repeatable</code></a> 允许<br>在单个元素上多次使用相同的该注解；</li>
  <li><a target="_blank" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-must-be-documented/index.html" "><code>@MustBeDocumented</code></a> 指定<br> 该注解是公有 API 的一部分，并且应该包含在<br> 生成的 API 文档中显示的类或方法的签名中。</li>
 </ul> 
 <pre><code class="lang-kotlin">@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION,
        AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.EXPRESSION)
@Retention(AnnotationRetention.SOURCE)
@MustBeDocumented
annotation class Fancy
</code></pre> 
 <h3 id="h3-u7528u6CD5"><a name="用法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>用法</h3>
 <pre><code class="lang-kotlin">@Fancy class Foo {
    @Fancy fun baz(@Fancy foo: Int): Int {
        return (@Fancy 1)
    }
}
</code></pre> 
 <p>如果需要对类的主构造函数进行标注，则需要在构造函数声明中添加 <em>constructor</em>{: .keyword} 关键字<br>，并将注解添加到其前面：</p> 
 <pre><code class="lang-kotlin">class Foo @Inject constructor(dependency: MyDependency) {
    // ……
}
</code></pre> 
 <p>你也可以标注属性访问器：</p> 
 <pre><code class="lang-kotlin">class Foo {
    var x: MyDependency? = null
        @Inject set
}
</code></pre> 
 <h3 id="h3-u6784u9020u51FDu6570"><a name="构造函数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>构造函数</h3>
 <p>注解可以有接受参数的构造函数。</p> 
 <pre><code class="lang-kotlin">annotation class Special(val why: String)

@Special("example") class Foo {}
</code></pre> 
 <p>允许的参数类型有：</p> 
 <ul> 
  <li>对应于 Java 原生类型的类型(Int、 Long等)；</li>
  <li>字符串；</li>
  <li>类(<code>Foo::class</code>)；</li>
  <li>枚举；</li>
  <li>其他注解；</li>
  <li>上面已列类型的数组。</li>
 </ul> 
 <p>注解参数不能有可空类型，因为 JVM 不支持将 <code>null</code> 作为<br>注解属性的值存储。</p> 
 <p>如果注解用作另一个注解的参数，则其名称不以 @ 字符为前缀：</p> 
 <pre><code class="lang-kotlin">annotation class ReplaceWith(val expression: String)

annotation class Deprecated(
        val message: String,
        val replaceWith: ReplaceWith = ReplaceWith(""))

@Deprecated("This function is deprecated, use === instead", ReplaceWith("this === other"))
</code></pre> 
 <p>如果需要将一个类指定为注解的参数，请使用 Kotlin 类<br>(<a target="_blank" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html">KClass</a>)。Kotlin 编译器会<br>自动将其转换为 Java 类，以便 Java 代码能够正常看到该注解和参数<br>。</p> 
 <pre><code class="lang-kotlin">
import kotlin.reflect.KClass

annotation class Ann(val arg1: KClass&lt;*&gt;, val arg2: KClass&lt;out Any?&gt;)

@Ann(String::class, Int::class) class MyClass
</code></pre> 
 <h3 id="h3-lambda-"><a name="Lambda 表达式" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Lambda 表达式</h3>
 <p>注解也可以用于 lambda 表达式。它们会被应用于生成 lambda 表达式体的 <code>invoke()</code><br>方法上。这对于像 <a target="_blank" href="http://www.paralleluniverse.co/quasar/">Quasar</a> 这样的框架很有用，<br>该框架使用注解进行并发控制。</p> 
 <pre><code class="lang-kotlin">annotation class Suspendable

val f = @Suspendable { Fiber.sleep(10) }
</code></pre> 
 <h2 id="h2-u6CE8u89E3u4F7Fu7528u5904u76EEu6807"><a name="注解使用处目标" class="reference-link"></a><span class="header-link octicon octicon-link"></span>注解使用处目标</h2>
 <p>当对属性或主构造函数参数进行标注时，从相应的 Kotlin 元素<br>生成的 Java 元素会有多个，因此在生成的 Java 字节码中该注解有多个可能位置<br>。如果要指定精确地指定应该如何生成该注解，请使用以下语法：</p> 
 <pre><code class="lang-kotlin">class Example(@field:Ann val foo,    // 标注 Java 字段
              @get:Ann val bar,      // 标注 Java getter
              @param:Ann val quux)   // 标注 Java 构造函数参数
</code></pre> 
 <p>可以使用相同的语法来标注整个文件。 要做到这一点，把带有目标 <code>file</code> 的注解放在<br>文件的顶层、package 指令之前或者在所有导入之前(如果文件在默认包中的话)：</p> 
 <pre><code class="lang-kotlin">@file:JvmName("Foo")

package org.jetbrains.demo
</code></pre> 
 <p>如果你对同一目标有多个注解，那么可以这样来避免目标重复——在目标后面添加方括号<br>并将所有注解放在方括号内：</p>   
 <pre><code class="lang-kotlin">class Example {
     @set:[Inject VisibleForTesting]
     var collaborator: Collaborator
}
</code></pre> 
 <p>支持的使用处目标的完整列表为：</p> 
 <ul> 
  <li><code>file</code></li>
  <li><code>property</code>(具有此目标的注解对 Java 不可见)</li>
  <li><code>field</code></li>
  <li><code>get</code>(属性 getter)</li>
  <li><code>set</code>(属性 setter)</li>
  <li><code>receiver</code>(扩展函数或属性的接收者参数)</li>
  <li><code>param</code>(构造函数参数)</li>
  <li><code>setparam</code>(属性 setter 参数)</li>
  <li><code>delegate</code>(为委托属性存储其委托实例的字段)</li>
 </ul> 
 <p>要标注扩展函数的接收者参数，请使用以下语法：</p> 
 <pre><code class="lang-kotlin">fun @receiver:Fancy String.myExtension() { }
</code></pre> 
 <p>如果不指定使用处目标，则根据正在使用的注解的 <code><a target="_blank" href="https://github.com/Target" title="@Target" class="at-link">@Target</a></code> 注解来选择目标<br>。如果有多个适用的目标，则使用以下列表中的第一个适用目标：</p> 
 <ul> 
  <li><code>param</code></li>
  <li><code>property</code></li>
  <li><code>field</code></li>
 </ul> 
 <h2 id="h2-java-"><a name="Java 注解" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Java 注解</h2>
 <p>Java 注解与 Kotlin 100% 兼容：</p> 
 <pre><code class="lang-kotlin">import org.junit.Test
import org.junit.Assert.*
import org.junit.Rule
import org.junit.rules.*

class Tests {
    // 将 @Rule 注解应用于属性 getter
    @get:Rule val tempFolder = TemporaryFolder()

    @Test fun simple() {
        val f = tempFolder.newFile()
        assertEquals(42, getTheAnswer())
    }
}
</code></pre> 
 <p>因为 Java 编写的注解没有定义参数顺序，所以不能使用常规函数调用<br>语法来传递参数。相反，你需要使用命名参数语法。</p> 
 <pre><code class="lang-java">// Java
public @interface Ann {
    int intValue();
    String stringValue();
}
</code></pre> 
 <pre><code class="lang-kotlin">// Kotlin
@Ann(intValue = 1, stringValue = "abc") class C
</code></pre> 
 <p>就像在 Java 中一样，一个特殊的情况是 <code>value</code> 参数；它的值无需显式名称指定。</p> 
 <pre><code class="lang-java">// Java
public @interface AnnWithValue {
    String value();
}
</code></pre> 
 <pre><code class="lang-kotlin">// Kotlin
@AnnWithValue("abc") class C
</code></pre> 
 <p>如果 Java 中的 <code>value</code> 参数具有数组类型，它会成为 Kotlin 中的一个 <code>vararg</code> 参数：</p> 
 <pre><code class="lang-java">// Java
public @interface AnnWithArrayValue {
    String[] value();
}
</code></pre> 
 <pre><code class="lang-kotlin">// Kotlin
@AnnWithArrayValue("abc", "foo", "bar") class C
</code></pre> 
 <p>对于具有数组类型的其他参数，你需要显式使用 <code>arrayOf</code>：</p> 
 <pre><code class="lang-java">// Java
public @interface AnnWithArrayMethod {
    String[] names();
}
</code></pre> 
 <pre><code class="lang-kotlin">// Kotlin
@AnnWithArrayMethod(names = arrayOf("abc", "foo", "bar")) class C
</code></pre> 
 <p>注解实例的值会作为属性暴露给 Kotlin 代码。</p> 
 <pre><code class="lang-java">// Java
public @interface Ann {
    int value();
}
</code></pre> 
 <pre><code class="lang-kotlin">// Kotlin
fun foo(ann: Ann) {
    val i = ann.value
}
</code></pre>
 <br>      
</div></body></html>