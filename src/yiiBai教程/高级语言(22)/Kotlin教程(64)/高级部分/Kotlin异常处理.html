<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Kotlin异常处理</h1><div style="width:100%;float:left;" class="article-content">   
 <h1 id="h1-u5F02u5E38"><a name="异常" class="reference-link"></a><span class="header-link octicon octicon-link"></span>异常</h1>
 <h2 id="h2-u5F02u5E38u7C7B"><a name="异常类" class="reference-link"></a><span class="header-link octicon octicon-link"></span>异常类</h2>
 <p>Kotlin 中所有异常类都是 <code>Throwable</code> 类的子孙类。<br>每个异常都有消息、堆栈回溯信息和可选的原因。</p> 
 <p>使用 <em>throw</em>{: .keyword }-表达式来抛出异常。</p> 
 <pre><code class="lang-kotlin">throw MyException("Hi There!")
</code></pre> 
 <p>使用 <em>try</em>{: .keyword }-表达式来捕获异常。</p> 
 <pre><code class="lang-kotlin">try {
    // 一些代码
}
catch (e: SomeException) {
    // 处理程序
}
finally {
    // 可选的 finally 块
}
</code></pre> 
 <p>可以有零到多个 <em>catch</em>{: .keyword } 块。<em>finally</em>{: .keyword } 块可以省略。<br>但是 <em>catch</em>{: .keyword } 和 <em>finally</em>{: .keyword } 块至少应该存在一个。</p> 
 <h3 id="h3-try-"><a name="Try 是一个表达式" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Try 是一个表达式</h3>
 <p><em>try</em>{: .keyword } 是一个表达式，即它可以有一个返回值。</p> 
 <pre><code class="lang-kotlin">val a: Int? = try { parseInt(input) } catch (e: NumberFormatException) { null }
</code></pre> 
 <p><em>try</em>{: .keyword }-表达式的返回值是 <em>try</em>{: .keyword } 块中的<br>最后一个表达式或者是(所有)<em>catch</em>{: .keyword } 块中的最后一个表达式。<br><em>finally</em>{: .keyword } 块中的内容不会影响表达式的结果。</p> 
 <h2 id="h2-u53D7u68C0u7684u5F02u5E38"><a name="受检的异常" class="reference-link"></a><span class="header-link octicon octicon-link"></span>受检的异常</h2>
 <p>Kotlin 没有受检的异常。这其中有很多原因，但我们会提供一个简单的例子。</p> 
 <p>以下是 JDK 中 <code>StringBuilder</code> 类实现的一个示例接口</p> 
 <pre><code class="lang-java">Appendable append(CharSequence csq) throws IOException;
</code></pre> 
 <p>这个签名是什么意思？ 它是说，每次我追加一个字符串到一些东西(一个 <code>StringBuilder</code>、某种日志、一个控制台等)上时<br>我就必须捕获那些 <code>IOException</code>。 为什么？因为它可能正在执行 IO 操作(<code>Writer</code> 也实现了 <code>Appendable</code>)……<br>所以它导致这种代码随处可见的出现：</p> 
 <pre><code class="lang-kotlin">try {
    log.append(message)
}
catch (IOException e) {
    // 必须要安全
}
</code></pre> 
 <p>这并不好，参见<a target="_blank" href="http://www.oracle.com/technetwork/java/effectivejava-136174.html">《Effective Java》</a> 第 65 条：<em>不要忽略异常</em>。</p> 
 <p>Bruce Eckel 在<a target="_blank" href="http://www.mindview.net/Etc/Discussions/CheckedExceptions">《Java 是否需要受检的异常？》(Does Java need Checked Exceptions?)</a> 中指出：</p> 
 <blockquote> 
  <p>通过一些小程序测试得出的结论是异常规范会同时提高开发者的生产力和代码质量，但是大型软件项目的经验表明一个不同的结论——生产力降低、代码质量很少或没有提高。</p> 
 </blockquote> 
 <p>其他相关引证：</p> 
 <ul> 
  <li><a target="_blank" href="http://radio-weblogs.com/0122027/stories/2003/04/01/JavasCheckedExceptionsWereAMistake.html">《Java 的受检异常是一个错误》(Java’s checked exceptions were a mistake)</a>(Rod Waldhoff)</li>
  <li><a target="_blank" href="http://www.artima.com/intv/handcuffs.html">《受检异常的烦恼》(The Trouble with Checked Exceptions)</a>(Anders Hejlsberg)</li>
 </ul> 
 <h2 id="h2-nothing-"><a name="Nothing 类型" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Nothing 类型</h2>
 <p>在 Kotlin 中 <code>throw</code> 是表达式，所以你可以使用它(比如)作为 Elvis 表达式的一部分：</p>   
 <pre><code class="lang-kotlin">val s = person.name ?: throw IllegalArgumentException("Name required")
</code></pre> 
 <p><code>throw</code> 表达式的类型是特殊类型 <code>Nothing</code>。<br>该类型没有值，而是用于标记永远不能达到的代码位置。<br>在你自己的代码中，你可以使用 <code>Nothing</code> 来标记一个永远不会返回的函数：</p> 
 <pre><code class="lang-kotlin">fun fail(message: String): Nothing {
    throw IllegalArgumentException(message)
}
</code></pre> 
 <p>当你调用该函数时，编译器会知道执行不会超出该调用：</p> 
 <pre><code class="lang-kotlin">val s = person.name ?: fail("Name required")
println(s)     // 在此已知“s”已初始化
</code></pre> 
 <h2 id="h2-java-"><a name="Java 互操作性" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Java 互操作性</h2>
 <p>与 Java 互操作性相关的信息，请参见 <a target="_blank" href="java-interop.html">Java 互操作性章节</a>中的异常部分。</p>
 <br>      
</div></body></html>