<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Kotlin类型安全的构建器</h1><div style="width:100%;float:left;" class="article-content">   
 <p><a target="_blank" href="http://www.groovy-lang.org/dsls.html#_nodebuilder">构建器(builder)</a>的概念在 <em>Groovy</em> 社区中非常热门。<br>构建器允许以半声明(semi-declarative)的方式定义数据。构建器很适合用来<a target="_blank" href="http://www.groovy-lang.org/processing-xml.html#_creating_xml">生成 XML</a>、<br><a target="_blank" href="http://www.groovy-lang.org/swing.html">布局 UI 组件</a>、<br><a target="_blank" href="http://www.artima.com/weblogs/viewpost.jsp?thread=296081">描述 3D 场景</a>以及其他更多功能……</p> 
 <p>对于很多情况下，Kotlin 允许<em>检查类型</em>的构建器，这使得它们比<br>Groovy 自身的动态类型实现更具吸引力。</p> 
 <p>对于其余的情况，Kotlin 支持动态类型构建器。</p> 
 <h2 id="h2-u4E00u4E2Au7C7Bu578Bu5B89u5168u7684u6784u5EFAu5668u793Au4F8B"><a name="一个类型安全的构建器示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>一个类型安全的构建器示例</h2>
 <p>考虑下面的代码：</p> 
 <pre><code class="lang-kotlin">import com.example.html.* // 参见下文声明

fun result(args: Array&lt;String&gt;) =
    html {
        head {
            title {+"XML encoding with Kotlin"}
        }
        body {
            h1 {+"XML encoding with Kotlin"}
            p  {+"this format can be used as an alternative markup to XML"}

            // 一个具有属性和文本内容的元素
            a(href = "http://kotlinlang.org") {+"Kotlin"}

            // 混合的内容
            p {
                +"This is some"
                b {+"mixed"}
                +"text. For more see the"
                a(href = "http://kotlinlang.org") {+"Kotlin"}
                +"project"
            }
            p {+"some text"}

            // 以下代码生成的内容
            p {
                for (arg in args)
                    +arg
            }
        }
    }
</code></pre> 
 <p>这是完全合法的 Kotlin 代码。<br>你可以<a target="_blank" href="http://try.kotlinlang.org/#/Examples/Longer examples/HTML Builder/HTML Builder.kt">在这里</a>在线运行上文代码(修改它并在浏览器中运行)。</p> 
 <h2 id="h2-u5B9Eu73B0u539Fu7406"><a name="实现原理" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实现原理</h2>
 <p>让我们来看看 Kotlin 中实现类型安全构建器的机制。<br>首先，我们需要定义我们想要构建的模型，在本例中我们需要建模 HTML 标签。<br>用一些类就可以轻易完成。<br>例如，<code>HTML</code> 是一个描述 <code>&lt;html&gt;</code> 标签的类，也就是说它定义了像 <code>&lt;head&gt;</code> 和 <code>&lt;body&gt;</code> 这样的子标签。<br>(参见<a target="_blank" href="#comexamplehtml-包的完整定义">下文</a>它的声明。)</p> 
 <p>现在，让我们回想下为什么我们可以在代码中这样写：</p> 
 <pre><code class="lang-kotlin">html {
 // ……
}
</code></pre> 
 <p><code>html</code> 实际上是一个函数调用，它接受一个 <a target="_blank" href="lambdas.html">lambda 表达式</a> 作为参数。<br>该函数定义如下：</p> 
 <pre><code class="lang-kotlin">fun html(init: HTML.() -&gt; Unit): HTML {
    val html = HTML()
    html.init()
    return html
}
</code></pre> 
 <p>这个函数接受一个名为 <code>init</code> 的参数，该参数本身就是一个函数。<br>该函数的类型是 <code>HTML.() -&gt; Unit</code>，它是一个 <em>带接收者的函数类型</em> 。<br>这意味着我们需要向函数传递一个 HTML 类型的实例( <em>接收者</em> )，<br>并且我们可以在函数内部调用该实例的成员。<br>该接收者可以通过 <em>this</em>{: .keyword } 关键字访问：</p> 
 <pre><code class="lang-kotlin">html {
    this.head { /* …… */ }
    this.body { /* …… */ }
}
</code></pre> 
 <p>(<code>head</code> 和 <code>body</code> 是 <code>HTML</code> 的成员函数。)</p> 
 <p>现在，像往常一样，<em>this</em>{: .keyword } 可以省略掉了，我们得到的东西看起来已经非常像一个构建器了：</p> 
 <pre><code class="lang-kotlin">html {
    head { /* …… */ }
    body { /* …… */ }
}
</code></pre> 
 <p>那么，这个调用做什么？ 下面来看看看上面定义的 <code>html</code> 函数的主体。<br>它创建了一个 <code>HTML</code> 的新实例，然后通过调用作为参数传入的函数来初始化它<br>(在我们的示例中，归结为在HTML实例上调用 <code>head</code> 和 <code>body</code>)，然后返回此实例。<br>这正是构建器所应做的。</p> 
 <p><code>HTML</code> 类中的 <code>head</code> 和 <code>body</code> 函数的定义与 <code>html</code> 类似。<br>唯一的区别是，它们将构建的实例添加到包含 <code>HTML</code> 实例的 <code>children</code> 集合中：</p> 
 <pre><code class="lang-kotlin">fun head(init: Head.() -&gt; Unit) : Head {
    val head = Head()
    head.init()
    children.add(head)
    return head
}

fun body(init: Body.() -&gt; Unit) : Body {
    val body = Body()
    body.init()
    children.add(body)
    return body
}
</code></pre> 
 <p>实际上这两个函数做同样的事情，所以我们可以有一个泛型版本，<code>initTag</code>：</p> 
 <pre><code class="lang-kotlin">    protected fun &lt;T : Element&gt; initTag(tag: T, init: T.() -&gt; Unit): T {
        tag.init()
        children.add(tag)
        return tag
    }
</code></pre> 
 <p>所以，现在我们的函数很简单：</p> 
 <pre><code class="lang-kotlin">fun head(init: Head.() -&gt; Unit) = initTag(Head(), init)

fun body(init: Body.() -&gt; Unit) = initTag(Body(), init)
</code></pre> 
 <p>并且我们可以使用它们来构建 <code>&lt;head&gt;</code> 和 <code>&lt;body&gt;</code> 标签。</p> 
 <p>这里要讨论的另一件事是如何向标签体中添加文本。在上例中我们这样写到</p> 
 <pre><code class="lang-kotlin">html {
    head {
        title {+"XML encoding with Kotlin"}
    }
    // ……
}
</code></pre> 
 <p>所以基本上，我们只是把一个字符串放进一个标签体内部，但在它前面有一个小的 <code>+</code>，<br>所以它是一个函数调用，调用一个前缀 <code>unaryPlus()</code> 操作。<br>该操作实际上是由一个扩展函数 <code>unaryPlus()</code> 定义的，该函数是 <code>TagWithText</code> 抽象类(<code>Title</code> 的父类)的成员：</p> 
 <pre><code class="lang-kotlin">fun String.unaryPlus() {
    children.add(TextElement(this))
}
</code></pre> 
 <p>所以，在这里前缀 <code>+</code> 所做的事情是把一个字符串包装到一个 <code>TextElement</code> 实例中，并将其添加到 <code>children</code> 集合中，<br>以使其成为标签树的一个适当的部分。</p> 
 <p>所有这些都在上面构建器示例顶部导入的包 <code>com.example.html</code> 中定义。<br>在最后一节中，你可以阅读这个包的完整定义。</p> 
 <h2 id="h2--dslmarker-1-1-"><a name="作用域控制：@DslMarker(自 1.1 起)" class="reference-link"></a><span class="header-link octicon octicon-link"></span>作用域控制：<a target="_blank" href="https://github.com/DslMarker" title="@DslMarker" class="at-link">@DslMarker</a>(自 1.1 起)</h2>
 <p>使用 DSL 时，可能会遇到上下文中可以调用太多函数的问题。<br>我们可以调用 lambda 表达式内部每个可用的隐式接收者的方法，因此得到一个不一致的结果，就像在另一个 <code>head</code> 内部的 <code>head</code> 标记那样：</p> 
 <pre><code class="lang-kotlin">html {
    head {
        head {} // 应该禁止
    }
    // ……
}
</code></pre> 
 <p>在这个例子中，必须只有最近层的隐式接收者 <code>this<a target="_blank" href="https://github.com/head" title="@head" class="at-link">@head</a></code> 的成员可用；<code>head()</code> 是外部接收者 <code>this<a target="_blank" href="https://github.com/html" title="@html" class="at-link">@html</a></code> 的成员，所以调用它一定是非法的。</p> 
 <p>为了解决这个问题，在 Kotlin 1.1 中引入了一种控制接收者作用域的特殊机制。</p> 
 <p>为了使编译器开始控制标记，我们只是必须用相同的标记注解来标注在 DSL 中使用的所有接收者的类型。<br>例如，对于 HTML 构建器，我们声明一个注解 <code><a target="_blank" href="https://github.com/HTMLTagMarker" title="@HTMLTagMarker" class="at-link">@HTMLTagMarker</a></code>：</p>   
 <pre><code class="lang-kotlin">@DslMarker
annotation class HtmlTagMarker
</code></pre> 
 <p>如果一个注解类使用 <code><a target="_blank" href="https://github.com/DslMarker" title="@DslMarker" class="at-link">@DslMarker</a></code> 注解标注，那么该注解类称为 DSL 标记。</p> 
 <p>在我们的 DSL 中，所有标签类都扩展了相同的超类 <code>Tag</code>。<br>只需使用 <code><a target="_blank" href="https://github.com/HtmlTagMarker" title="@HtmlTagMarker" class="at-link">@HtmlTagMarker</a></code> 来标注超类就足够了，之后，Kotlin 编译器会将所有继承的类视为已标注：</p> 
 <pre><code class="lang-kotlin">@HtmlTagMarker
abstract class Tag(val name: String) { …… }
</code></pre> 
 <p>我们不必用 <code><a target="_blank" href="https://github.com/HtmlTagMarker" title="@HtmlTagMarker" class="at-link">@HtmlTagMarker</a></code> 标注 <code>HTML</code> 或 <code>Head</code> 类，因为它们的超类已标注过：</p> 
 <pre><code>class HTML() : Tag("html") { …… }
class Head() : Tag("head") { …… }
</code></pre>
 <p>在添加了这个注解之后，Kotlin 编译器就知道哪些隐式接收者是同一个 DSL 的一部分，并且只允许调用最近层的接收者的成员：</p> 
 <pre><code class="lang-kotlin">html {
    head {
        head { } // 错误：外部接收者的成员
    }
    // ……
}
</code></pre> 
 <p>请注意，仍然可以调用外部接收者的成员，但是要做到这一点，你必须明确指定这个接收者：</p> 
 <pre><code class="lang-kotlin">html {
    head {
        this@html.head { } // 可能
    }
    // ……
}
</code></pre> 
 <h2 id="h2--code-com-example-html-code-"><a name="<code>com.example.html</code> 包的完整定义" class="reference-link"></a><span class="header-link octicon octicon-link"></span><code>com.example.html</code> 包的完整定义</h2>
 <p>这就是 <code>com.example.html</code> 包的定义(只有上面例子中使用的元素)。<br>它构建一个 HTML 树。代码中大量使用了<a target="_blank" href="extensions.html">扩展函数</a>和<br><a target="_blank" href="lambdas.html#带接收者的函数字面值">带接收者的 lambda 表达式</a>。</p> 
 <p>请注意，<code><a target="_blank" href="https://github.com/DslMarker" title="@DslMarker" class="at-link">@DslMarker</a></code> 注解在 Kotlin 1.1 起才可用。</p> 
 <pre><code class="lang-kotlin">package com.example.html

interface Element {
    fun render(builder: StringBuilder, indent: String)
}

class TextElement(val text: String) : Element {
    override fun render(builder: StringBuilder, indent: String) {
        builder.append("$indent$text\n")
    }
}

@DslMarker
annotation class HtmlTagMarker

@HtmlTagMarker
abstract class Tag(val name: String) : Element {
    val children = arrayListOf&lt;Element&gt;()
    val attributes = hashMapOf&lt;String, String&gt;()

    protected fun &lt;T : Element&gt; initTag(tag: T, init: T.() -&gt; Unit): T {
        tag.init()
        children.add(tag)
        return tag
    }

    override fun render(builder: StringBuilder, indent: String) {
        builder.append("$indent&lt;$name${renderAttributes()}&gt;\n")
        for (c in children) {
            c.render(builder, indent + "  ")
        }
        builder.append("$indent&lt;/$name&gt;\n")
    }

    private fun renderAttributes(): String {
        val builder = StringBuilder()
        for ((attr, value) in attributes) {
            builder.append(" $attr=\"$value\"")
        }
        return builder.toString()
    }

    override fun toString(): String {
        val builder = StringBuilder()
        render(builder, "")
        return builder.toString()
    }
}

abstract class TagWithText(name: String) : Tag(name) {
    operator fun String.unaryPlus() {
        children.add(TextElement(this))
    }
}

class HTML : TagWithText("html") {
    fun head(init: Head.() -&gt; Unit) = initTag(Head(), init)

    fun body(init: Body.() -&gt; Unit) = initTag(Body(), init)
}

class Head : TagWithText("head") {
    fun title(init: Title.() -&gt; Unit) = initTag(Title(), init)
}

class Title : TagWithText("title")

abstract class BodyTag(name: String) : TagWithText(name) {
    fun b(init: B.() -&gt; Unit) = initTag(B(), init)
    fun p(init: P.() -&gt; Unit) = initTag(P(), init)
    fun h1(init: H1.() -&gt; Unit) = initTag(H1(), init)
    fun a(href: String, init: A.() -&gt; Unit) {
        val a = initTag(A(), init)
        a.href = href
    }
}

class Body : BodyTag("body")
class B : BodyTag("b")
class P : BodyTag("p")
class H1 : BodyTag("h1")

class A : BodyTag("a") {
    var href: String
        get() = attributes["href"]!!
        set(value) {
            attributes["href"] = value
        }
}

fun html(init: HTML.() -&gt; Unit): HTML {
    val html = HTML()
    html.init()
    return html
}
</code></pre>
 <br>      
</div></body></html>