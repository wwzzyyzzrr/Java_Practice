<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Kotlin类型的检查与转换</h1><div style="width:100%;float:left;" class="article-content">   
 <h2 id="h2--code-is-code-code-is-code-"><a name="<code>is</code> 和 <code>!is</code> 操作符" class="reference-link"></a><span class="header-link octicon octicon-link"></span><code>is</code> 和 <code>!is</code> 操作符</h2>
 <p>我们可以在运行时通过使用 <code>is</code> 操作符或其否定形式 <code>!is</code> 来检查对象是否符合给定类型：</p> 
 <pre><code class="lang-kotlin">if (obj is String) {
    print(obj.length)
}

if (obj !is String) { // 与 !(obj is String) 相同
    print("Not a String")
}
else {
    print(obj.length)
}
</code></pre> 
 <h2 id="h2-u667Au80FDu8F6Cu6362"><a name="智能转换" class="reference-link"></a><span class="header-link octicon octicon-link"></span>智能转换</h2>
 <p>在许多情况下，不需要在 Kotlin 中使用显式转换操作符，因为编译器跟踪<br>不可变值的 <code>is</code>-检查，并在需要时自动插入(安全的)转换：</p> 
 <pre><code class="lang-kotlin">fun demo(x: Any) {
    if (x is String) {
        print(x.length) // x 自动转换为字符串
    }
}
</code></pre> 
 <p>编译器足够聪明，能够知道如果反向检查导致返回那么该转换是安全的：</p> 
 <pre><code class="lang-kotlin">    if (x !is String) return
    print(x.length) // x 自动转换为字符串
</code></pre> 
 <p>或者在 <code>&amp;&amp;</code> 和 <code>||</code> 的右侧：</p> 
 <pre><code class="lang-kotlin">    // `||` 右侧的 x 自动转换为字符串
    if (x !is String || x.length == 0) return

    // `&amp;&amp;` 右侧的 x 自动转换为字符串
    if (x is String &amp;&amp; x.length &gt; 0) {
        print(x.length) // x 自动转换为字符串
    }
</code></pre> 
 <p>这些 <em>智能转换</em> 用于 <a target="_blank" href="control-flow.html#when-表达式"><em>when</em>{: .keyword }-表达式</a><br>和 <a target="_blank" href="control-flow.html#while-循环"><em>while</em>{: .keyword }-循环 </a> 也一样：</p> 
 <pre><code class="lang-kotlin">when (x) {
    is Int -&gt; print(x + 1)
    is String -&gt; print(x.length + 1)
    is IntArray -&gt; print(x.sum())
}
</code></pre> 
 <p>请注意，当编译器不能保证变量在检查和使用之间不可改变时，智能转换不能用。<br>更具体地，智能转换能否适用根据以下规则：</p> 
 <ul> 
  <li><em>val</em>{: .keyword } 局部变量——总是可以；</li>
  <li><em>val</em>{: .keyword } 属性——如果属性是 private 或 internal，或者该检查在声明属性的同一模块中执行。智能转换不适用于 open 的属性或者具有自定义 getter 的属性；</li>
  <li><em>var</em>{: .keyword } 局部变量——如果变量在检查和使用之间没有修改、并且没有在会修改它的 lambda 中捕获；</li>
  <li><em>var</em>{: .keyword } 属性——决不可能(因为该变量可以随时被其他代码修改)。</li>
 </ul> 
 <h2 id="h2--"><a name="“不安全的”转换操作符" class="reference-link"></a><span class="header-link octicon octicon-link"></span>“不安全的”转换操作符</h2>
 <p>通常，如果转换是不可能的，转换操作符会抛出一个异常。因此，我们称之为<em>不安全的</em>。<br>Kotlin 中的不安全转换由中缀操作符 <em>as</em>{: .keyword }(参见<a target="_blank" href="grammar.html#precedence">operator precedence</a>)完成：</p>   
 <pre><code class="lang-kotlin">val x: String = y as String
</code></pre> 
 <p>请注意，<em>null</em>{: .keyword } 不能转换为 <code>String</code> 因该类型不是<a target="_blank" href="null-safety.html">可空的</a>，<br>即如果 <code>y</code> 为空，上面的代码会抛出一个异常。<br>为了匹配 Java 转换语义，我们必须在转换右边有可空类型，就像：</p> 
 <pre><code class="lang-kotlin">val x: String? = y as String?
</code></pre> 
 <h2 id="h2--"><a name="“安全的”(可空)转换操作符" class="reference-link"></a><span class="header-link octicon octicon-link"></span>“安全的”(可空)转换操作符</h2>
 <p>为了避免抛出异常，可以使用<em>安全</em>转换操作符 <em>as?</em>{: .keyword }，它可以在失败时返回 <em>null</em>{: .keyword }：</p> 
 <pre><code class="lang-kotlin">val x: String? = y as? String
</code></pre> 
 <p>请注意，尽管事实上 <em>as?</em>{: .keyword } 的右边是一个非空类型的 <code>String</code>，但是其转换的结果是可空的。</p>
 <br>      
</div></body></html>