<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Kotlin类型别名</h1><div style="width:100%;float:left;" class="article-content">   
 <p>类型别名为现有类型提供替代名称。<br>如果类型名称太长，你可以另外引入较短的名称，并使用新的名称替代原类型名。</p> 
 <p>它有助于缩短较长的泛型类型。<br>例如，通常缩减集合类型是很有吸引力的：</p> 
 <pre><code class="lang-kotlin">typealias NodeSet = Set&lt;Network.Node&gt;

typealias FileTable&lt;K&gt; = MutableMap&lt;K, MutableList&lt;File&gt;&gt;
</code></pre> 
 <p>你可以为函数类型提供另外的别名：</p> 
 <pre><code class="lang-kotlin">typealias MyHandler = (Int, String, Any) -&gt; Unit

typealias Predicate&lt;T&gt; = (T) -&gt; Boolean
</code></pre> 
 <p>你可以为内部类和嵌套类创建新名称：</p> 
 <pre><code class="lang-kotlin">class A {
    inner class Inner
}
class B {
    inner class Inner
}

typealias AInner = A.Inner
typealias BInner = B.Inner
</code></pre> 
 <p>类型别名不会引入新类型。<br>它们等效于相应的底层类型。<br>当你在代码中添加 <code>typealias Predicate&lt;T&gt;</code> 并使用 <code>Predicate&lt;Int&gt;</code> 时，Kotlin 编译器总是把它扩展为 <code>(Int) -&gt; Boolean</code>。<br>因此，当你需要泛型函数类型时，你可以传递该类型的变量，反之亦然：</p>   
 <pre><code class="lang-kotlin">typealias Predicate&lt;T&gt; = (T) -&gt; Boolean

fun foo(p: Predicate&lt;Int&gt;) = p(42)

fun main(args: Array&lt;String&gt;) {
    val f: (Int) -&gt; Boolean = { it &gt; 0 }
    println(foo(f)) // 输出 "true"

    val p: Predicate&lt;Int&gt; = { it &gt; 0 }
    println(listOf(1, -2).filter(p)) // 输出 "[1]"
}
</code></pre>
 <br>      
</div></body></html>