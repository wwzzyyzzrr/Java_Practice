<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Kotlin操作符符重载</h1><div style="width:100%;float:left;" class="article-content">   
 <p>Kotlin 允许我们为自己的类型提供预定义的一组操作符的实现。这些操作符具有固定的符号表示<br>(如 <code>+</code> 或 <code>*</code>)和固定的<a target="_blank" href="grammar.html#precedence">优先级</a>。为实现这样的操作符，我们为相应的类型(即二元操作符左侧的类型和一元操作符的参数类型)提供了一个固定名字的<a target="_blank" href="functions.html#成员函数">成员函数</a><br>或<a target="_blank" href="extensions.html">扩展函数</a>。<br>重载操作符的函数需要用 <code>operator</code> 修饰符标记。</p> 
 <h2 id="h2-u7EA6u5B9A"><a name="约定" class="reference-link"></a><span class="header-link octicon octicon-link"></span>约定</h2>
 <p>在这里我们描述为不同操作符规范操作符重载的约定。</p> 
 <h3 id="h3-u4E00u5143u64CDu4F5C"><a name="一元操作" class="reference-link"></a><span class="header-link octicon octicon-link"></span>一元操作</h3>
 <table> 
  <thead> 
   <tr> 
    <th>表达式</th> 
    <th>翻译为</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td><code>+a</code></td> 
    <td><code>a.unaryPlus()</code></td> 
   </tr> 
   <tr> 
    <td><code>-a</code></td> 
    <td><code>a.unaryMinus()</code></td> 
   </tr> 
   <tr> 
    <td><code>!a</code></td> 
    <td><code>a.not()</code></td> 
   </tr> 
  </tbody> 
 </table> 
 <p>这个表是说，当编译器处理例如表达式 <code>+a</code> 时，它执行以下步骤：</p> 
 <ul> 
  <li>确定 <code>a</code> 的类型，令其为 <code>T</code>。</li>
  <li>为接收者 <code>T</code> 查找一个带有 <code>operator</code> 修饰符的无参函数 <code>unaryPlus()</code>，即成员函数或扩展函数。</li>
  <li>如果函数不存在或不明确，则导致编译错误。</li>
  <li>如果函数存在且其返回类型为 <code>R</code>，那就表达式 <code>+a</code> 具有类型 <code>R</code>。</li>
 </ul> 
 <p><em>注意</em> 这些操作以及所有其他操作都针对<a target="_blank" href="basic-types.html">基本类型</a>做了优化，不会为它们引入函数调用的开销。</p> 
 <table> 
  <thead> 
   <tr> 
    <th>表达式</th> 
    <th>翻译为</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td><code>a++</code></td> 
    <td><code>a.inc()</code> + 见下文</td> 
   </tr> 
   <tr> 
    <td><code>a--</code></td> 
    <td><code>a.dec()</code> + 见下文</td> 
   </tr> 
  </tbody> 
 </table> 
 <p><code>inc()</code> 和 <code>dec()</code> 函数必须返回一个值，它用于赋值给使用<br><code>++</code> 或 <code>--</code> 操作的变量。它们不应该改变在其上调用 <code>inc()</code> 或 <code>dec()</code> 的对象。</p> 
 <p>编译器执行以下步骤来解析<em>后缀</em>形式的操作符，例如 <code>a++</code>：</p> 
 <ul> 
  <li>确定 <code>a</code> 的类型，令其为 <code>T</code>。</li>
  <li>查找一个适用于类型为 <code>T</code> 的接收者的、带有 <code>operator</code> 修饰符的无参数函数 <code>inc()</code>。</li>
  <li>检查函数的返回类型是 <code>T</code> 的子类型。</li>
 </ul> 
 <p>计算表达式的步骤是：</p> 
 <ul> 
  <li>把 <code>a</code> 的初始值存储到临时存储 <code>a0</code> 中，</li>
  <li>把 <code>a.inc()</code> 结果赋值给 <code>a</code>，</li>
  <li>把 <code>a0</code> 作为表达式的结果返回。</li>
 </ul> 
 <p>对于 <code>a--</code>，步骤是完全类似的。</p> 
 <p>对于<em>前缀</em>形式 <code>++a</code> 和 <code>--a</code> 以相同方式解析，其步骤是：</p> 
 <ul> 
  <li>把 <code>a.inc()</code> 结果赋值给 <code>a</code>，</li>
  <li>把 <code>a</code> 的新值作为表达式结果返回。</li>
 </ul> 
 <h3 id="h3-u4E8Cu5143u64CDu4F5C"><a name="二元操作" class="reference-link"></a><span class="header-link octicon octicon-link"></span>二元操作</h3>
 <table> 
  <thead> 
   <tr> 
    <th>表达式</th> 
    <th>翻译为</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td><code>a + b</code></td> 
    <td><code>a.plus(b)</code></td> 
   </tr> 
   <tr> 
    <td><code>a - b</code></td> 
    <td><code>a.minus(b)</code></td> 
   </tr> 
   <tr> 
    <td><code>a * b</code></td> 
    <td><code>a.times(b)</code></td> 
   </tr> 
   <tr> 
    <td><code>a / b</code></td> 
    <td><code>a.div(b)</code></td> 
   </tr> 
   <tr> 
    <td><code>a % b</code></td> 
    <td><code>a.rem(b)</code>、 <code>a.mod(b)</code> (已弃用)</td> 
   </tr> 
   <tr> 
    <td><code>a..b</code></td> 
    <td><code>a.rangeTo(b)</code></td> 
   </tr> 
  </tbody> 
 </table> 
 <p>对于此表中的操作，编译器只是解析成<em>翻译为</em>列中的表达式。</p> 
 <p>请注意，自 Kotlin 1.1 起支持 <code>rem</code> 运算符。Kotlin 1.0 使用 <code>mod</code> 运算符，它在<br>Kotlin 1.1 中被弃用。</p> 
 <table> 
  <thead> 
   <tr> 
    <th>表达式</th> 
    <th>翻译为</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td><code>a in b</code></td> 
    <td><code>b.contains(a)</code></td> 
   </tr> 
   <tr> 
    <td><code>a !in b</code></td> 
    <td><code>!b.contains(a)</code></td> 
   </tr> 
  </tbody> 
 </table> 
 <p>对于 <code>in</code> 和 <code>!in</code>，过程是相同的，但是参数的顺序是相反的。<br>{:#in}</p> 
 <table> 
  <thead> 
   <tr> 
    <th>表达式</th> 
    <th>翻译为</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td><code>a[i]</code></td> 
    <td><code>a.get(i)</code></td> 
   </tr> 
   <tr> 
    <td><code>a[i, j]</code></td> 
    <td><code>a.get(i, j)</code></td> 
   </tr> 
   <tr> 
    <td><code>a[i_1, ……, i_n]</code></td> 
    <td><code>a.get(i_1, ……, i_n)</code></td> 
   </tr> 
   <tr> 
    <td><code>a[i] = b</code></td> 
    <td><code>a.set(i, b)</code></td> 
   </tr> 
   <tr> 
    <td><code>a[i, j] = b</code></td> 
    <td><code>a.set(i, j, b)</code></td> 
   </tr> 
   <tr> 
    <td><code>a[i_1, ……, i_n] = b</code></td> 
    <td><code>a.set(i_1, ……, i_n, b)</code></td> 
   </tr> 
  </tbody> 
 </table> 
 <p>方括号转换为调用带有适当数量参数的 <code>get</code> 和 <code>set</code>。</p> 
 <table> 
  <thead> 
   <tr> 
    <th>表达式</th> 
    <th>翻译为</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td><code>a()</code></td> 
    <td><code>a.invoke()</code></td> 
   </tr> 
   <tr> 
    <td><code>a(i)</code></td> 
    <td><code>a.invoke(i)</code></td> 
   </tr> 
   <tr> 
    <td><code>a(i, j)</code></td> 
    <td><code>a.invoke(i, j)</code></td> 
   </tr> 
   <tr> 
    <td><code>a(i_1, ……, i_n)</code></td> 
    <td><code>a.invoke(i_1, ……, i_n)</code></td> 
   </tr> 
  </tbody> 
 </table> 
 <p>圆括号转换为调用带有适当数量参数的 <code>invoke</code>。</p> 
 <table> 
  <thead> 
   <tr> 
    <th>表达式</th> 
    <th>翻译为</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td><code>a += b</code></td> 
    <td><code>a.plusAssign(b)</code></td> 
   </tr> 
   <tr> 
    <td><code>a -= b</code></td> 
    <td><code>a.minusAssign(b)</code></td> 
   </tr> 
   <tr> 
    <td><code>a *= b</code></td> 
    <td><code>a.timesAssign(b)</code></td> 
   </tr> 
   <tr> 
    <td><code>a /= b</code></td> 
    <td><code>a.divAssign(b)</code></td> 
   </tr> 
   <tr> 
    <td><code>a %= b</code></td> 
    <td><code>a.modAssign(b)</code></td> 
   </tr> 
  </tbody> 
 </table> 
 <p>{:#assignments}</p> 
 <p>对于赋值操作，例如 <code>a += b</code>，编译器执行以下步骤：</p> 
 <ul> 
  <li>如果右列的函数可用
   <ul> 
    <li>如果相应的二元函数(即 <code>plusAssign()</code> 对应于 <code>plus()</code>)也可用，那么报告错误(模糊)。</li>
    <li>确保其返回类型是 <code>Unit</code>，否则报告错误。</li>
    <li>生成 <code>a.plusAssign(b)</code> 的代码</li>
   </ul> </li>
  <li>否则试着生成 <code>a = a + b</code> 的代码(这里包含类型检查：<code>a + b</code> 的类型必须是 <code>a</code> 的子类型)。</li>
 </ul> 
 <p><em>注意</em>：赋值在 Kotlin 中<em>不是</em>表达式。<br>{:#Equals}</p> 
 <table> 
  <thead> 
   <tr> 
    <th>表达式</th> 
    <th>翻译为</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td><code>a == b</code></td> 
    <td><code>a?.equals(b) ?: (b === null)</code></td> 
   </tr> 
   <tr> 
    <td><code>a != b</code></td> 
    <td><code>!(a?.equals(b) ?: (b === null))</code></td> 
   </tr> 
  </tbody> 
 </table> 
 <p><em>注意</em>：<code>===</code> 和 <code>!==</code>(同一性检查)不可重载，因此不存在对他们的约定</p> 
 <p>这个 <code>==</code> 操作符有些特殊：它被翻译成一个复杂的表达式，用于筛选 <code>null</code> 值。<br><code>null == null</code> 总是 true，对于非空的 <code>x</code>，<code>x == null</code> 总是 false 而不会调用 <code>x.equals()</code>。</p> 
 <table> 
  <thead> 
   <tr> 
    <th>表达式</th> 
    <th>翻译为</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td><code>a &gt; b</code></td> 
    <td><code>a.compareTo(b) &gt; 0</code></td> 
   </tr> 
   <tr> 
    <td><code>a &lt; b</code></td> 
    <td><code>a.compareTo(b) &lt; 0</code></td> 
   </tr> 
   <tr> 
    <td><code>a &gt;= b</code></td> 
    <td><code>a.compareTo(b) &gt;= 0</code></td> 
   </tr> 
   <tr> 
    <td><code>a &lt;= b</code></td> 
    <td><code>a.compareTo(b) &lt;= 0</code></td> 
   </tr> 
  </tbody> 
 </table> 
 <p>所有的比较都转换为对 <code>compareTo</code> 的调用，这个函数需要返回 <code>Int</code> 值</p> 
 <h2 id="h2-u547Du540Du51FDu6570u7684u4E2Du7F00u8C03u7528"><a name="命名函数的中缀调用" class="reference-link"></a><span class="header-link octicon octicon-link"></span>命名函数的中缀调用</h2>  
 <p>我们可以通过<a target="_blank" href="functions.html#中缀表示法">中缀函数的调用</a> 来模拟自定义中缀操作符。</p>
 <br>      
</div></body></html>