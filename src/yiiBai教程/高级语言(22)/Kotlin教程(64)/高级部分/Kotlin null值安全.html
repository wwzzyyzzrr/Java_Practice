<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Kotlin null值安全</h1><div style="width:100%;float:left;" class="article-content">   
 <h2 id="h2-u53EFu7A7Au7C7Bu578Bu4E0Eu975Eu7A7Au7C7Bu578B"><a name="可空类型与非空类型" class="reference-link"></a><span class="header-link octicon octicon-link"></span>可空类型与非空类型</h2>
 <p>Kotlin 的类型系统旨在消除来自代码空引用的危险，也称为<a target="_blank" href="http://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions">《十亿美元的错误》</a>。</p> 
 <p>许多编程语言(包括 Java)中最常见的陷阱之一是访问空引用的成员，导致空引用异常。在 Java 中，<br>这等同于 <code>NullPointerException</code> 或简称 <code>NPE</code>。</p> 
 <p>Kotlin 的类型系统旨在从我们的代码中消除 <code>NullPointerException</code>。NPE 的唯一可能的原因可能是</p> 
 <ul> 
  <li>显式调用 <code>throw NullPointerException()</code></li>
  <li>使用了下文描述的 <code>!!</code> 操作符</li>
  <li>外部 Java 代码导致的</li>
  <li>对于初始化，有一些数据不一致(如一个未初始化的 <code>this</code> 用于构造函数的某个地方)</li>
 </ul> 
 <p>在 Kotlin 中，类型系统区分一个引用可以容纳 <em>null</em>{: .keyword } (可空引用)还是不能容纳(非空引用)。<br>例如，String 类型的常规变量不能容纳 <em>null</em>{: .keyword }：</p> 
 <pre><code class="lang-kotlin">var a: String = "abc"
a = null // 编译错误
</code></pre> 
 <p>如果要允许为空，我们可以声明一个变量为可空字符串，写作 <code>String?</code>：</p> 
 <pre><code class="lang-kotlin">var b: String? = "abc"
b = null // ok
</code></pre> 
 <p>现在，如果你调用 <code>a</code> 的方法或者访问它的属性，它保证不会导致 <code>NPE</code>，这样你就可以放心地使用：</p> 
 <pre><code class="lang-kotlin">val l = a.length
</code></pre> 
 <p>但是如果你想访问 <code>b</code> 的同一个属性，那么这是不安全的，并且编译器会报告一个错误：</p> 
 <pre><code class="lang-kotlin">val l = b.length // 错误：变量“b”可能为空
</code></pre> 
 <p>但是我们还是需要访问该属性，对吧？有几种方式可以做到。</p> 
 <h2 id="h2--em-null-em-keyword-"><a name="在条件中检查 <em>null</em>{: .keyword }" class="reference-link"></a><span class="header-link octicon octicon-link"></span>在条件中检查 <em>null</em>{: .keyword }</h2>
 <p>首先，你可以显式检查 <code>b</code> 是否为 <em>null</em>{: .keyword }，并分别处理两种可能：</p> 
 <pre><code class="lang-kotlin">val l = if (b != null) b.length else -1
</code></pre> 
 <p>编译器会跟踪所执行检查的信息，并允许你在 <em>if</em>{: .keyword } 内部调用 <code>length</code>。<br>同时，也支持更复杂(更智能)的条件：</p> 
 <pre><code class="lang-kotlin">if (b != null &amp;&amp; b.length &gt; 0) {
    print("String of length ${b.length}")
} else {
    print("Empty string")
}
</code></pre> 
 <p>请注意，这只适用于 <code>b</code> 是不可变的情况(即在检查和使用之间没有修改过的局部变量<br>，或者不可覆盖并且有幕后字段的 <em>val</em>{: .keyword } 成员)，因为否则可能会发生<br>在检查之后 <code>b</code> 又变为 <em>null</em>{: .keyword } 的情况。</p> 
 <h2 id="h2-u5B89u5168u7684u8C03u7528"><a name="安全的调用" class="reference-link"></a><span class="header-link octicon octicon-link"></span>安全的调用</h2>
 <p>你的第二个选择是安全调用操作符，写作 <code>?.</code>：</p> 
 <pre><code class="lang-kotlin">b?.length
</code></pre> 
 <p>如果 <code>b</code> 非空，就返回 <code>b.length</code>，否则返回 <em>null</em>{: .keyword }，这个表达式的类型是 <code>Int?</code>。</p> 
 <p>安全调用在链式调用中很有用。例如，如果一个员工 Bob 可能会(或者不会)分配给一个部门，<br>并且可能有另外一个员工是该部门的负责人，那么获取 Bob 所在部门负责人(如果有的话)的名字，我们写作：</p> 
 <pre><code class="lang-kotlin">bob?.department?.head?.name
</code></pre> 
 <p>如果任意一个属性(环节)为空，这个链式调用就会返回 <em>null</em>{: .keyword }。</p> 
 <p>如果要只对非空值执行某个操作，安全调用操作符可以与 <a target="_blank" href="http://kotlinlang.org/api/latest/jvm/stdlib/kotlin/let.html"><code>let</code></a> 一起使用：</p> 
 <pre><code class="lang-kotlin">val listWithNulls: List&lt;String?&gt; = listOf("A", null)
for (item in listWithNulls) {
     item?.let { println(it) } // 输出 A 并忽略 null
}
</code></pre> 
 <h2 id="h2-elvis-"><a name="Elvis 操作符" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Elvis 操作符</h2>
 <p>当我们有一个可空的引用 <code>r</code> 时，我们可以说“如果 <code>r</code> 非空，我使用它；否则使用某个非空的值 <code>x</code>”：</p>   
 <pre><code class="lang-kotlin">val l: Int = if (b != null) b.length else -1
</code></pre> 
 <p>除了完整的 <em>if</em>{: .keyword }-表达式，这还可以通过 Elvis 操作符表达，写作 <code>?:</code>：</p> 
 <pre><code class="lang-kotlin">val l = b?.length ?: -1
</code></pre> 
 <p>如果 <code>?:</code> 左侧表达式非空，elvis 操作符就返回其左侧表达式，否则返回右侧表达式。<br>请注意，当且仅当左侧为空时，才会对右侧表达式求值。</p> 
 <p>请注意，因为 <em>throw</em>{: .keyword } 和 <em>return</em>{: .keyword } 在 Kotlin 中都是表达式，所以它们也可以用在<br> elvis 操作符右侧。这可能会非常方便，例如，检查函数参数：</p> 
 <pre><code class="lang-kotlin">fun foo(node: Node): String? {
    val parent = node.getParent() ?: return null
    val name = node.getName() ?: throw IllegalArgumentException("name expected")
    // ……
}
</code></pre> 
 <h2 id="h2--code-code-"><a name="<code>!!</code> 操作符" class="reference-link"></a><span class="header-link octicon octicon-link"></span><code>!!</code> 操作符</h2>
 <p>第三种选择是为 NPE 爱好者准备的。我们可以写 <code>b!!</code> ，这会返回一个非空的 <code>b</code> 值<br>(例如：在我们例子中的 <code>String</code>)或者如果 <code>b</code> 为空，就会抛出一个 <code>NPE</code> 异常：</p> 
 <pre><code class="lang-kotlin">val l = b!!.length
</code></pre> 
 <p>因此，如果你想要一个 NPE，你可以得到它，但是你必须显式要求它，否则它不会不期而至。</p> 
 <h2 id="h2-u5B89u5168u7684u7C7Bu578Bu8F6Cu6362"><a name="安全的类型转换" class="reference-link"></a><span class="header-link octicon octicon-link"></span>安全的类型转换</h2>
 <p>如果对象不是目标类型，那么常规类型转换可能会导致 <code>ClassCastException</code>。<br>另一个选择是使用安全的类型转换，如果尝试转换不成功则返回 <em>null</em>{: .keyword }：</p> 
 <pre><code class="lang-kotlin">val aInt: Int? = a as? Int
</code></pre> 
 <h2 id="h2-u53EFu7A7Au7C7Bu578Bu7684u96C6u5408"><a name="可空类型的集合" class="reference-link"></a><span class="header-link octicon octicon-link"></span>可空类型的集合</h2>
 <p>如果你有一个可空类型元素的集合，并且想要过滤非空元素，你可以使用 <code>filterNotNull</code> 来实现。</p> 
 <pre><code class="lang-kotlin">val nullableList: List&lt;Int?&gt; = listOf(1, 2, null, 4)
val intList: List&lt;Int&gt; = nullableList.filterNotNull()
</code></pre>
 <br>      
</div></body></html>