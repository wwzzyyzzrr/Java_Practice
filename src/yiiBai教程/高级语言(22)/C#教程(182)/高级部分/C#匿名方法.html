<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">C#匿名方法</h1><div style="width:100%;float:left;" class="article-content">   
 <p>前面我们学习过，委托可用于引用任何与委托签名相同的方法。换句话说，可以调用可以由委托使用该委托对象引用的方法。</p> 
 <p>匿名方法提供了一种将代码块作为委托参数传递的技术。匿名方法是没有名称的方法，只有方法体。</p> 
 <p>不需要在匿名方法中指定返回类型; 它是从方法体中的<code>return</code>语句来推断的。</p> 
 <h2 id="h2-u7F16u5199u533Fu540Du65B9u6CD5"><a name="编写匿名方法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>编写匿名方法</h2>
 <p>使用<code>delegate</code>关键字创建代理实例时，就可以声明匿名方法。 例如，</p> 
 <pre><code class="lang-csharp">delegate void NumberChanger(int n);
...
NumberChanger nc = delegate(int x)
{
   Console.WriteLine("Anonymous Method: {0}", x);
};
</code></pre> 
 <p>代码块<code>Console.WriteLine("Anonymous Method: {0}", x);</code>是匿名方法体。</p> 
 <p>代理可以使用匿名方法和命名方法以相同的方式调用，即通过将方法参数传递给委托对象。</p> 
 <p>例如，</p> 
 <pre><code class="lang-csharp">nc(10);
</code></pre> 
 <h2 id="h2-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h2>
 <p>以下示例演示如何实现概念：</p> 
 <pre><code class="lang-csharp">using System;

delegate void NumberChanger(int n);
namespace DelegateAppl
{
   class TestDelegate
   {
      static int num = 10;
      public static void AddNum(int p)
      {
         num += p;
         Console.WriteLine("Named Method: {0}", num);
      }

      public static void MultNum(int q)
      {
         num *= q;
         Console.WriteLine("Named Method: {0}", num);
      }

      public static int getNum()
      {
         return num;
      }
      static void Main(string[] args)
      {
         //create delegate instances using anonymous method
         NumberChanger nc = delegate(int x)
         {
            Console.WriteLine("Anonymous Method: {0}", x);
         };

         //calling the delegate using the anonymous method 
         nc(10);

         //instantiating the delegate using the named methods 
         nc =  new NumberChanger(AddNum);

         //calling the delegate using the named methods 
         nc(5);

         //instantiating the delegate using another named methods 
         nc =  new NumberChanger(MultNum);

         //calling the delegate using the named methods 
         nc(2);
         Console.ReadKey();
      }
   }
}
</code></pre> 
 <p>当上述代码被编译并执行时，它产生以下结果：</p>   
 <pre><code class="lang-shell">Anonymous Method: 10
Named Method: 15
Named Method: 30
</code></pre>
 <br>      
</div></body></html>