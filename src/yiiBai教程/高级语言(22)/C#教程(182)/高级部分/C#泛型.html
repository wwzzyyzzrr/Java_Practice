<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">C#泛型</h1><div style="width:100%;float:left;" class="article-content">   
 <p>泛型允许延迟编程元素的类或方法的数据类型的规范，直到它在程序中实际使用时确定。 换句话说，泛型允许编写一个可以使用任何数据类型的类或方法。</p> 
 <p>为类或方法编写规范，使用数据类型的替代参数。当编译器遇到类的构造函数或方法的函数调用时，它会生成代码来处理特定的数据类型。看看下面一个简单的例子将有助于理解这个概念：</p> 
 <pre><code class="lang-csharp">using System;
using System.Collections.Generic;

namespace GenericApplication
{
    public class MyGenericArray&lt;T&gt;
    {
        private T[] array;
        public MyGenericArray(int size)
        {
            array = new T[size + 1];
        }

        public T getItem(int index)
        {
            return array[index];
        }

        public void setItem(int index, T value)
        {
            array[index] = value;
        }
    }

    class Tester
    {
        static void Main(string[] args)
        {

            //declaring an int array
            MyGenericArray&lt;int&gt; intArray = new MyGenericArray&lt;int&gt;(5);

            //setting values
            for (int i = 0; i &lt; 5; i++)
            {
                intArray.setItem(i, i * 10);
            }

            //retrieving the values
            for (int i = 0; i &lt; 5; i++)
            {
                Console.Write(intArray.getItem(i) + " ");
            }

            Console.WriteLine();

            //declaring a character array
            MyGenericArray&lt;char&gt; charArray = new MyGenericArray&lt;char&gt;(5);

            //setting values
            for (int i = 0; i &lt; 5; i++)
            {
                charArray.setItem(i, (char)(i + 97));
            }

            //retrieving the values
            for (int c = 0; c &lt; 5; c++)
            {
                Console.Write(charArray.getItem(c) + " ");
            }
            Console.WriteLine();

            Console.ReadKey();
        }
    }
}
</code></pre> 
 <p>当上述代码被编译并执行时，它产生以下结果：</p> 
 <pre><code class="lang-shell">0 10 20 30 40
a b c d e
</code></pre> 
 <h2 id="h2-u6CDBu578Bu7279u5F81"><a name="泛型特征" class="reference-link"></a><span class="header-link octicon octicon-link"></span>泛型特征</h2>
 <p>泛型是一种通过以下方式丰富程序的技术：</p> 
 <ul> 
  <li>它可以帮助开发者最大限度地实现代码重用，类型安全和性能。</li>
  <li>创建通用集合类。 <code>.NET Framework</code>类库在<code>System.Collections.Generic</code>命名空间中包含几个新的通用集合类。开发者使用这些通用集合类，而不是<code>System.Collections</code>命名空间中的集合类。</li>
  <li>创建自己的通用接口，类，方法，事件和委托。</li>
  <li>可以创建限制为允许访问特定数据类型的方法的泛型类。</li>
  <li>通过反射获取关于通用数据类型在运行时使用的类型的信息。</li>
 </ul> 
 <h2 id="h2-u6CDBu578Bu65B9u6CD5"><a name="泛型方法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>泛型方法</h2>
 <p>在前面的例子中，使用了一个泛型类; 可以声明一个类型参数的泛型方法。以下程序说明了以下概念：</p> 
 <pre><code class="lang-csharp">using System;
using System.Collections.Generic;

namespace GenericMethodAppl
{
    class Program
    {
        static void Swap&lt;T&gt;(ref T lhs, ref T rhs)
        {
            T temp;
            temp = lhs;
            lhs = rhs;
            rhs = temp;
        }
        static void Main(string[] args)
        {
            int a, b;
            char c, d;
            a = 100;
            b = 201;
            c = 'Y';
            d = 'B';

            //display values before swap:
            Console.WriteLine("Int values before calling swap:");
            Console.WriteLine("a = {0}, b = {1}", a, b);
            Console.WriteLine("Char values before calling swap:");
            Console.WriteLine("c = {0}, d = {1}", c, d);

            //call swap
            Swap&lt;int&gt;(ref a, ref b);
            Swap&lt;char&gt;(ref c, ref d);

            //display values after swap:
            Console.WriteLine("Int values after calling swap:");
            Console.WriteLine("a = {0}, b = {1}", a, b);
            Console.WriteLine("Char values after calling swap:");
            Console.WriteLine("c = {0}, d = {1}", c, d);

            Console.ReadKey();
        }
    }
}
</code></pre> 
 <p>当上述代码被编译并执行时，它产生以下结果：</p>   
 <pre><code class="lang-csharp">Int values before calling swap:
a = 100, b = 201
Char values before calling swap:
c = Y, d = B
Int values after calling swap:
a = 201, b = 100
Char values after calling swap:
c = B, d = Y
</code></pre> 
 <h2 id="h2-u6CDBu578Bu59D4u6258"><a name="泛型委托" class="reference-link"></a><span class="header-link octicon octicon-link"></span>泛型委托</h2>
 <p>可以使用类型参数定义一个泛型委托。 例如：</p> 
 <pre><code class="lang-csharp">delegate T NumberChanger&lt;T&gt;(T n);
</code></pre> 
 <p>以下示例显示了如何使用此委托：</p> 
 <pre><code class="lang-csharp">using System;
using System.Collections.Generic;

delegate T NumberChanger&lt;T&gt;(T n);
namespace GenericDelegateAppl
{
    class TestDelegate
    {
        static int num = 101;
        public static int AddNum(int p)
        {
            num += p;
            return num;
        }

        public static int MultNum(int q)
        {
            num *= q;
            return num;
        }
        public static int getNum()
        {
            return num;
        }

        static void Main(string[] args)
        {
            //create delegate instances
            NumberChanger&lt;int&gt; nc1 = new NumberChanger&lt;int&gt;(AddNum);
            NumberChanger&lt;int&gt; nc2 = new NumberChanger&lt;int&gt;(MultNum);

            //calling the methods using the delegate objects
            nc1(25);
            Console.WriteLine("Value of Num: {0}", getNum());
            nc2(5);
            Console.WriteLine("Value of Num: {0}", getNum());
            Console.ReadKey();
        }
    }
}
</code></pre> 
 <pre><code class="lang-shell">Value of Num: 126
Value of Num: 630
</code></pre>
 <br>      
</div></body></html>