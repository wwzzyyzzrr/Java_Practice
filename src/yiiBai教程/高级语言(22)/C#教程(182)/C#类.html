<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">C#类</h1><div style="width:100%;float:left;" class="article-content">   
 <p>类是对象的蓝图或模板，可以定义类来表示某种数据类型。这实际上并不定义任何数据，但它确实定义了类名称的含义。也就是说，该类的对象由哪个对象组成，哪些对象可以执行什么操作。 对象是类的实例。 构成类的方法和变量称为类的成员。</p> 
 <h2 id="h2-u5B9Au4E49u4E00u4E2Au7C7B"><a name="定义一个类" class="reference-link"></a><span class="header-link octicon octicon-link"></span>定义一个类</h2>
 <p>类定义从<code>class</code>关键字开始，后跟类名称; 和由一对花括号括在一起表示类的主体。 以下是类定义的一般形式：</p> 
 <pre><code class="lang-csharp">&lt;access specifier&gt; class  class_name
{
   // member variables
   &lt;access specifier&gt; &lt;data type&gt; variable1;
   &lt;access specifier&gt; &lt;data type&gt; variable2;
   ...
   &lt;access specifier&gt; &lt;data type&gt; variableN;
   // member methods
   &lt;access specifier&gt; &lt;return type&gt; method1(parameter_list)
   {
      // method1 body
   }
   &lt;access specifier&gt; &lt;return type&gt; method2(parameter_list)
   {
      // method2 body
   }
   ...
   &lt;access specifier&gt; &lt;return type&gt; methodN(parameter_list)
   {
      // method3 body
   }
}
</code></pre> 
 <p><strong>注意：</strong></p> 
 <ul> 
  <li>访问说明符(<em>access specifier</em>)指定成员以及类本身的访问规则。如果没有指定，则类的默认访问说明符是<code>internal</code>。成员的默认访问权限是<code>private</code>。</li>
  <li>数据类型(<em>data type</em>)指定变量的类型，返回类型(<em>return type</em>)指定方法返回的数据的数据类型(如果有)。</li>
  <li>要访问类成员，请使用点(<code>.</code>)运算符。</li>
  <li>点(<code>.</code>)运算符将对象的名称与成员的名称相链接。</li>
 </ul> 
 <p>以下示例说明了上面所讨论的概念：</p> 
 <pre><code class="lang-csharp">using System;
namespace BoxApplication
{
    class Box
    {
       public double length;   // Length of a box
       public double breadth;  // Breadth of a box
       public double height;   // Height of a box
    }
    class Boxtester
    {
        static void Main(string[] args)
        {
            Box Box1 = new Box();   // Declare Box1 of type Box
            Box Box2 = new Box();   // Declare Box2 of type Box
            double volume = 0.0;    // Store the volume of a box here

            // box 1 specification
            Box1.height = 5.0;
            Box1.length = 6.0;
            Box1.breadth = 7.0;

            // box 2 specification
            Box2.height = 10.0;
            Box2.length = 12.0;
            Box2.breadth = 13.0;

            // volume of box 1
            volume = Box1.height * Box1.length * Box1.breadth;
            Console.WriteLine("Volume of Box1 : {0}",  volume);

            // volume of box 2
            volume = Box2.height * Box2.length * Box2.breadth;
            Console.WriteLine("Volume of Box2 : {0}", volume);
            Console.ReadKey();
        }
    }
}
</code></pre> 
 <p>当编译和执行上述代码时，会产生以下结果：</p> 
 <pre><code class="lang-shell">Volume of Box1 : 210
Volume of Box2 : 1560
</code></pre> 
 <h2 id="h2-u6210u5458u51FDu6570u548Cu5C01u88C5"><a name="成员函数和封装" class="reference-link"></a><span class="header-link octicon octicon-link"></span>成员函数和封装</h2>
 <p>类的成员函数是在类中定义具有与其他变量类似的定义或其原型的函数。它对其所属类的任何对象进行操作，并且可以访问该对象的类的所有成员。</p> 
 <p>成员变量是对象的属性(从设计的角度)，它们被保留为私有(<code>private</code>)以实现封装。这些变量只能使用公共成员函数来访问。</p> 
 <p>为了理解上面的概念，我们从一个类中设置并读取另外一个类的成员的值：</p> 
 <pre><code class="lang-csharp">using System;
namespace BoxApplication
{
   class Box
   {
      private double length;   // Length of a box
      private double breadth;  // Breadth of a box
      private double height;   // Height of a box
      public void setLength( double len )
      {
         length = len;
      }

      public void setBreadth( double bre )
      {
         breadth = bre;
      }

      public void setHeight( double hei )
      {
         height = hei;
      }
      public double getVolume()
      {
         return length * breadth * height;
      }
   }
   class Boxtester
   {
      static void Main(string[] args)
      {
         Box Box1 = new Box();   // Declare Box1 of type Box
         Box Box2 = new Box();
         double volume;

         // Declare Box2 of type Box
         // box 1 specification
         Box1.setLength(6.0);
         Box1.setBreadth(7.0);
         Box1.setHeight(5.0);

         // box 2 specification
         Box2.setLength(12.0);
         Box2.setBreadth(13.0);
         Box2.setHeight(10.0);

         // volume of box 1
         volume = Box1.getVolume();
         Console.WriteLine("Volume of Box1 : {0}" ,volume);

         // volume of box 2
         volume = Box2.getVolume();
         Console.WriteLine("Volume of Box2 : {0}", volume);

         Console.ReadKey();
      }
   }
}
</code></pre> 
 <p>当编译和执行上述代码时，会产生以下结果：</p> 
 <pre><code class="lang-shell">Volume of Box1 : 210
Volume of Box2 : 1560
</code></pre> 
 <h2 id="h2-c-"><a name="C# 构造函数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>C# 构造函数</h2>
 <p>类构造函数是当创建该类的新对象时执行的一个类的特殊成员函数。</p> 
 <p>构造函数具有与类完全相同的名称，它没有任何返回值。下面的例子解释了构造函数的概念：</p> 
 <pre><code class="lang-csharp">using System;
namespace LineApplication
{
   class Line
   {
      private double length;   // Length of a line
      public Line()
      {
         Console.WriteLine("Object is being created");
      }

      public void setLength( double len )
      {
         length = len;
      }

      public double getLength()
      {
         return length;
      }

      static void Main(string[] args)
      {
         Line line = new Line();    

         // set line length
         line.setLength(6.0);
         Console.WriteLine("Length of line : {0}", line.getLength());
         Console.ReadKey();
      }
   }
}
</code></pre> 
 <p>当编译和执行上述代码时，会产生以下结果：</p> 
 <pre><code class="lang-shell">Object is being created
Length of line : 6
</code></pre> 
 <p>默认构造函数没有任何参数，但是如果需要，构造函数可以有参数。这样的构造函数被称为参数化构造函数。此技术可用在创建时为对象分配初始值，如以下示例所示：</p> 
 <pre><code class="lang-csharp">using System;
namespace LineApplication
{
   class Line
   {
      private double length;   // Length of a line
      public Line(double len)  //Parameterized constructor
      {
         Console.WriteLine("Object is being created, length = {0}", len);
         length = len;
      }

      public void setLength( double len )
      {
         length = len;
      }
      public double getLength()
      {
         return length;
      }

      static void Main(string[] args)
      {
         Line line = new Line(100.0);
         Console.WriteLine("Length of line : {0}", line.getLength()); 

         // set line length
         line.setLength(60.0);
         Console.WriteLine("Length of line : {0}", line.getLength()); 
         Console.ReadKey();
      }
   }
}
</code></pre> 
 <p>当编译和执行上述代码时，会产生以下结果：</p>   
 <pre><code class="lang-shell">Object is being created, length = 100
Length of line : 100
Length of line : 60
</code></pre> 
 <h2 id="h2-c-"><a name="C# 析构函数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>C# 析构函数</h2>
 <p>析构函数是一个类的特殊成员函数，只要其类的对象超出范围就执行。析构函数使用具有前缀波形符(<code>~</code>)和类名称来表示，并且它不能拥有返回值，也不能使用任何参数。</p> 
 <p>析构函数在退出程序之前释放内存资源非常有用。 析构函数不能被继承或重载。</p> 
 <p>以下示例解释析构函数的用法，参考代码：</p> 
 <pre><code class="lang-csharp">using System;
namespace LineApplication
{
   class Line
   {
      private double length;   // Length of a line
      public Line()  // constructor
      {
         Console.WriteLine("Object is being created");
      }
      ~Line() //destructor
      {
         Console.WriteLine("Object is being deleted");
      }

      public void setLength( double len )
      {
         length = len;
      }

      public double getLength()
      {
         return length;
      }

      static void Main(string[] args)
      {
         Line line = new Line();

         // set line length
         line.setLength(126.0);
         Console.WriteLine("Length of line : {0}", line.getLength());           
      }
   }
}
</code></pre> 
 <p>当编译和执行上述代码时，会产生以下结果：</p> 
 <pre><code class="lang-shell">Object is being created
Length of line : 126
Object is being deleted
</code></pre> 
 <h2 id="h2-c-"><a name="C# 类静态成员" class="reference-link"></a><span class="header-link octicon octicon-link"></span>C# 类静态成员</h2>
 <p>我们可以使用<code>static</code>关键字将类成员定义为静态(<code>static</code>)。 当将一个类的成员声明为静态时，则无论创建了多少个类的对象，静态成员只有一个副本。</p> 
 <p>在一个类使用关键字<code>static</code>来修辞成员，则表示实例只有一个成员存在。静态变量用于定义常量，因为它们的值可以通过调用该类而不创建它的实例来引用。 静态变量可以在成员函数或类定义之外初始化。还可以在类定义内初始化静态变量。</p> 
 <p>以下示例演示了如何使用静态变量：</p> 
 <pre><code class="lang-csharp">using System;
namespace StaticVarApplication
{
   class StaticVar
   {
      public static int num;
      public void count()
      {
         num++;
      }
      public int getNum()
      {
         return num;
      }
   }
   class StaticTester
   {
      static void Main(string[] args)
      {
         StaticVar s1 = new StaticVar();
         StaticVar s2 = new StaticVar();
         s1.count();
         s1.count();
         s1.count();
         s2.count();
         Console.WriteLine("Variable num for s1: {0}", s1.getNum());
         Console.WriteLine("Variable num for s2: {0}", s2.getNum());
         Console.ReadKey();
      }
   }
}
</code></pre> 
 <p>当编译和执行上述代码时，会产生以下结果：</p> 
 <pre><code class="lang-shell">Variable num for s1: 4
Variable num for s2: 4
</code></pre> 
 <p>您也可以将成员函数声明为静态。这些函数只能访问静态变量。静态函数即使在创建对象之前也存在。以下示例演示了如何使用静态函数：</p> 
 <pre><code class="lang-csharp">using System;
namespace StaticVarApplication
{
   class StaticVar
   {
      public static int num;
      public void count()
      {
         num++;
      }
      public static int getNum()
      {
         return num;
      }
   }
   class StaticTester
   {
      static void Main(string[] args)
      {
         StaticVar s = new StaticVar();
         s.count();
         s.count();
         s.count();
         Console.WriteLine("Variable num: {0}", StaticVar.getNum());
         Console.ReadKey();
      }
   }
}
</code></pre> 
 <p>当编译和执行上述代码时，会产生以下结果：</p> 
 <pre><code class="lang-shell">Variable num: 3
</code></pre>
 <br>      
</div></body></html>