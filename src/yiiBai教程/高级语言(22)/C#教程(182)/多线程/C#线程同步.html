<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">C#线程同步</h1><div style="width:100%;float:left;" class="article-content">   
 <p>同步是一种只允许一个线程在特定时间访问某些资源的技术。没有其他线程可以中断，直到所分配的线程或当前访问线程访问数据完成其任务。</p> 
 <p>在多线程程序中，允许线程访问任何资源所需的执行时间。线程共享资源并异步执行。 访问共享资源(数据)是有时可能会暂停系统的关键任务。所以可以通过线程同步来处理它。</p> 
 <p>主要场景如：存款，取款等交易业务处理。</p> 
 <h2 id="h2-u7EBFu7A0Bu540Cu6B65u7684u4F18u70B9"><a name="线程同步的优点" class="reference-link"></a><span class="header-link octicon octicon-link"></span>线程同步的优点</h2>
 <ul> 
  <li>一致性维护</li>
  <li>无线程干扰</li>
 </ul> 
 <h2 id="h2-c-"><a name="C#锁定" class="reference-link"></a><span class="header-link octicon octicon-link"></span>C#锁定</h2>
 <p>使用 C# <code>lock</code>关键字同步执行程序。它用于为当前线程锁定，执行任务，然后释放锁定。它确保其他线程在执行完成之前不会中断执行。</p> 
 <p>下面，创建两个非同步和同步的例子。</p> 
 <h2 id="h2-c-"><a name="C# 示例：非同步" class="reference-link"></a><span class="header-link octicon octicon-link"></span>C# 示例：非同步</h2>
 <p>在这个例子中，我们不使用锁。此示例异步执行。换句话说，线程之间存在上下文切换。</p> 
 <pre><code class="lang-csharp">using System;
using System.Threading;
class Printer
{
    public void PrintTable()
    {
        for (int i = 1; i &lt;= 5; i++)
        {
            Thread t = Thread.CurrentThread;
            Thread.Sleep(200);
            Console.WriteLine(t.Name+" "+i);
        }
    }
}
class Program
{
    public static void Main(string[] args)
    {
        Printer p = new Printer();
        Thread t1 = new Thread(new ThreadStart(p.PrintTable));
        Thread t2 = new Thread(new ThreadStart(p.PrintTable));
        t1.Name = "Thread 1 :";
        t2.Name = "Thread 2 :";
        t1.Start();
        t2.Start();
    }
}
</code></pre> 
 <p>执行上面示例代码，可以看到以下输出结果 - </p> 
 <pre><code class="lang-shell">Thread 2 : 1
Thread 1 : 1
Thread 2 : 2
Thread 1 : 2
Thread 2 : 3
Thread 1 : 3
Thread 2 : 4
Thread 1 : 4
Thread 2 : 5
Thread 1 : 5
</code></pre> 
 <h2 id="h2-c-"><a name="C# 线程同步示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>C# 线程同步示例</h2>
 <p>在这个例子中，我们使用<code>lock</code>块，因此示例同步执行。 换句话说，线程之间没有上下文切换。在输出部分，可以看到第二个线程在第一个线程完成任务之后开始执行。</p>   
 <pre><code class="lang-csharp">using System;
using System.Threading;
class Printer
{
    public void PrintTable()
    {
        lock (this)
        {
            for (int i = 1; i &lt;= 5; i++)
            {
                Thread t = Thread.CurrentThread;
                Thread.Sleep(100);
                Console.WriteLine(t.Name + " " + i);
            }
        }
    }
}
class Program
{
    public static void Main(string[] args)
    {
        Printer p = new Printer();
        Thread t1 = new Thread(new ThreadStart(p.PrintTable));
        Thread t2 = new Thread(new ThreadStart(p.PrintTable));
        t1.Name = "Thread 1 :";
        t2.Name = "Thread 2 :";
        t1.Start();
        t2.Start();
    }
}
</code></pre> 
 <p>执行上面示例代码，可以看到以下输出结果 - </p> 
 <pre><code class="lang-shell">Thread 1 : 1
Thread 1 : 2
Thread 1 : 3
Thread 1 : 4
Thread 1 : 5
Thread 2 : 1
Thread 2 : 2
Thread 2 : 3
Thread 2 : 4
Thread 2 : 5
</code></pre>
 <br>      
</div></body></html>