<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">C#封装</h1><div style="width:100%;float:left;" class="article-content">   
 <p>封装是一种被定义为在物理或逻辑包中包含一个或多个项目的过程。封装在面向对象的编程方法中，是用来阻止访问具体的实现细节。</p> 
 <p>抽象和封装是面向对象编程中的相关特征。抽象允许相关信息可见，封装使程序员能够实现所需的抽象级别。</p> 
 <p>封装通过使用访问说明符来实现。访问说明符定义了一个类成员的范围和可见性 C# 支持以下访问说明符：</p> 
 <ul> 
  <li>公共访问说明符</li>
  <li>私有访问说明符</li>
  <li>受保护访问说明符</li>
  <li>内部访问说明符</li>
  <li>保护内部访问说明符</li>
 </ul> 
 <h2 id="h2-u516Cu5171u8BBFu95EEu8BF4u660Eu7B26"><a name="公共访问说明符" class="reference-link"></a><span class="header-link octicon octicon-link"></span>公共访问说明符</h2>
 <p>公共访问说明符允许类将成员变量和成员函数公开到其他函数和对象。任何公共会员都可以从类的外部来访问。</p> 
 <p>以下示例说明了这一点：</p> 
 <pre><code class="lang-csharp">using System;
namespace RectangleApplication
{
    class Rectangle
    {
        //member variables
        public double length;
        public double width;

        public double GetArea()
        {
            return length * width;
        }
        public void Display()
        {
            Console.WriteLine("Length: {0}", length);
            Console.WriteLine("Width: {0}", width);
            Console.WriteLine("Area: {0}", GetArea());
        }
    }//end class Rectangle

    class ExecuteRectangle
    {
        static void Main(string[] args)
        {
            Rectangle r = new Rectangle();
            r.length = 14.5;
            r.width = 10.5;
            r.Display();
            Console.ReadLine();
        }
    }
}
</code></pre> 
 <p>当编译和执行上述代码时，会产生以下结果：</p> 
 <pre><code class="lang-shell">Length: 14.5
Width: 10.5
Area: 152.25
</code></pre> 
 <p>在前面的例子中，成员变量:<code>length</code>和<code>width</code>被声明为<code>public</code>，因此可以使用名为<code>r</code>的<code>Rectangle</code>类的实例从<code>Main()</code>函数访问它们。</p> 
 <p>成员函数<code>Display()</code>和<code>GetArea()</code>也可以直接访问这些变量，而不用通过该类的任何实例。</p> 
 <p>成员函数<code>Display()</code>也被声明为<code>public</code>，因此也可以使用名为<code>r</code>的<code>Rectangle</code>类的实例从<code>Main()</code>访问它。</p> 
 <h2 id="h2-u79C1u6709u8BBFu95EEu8BF4u660Eu7B26"><a name="私有访问说明符" class="reference-link"></a><span class="header-link octicon octicon-link"></span>私有访问说明符</h2>
 <p>私有访问说明符允许类从其他函数和对象中隐藏其成员变量和成员函数。只有同一个类的函数才能访问其私有成员。即使是类的实例也无法访问其私有成员。</p> 
 <p>以下示例说明了这一点：</p> 
 <pre><code class="lang-csharp">using System;
namespace RectangleApplication 
{
   class Rectangle
   {
      //member variables
      private double length;
      private double width;

      public void Acceptdetails()
      {
         Console.WriteLine("Enter Length: ");
         length = Convert.ToDouble(Console.ReadLine());
         Console.WriteLine("Enter Width: ");
         width = Convert.ToDouble(Console.ReadLine());
      }
      public double GetArea()
      {
         return length * width;
      }
      public void Display()
      {
         Console.WriteLine("Length: {0}", length);
         Console.WriteLine("Width: {0}", width);
         Console.WriteLine("Area: {0}", GetArea());
      }
   }//end class Rectangle

   class ExecuteRectangle
   {
      static void Main(string[] args)
      {
         Rectangle r = new Rectangle();
         r.Acceptdetails();
         r.Display();
         Console.ReadLine();
      }
   }
}
</code></pre> 
 <p>当编译和执行上述代码时，会产生以下结果：</p> 
 <pre><code class="lang-shell">Enter Length:
12.5
Enter Width:
8.25
Length: 12.5
Width: 8.25
Area: 103.125
</code></pre> 
 <p>在前面的例子中，成员变量：<code>length</code>和<code>width</code>被声明为私有的，所以不能从函数<code>Main()</code>访问它们。成员函数<code>AcceptDetails()</code>和<code>Display()</code>可以访问这些变量。由于成员函数<code>AcceptDetails()</code>和<code>Display()</code>被声明为<code>public</code>，因此可以使用名为<code>r</code>的<code>Rectangle</code>类的实例从<code>Main()</code>访问它们。</p> 
 <h2 id="h2-u53D7u4FDDu62A4u8BBFu95EEu6307u5B9Au7B26"><a name="受保护访问指定符" class="reference-link"></a><span class="header-link octicon octicon-link"></span>受保护访问指定符</h2>
 <p>受保护的访问说明符允许子类访问其基类的成员变量和成员函数。这样就有助于实现继承。我们将在后续章节中详细讨论。</p> 
 <h2 id="h2-u5185u90E8u8BBFu95EEu6307u5B9Au7B26"><a name="内部访问指定符" class="reference-link"></a><span class="header-link octicon octicon-link"></span>内部访问指定符</h2>
 <p>内部访问说明符允许类将其成员变量和成员函数公开到当前程序集中的其他函数和对象。换句话说，具有内部访问说明符的任何成员都可以从定义成员的应用程序中定义的任何类或方法访问。</p> 
 <p>以下程序说明了这一点：</p>   
 <pre><code class="lang-csharp">using System;
namespace RectangleApplication
{
    class Rectangle
    {
        //member variables
        internal double length;
        internal double width;

        double GetArea()
        {
            return length * width;
        }
        public void Display()
        {
            Console.WriteLine("Length: {0}", length);
            Console.WriteLine("Width: {0}", width);
            Console.WriteLine("Area: {0}", GetArea());
        }
    }//end class Rectangle

    class ExecuteRectangle
    {
        static void Main(string[] args)
        {
            Rectangle r = new Rectangle();
            r.length = 12.5;
            r.width = 8.25;
            r.Display();
            Console.ReadLine();
        }
    }
}
</code></pre> 
 <p>当编译和执行上述代码时，会产生以下结果：</p> 
 <pre><code class="lang-shell">Length: 12.5
Width: 8.25
Area: 103.125
</code></pre> 
 <p>在上面的示例中，请注意，成员函数<code>GetArea()</code>没有使用任何访问说明符声明。如果没有使用任何一个访问说明符的类成员，它的默认访问说明符是什么呢？ 默认使用的是私有的。</p> 
 <h2 id="h2-u53D7u4FDDu62A4u5185u90E8u8BBFu95EEu6307u5B9Au7B26"><a name="受保护内部访问指定符" class="reference-link"></a><span class="header-link octicon octicon-link"></span>受保护内部访问指定符</h2>
 <p>受保护的内部访问说明符允许类从其他类对象和函数中隐藏其成员变量和成员函数，但同一应用程序中的子类除外。这也是在实现继承时要使用的。</p>
 <br>      
</div></body></html>