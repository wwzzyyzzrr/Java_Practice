<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">C#异常处理</h1><div style="width:100%;float:left;" class="article-content">   
 <p>异常(例外)是在执行程序期间出现的问题。 C# 异常是对程序运行时出现的异常情况的响应，例如：除以零的算术运算。</p> 
 <p>异常提供了将控制从程序的一个部分转移到另一个程序的方法。 C# 异常处理建立在四个关键字上：<code>try</code>，<code>catch</code>，<code>finally</code>和<code>throw</code>。</p> 
 <ul> 
  <li><em>try</em>：<code>try</code>块标识一个特定异常被激活的代码块。<code>try</code>块之后有一个或多个<code>catch</code>块。</li>
  <li><em>catch</em>：程序在处理问题的程序中的某个位置使用异常处理程序捕获异常。<code>catch</code>关键字表示捕获异常。</li>
  <li><em>finally</em>：<code>finally</code>块用于执行给定的一组语句，无论抛出异常还是抛出异常。例如，如果打开文件，则不管是否引发异常，都必须关闭该文件。</li>
  <li><em>throw</em>：当出现问题时，程序会抛出异常。这是使用<code>throw</code>关键字完成的。</li>
 </ul> 
 <h2 id="h2-u8BEDu6CD5"><a name="语法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>语法</h2>
 <p>假设一个块引发异常，一个方法使用<code>try</code>和<code>catch</code>关键字的组合来捕获异常。<code>try/catch</code>块放在可能会产生异常的代码周围。<code>try/catch</code>块中的代码被称为受保护代码，并且使用<code>try/catch</code>的语法如下所示：</p> 
 <pre><code class="lang-csharp">try
{
   // statements causing exception
}catch( ExceptionName e1 ){
   // error handling code
}catch( ExceptionName e2 ){
   // error handling code
}catch( ExceptionName eN ){
   // error handling code
}finally{
   // statements to be executed
}
</code></pre> 
 <p>可以列出多个<code>catch</code>语句来捕获不同类型的异常，以防<code>try</code>块在不同情况(<code>case</code>)下引发多个异常。</p> 
 <h2 id="h2-c-"><a name="C# 异常类" class="reference-link"></a><span class="header-link octicon octicon-link"></span>C# 异常类</h2>
 <p> C# 异常由类表示。 C# 中的异常类主要直接或间接地从<code>System.Exception</code>类派生。 从<code>System.Exception</code>类派生的一些异常类是<code>System.ApplicationException</code>和<code>System.SystemException</code>类。</p> 
 <p><code>System.ApplicationException</code>类支持应用程序生成的异常。因此，程序员定义的异常应该从这个类派生出来。</p> 
 <p><code>System.SystemException</code>类是所有预定义系统异常的基类。</p> 
 <p>下表列出了一些从<code>System.SystemException</code>类派生的一些预定义的异常类：</p> 
 <table> 
  <thead> 
   <tr> 
    <th>异常类</th> 
    <th>描述</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td><em>System.IO.IOException</em></td> 
    <td>处理<code>I/O</code>错误</td> 
   </tr> 
   <tr> 
    <td><em>System.IndexOutOfRangeException</em></td> 
    <td>处理当方法引用数组索引超出范围时生成的错误。</td> 
   </tr> 
   <tr> 
    <td><em>System.ArrayTypeMismatchException</em></td> 
    <td>处理类型与数组类型不匹配时生成的错误。</td> 
   </tr> 
   <tr> 
    <td><em>System.NullReferenceException</em></td> 
    <td>处理从引用空(<code>null</code>)对象而产生的错误。</td> 
   </tr> 
   <tr> 
    <td><em>System.DivideByZeroException</em></td> 
    <td>处理除以零产生的错误。</td> 
   </tr> 
   <tr> 
    <td><em>System.InvalidCastException</em></td> 
    <td>处理类型转换过程中产生的错误。</td> 
   </tr> 
   <tr> 
    <td><em>System.OutOfMemoryException</em></td> 
    <td>处理由于空闲内存不足而产生的错误。</td> 
   </tr> 
   <tr> 
    <td><em>System.StackOverflowException</em></td> 
    <td>处理由于空闲内存不足而产生的错误。</td> 
   </tr> 
   <tr> 
    <td><em>System.StackOverflowException</em></td> 
    <td>处理堆栈溢出产生的错误。</td> 
   </tr> 
  </tbody> 
 </table> 
 <h2 id="h2-u5904u7406u5F02u5E38"><a name="处理异常" class="reference-link"></a><span class="header-link octicon octicon-link"></span>处理异常</h2>
 <p> C# 以<code>try</code>和<code>catch</code>块的形式提供了异常处理的结构化解决方案。使用这些块，核心程序语句与错误处理语句分离。</p> 
 <p>这些错误处理块使用<code>try</code>，<code>catch</code>和<code>finally</code>关键字实现。下面是一个除以零条件发生异常时的异常：</p>   
 <pre><code class="lang-csharp">using System;
namespace ErrorHandlingApplication
{
   class DivNumbers
   {
      int result;
      DivNumbers()
      {
         result = 0;
      }
      public void division(int num1, int num2)
      {
         try
         {
            result = num1 / num2;
         }
         catch (DivideByZeroException e)
         {
            Console.WriteLine("Exception caught: {0}", e);
         }
         finally
         {
            Console.WriteLine("Result: {0}", result);
         }
      }
      static void Main(string[] args)
      {
         DivNumbers d = new DivNumbers();
         d.division(25, 0);
         Console.ReadKey();
      }
   }
}
</code></pre> 
 <p>当上述代码被编译并执行时，它产生以下结果：</p> 
 <pre><code class="lang-csharp">Exception caught: System.DivideByZeroException: Attempted to divide by zero. 
at ...
Result: 0
</code></pre> 
 <h2 id="h2-u7528u6237u5B9Au4E49u7684u5F02u5E38"><a name="用户定义的异常" class="reference-link"></a><span class="header-link octicon octicon-link"></span>用户定义的异常</h2>
 <p>您也可以定义自己的异常。用户定义的异常类派生自<code>Exception</code>类。以下示例演示如何创建一个自定义异常：</p> 
 <pre><code class="lang-csharp">using System;
namespace UserDefinedException
{
   class TestTemperature
   {
      static void Main(string[] args)
      {
         Temperature temp = new Temperature();
         try
         {
            temp.showTemp();
         }
         catch(TempIsZeroException e)
         {
            Console.WriteLine("TempIsZeroException: {0}", e.Message);
         }
         Console.ReadKey();
      }
   }
}

public class TempIsZeroException: Exception
{
   public TempIsZeroException(string message): base(message)
   {
   }
}

public class Temperature
{
   int temperature = 0;
   public void showTemp()
   {
      if(temperature == 0)
      {
         throw (new TempIsZeroException("Zero Temperature found"));
      }
      else
      {
         Console.WriteLine("Temperature: {0}", temperature);
      }
   }
}
</code></pre> 
 <p>当上述代码被编译并执行时，它产生以下结果：</p> 
 <pre><code class="lang-csharp">TempIsZeroException: Zero Temperature found
</code></pre> 
 <h2 id="h2-u629Bu51FAu5BF9u8C61"><a name="抛出对象" class="reference-link"></a><span class="header-link octicon octicon-link"></span>抛出对象</h2>
 <p>如果直接或间接派生自<code>System.Exception</code>类，则可以抛出一个对象。可以在<code>catch</code>块中使用<code>throw</code>语句将当前对象抛出：</p> 
 <pre><code class="lang-csharp">Catch(Exception e)
{
   ...
   Throw e
}
</code></pre>
 <br>      
</div></body></html>