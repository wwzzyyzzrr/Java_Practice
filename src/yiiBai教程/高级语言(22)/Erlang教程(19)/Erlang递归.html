<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Erlang递归</h1><div style="width:100%;float:left;" class="article-content">   
 <div> 
  <div>
    递归是&nbsp;Erlang&nbsp;的重要组成部分。首先，让我们通过实现阶乘程序来了解简单的递归。 
  </div> 
 </div> 
 <div> 
  <h3> 示例 </h3> 
  <pre>-module(helloworld). 
-export([fac/1,start/0]). 

fac(N) when N == 0 -&gt; 1; 
fac(N) when N &gt; 0 -&gt; N*fac(N-1). 

start() -&gt; 
   X = fac(4), 
   io:fwrite("~w",[X]).</pre> 
  <div>
    对于上面的例子，有以下几点需要注意&nbsp;- 
  </div> 
  <ul> 
   <li> 
    <div>
      我们首先定义一个函数&nbsp;fac(N)； 
    </div> </li> 
   <li> 
    <div>
      我们可以通过定义递归函数&nbsp;fac(N)&nbsp;递归； 
    </div> </li> 
  </ul> 
  <div>
    上面的代码的输出结果是&nbsp;- 
  </div> 
  <pre>24</pre> 
  <h2> 
   <div>
     实用方法递归 
   </div> </h2> 
  <div>
    在本节中，我们将详细了解不同类型的递归及其在&nbsp;Erlang&nbsp;中的使用。 
  </div> 
  <h3> 长度递归 </h3> 
  <div>
    以递归一个更有效的方法可以用于确定一个列表的长度，现在来看看一个简单的例子。列表中有多个值，如[1,2,3,4]。 
  </div> 
  <div>
    让我们用递归的方法来看看如何能够得到一个列表的长度。 
  </div> 
  <p style="text-align:justify;"> 示例 </p> 
  <pre>-module(helloworld). 
-export([len/1,start/0]). 

len([]) -&gt; 0; 
len([_|T]) -&gt; 1 + len(T). 

start() -&gt; 
   X = [1,2,3,4], 
   Y = len(X), 
   io:fwrite("~w",[Y]).</pre> 
  <div>
    以下是上述程序需要说明的一些关键点&nbsp;- 
  </div> 
  <ul> 
   <li> 
    <div>
      第一个函数&nbsp;len([])&nbsp;用于特殊情况的条件：如果列表为空。 
    </div> </li> 
   <li> 
    <div>
      [H|T]&nbsp;模式来匹配一个或多个元素的列表，如长度为1的列表将被定义为&nbsp;[X|[]]，而长度为&nbsp;2&nbsp;的列表将被定义为&nbsp;[X|[Y|[]]]&nbsp;。 
    </div> 
    <div>
      注意，第二元素是列表本身。这意味着我们只需要计数第一个，函数可以调用它本身在第二元素上。在列表给定每个值的长度计数为&nbsp;1&nbsp;。 
    </div> </li> 
  </ul> 
  <div>
    上面的代码的输出结果是&nbsp;- 
  </div> 
  <pre>4</pre> 
  <h3> 
   <div>
     尾部递归 
   </div> </h3> 
  <div>
    要了解尾递归是如何工作的，让我们来了解下面的代码在上一节中是如何工作的。 
  </div> 
  <p style="text-align:justify;"> 语法 </p> 
  <pre>len([]) -&gt; 0; 
len([_|T]) -&gt; 1 + len(T).</pre> 
  <div>
    回答&nbsp;1&nbsp;+&nbsp;len(Rest)&nbsp;需要&nbsp;len(Rest)&nbsp;。函数&nbsp;len(Rest)&nbsp;根据需要自行调用另一个函数的结果。该补充将得到堆积，直到最后一个被发现，然后才会计算最终结果。尾递归旨在通过减少它们，以消除这种操作堆叠。 
  </div> 
  <div>
    为了达到这个目的，我们将需要保持一个额外的临时变量作为函数的一个参数。上述临时变量有时被称为累加器并用来存储计算的结果，因为它们会限制调用增长。 
  </div> 
  <div>
    让我们来看看尾递归的一个例子&nbsp;- 
  </div> 
  <p style="text-align:justify;"> <strong>示例</strong> </p> 
  <pre>-module(helloworld).
-export([tail_len/1,tail_len/2,start/0]). 

tail_len(L) -&gt; tail_len(L,0). 
tail_len([], Acc) -&gt; Acc; 
tail_len([_|T], Acc) -&gt; tail_len(T,Acc+1). 

start() -&gt; 
   X = [1,2,3,4], 
   Y = tail_len(X), 
   io:fwrite("~w",[Y]).</pre> 
  <div>
    上面的代码的输出结果是&nbsp;- 
  </div>   
  <pre>4</pre> 
  <h2> 
   <div>
     重复(复本) 
   </div> </h2> 
  <div>
    让我们来看看递归的例子。这一次我们写一个函数，它接受一个整数作为其第一个参数，然后有一个其他子句作为其第二个参数。它将由整数指定创建多个副本的列表。 
  </div> 
  <div>
    让我们来看看这个例子如下&nbsp;- 
  </div> 
  <pre>-module(helloworld). 
-export([duplicate/2,start/0]). 

duplicate(0,_) -&gt; 
   []; 
duplicate(N,Term) when N &gt; 0 -&gt;
   io:fwrite("~w,~n",[Term]),
   [Term|duplicate(N-1,Term)]. 
start() -&gt; 
   duplicate(5,1).</pre> 
  <div>
    上面的代码的输出结果是&nbsp;- 
  </div> 
  <pre>1,
1,
1,
1,
1,</pre> 
  <h2> 
   <div>
     列表反转 
   </div> </h2> 
  <div>
    有无止境的在&nbsp;Erlang&nbsp;中使用递归。让我们现在快速地来看看如何使用递归来反转列表的元素。 
  </div> 
  <div>
    下面的程序可用于实现此目的。 
  </div> 
  <h3> 示例 </h3> 
  <pre>-module(helloworld). 
-export([tail_reverse/2,start/0]). 

tail_reverse(L) -&gt; tail_reverse(L,[]).

tail_reverse([],Acc) -&gt; Acc; 
tail_reverse([H|T],Acc) -&gt; tail_reverse(T, [H|Acc]).

start() -&gt; 
   X = [1,2,3,4], 
   Y = tail_reverse(X), 
   io:fwrite("~w",[Y]).</pre> 
  <div>
    上面的代码的输出结果是&nbsp;- 
  </div> 
  <pre>[4,3,2,1]</pre> 
  <div>
    以下是上述程序需要说明的一些关键点&nbsp;- 
  </div> 
  <ul> 
   <li> 
    <div>
      我们再次使用临时变量&nbsp;Acc&nbsp;存储列表中的每个元素 
    </div> </li> 
   <li> 
    <div>
      调用递归尾反转，确保最后一个元素被放入新列表的第一位置 
    </div> </li> 
   <li> 
    <div>
      递归调用尾反向列表中的每个元素 
    </div> </li> 
  </ul> 
 </div>
 <br>      
</div></body></html>