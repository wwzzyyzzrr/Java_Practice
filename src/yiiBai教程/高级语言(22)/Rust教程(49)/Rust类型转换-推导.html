<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Rust类型转换-推导</h1><div style="width:100%;float:left;" class="article-content">   
 <h2 id="52-inference" style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; -webkit-font-smoothing: antialiased; margin-bottom: 16px; line-height: 1.225; font-size: 1.75em; position: relative; padding-bottom: 0.3em; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(238, 238, 238); color: rgb(51, 51, 51);  'Clear Sans', 'Helvetica Neue', Helvetica,   margin-top: 0px !important;"> Rust类型转换-推导</h2> 
 <p style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; -webkit-font-smoothing: antialiased; margin-top: 0px; margin-bottom: 16px; color: rgb(51, 51, 51);  'Clear Sans', 'Helvetica Neue', Helvetica,   font-size: 16px; line-height: 25.6000003814697px;"> 类型推理引擎是非常灵巧的。 它在一个初始化期间会寻找&nbsp;<a target="_blank" href="http://en.wikipedia.org/wiki/Value_%28computer_science%29#lrvalue">r-value</a>&nbsp;的类型。&nbsp;它也着眼于如何使用变量，事后推断其类型。这里是类型推断的高级示例：</p> 
 <pre>
fn main() {
    // Because of the annotation, the compiler knows that `elem` has type u8.
    let elem = 5u8;

    // Create an empty vector (a growable array).
    let mut vec = Vec::new();
    // At this point the compiler doesn't know the exact type of `vec`, it
    // just knows that it's a vector of something (`Vec&lt;_&gt;`).

    // Insert `elem` in the vector.
    vec.push(elem);
    // Aha! Now the compiler knows that `vec` is a vector of `u8`s (`Vec
  <u8>
   `)
    // TODO ^ Try commenting out the `vec.push(elem)` line

    println!("{:?}", vec);
}

  </u8></pre> 
 <span style="font-size:16px;">需要的变量没有类型注释。</span>
 <br>      
</div></body></html>