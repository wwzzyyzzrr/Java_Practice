<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">io::rdbuf()函数</h1><div style="width:100%;float:left;" class="article-content">   
 <p>它用于获取/设置流缓冲区。 如果<code>sb</code>是一个空指针，函数会自动设置<code>badbit</code>错误状态标志（如果成员异常已经传递<code>badbit</code>，它可能会抛出异常）。</p> 
 <h2 id="h2-u58F0u660E"><a name="声明" class="reference-link"></a><span class="header-link octicon octicon-link"></span>声明</h2>
 <p>以下是<code>ios::rdbuf</code>函数的声明。</p> 
 <pre><code class="lang-cpp">get (1)    streambuf* rdbuf() const;
set (2)    streambuf* rdbuf (streambuf* sb);
</code></pre> 
 <h2 id="h2-u53C2u6570"><a name="参数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>参数</h2>
 <ul> 
  <li><code>sb</code> − 指向<code>streambuf</code>对象的指针。</li>
 </ul> 
 <h2 id="h2-u8FD4u56DEu503C"><a name="返回值" class="reference-link"></a><span class="header-link octicon octicon-link"></span>返回值</h2>
 <p>指向与调用前流相关联的流缓冲区对象的指针。</p> 
 <h2 id="h2-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h2>
 <p>下面的例子中演示了<code>ios::rdbuf</code>函数应用。</p>   
 <pre><code class="lang-cpp">#include &lt;iostream&gt;     
#include &lt;fstream&gt;      

int main () {
  std::streambuf *psbuf, *backup;
  std::ofstream filestr;
  filestr.open ("test.txt");

  backup = std::cout.rdbuf();     

  psbuf = filestr.rdbuf();        
  std::cout.rdbuf(psbuf);         

  std::cout &lt;&lt; "This is written to the file";

  std::cout.rdbuf(backup);        

  filestr.close();

  return 0;
}
</code></pre>
 <br>      
</div></body></html>