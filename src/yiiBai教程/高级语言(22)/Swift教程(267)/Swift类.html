<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Swift类</h1><div style="width:100%;float:left;" class="article-content">   
 <p> 在 Swift 中类是建立灵活的构建块。类似于常量，变量和函数，用户可以定义的类的属性和方法。Swift给我们提供了声明类，而无需用户创建接口和实现文件的功能。Swift 允许我们创建类作为单个文件和外部接口，将默认在类一次初始化来创建。</p> 
 <h2> 使用类的好处</h2> 
 <ul> 
  <li> <p> 继承获得一个类的属性到其他类</p> </li> 
  <li> <p> 类型转换使用户能够在运行时检查类的类型</p> </li> 
  <li> <p> 初始化器需要处理释放内存资源</p> </li> 
  <li> <p> 引用计数允许类实例有一个以上的参考</p> </li> 
 </ul> 
 <h2> 类和结构的共同特征</h2> 
 <ul> 
  <li> <p> 属性被定义为存储值</p> </li> 
  <li> <p> 下标被定义为提供访问值</p> </li> 
  <li> <p> 方法被初始化来改善功能</p> </li> 
  <li> <p> 初始状态是由初始化函数定义</p> </li> 
  <li> <p> 功能被扩大，超出默认值</p> </li> 
  <li> <p> 确认协议功能标准</p> </li> 
 </ul> 
 <h2> 语法</h2> 
 <pre style="Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 14px; line-height: 16px; widows: auto; color: rgb(49, 49, 49); background-color: rgb(241, 241, 241);">
Class classname {
   Definition 1
   Definition 2
    --- 
   Definition N
}</pre> 
 <h2> 定义类</h2> 
 <pre style="Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 14px; line-height: 16px; widows: auto; color: rgb(49, 49, 49); background-color: rgb(241, 241, 241);">
class student{
   var studname: String
   var mark: Int 
   var mark2: Int 
}</pre> 
 <p> 创建一个实例的语法：</p> 
 <pre style="Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 14px; line-height: 16px; widows: auto; color: rgb(49, 49, 49); background-color: rgb(241, 241, 241);">
let studrecord = student()</pre> 
 <h2> 示例</h2> 
 <pre style="Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 14px; line-height: 16px; widows: auto; color: rgb(49, 49, 49);">
class MarksStruct {
   var mark: Int
   init(mark: Int) {
      self.mark = mark
   }
}

class studentMarks {
   var mark = 300
}
let marks = studentMarks()
println("Mark is \(marks.mark)")</pre> 
 <p> 当我们使用 playground 运行上面的程序，我们得到以下结果</p> 
 <pre style="Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 14px; line-height: 16px; widows: auto; color: rgb(49, 49, 49); background-color: rgb(241, 241, 241);">
Mark is 300</pre> 
 <h2> 访问类属性作为引用类型</h2> 
 <p> 类属性可使用 '.' 语法来访问。属性名称由 "." 分离在实例名后。</p> 
 <pre style="Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 14px; line-height: 16px; widows: auto; color: rgb(49, 49, 49);">
class MarksStruct {
   var mark: Int
   init(mark: Int) {
      self.mark = mark
   }
}

class studentMarks {
   var mark1 = 300
   var mark2 = 400
   var mark3 = 900
}
let marks = studentMarks()
println("Mark1 is \(marks.mark1)")
println("Mark2 is \(marks.mark2)")
println("Mark3 is \(marks.mark3)")</pre> 
 <p> 当我们使用 playground 运行上面的程序，得到以下结果</p> 
 <pre style="Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 14px; line-height: 16px; widows: auto; color: rgb(49, 49, 49); background-color: rgb(241, 241, 241);">
Mark1 is 300
Mark2 is 400
Mark3 is 900</pre> 
 <h2> 类标识符</h2> 
 <p> 在 Swift 引用多个常量和变量指向的单个实例。要了解常量和变量指向一个特定的类实例标识操作符的使用。 类实例总是通过引用传递。在类NSString，NSArray 和 NSDictionary 实例始终分配作为参考传递到现有的实例，而不是使用一个副本。</p> 
 <table border="1" cellpadding="2" cellspacing="0" style="font-size: 14px; border-collapse: collapse; margin-top: 10px; margin-bottom: 10px; widows: auto; color: rgb(49, 49, 49); "> 
  <tbody style="background-color: inherit;"> 
   <tr style="background-color: inherit;"> 
    <td style="word-break: break-all; border: 1px solid rgb(153, 153, 153); padding: 5px 10px; min-height: 25px; min-width: 25px; height: 25px; background-color: inherit;"> <b style="background-color: inherit;">等同运算符</b></td> 
    <td style="word-break: break-all; border: 1px solid rgb(153, 153, 153); padding: 5px 10px; min-height: 25px; min-width: 25px; height: 25px; background-color: inherit;"> <b style="background-color: inherit;">不相同操算符</b></td> 
   </tr> 
   <tr style="background-color: inherit;"> 
    <td style="word-break: break-all; border: 1px solid rgb(153, 153, 153); padding: 5px 10px; min-height: 25px; min-width: 25px; height: 25px; background-color: inherit;"> 使用的操作符是 (===)</td> 
    <td style="word-break: break-all; border: 1px solid rgb(153, 153, 153); padding: 5px 10px; min-height: 25px; min-width: 25px; height: 25px; background-color: inherit;"> 使用的操作符是 (!==)</td> 
   </tr> 
   <tr style="background-color: inherit;"> 
    <td style="word-break: break-all; border: 1px solid rgb(153, 153, 153); padding: 5px 10px; min-height: 25px; min-width: 25px; height: 25px; background-color: inherit;"> 当两个常量或变量指向同一个实例返回true</td> 
    <td style="word-break: break-all; border: 1px solid rgb(153, 153, 153); padding: 5px 10px; min-height: 25px; min-width: 25px; height: 25px; background-color: inherit;"> 当两个常数或变量指向一个不同的实例返回true</td> 
   </tr> 
  </tbody> 
 </table>   
 <pre style="Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 14px; line-height: 16px; widows: auto; color: rgb(49, 49, 49);">
class SampleClass: Equatable {
   let myProperty: String
   init(s: String) {
      myProperty = s
   }
}
func ==(lhs: SampleClass, rhs: SampleClass) -&gt; Bool {
   return lhs.myProperty == rhs.myProperty
}

let spClass1 = SampleClass(s: "Hello")
let spClass2 = SampleClass(s: "Hello")

spClass1 === spClass2 // false
println("\(spClass1)")

spClass1 !== spClass2 // true
println("\(spClass2)")</pre> 
 <p> 当我们使用 playground 运行上面的程序，得到以下结果</p> 
 <pre style="Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 14px; line-height: 16px; widows: auto; color: rgb(49, 49, 49); background-color: rgb(241, 241, 241);">
main.SampleClass
main.SampleClass</pre> 
 <br>      
</div></body></html>