<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">ASP.NET生命周期</h1><div style="width:100%;float:left;" class="article-content">   
 <p>ASP.NET生命周期如何指定？如下说明：</p> 
 <ul> 
  <li>ASP.NET处理页面以产生动态输出</li>
  <li>应用程序及其页面被实例化和处理</li>
  <li>ASP.NET动态编译成页面</li>
 </ul> 
 <p>ASP.NET的生命周期可以分为两组：</p> 
 <ul> 
  <li>应用程序生命周期</li>
  <li>页面生命周期</li>
 </ul> 
 <h2 id="h2-asp-net-"><a name="ASP.NET应用程序生命周期" class="reference-link"></a><span class="header-link octicon octicon-link"></span>ASP.NET应用程序生命周期</h2>
 <p>应用程序生命周期有以下几个阶段：</p> 
 <ul> 
  <li>用户请求访问应用程序资源，页面。浏览器将此请求发送到Web服务器。</li>
  <li>统一管道接收第一个请求，并发生以下事件：
   <ul> 
    <li><code>ApplicationManager</code>类的一个对象被创建。</li>
    <li>创建<code>HostingEnvironment</code>类的一个对象来提供有关资源的信息。</li>
    <li>编译应用程序中的顶级项目。</li>
   </ul> </li>
  <li>响应(<code>Response</code>)对象被创建。应用程序对象，如<code>HttpContext</code>，<code>HttpRequest</code>和<code>HttpResponse</code>被创建和初始化。</li>
  <li><code>HttpApplication</code>对象的一个实例被创建并分配给请求。</li>
  <li>该请求由<code>HttpApplication</code>类处理，这个类处理请求的不同事件。</li>
 </ul> 
 <h2 id="h2-asp-net-"><a name="ASP.NET页面生命周期" class="reference-link"></a><span class="header-link octicon octicon-link"></span>ASP.NET页面生命周期</h2>
 <p>当一个页面被请求时，它被加载到服务器内存中，进行处理并发送到浏览器。 然后它从内存中卸载。在这些步骤的每个步骤中，都有可用的方法和事件，这些方法和事件可以根据应用程序的需要进行覆盖。换句话说，您可以编写自己的代码来覆盖默认代码。</p> 
 <p><code>Page</code>类创建页面上所有控件的分层树。页面上的所有组件(指令除外)都是此控件树的一部分。可以通过将<code>trace =“true”</code>添加到页面指令来查看控件树。我们将涵盖页面指令，并在“指令”和“事件处理”下的跟踪。</p> 
 <p>页面生命周期阶段是：</p> 
 <ul> 
  <li>初始化</li>
  <li>实例化页面上的控件</li>
  <li>恢复和维护状态</li>
  <li>执行事件处理程序代码</li>
  <li>页面渲染</li>
 </ul> 
 <p>了解页面循环有助于编写代码，使页面生命周期的任何阶段都能发生一些特定的事情。 它还有助于编写自定义控件并在正确的时间初始化它们，使用视图状态数据填充它们的属性并运行控制行为代码。</p> 
 <p>以下是ASP.NET页面的不同阶段：</p> 
 <table> 
  <thead> 
   <tr> 
    <th>编号</th> 
    <th>阶段</th> 
    <th>描述/说明</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>1</td> 
    <td>页面请求</td> 
    <td>当ASP.NET获得一个页面请求时，它决定是否解析和编译该页面，或者会使用一个缓存的页面版本。相应地发送响应。</td> 
   </tr> 
   <tr> 
    <td>2</td> 
    <td>开始页面生命周期</td> 
    <td>在这个阶段，<code>Request</code>和<code>Response</code>对象被设置。如果请求是旧请求或回发，则页面的<code>IsPostBack</code>属性设置为<code>true</code>。页面的<code>UICulture</code>属性也被设置。</td> 
   </tr> 
   <tr> 
    <td>3</td> 
    <td>页面初始化</td> 
    <td>在此阶段，通过设置<code>UniqueID</code>属性并应用主题，页面上的控件被分配唯一ID。 对于新的请求，加载回发数据并将控件属性恢复为视图状态值。</td> 
   </tr> 
   <tr> 
    <td>4</td> 
    <td>页面加载</td> 
    <td>在此阶段，使用视图状态和控件状态值设置控件属性。</td> 
   </tr> 
   <tr> 
    <td>5</td> 
    <td>验证</td> 
    <td>验证控件的验证方法被调用，并在成功执行时，页面的<code>IsValid</code>属性设置为true。</td> 
   </tr> 
   <tr> 
    <td>6</td> 
    <td>回发事件处理</td> 
    <td>如果请求是回发(旧请求)，则调用相关的事件处理程序。</td> 
   </tr> 
   <tr> 
    <td>7</td> 
    <td>页面渲染</td> 
    <td>在这个阶段，页面和所有控件的查看状态被保存。页面为每个控件调用<code>Render</code>方法，并将渲染的输出写入到页面的<code>Response</code>属性的<code>OutputStream</code>类中。</td> 
   </tr> 
   <tr> 
    <td>8</td> 
    <td>卸下/Unload</td> 
    <td>呈现的页面被发送到客户端，并且页面属性(例如响应和请求)被卸载，并且所有清理完成。</td> 
   </tr> 
  </tbody> 
 </table> 
 <p>一个请求的页面在处理完之后，首先被加载到服务器的内存中，并发送到浏览器。 最后它从服务器内存中卸载。 ASP.NET在页面生命周期的每个阶段提供方法和事件，我们可以在应用程序中使用。</p> 
 <h2 id="h2-asp-net-"><a name="ASP.NET页面生命周期事件" class="reference-link"></a><span class="header-link octicon octicon-link"></span>ASP.NET页面生命周期事件</h2>
 <p>在页面生命周期的每个阶段，页面会引发一些事件，这些事件可以被编码。 事件处理程序基本上是一个函数或子例程，绑定到事件，使用声明性的属性，如<code>Onclick</code>或处理句柄。</p> 
 <p>以下是页面生命周期事件：</p> 
 <table> 
  <thead> 
   <tr> 
    <th>编号</th> 
    <th>事件</th> 
    <th>描述</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>1</td> 
    <td><strong>PreInit</strong></td> 
    <td><code>PreInit</code>是页面生命周期中的第一个事件。它检查<code>IsPostBack</code>属性并确定页面是否是回发。它设置主题和主页面，创建动态控件，并获取和设置配置文件属性值。可以通过重载<code>OnPreInit</code>方法或创建<code>Page_PreInit</code>处理程序来处理此事件。</td> 
   </tr> 
   <tr> 
    <td>2</td> 
    <td><strong>Init </strong></td> 
    <td><code>Init</code>事件初始化控件属性，构建控件树。可以通过重载<code>OnInit</code>方法或创建<code>Page_Init</code>处理程序来处理此事件。</td> 
   </tr> 
   <tr> 
    <td>3</td> 
    <td><strong>InitComplete</strong></td> 
    <td><code>InitComplete</code>事件允许跟踪视图状态。所有的控件都打开了视图状态跟踪。</td> 
   </tr> 
   <tr> 
    <td>4</td> 
    <td><strong>LoadViewState</strong></td> 
    <td><code>LoadViewState</code>事件允许将视图状态信息加载到控件中。</td> 
   </tr> 
   <tr> 
    <td>5</td> 
    <td><strong>LoadPostData</strong></td> 
    <td>在这个阶段，所有输入字段的内容都是用<code>&lt;form&gt;</code>标签定义的。</td> 
   </tr> 
   <tr> 
    <td>6</td> 
    <td><strong>PreLoad</strong></td> 
    <td><code>PreLoad</code>发生在回发数据加载到控件中之前。可以通过重载<code>OnPreLoad</code>方法或创建<code>Page_PreLoad</code>处理程序来处理此事件。</td> 
   </tr> 
   <tr> 
    <td>7</td> 
    <td><strong>Load</strong></td> 
    <td>首先为页面引发<code>Load</code>事件，然后递归地为所有子控件引发<code>Load</code>事件。控制树中的控件已创建。可以通过重载<code>OnLoad</code>方法或创建<code>Page_Load</code>处理程序来处理此事件。</td> 
   </tr> 
   <tr> 
    <td>8</td> 
    <td><strong>LoadComplete</strong></td> 
    <td>加载过程完成，控制事件处理程序运行，页面验证发生。可以通过重载<code>OnLoadComplete</code>方法或创建<code>Page_LoadComplete</code>处理程序来处理此事件。</td> 
   </tr> 
   <tr> 
    <td>9</td> 
    <td><strong>PreRender</strong></td> 
    <td><code>PreRender</code>事件在输出呈现之前发生。通过处理此事件，页面和控件可以在输出呈现之前执行任何更新。</td> 
   </tr> 
   <tr> 
    <td>10</td> 
    <td><strong>PreRenderComplete</strong></td> 
    <td>由于<code>PreRender</code>事件是为所有子控件递归触发的，因此此事件将确保完成预渲染阶段。</td> 
   </tr> 
   <tr> 
    <td>11</td> 
    <td><strong>SaveStateComplete</strong></td> 
    <td>页面上的控制状态被保存个性化，控制状态和视图状态信息被保存，HTML标记被生成。这个阶段可以通过重写<code>Render</code>方法或创建<code>Page_Render</code>处理程序来处理。</td> 
   </tr> 
   <tr> 
    <td>12</td> 
    <td><strong>UnLoad</strong></td> 
    <td><code>UnLoad</code>阶段是页面生命周期的最后阶段。它递归地提交所有控件的<code>UnLoad</code>事件，最后为页面本身。最后的清理工作已经完成，所有的资源和引用(如数据库连接)都被释放了。可以通过修改<code>OnUnLoad</code>方法或创建<code>Page_UnLoad</code>处理程序来处理此事件。</td> 
   </tr> 
  </tbody> 
 </table>
 <br>      
</div></body></html>