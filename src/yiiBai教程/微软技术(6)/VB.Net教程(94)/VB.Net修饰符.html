<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">VB.Net修饰符</h1><div style="width:100%;float:left;" class="article-content">   
 <p>修饰符是添加了任何编程元素的关键字，以特别强调编程元素在程序中的行为或将被访问</p> 
 <p>例如，访问修饰符：<code>Public</code>, <code>Private</code>, <code>Protected</code>, <code>Friend</code>, <code>Protected Friend</code>等指示编程元素的访问级别，如：变量，常量，枚举或类。</p> 
 <h2 id="h2-vb-net-"><a name="VB.Net修饰符列表" class="reference-link"></a><span class="header-link octicon octicon-link"></span>VB.Net修饰符列表</h2>
 <p>下表提供了VB.Net修饰符的完整列表：</p> 
 <table> 
  <thead> 
   <tr> 
    <th>编号</th> 
    <th>修饰符</th> 
    <th>描述</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>1</td> 
    <td><code>Ansi</code></td> 
    <td>指定Visual Basic应将所有字符串封送到美国国家标准学会(ANSI)值，而不管正在声明的外部过程的名称如何。</td> 
   </tr> 
   <tr> 
    <td>2</td> 
    <td><code>Assembly</code></td> 
    <td>指定源文件开始处的属性适用于整个程序集。</td> 
   </tr> 
   <tr> 
    <td>3</td> 
    <td><code>Async</code></td> 
    <td>表示它修改的方法或<code>lambda</code>表达式是异步的。 这样的方法被称为异步方法。 异步方法的调用者可以在不等待异步方法完成的情况下恢复工作。</td> 
   </tr> 
   <tr> 
    <td>4</td> 
    <td><code>Auto</code></td> 
    <td><code>Declare</code>语句中的<code>charsetmodifier</code>部分在调用外部过程期间为字符串提供字符集信息。它还影响Visual Basic如何搜索外部文件的外部过程名称。<code>Auto</code>修饰符指定Visual Basic应根据.NET框架规则对字符串进行编组。</td> 
   </tr> 
   <tr> 
    <td>5</td> 
    <td><code>ByRef</code></td> 
    <td>指定参数是通过引用传递的，即被调用的过程可以改变调用代码中参数的潜在变量的值。它在以下情况下使用： (1)<code>Declare</code>语句，(2)<code>Function</code>语句，(3)<code>Sub</code>语句</td> 
   </tr> 
   <tr> 
    <td>6</td> 
    <td><code>ByVal</code></td> 
    <td>指定参数以被调用过程或属性不能更改调用代码中参数基础变量的值的方式传递。它在以下情况下使用：(1)<code>Declare</code>语句，(2)<code>Function</code>语句，(3)<code>Operator</code>语句,(2)<code>Property</code>语句，(2)<code>Sub</code>语句</td> 
   </tr> 
   <tr> 
    <td>7</td> 
    <td><code>Default</code></td> 
    <td>将属性标识为其类，结构或接口的默认属性。</td> 
   </tr> 
   <tr> 
    <td>8</td> 
    <td><code>Friend</code></td> 
    <td>指定一个或多个声明的编程元素可以从包含声明的程序集中访问，而不仅仅是声明它们的组件。<code>Friend</code>访问通常是应用程序编程元素的首选级别，<code>Friend</code>是接口，模块，类或结构的默认访问级别。</td> 
   </tr> 
   <tr> 
    <td>9</td> 
    <td><code>In</code></td> 
    <td>它用于通用接口和委托。</td> 
   </tr> 
   <tr> 
    <td>10</td> 
    <td><code>Iterator</code></td> 
    <td>指定函数或<code>Get</code>访问器是一个迭代器。迭代器对集合执行自定义迭代。</td> 
   </tr> 
   <tr> 
    <td>11</td> 
    <td><code>Key</code></td> 
    <td><code>Key</code>关键字使我们能够为匿名类型的属性指定行为。</td> 
   </tr> 
   <tr> 
    <td>12</td> 
    <td><code>Module</code></td> 
    <td>指定源文件开始处的属性适用于当前装配模块。它与<code>Module</code>语句不同。</td> 
   </tr> 
   <tr> 
    <td>13</td> 
    <td><code>MustInherit</code></td> 
    <td>指定一个类只能用作基类，并且不能直接从它创建对象。</td> 
   </tr> 
   <tr> 
    <td>14</td> 
    <td><code>MustOverride</code></td> 
    <td>指定在此类中未实现某个属性或过程，并且必须在派生类中重写它，然后才能使用它。</td> 
   </tr> 
   <tr> 
    <td>15</td> 
    <td><code>Narrowing</code></td> 
    <td>指示转换运算符(<code>CType</code>)将类或结构转换为可能无法保存原始类或结构的某些可能值的类型。</td> 
   </tr> 
   <tr> 
    <td>16</td> 
    <td><code>NotInheritable</code></td> 
    <td>指定一个类不能用作基类。</td> 
   </tr> 
   <tr> 
    <td>17</td> 
    <td><code>NotOverridable</code></td> 
    <td>指定在派生类中不能覆盖属性或过程。</td> 
   </tr> 
   <tr> 
    <td>18</td> 
    <td><code>Optional</code></td> 
    <td>指定在调用过程时可以省略过程参数。</td> 
   </tr> 
   <tr> 
    <td>19</td> 
    <td><code>Out</code></td> 
    <td>对于泛型类型参数，<code>Out</code>关键字指定类型是协变的。</td> 
   </tr> 
   <tr> 
    <td>20</td> 
    <td><code>Overloads</code></td> 
    <td>指定属性或过程使用相同的名称重新声明一个或多个现有属性或过程。</td> 
   </tr> 
   <tr> 
    <td>21</td> 
    <td><code>Overridable</code></td> 
    <td>指定属性或过程可以由派生类中的名称相同的属性或过程重写。</td> 
   </tr> 
   <tr> 
    <td>22</td> 
    <td><code>Overrides</code></td> 
    <td>指定属性或过程覆盖从基类继承的名称相同的属性或过程。</td> 
   </tr> 
   <tr> 
    <td>23</td> 
    <td><code>ParamArray</code></td> 
    <td><code>ParamArray</code>允许将任意数量的参数传递给过程。一个<code>ParamArray</code>参数总是使用<code>ByVal</code>声明的。</td> 
   </tr> 
   <tr> 
    <td>24</td> 
    <td><code>Partial</code></td> 
    <td>指示类或结构声明是类或结构的部分定义。</td> 
   </tr> 
   <tr> 
    <td>25</td> 
    <td><code>Private</code></td> 
    <td>指定一个或多个声明的编程元素只能在其声明上下文中访问，包括从任何包含的类型中访问。</td> 
   </tr> 
   <tr> 
    <td>26</td> 
    <td><code>Protected</code></td> 
    <td>指定一个或多个声明的编程元素只能从其自己的类或派生类中访问。</td> 
   </tr> 
   <tr> 
    <td>27</td> 
    <td><code>Public</code></td> 
    <td>指定一个或多个声明的编程元素没有访问限制。</td> 
   </tr> 
   <tr> 
    <td>28</td> 
    <td><code>ReadOnly</code></td> 
    <td>指定可以读取但不写入变量或属性。</td> 
   </tr> 
   <tr> 
    <td>29</td> 
    <td><code>Shadows</code></td> 
    <td>指定声明的编程元素在基类中重新声明并隐藏相同名称的元素或一组重载元素。</td> 
   </tr> 
   <tr> 
    <td>30</td> 
    <td><code>Shared</code></td> 
    <td>指定一个或多个已声明的编程元素与整个类或结构关联，而不与类或结构的特定实例关联。</td> 
   </tr> 
   <tr> 
    <td>31</td> 
    <td><code>Static</code></td> 
    <td>指定一个或多个声明的局部变量将在声明它们的过程终止之后，继续存在并保留其最新值。</td> 
   </tr> 
   <tr> 
    <td>32</td> 
    <td><code>Unicode</code></td> 
    <td>指定Visual Basic应将所有字符串编组为<code>Unicode</code>值，而不管正在声明的外部过程的名称。</td> 
   </tr> 
   <tr> 
    <td>33</td> 
    <td><code>Widening</code></td> 
    <td>指示转换运算符(<code>CType</code>)将类或结构转换为可以保存原始类或结构的所有可能值的类型。</td> 
   </tr> 
   <tr> 
    <td>34</td> 
    <td><code>WithEvents</code></td> 
    <td>指定一个或多个声明的成员变量引用可引发事件的类的实例。</td> 
   </tr> 
   <tr> 
    <td>35</td> 
    <td><code>WriteOnly</code></td> 
    <td>指定可以写入属性但不能读取。</td> 
   </tr> 
  </tbody> 
 </table>
 <br>      
</div></body></html>