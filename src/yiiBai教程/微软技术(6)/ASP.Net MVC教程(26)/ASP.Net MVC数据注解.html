<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">ASP.Net MVC数据注解</h1><div style="width:100%;float:left;" class="article-content">   
 <p><code>DataAnnotations</code>用于配置模型类，它将突出显示最常用的配置。 <code>DataAnnotations</code>也被许多.NET应用程序所理解，例如ASP.NET MVC，它允许这些应用程序利用相同的注释来进行客户端验证。<code>DataAnnotation</code>属性重写默认的<code>Code-First</code>约定。</p> 
 <p><code>System.ComponentModel.DataAnnotations</code>包括以下影响列的可空性或大小的属性。</p> 
 <ul> 
  <li><em>Key</em></li>
  <li><em>Timestamp</em></li>
  <li><em>ConcurrencyCheck</em></li>
  <li><em>Required</em></li>
  <li><em>MinLength</em></li>
  <li><em>MaxLength</em></li>
  <li><em>StringLength</em></li>
 </ul> 
 <p><code>System.ComponentModel.DataAnnotations.Schema</code>命名空间包括以下影响数据库模式的属性。</p> 
 <ul> 
  <li><em>Table</em></li>
  <li><em>Column</em></li>
  <li><em>Index</em></li>
  <li><em>ForeignKey</em></li>
  <li><em>NotMapped</em></li>
  <li><em>InverseProperty</em></li>
 </ul> 
 <h2 id="h2-1-key-"><a name="1. 键(Key)" class="reference-link"></a><span class="header-link octicon octicon-link"></span>1. 键(Key)</h2>
 <p>实体框架(<em>Entity Framework</em>或简称为<em>EF</em> )依赖于具有用于跟踪实体的键值的每个实体。 <em>Code First</em>依赖的其中一个约定是它如何暗示哪个属性是每个<em>Code First</em>类中的键。</p> 
 <p>约定是寻找一个名为<code>Id</code>的属性，或者将类名和<code>Id</code>结合起来的属性，比如<code>StudentId</code>。 该属性将映射到数据库中的主键列。学生，课程和入学课程遵循这个约定。</p> 
 <p>现在让假设<code>Student</code>类使用名称<code>StdntID</code>而不是<code>ID</code>。 当<em>Code First</em>找不到符合此约定的属性时，它将抛出一个异常，因为<em>Entity Framework</em>要求必须具有一个键属性。</p> 
 <p>可以使用键注释来指定哪个属性将被用作<code>EntityKey</code>。</p> 
 <p>下面来看看包含<code>StdntID</code>的<code>Student</code>类。 它不遵循默认的<em>Code First</em>约定，所以要处理这个问题，添加了<code>Key</code>属性，使<code>StdntID</code>列成为主键。</p> 
 <pre><code class="lang-csharp">public class Student{
   [Key]
   public int StdntID { get; set; }
   public string LastName { get; set; }
   public string FirstMidName { get; set; }
   public DateTime EnrollmentDate { get; set; }

   public virtual ICollection&lt;Enrollment&gt; Enrollments { get; set; }
}
</code></pre> 
 <p>在运行应用程序并查看SQL Server资源管理器中的数据库时，您将看到现在<code>Students</code>表中的主键是：<code>StdntID</code>。<br><img src="http://www.yiibai.com/uploads/images/201712/1812/751091234_95098.jpg" alt=""></p> 
 <p>实体框架(<em>Entity Framework</em>)也支持复合键。 复合键是由多个属性组成的主键。例如，有一个<code>DrivingLicense</code>类，其主键是<code>LicenseNumber</code>和<code>IssuingCountry</code>的组合。</p> 
 <pre><code class="lang-csharp">public class DrivingLicense{
   [Key, Column(Order = 1)]
   public int LicenseNumber { get; set; }

   [Key, Column(Order = 2)]
   public string IssuingCountry { get; set; }
   public DateTime Issued { get; set; }
   public DateTime Expires { get; set; }
}
</code></pre> 
 <p>当有组合键时，实体框架要求你定义键属性的顺序。可以使用<code>Column</code>注释来指定顺序。<br><img src="http://www.yiibai.com/uploads/images/201712/1812/533091235_92808.jpg" alt=""></p> 
 <h2 id="h2-2-timestamp-"><a name="2. 时间戳(Timestamp)" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2. 时间戳(Timestamp)</h2>
 <p><em>Code First</em>会将<code>Timestamp</code>属性视为<code>ConcurrencyCheck</code>属性，但它也将确保<em>Code First</em>生成的数据库字段不可空。</p> 
 <p>使用<code>rowversion</code>或<code>timestamp</code>字段进行并发检查更为常见。但是，不要使用<code>ConcurrencyCheck</code>注释，只要属性的类型是字节数组，就可以使用更具体的<code>TimeStamp</code>注释。在给定的类中只能有一个时间戳属性。</p> 
 <p>下面来看一个简单的例子，将<code>TimeStamp</code>属性添加到<code>Course</code>类中。参考以下代码 - </p> 
 <pre><code class="lang-csharp">public class Course{
   public int CourseID { get; set; }
   public string Title { get; set; }
   public int Credits { get; set; }
   [Timestamp]
   public byte[] TStamp { get; set; }

   public virtual ICollection&lt;Enrollment&gt; Enrollments { get; set; }
}
</code></pre> 
 <p>如上例所示，<code>Timestamp</code>属性应用于<code>Course</code>类的<code>Byte []</code>属性。 所以，<em>Code First</em> 将在<code>Courses</code>表中创建一个时间戳列<code>TStamp</code>。</p> 
 <h2 id="h2-3-concurrencycheck"><a name="3. ConcurrencyCheck" class="reference-link"></a><span class="header-link octicon octicon-link"></span>3. ConcurrencyCheck</h2>
 <p><code>ConcurrencyCheck</code>注释允许在用户编辑或删除实体时标记一个或多个要用于数据库并发检查的属性。如果一直在使用<em>EF Designer</em>，那么这将与将属性的“并发性模式”设置为“固定”一致。</p> 
 <p>下面来看看一个简单的例子，通过将它添加<code>Title</code>属性到<code>Course</code>类中来了解<code>ConcurrencyCheck</code>是如何工作的。</p> 
 <pre><code class="lang-csharp">public class Course{
   public int CourseID { get; set; }

   [ConcurrencyCheck]
   public string Title { get; set; }
   public int Credits { get; set; }

   [Timestamp, DataType("timestamp")]
   public byte[] TimeStamp { get; set; }

   public virtual ICollection&lt;Enrollment&gt; Enrollments { get; set; }
}
</code></pre> 
 <p>在上面的<code>Course</code>类中，<code>ConcurrencyCheck</code>属性应用于现有的<code>Title</code>属性。<em> Code First</em>将在<code>update</code>命令中包含<code>Title</code>列来检查以下代码所示的乐观并发。</p> 
 <pre><code class="lang-sql">exec sp_executesql N'UPDATE [dbo].[Courses]
   SET [Title] = @0
   WHERE (([CourseID] = @1) AND ([Title] = @2))
   ',N'@0 nvarchar(max) ,@1 int,@2 nvarchar(max)
',@0 = N'Maths',@1 = 1,@2 = N'Calculus'
go
</code></pre> 
 <h2 id="h2-4-required"><a name="4. Required" class="reference-link"></a><span class="header-link octicon octicon-link"></span>4. Required</h2>
 <p><code>Required</code>注释告诉实体框架(<em>Entity Framework</em>)需要一个特定的属性。下面来看看<code>Student</code>类，其中必需的<code>id</code>被添加到<code>FirstMidName</code>属性中。 <code>Required</code>属性将强制<em>Entity Framework</em> 确保该属性中包含数据。</p> 
 <pre><code class="lang-csharp">public class Student{
   [Key]
   public int StdntID { get; set; }

   [Required]
   public string LastName { get; set; }

   [Required]
   public string FirstMidName { get; set; }
   public DateTime EnrollmentDate { get; set; }

   public virtual ICollection&lt;Enrollment&gt; Enrollments { get; set; }
}
</code></pre> 
 <p>可以在上面的<code>Student</code>类的示例中看到<code>Required</code>属性应用于<code>FirstMidName</code>和<code>LastName</code>。 因此，<em>Code First</em>将在<code>Students</code>表中创建一个<code>NOT NULL</code>的 <code>FirstMidName</code>和<code>LastName</code>列，如下图所示。<br><img src="http://www.yiibai.com/uploads/images/201712/1812/768091245_49437.jpg" alt=""></p> 
 <h2 id="h2-5-maxlength"><a name="5. MaxLength" class="reference-link"></a><span class="header-link octicon octicon-link"></span>5. MaxLength</h2>
 <p><code>MaxLength</code>属性用于指定其他属性验证。它可以应用于类的字符串或数组类型的属性。 <em>Entity Framework</em>的 <em>Code First</em> 将设置<code>MaxLength</code>属性中指定的列的大小。</p> 
 <p>下面来看看<code>MaxLength(24)</code>属性应用于<code>Title</code>属性的以下<code>Course</code>类。</p> 
 <pre><code class="lang-csharp">public class Course{
   public int CourseID { get; set; }
   [ConcurrencyCheck]
   [MaxLength(24)]

   public string Title { get; set; }
   public int Credits { get; set; }

   public virtual ICollection&lt;Enrollment&gt; Enrollments { get; set; }
}
</code></pre> 
 <p>当运行上述应用程序时，<em>Code-First</em>将在<code>Coursed</code>表中创建一个<code>nvarchar(24)</code>列标题，如以下屏幕截图所示。</p> 
 <p>现在当用户设置包含超过<code>24</code>个字符的标题时，<em>Entity Framework</em>将抛出<code>EntityValidationError</code>异常。</p> 
 <h2 id="h2-6-minlength"><a name="6. MinLength" class="reference-link"></a><span class="header-link octicon octicon-link"></span>6. MinLength</h2>
 <p><code>MinLength</code>属性可指定其他属性验证，就像上面使用的<code>MaxLength</code>属性一样。 <code>MinLength</code>属性也可以与<code>MaxLength</code>属性一起使用，如下面的代码所示。</p> 
 <pre><code class="lang-csharp">public class Course{
   public int CourseID { get; set; }
   [ConcurrencyCheck]
   [MaxLength(24) , MinLength(5)]
   public string Title { get; set; }
   public int Credits { get; set; }

   public virtual ICollection&lt;Enrollment&gt; Enrollments { get; set; }
}
</code></pre> 
 <p>如果在<code>MinLength</code>属性中将<code>Title</code>属性的值设置为小于指定的长度或大于<code>MaxLength</code>属性中的指定长度，则<em>EF</em>将抛出<code>EntityValidationError</code>异常。</p> 
 <h2 id="h2-7-stringlength"><a name="7. StringLength" class="reference-link"></a><span class="header-link octicon octicon-link"></span>7. StringLength</h2>
 <p><code>StringLength</code>还允许指定其他属性验证，如<code>MaxLength</code>。 不同的是<code>StringLength</code>属性只能应用于<code>Domain</code>类的字符串类型属性。参考以下示例代码 - </p> 
 <pre><code class="lang-csharp">public class Course{
   public int CourseID { get; set; }
   [StringLength (24)]
   public string Title { get; set; }
   public int Credits { get; set; }

   public virtual ICollection&lt;Enrollment&gt; Enrollments { get; set; }
}
</code></pre> 
 <p><em>Entity Framework</em>还验证<code>StringLength</code>属性的属性值。 现在，如果用户设置标题(<em>Title</em>)，其中包含超过<code>24</code>个字符，那么<em>EF</em>将抛出<code>EntityValidationError</code>异常。</p> 
 <h2 id="h2-8-table"><a name="8. Table" class="reference-link"></a><span class="header-link octicon octicon-link"></span>8. Table</h2>
 <p>默认代码第一个约定创建一个与类名相同的表名。 如果让<em>Code First</em>创建数据库，则还可以更改正在创建的表的名称。可以让<em>Code First</em>使用现有的数据库表。 但并不总是这样，有时类的名称与数据库中表的名称不能总是相匹配。</p> 
 <p><code>Table</code>属性重写此默认约定。 对于给定的域类，<em>EF Code First</em>将在<code>Table</code>属性使用指定的名称来创建一个表。</p> 
 <p>下面来看看一个类名为<code>Student</code>的例子，按照惯例，<em>Code First</em>假定这将映射到一个名为<code>Students</code>的表。 如果不是这种情况，可以使用<code>Table</code>属性指定表的名称，如以下代码所示 指定要创建的表名称为：<em>StudentInfo</em> -</p> 
 <pre><code class="lang-csharp">[Table("StudentsInfo")]
public class Student{
   [Key]
   public int StdntID { get; set; }

   [Required]
   public string LastName { get; set; }

   [Required]
   public string FirstMidName { get; set; }
   public DateTime EnrollmentDate { get; set; }

   public virtual ICollection&lt;Enrollment&gt; Enrollments { get; set; }
}
</code></pre> 
 <p>现在可以看到<code>Table</code>属性将表指定为<code>StudentsInfo</code>。 生成表时，如下图所示的表名<code>StudentInfo</code>。</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201712/1812/386091256_87515.jpg" alt=""></p> 
 <p>不仅可以指定表名，还可以使用以下代码使用<code>Table</code>属性指定表的模式。</p> 
 <pre><code class="lang-sql">[Table("StudentsInfo", Schema = "Admin")]

public class Student{
   [Key]
   public int StdntID { get; set; }

   [Required]
   public string LastName { get; set; }

   [Required]
   public string FirstMidName { get; set; }
   public DateTime EnrollmentDate { get; set; }

   public virtual ICollection&lt;Enrollment&gt; Enrollments { get; set; }
}
</code></pre> 
 <p>在上面的例子中，表被指定为<em>Admin</em>模式。 现在，<em>Code First</em>将在<em>Admin</em>模式中创建<code>StudentsInfo</code>表，如以下屏幕截图所示。<br><img src="http://www.yiibai.com/uploads/images/201712/1812/656101201_29566.jpg" alt=""></p> 
 <h2 id="h2-9-column"><a name="9. Column" class="reference-link"></a><span class="header-link octicon octicon-link"></span>9. Column</h2>
 <p><code>Column</code>属性也与<code>Table</code>属性相同，但<code>Table</code>属性覆盖表行为，而<code>Column</code>属性覆盖列行为。 默认代码第一个约定创建一个与属性名相同的列名。</p> 
 <p>如果让<em>Code First</em>创建数据库，并且还希望更改表中列的名称。<code>Column</code>属性重写此默认约定。 EF <em>Code First</em>将在给定类属性的<code>Column</code>属性中创建一个具有指定名称的列。</p> 
 <p>下面来看看下面的例子，其中属性名为<code>FirstMidName</code>，按照惯例，<em>Code First</em>假定这将映射到一个名为<code>FirstMidName</code>的列。 如果不是要映射到<code>FirstMidName</code>列时，可以使用<code>Column</code>属性指定其它列的名称，如以下代码所示。</p> 
 <pre><code class="lang-csharp">public class Student{
   public int ID { get; set; }
   public string LastName { get; set; }

   [Column("FirstName")]
   public string FirstMidName { get; set; }
   public DateTime EnrollmentDate { get; set; }

   public virtual ICollection&lt;Enrollment&gt; Enrollments { get; set; }
}
</code></pre> 
 <p>现在可以看到<code>Column</code>属性将列指定为<code>FirstName</code>。 生成表后，可以看到列名为<code>FirstName</code>，如以下屏幕截图所示。<br><img src="http://www.yiibai.com/uploads/images/201712/1812/396101205_62349.jpg" alt=""></p> 
 <h2 id="h2-10-index"><a name="10. Index" class="reference-link"></a><span class="header-link octicon octicon-link"></span>10. Index</h2>
 <p><code>Index</code>属性是在Entity Framework 6.1中引入的。</p> 
 <blockquote> 
  <p>注 - 如果您使用的是早期版本，则本节中的信息不适用。</p> 
 </blockquote> 
 <p>可以使用<code>Index</code>属性在一列或多列上创建索引。将属性添加到一个或多个属性将导致EF在创建数据库时在数据库中创建相应的索引。</p> 
 <p>在大多数情况下，索引使数据的检索更快，更高效。但是，使用索引重载表或视图可能会不愉快地影响其他操作(如插入或更新)的性能。</p> 
 <p>索引是实体框架中的新功能，可以通过减少从数据库查询数据所需的时间来提高<em>Code First</em>应用程序的性能。</p> 
 <p>可以使用<code>Index</code>属性将索引添加到数据库，并覆盖默认的“唯一”和“群集”设置，以获得最适合您的方案的索引。默认情况下，索引将被命名为<em>IX_&lt;属性名称&gt;</em></p> 
 <p>让我们来看看以下代码，其中<code>Index</code>属性被添加到<code>Course</code>类<code>Credits</code>列上。</p>   
 <pre><code class="lang-csharp">public class Cours{
   public int CourseID { get; set; }
   public string Title { get; set; }
   [Index]
   public int Credits { get; set; }

   public virtual ICollection&lt;Enrollment&gt; Enrollments { get; set; }
}
</code></pre> 
 <p>可以看到<code>Index</code>属性应用于<code>Credits</code>属性。 现在，当表生成时，将在索引中看到名称为<code>IX_Credits</code>的索引。<br><img src="http://www.yiibai.com/uploads/images/201712/1812/903101209_79391.jpg" alt=""></p> 
 <p>默认情况下，索引是非唯一的，但是可以使用<code>IsUnique</code>命名参数来指定索引应该是唯一的。 以下示例引入了一个唯一索引，如下面的代码所示。</p> 
 <pre><code class="lang-csharp">public class Course{
   public int CourseID { get; set; }
   [Index(IsUnique = true)]

   public string Title { get; set; }
   [Index]

   public int Credits { get; set; }

   public virtual ICollection&lt;Enrollment&gt; Enrollments { get; set; }
}
</code></pre> 
 <h2 id="h2-11-foreignkey"><a name="11. ForeignKey" class="reference-link"></a><span class="header-link octicon octicon-link"></span>11. ForeignKey</h2>
 <p><em>Code First</em>约定将处理模型中最常见的关系。 例如，通过更改<code>Student</code>类中的<code>key</code>属性名称，创建了与<code>Enrollment</code>类的关系问题。</p> 
 <pre><code class="lang-csharp">public class Enrollment{
   public int EnrollmentID { get; set; }
   public int CourseID { get; set; }
   public int StudentID { get; set; }
   public Grade? Grade { get; set; }
   public virtual Course Course { get; set; }
   public virtual Student Student { get; set; }
}

public class Student{
   [Key]
   public int StdntID { get; set; }
   public string LastName { get; set; }
   public string FirstMidName { get; set; }
   public DateTime EnrollmentDate { get; set; }

   public virtual ICollection&lt;Enrollment&gt; Enrollments { get; set; }
}
</code></pre> 
 <p>在生成数据库时，<em>Code First</em>会在<code>Enrollment</code>类中看到<code>StudentID</code>属性，并按照约定将其识别为类名称加<code>ID</code>，作为<code>Student</code>类的外键。但是<code>Student</code>类中没有<code>StudentID</code>属性，而是<code>Student</code>类中的<code>StdntID</code>属性。</p> 
 <p>解决方法是在<code>Enrollment</code>中创建导航属性，并使用<code>ForeignKey DataAnnotation</code>来帮助<em>Code First</em>了解如何构建两个类之间的关系，如以下代码所示。</p> 
 <pre><code class="lang-csharp">public class Enrollment{
   public int EnrollmentID { get; set; }
   public int CourseID { get; set; }
   public int StudentID { get; set; }
   public Grade? Grade { get; set; }
   public virtual Course Course { get; set; }

   [ForeignKey("StudentID")]
   public virtual Student Student { get; set; }
}
</code></pre> 
 <p>现在可以看到<code>ForeignKey</code>属性应用于导航属性。<br><img src="http://www.yiibai.com/uploads/images/201712/1812/919101214_13480.jpg" alt=""></p> 
 <h2 id="h2-12-notmapped"><a name="12. NotMapped" class="reference-link"></a><span class="header-link octicon octicon-link"></span>12. NotMapped</h2>
 <p><em>Code First</em>的约定在默认情况下，每个属于受支持数据类型的属性都包含<code>getter</code>和<code>setter</code>，它们在数据库中表示。 但是在应用中并不总是这样。 <code>NotMapped</code>属性将覆盖此默认约定。 例如，可能在<code>Student</code>类中有一个属性，例如<code>FatherName</code>，但不需要存储它到数据库表。 那么可以将<code>NotMapped</code>属性应用于您不希望在数据库中创建列的<code>FatherName</code>属性。 以下是代码。</p> 
 <pre><code class="lang-csharp">public class Student{
   [Key]
   public int StdntID { get; set; }
   public string LastName { get; set; }
   public string FirstMidName { get; set; }
   public DateTime EnrollmentDate { get; set; }
   [NotMapped]
   public int FatherName { get; set; }

   public virtual ICollection&lt;Enrollment&gt; Enrollments { get; set; }
}
</code></pre> 
 <p>可以看到<code>NotMapped</code>属性应用于<code>FatherName</code>属性。 现在，当生成表时，将看到<code>FatherName</code>列不会在数据库中创建，但它存在于<code>Student</code>类中。<br><img src="http://www.yiibai.com/uploads/images/201712/1812/218101216_43489.jpg" alt=""></p> 
 <p><em>Code First</em> 不会为没有<code>getter</code>或<code>setter</code>的属性创建一个列。</p> 
 <h2 id="h2-13-inverseproperty"><a name="13. InverseProperty" class="reference-link"></a><span class="header-link octicon octicon-link"></span>13. InverseProperty</h2>
 <p>在类之间有多个关系时使用<code>InverseProperty</code>。 在<code>Enrollment</code>类中，可能想要跟踪注册“当前课程”的人员和注册“以前课程”的人员。</p> 
 <p>我们为<code>Enrollment</code>类添加两个导航属性。</p> 
 <pre><code class="lang-csharp">public class Enrollment{
   public int EnrollmentID { get; set; }
   public int CourseID { get; set; }
   public int StudentID { get; set; }
   public Grade? Grade { get; set; }

   public virtual Course CurrCourse { get; set; }
   public virtual Course PrevCourse { get; set; }
   public virtual Student Student { get; set; }
}
</code></pre> 
 <p>同样，还需要添加这些属性引用<code>Course</code>类。 <code>Course</code>类的导航属性返回到<code>Enrollment</code>类，其中包含当前和以前的所有注册。</p> 
 <pre><code class="lang-csharp">public class Course{
   public int CourseID { get; set; }
   public string Title { get; set; }
   [Index]

   public int Credits { get; set; }
   public virtual ICollection&lt;Enrollment&gt; CurrEnrollments { get; set; }
   public virtual ICollection&lt;Enrollment&gt; PrevEnrollments { get; set; }
}
</code></pre> 
 <p>如果外键属性未包含在上述类中所示的特定类中，<em>Code First</em>会创建<code>{Class Name} _ {Primary Key}</code>外键列。 生成数据库表时，您将看到许多外键，如以下屏幕截图所示。</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201712/1812/895101219_34247.jpg" alt=""></p> 
 <p>正如所看到的<em>Code First</em> 无法自己匹配两个类的属性。 用于<code>Enrollments</code>的数据库表应该有一个用于<code>CurrCourse</code>的外键和一个用于<code>PrevCourse</code>的外键，但<em>Code First</em> 将创建四个外键属性，即 -</p> 
 <ul> 
  <li><em>CurrCourse_CourseID</em></li>
  <li><em>PrevCourse_CourseID</em></li>
  <li><em>Course_CourseID</em></li>
  <li><em>Course_CourseID1</em></li>
 </ul> 
 <p>要解决这些问题，可以使用<code>InverseProperty</code>注解来指定属性的对齐方式。</p> 
 <pre><code class="lang-csharp">public class Course{
   public int CourseID { get; set; }
   public string Title { get; set; }

   [Index]
   public int Credits { get; set; }

   [InverseProperty("CurrCourse")]
   public virtual ICollection&lt;Enrollment&gt; CurrEnrollments { get; set; }

   [InverseProperty("PrevCourse")]
   public virtual ICollection&lt;Enrollment&gt; PrevEnrollments { get; set; }
}
</code></pre> 
 <p>正如上面所看到的那样，当<code>InverseProperty</code>属性通过指定它所属的<code>Enrollment</code>类的哪个引用属性应用于上述<code>Course</code>类时，<em>Code First</em>将生成数据库表，并在<code>Enrollments</code>表中创建两个外键列，如以下屏幕截图所示。<br><img src="http://www.yiibai.com/uploads/images/201712/1812/576101223_96604.jpg" alt=""></p> 
 <p>我们建议执行上述示例以便更好地理解。</p>
 <br>      
</div></body></html>