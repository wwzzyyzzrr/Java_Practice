<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">git reset命令</h1><div style="width:100%;float:left;" class="article-content">   
 <p><code>git reset</code>命令用于将当前<code>HEAD</code>复位到指定状态。一般用于撤消之前的一些操作(如：<code>git add</code>,<code>git commit</code>等)。</p> 
 <p><strong>简介</strong></p> 
 <pre><code class="lang-shell">git reset [-q] [&lt;tree-ish&gt;] [--] &lt;paths&gt;…​
git reset (--patch | -p) [&lt;tree-ish&gt;] [--] [&lt;paths&gt;…​]
git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [&lt;commit&gt;]
</code></pre> 
 <h2 id="h2-u63CFu8FF0"><a name="描述" class="reference-link"></a><span class="header-link octicon octicon-link"></span>描述</h2>
 <p>在第一和第二种形式中，将条目从<code>&lt;tree-ish&gt;</code>复制到索引。 在第三种形式中，将当前分支头(<code>HEAD</code>)设置为<code>&lt;commit&gt;</code>，可选择修改索引和工作树进行匹配。所有形式的<code>&lt;tree-ish&gt;/&lt;commit&gt;</code>默认为 <code>HEAD</code> 。</p> 
 <p>这里的 <code>HEAD</code> 关键字指的是当前分支最末梢最新的一个提交。也就是版本库中该分支上的最新版本。</p> 
 <h2 id="h2-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h2>
 <p>以下是一些示例 -</p> 
 <p>在git的一般使用中，如果发现错误的将不想暂存的文件被<code>git add</code>进入索引之后，想回退取消，则可以使用命令：<code>git reset HEAD &lt;file&gt;</code>，同时<code>git add</code>完毕之后，git也会做相应的提示，比如：</p> 
 <pre><code class="lang-shell"># Changes to be committed: 
#   (use "git reset HEAD &lt;file&gt;..." to unstage) 
# 
# new file:   test.py
</code></pre> 
 <p><code>git reset [--hard|soft|mixed|merge|keep] [&lt;commit&gt;或HEAD]</code>：将当前的分支重设(<code>reset</code>)到指定的<code>&lt;commit&gt;</code>或者<code>HEAD</code>(默认，如果不显示指定<code>&lt;commit&gt;</code>，默认是<code>HEAD</code>，即最新的一次提交)，并且根据<code>[mode]</code>有可能更新索引和工作目录。<code>mode</code>的取值可以是<code>hard</code>、<code>soft</code>、<code>mixed</code>、<code>merged</code>、<code>keep</code>。下面来详细说明每种模式的意义和效果。</p> 
 <p>A). <code>--hard</code>：重设(reset) 索引和工作目录，自从<code>&lt;commit&gt;</code>以来在工作目录中的任何改变都被丢弃，并把HEAD指向<code>&lt;commit&gt;</code>。 </p> 
 <p>下面是具体一个例子，假设有三个commit， 执行 <code>git status</code>结果如下:</p> 
 <pre><code class="lang-shell">commit3: add test3.c
commit2: add test2.c
commit1: add test1.c
</code></pre> 
 <p>执行<code>git reset --hard HEAD~1</code>命令后，<br>显示：<code>HEAD is now at commit2</code>，运行<code>git log</code>，如下所示 - </p> 
 <pre><code class="lang-shell">commit2: add test2.c
commit1: add test1.c
</code></pre> 
 <h2 id="h2-u5E94u7528u573Au666F"><a name="应用场景" class="reference-link"></a><span class="header-link octicon octicon-link"></span>应用场景</h2>
 <p>下面列出一些git reset的典型的应用场景： </p> 
 <p><strong>(A) 回滚添加操作 </strong></p> 
 <pre><code class="lang-shell">$ edit    file1.c file2.c           # (1) 
$ git add file1.c file1.c           # (1.1) 添加两个文件到暂存
$ mailx                             #  (2) 
$ git reset                           # (3) 
$ git pull git://info.example.com/ nitfol    # (4)
</code></pre> 
 <p>(1). 编辑文件 <code>file1.c</code>, <code>file2.c</code>，做了些更改，并把更改添加到了暂存区。<br>(2). 查看邮件，发现某人要您执行<code>git pull</code>，有一些改变需要合并下来。<br>(3). 然而，您已经把暂存区搞乱了，因为暂存区同HEAD commit不匹配了，但是即将<code>git pull</code>下来的东西不会影响已经修改的<code>file1.c</code> 和 <code>file2.c</code>，因此可以<code>revert</code>这两个文件的改变。在revert后，那些改变应该依旧在工作目录中，因此执行<code>git reset</code>。<br>(4). 然后，执行了<code>git pull</code>之后，自动合并，<code>file1.c</code> 和 <code>file2.c</code>这些改变依然在工作目录中。 </p> 
 <p><strong>(B)回滚最近一次提交</strong></p> 
 <pre><code class="lang-shell">$ git commit -a -m "这是提交的备注信息"
$ git reset --soft HEAD^      #(1) 
$ edit code                        #(2) 编辑代码操作
$ git commit -a -c ORIG_HEAD  #(3)
</code></pre> 
 <p>(1) 当提交了之后，又发现代码没有提交完整，或者想重新编辑一下提交的信息，可执行<code>git reset --soft HEAD^</code>，让工作目录还跟<code>reset</code>之前一样，不作任何改变。<br><code>HEAD^</code>表示指向<code>HEAD</code>之前最近的一次提交。<br>(2) 对工作目录下的文件做修改，比如：修改文件中的代码等。<br>(3) 然后使用<code>reset</code>之前那次提交的注释、作者、日期等信息重新提交。注意，当执行<code>git reset</code>命令时，git会把老的HEAD拷贝到文件<code>.git/ORIG_HEAD</code>中，在命令中可以使用ORIG_HEAD引用这个提交。<code>git commit</code> 命令中 <code>-a</code>参数的意思是告诉git，自动把所有修改的和删除的文件都放进暂存区，未被git跟踪的新建的文件不受影响。<code>commit</code>命令中<code>-c &lt;commit&gt;</code> 或者 <code>-C &lt;commit&gt;</code>意思是拿已经提交的对象中的信息(作者，提交者，注释，时间戳等)提交，那么这条<code>git commit</code> 命令的意思就非常清晰了，把所有更改的文件加入暂存区，并使用上次的提交信息重新提交。 </p> 
 <p><strong>(C) 回滚最近几次提交，并把这几次提交放到指定分支中</strong></p> 
 <p>回滚最近几次提交，并把这几次提交放到叫做<code>topic/wip</code>的分支上去。</p> 
 <pre><code class="lang-shell">$ git branch topic/wip     (1) 
$ git reset --hard HEAD~3  (2) 
$ git checkout topic/wip   (3)
</code></pre> 
 <p>(1) 假设已经提交了一些代码，但是此时发现这些提交还不够成熟，不能进入<code>master</code>分支，希望在新的<code>branch</code>上暂存这些改动。因此执行了<code>git branch</code>命令在当前的HEAD上建立了新的叫做 <code>topic/wip</code> 的分支。<br>(2) 然后回滚<code>master</code>分支上的最近三次提交。<code>HEAD~3</code>指向当前<code>HEAD-3</code>个提交，<code>git reset --hard HEAD~3</code>，即删除最近的三个提交(删除<code>HEAD</code>, <code>HEAD^</code>, <code>HEAD~2</code>)，将HEAD指向<code>HEAD~3</code>。 </p> 
 <p><strong>(D) 永久删除最后几个提交</strong></p> 
 <pre><code class="lang-shell">$ git commit ## 执行一些提交
$ git reset --hard HEAD~3   (1)
</code></pre> 
 <p>(1) 最后三个提交(即<code>HEAD</code>, <code>HEAD^</code>和<code>HEAD~2</code>)提交有问题，想永久删除这三个提交。 </p> 
 <p><strong>(E) 回滚merge和pull操作 </strong></p> 
 <pre><code class="lang-shell">$ git pull                         (1) 
Auto-merging nitfol 
CONFLICT (content): Merge conflict in nitfol 
Automatic merge failed; fix conflicts and then commit the result. 
$ git reset --hard                 (2) 
$ git pull . topic/branch          (3) 
Updating from 41223... to 13134... 
Fast-forward 
$ git reset --hard ORIG_HEAD       (4)
`
</code></pre> 
 <p>(1) 从<code>origin</code>拉取下来一些更新，但是产生了很多冲突，但您暂时没有这么多时间去解决这些冲突，因此决定稍候有空的时候再重新执行<code>git pull</code>操作。<br>(2) 由于<code>git pull</code>操作产生了冲突，因此所有拉取下来的改变尚未提交，仍然再暂存区中，这种情况下<code>git reset --hard</code> 与 <code>git reset --hard HEAD</code>意思相同，即都是清除索引和工作区中被搞乱的东西。<br>(3) 将<code>topic/branch</code>分支合并到当前的分支，这次没有产生冲突，并且合并后的更改自动提交。<br>(4) 但是此时又发现将<code>topic/branch</code>合并过来为时尚早，因此决定退滚合并，执行<code>git reset --hard ORIG_HEAD</code>回滚刚才的<code>pull/merge</code>操作。说明：前面讲过，执行<code>git reset</code>时，git会把<code>reset</code>之前的HEAD放入<code>.git/ORIG_HEAD</code>文件中，命令行中使用ORIG_HEAD引用这个提交。同样的，执行<code>git pull</code>和<code>git merge</code>操作时，git都会把执行操作前的HEAD放入<code>ORIG_HEAD</code>中，以防回滚操作。 </p> 
 <p><strong>(F) 在污染的工作区中回滚合并或者拉取 </strong></p>   
 <pre><code class="lang-shell">$ git pull                         (1) 
Auto-merging nitfol 
Merge made by recursive. 
nitfol                |   20 +++++---- 
... 
$ git reset --merge ORIG_HEAD      (2)
</code></pre> 
 <p>(1) 即便你已经在本地更改了工作区中的一些东西，可安全的执行<code>git pull</code>操作，前提是要知道将要<code>git pull</code>下面的内容不会覆盖工作区中的内容。<br>(2) <code>git pull</code>完后，发现这次拉取下来的修改不满意，想要回滚到<code>git pull</code>之前的状态，从前面的介绍知道，我们可以执行<code>git reset --hard ORIG_HEAD</code>，但是这个命令有个副作用就是清空工作区，即丢弃本地未使用<code>git add</code>的那些改变。为了避免丢弃工作区中的内容，可以使用<code>git reset --merge ORIG_HEAD</code>，注意其中的<code>--hard</code> 换成了 <code>--merge</code>，这样就可以避免在回滚时清除工作区。 </p> 
 <p><strong>(G) 中断的工作流程处理 </strong></p> 
 <p>在实际开发中经常出现这样的情形：你正在开发一个大的新功能(工作在分支：<code>feature</code> 中)，此时来了一个紧急的bug需要修复，但是目前在工作区中的内容还没有成型，还不足以提交，但是又必须切换的另外的分支去修改bug。请看下面的例子 - </p> 
 <pre><code class="lang-shell">$ git checkout feature ;# you were working in "feature" branch and 
$ work work work       ;# got interrupted 
$ git commit -a -m "snapshot WIP"                 (1) 
$ git checkout master 
$ fix fix fix 
$ git commit ;# commit with real log 
$ git checkout feature 
$ git reset --soft HEAD^ ;# go back to WIP state  (2) 
$ git reset                                       (3)
</code></pre> 
 <p>(1) 这次属于临时提交，因此随便添加一个临时注释即可。<br>(2) 这次<code>reset</code>删除了WIP commit，并且把工作区设置成提交WIP快照之前的状态。<br>(3) 此时，在索引中依然遗留着“<em>snapshot WIP</em>”提交时所做的未提交变化，<code>git reset</code>将会清理索引成为尚未提交”<em>snapshot WIP</em>“时的状态便于接下来继续工作。 </p> 
 <p><strong>(H) 重置单独的一个文件 </strong></p> 
 <p>假设你已经添加了一个文件进入索引，但是而后又不打算把这个文件提交，此时可以使用<code>git reset</code>把这个文件从索引中去除。</p> 
 <pre><code class="lang-shell">$ git reset -- frotz.c                      (1) 
$ git commit -m "Commit files in index"     (2) 
$ git add frotz.c                           (3)
</code></pre> 
 <p>(1) 把文件<code>frotz.c</code>从索引中去除，<br>(2) 把索引中的文件提交<br>(3) 再次把<code>frotz.c</code>加入索引</p> 
 <p><strong>(I) 保留工作区并丢弃一些之前的提交 </strong></p> 
 <p>假设你正在编辑一些文件，并且已经提交，接着继续工作，但是现在你发现当前在工作区中的内容应该属于另一个分支，与之前的提交没有什么关系。此时，可以开启一个新的分支，并且保留着工作区中的内容。 </p> 
 <pre><code class="lang-shell">$ git tag start 
$ git checkout -b branch1 
$ edit 
$ git commit ...                            (1) 
$ edit 
$ git checkout -b branch2                   (2) 
$ git reset --keep start                    (3)
</code></pre> 
 <p>(1) 这次是把在<code>branch1</code>中的改变提交了。<br>(2) 此时发现，之前的提交不属于这个分支，此时新建了<code>branch2</code>分支，并切换到了<code>branch2</code>上。<br>(3) 此时可以用<code>reset --keep</code>把在<code>start</code>之后的提交清除掉，但是保持工作区不变。 </p>
 <br>      
</div></body></html>