<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">git add命令</h1><div style="width:100%;float:left;" class="article-content">   
 <p><code>git add</code>命令将文件内容添加到索引(将修改添加到暂存区)。也就是将要提交的文件的信息添加到索引库中。</p> 
 <p><strong>简介</strong></p> 
 <pre><code class="lang-shell">git add [--verbose | -v] [--dry-run | -n] [--force | -f] [--interactive | -i] [--patch | -p]
      [--edit | -e] [--[no-]all | --[no-]ignore-removal | [--update | -u]]
      [--intent-to-add | -N] [--refresh] [--ignore-errors] [--ignore-missing]
      [--chmod=(+|-)x] [--] [&lt;pathspec&gt;…​]
</code></pre> 
 <h2 id="h2-u63CFu8FF0"><a name="描述" class="reference-link"></a><span class="header-link octicon octicon-link"></span>描述</h2>
 <p>此命令将要提交的文件的信息添加到索引库中(将修改添加到暂存区)，以准备为下一次提交分段的内容。 它通常将现有路径的当前内容作为一个整体添加，但是通过一些选项，它也可以用于添加内容，只对所应用的工作树文件进行一些更改，或删除工作树中不存在的路径了。</p> 
 <p>“索引”保存工作树内容的快照，并且将该快照作为下一个提交的内容。 因此，在对工作树进行任何更改之后，并且在运行<code>git commit</code>命令之前，必须使用<code>git add</code>命令将任何新的或修改的文件添加到索引。</p> 
 <p>该命令可以在提交之前多次执行。它只在运行<code>git add</code>命令时添加指定文件的内容; 如果希望随后的更改包含在下一个提交中，那么必须再次运行<code>git add</code>将新的内容添加到索引。</p> 
 <p><code>git status</code>命令可用于获取哪些文件具有为下一次提交分段的更改的摘要。</p> 
 <p>默认情况下，<code>git add</code>命令不会添加忽略的文件。 如果在命令行上显式指定了任何忽略的文件，<code>git add</code>命令都将失败，并显示一个忽略的文件列表。由Git执行的目录递归或文件名遍历所导致的忽略文件将被默认忽略。 <code>git add</code>命令可以用<code>-f(force)</code>选项添加被忽略的文件。</p> 
 <h2 id="h2-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h2>
 <p>以下是一些示例 -</p> 
 <p>添加<code>documentation</code>目录及其子目录下所有<code>*.txt</code>文件的内容：</p> 
 <pre><code class="lang-shell">$ git add documentation/*.txt
</code></pre> 
 <blockquote> 
  <p>注意，在这个例子中，星号<code>*</code>是从shell引用的; 这允许命令包含来自 <code>Documentation/</code>目录和子目录的文件。</p> 
 </blockquote> 
 <p>将所有 <code>git-*.sh</code> 脚本内容添加：</p> 
 <pre><code class="lang-shell">$ git add git-*.sh
</code></pre> 
 <p>因为这个例子让shell扩展星号(即明确列出文件)，所以它不考虑子目录中的文件，如：<code>subdir/git-foo.sh</code> 这样的文件不会被添加。</p> 
 <p><strong>基本用法</strong></p> 
 <pre><code class="lang-shell">git add &lt;path&gt;
</code></pre> 
 <p>通常是通过<code>git add &lt;path&gt;</code>的形式把<code>&lt;path&gt;</code>添加到索引库中，<code>&lt;path&gt;</code>可以是文件也可以是目录。</p> 
 <p>git不仅能判断出<code>&lt;path&gt;</code>中，修改(不包括已删除)的文件，还能判断出新添的文件，并把它们的信息添加到索引库中。</p>   
 <pre><code class="lang-shell">$ git add .  # 将所有修改添加到暂存区
$ git add *  # Ant风格添加修改
$ git add *Controller   # 将以Controller结尾的文件的所有修改添加到暂存区

$ git add Hello*   # 将所有以Hello开头的文件的修改添加到暂存区 例如:HelloWorld.txt,Hello.java,HelloGit.txt ...

$ git add Hello?   # 将以Hello开头后面只有一位的文件的修改提交到暂存区 例如:Hello1.txt,HelloA.java 如果是HelloGit.txt或者Hello.java是不会被添加的
</code></pre> 
 <p><code>git add -u [&lt;path&gt;]</code>: 把<code>&lt;path&gt;</code>中所有跟踪文件中被修改过或已删除文件的信息添加到索引库。它不会处理那些不被跟踪的文件。省略<code>&lt;path&gt;</code>表示 <code>.</code> ,即当前目录。</p> 
 <p><code>git add -A</code>: [
  <path>
   ]表示把
   <path>
    中所有跟踪文件中被修改过或已删除文件和所有未跟踪的文件信息添加到索引库。省略
    <code>&lt;path&gt;</code>表示 
    <code>.</code> ,即当前目录。
   </path>
  </path></p> 
 <p><code>git add -i</code></p> 
 <p>我们可以通过<code>git add -i [&lt;path&gt;]</code>命令查看
  <path>
   中被所有修改过或已删除文件但没有提交的文件，并通过其
   <code>revert</code>子命令可以查看
   <code>&lt;path&gt;</code>中所有未跟踪的文件，同时进入一个子命令系统。
  </path></p> 
 <p>比如：</p> 
 <pre><code class="lang-shell">$ git add -i
           staged     unstaged path
  1:        +0/-0      nothing branch/t.txt
  2:        +0/-0      nothing branch/t2.txt
  3:    unchanged        +1/-0 readme.txt

*** Commands ***
  1: [s]tatus     2: [u]pdate     3: [r]evert     4: [a]dd untracked
  5: [p]atch      6: [d]iff       7: [q]uit       8: [h]elp
</code></pre> 
 <p>这里的<code>t.txt</code>和<code>t2.txt</code>表示已经被执行了<code>git add</code>，待提交。即已经添加到索引库中。<br><code>readme.txt</code>表示已经处于tracked下，它被修改了，但是还没有执行<code>git add</code>。即还没添加到索引库中。</p>
 <br>      
</div></body></html>