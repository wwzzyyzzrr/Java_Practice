<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">git checkout命令</h1><div style="width:100%;float:left;" class="article-content">   
 <p><code>git checkout</code>命令用于切换分支或恢复工作树文件。<code>git checkout</code>是git最常用的命令之一，同时也是一个很危险的命令，因为这条命令会重写工作区。</p> 
 <p><strong>使用语法</strong></p> 
 <pre><code class="lang-shell">git checkout [-q] [-f] [-m] [&lt;branch&gt;]
git checkout [-q] [-f] [-m] --detach [&lt;branch&gt;]
git checkout [-q] [-f] [-m] [--detach] &lt;commit&gt;
git checkout [-q] [-f] [-m] [[-b|-B|--orphan] &lt;new_branch&gt;] [&lt;start_point&gt;]
git checkout [-f|--ours|--theirs|-m|--conflict=&lt;style&gt;] [&lt;tree-ish&gt;] [--] &lt;paths&gt;…​
git checkout [-p|--patch] [&lt;tree-ish&gt;] [--] [&lt;paths&gt;…]
</code></pre> 
 <h2 id="h2-u63CFu8FF0"><a name="描述" class="reference-link"></a><span class="header-link octicon octicon-link"></span>描述</h2>
 <p>更新工作树中的文件以匹配索引或指定树中的版本。如果没有给出路径 - <code>git checkout</code>还会更新<code>HEAD</code>，将指定的分支设置为当前分支。</p> 
 <h2 id="h2-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h2>
 <p>以下是一些示例 -</p> 
 <p><strong>示例-1</strong></p> 
 <p>以下顺序检查主分支，将<code>Makefile</code>还原为两个修订版本，错误地删除<code>hello.c</code>，并从索引中取回。</p> 
 <pre><code class="lang-shell">$ git checkout master             #(1)
$ git checkout master~2 Makefile  #(2)
$ rm -f hello.c
$ git checkout hello.c            #(3)
</code></pre> 
 <p>(1) 切换分支<br>(2) 从另一个提交中取出文件<br>(3)从索引中恢复<code>hello.c</code></p> 
 <p>如果想要检出索引中的所有<code>C</code>源文件，可以使用以下命令 - </p> 
 <pre><code class="lang-shell">$ git checkout -- '*.c'
</code></pre> 
 <p>注意:<code>*.c</code>是使用引号的。 文件<code>hello.c</code>也将被检出，即使它不再在工作树中，因为文件<code>globbing</code>用于匹配索引中的条目(而不是在shell的工作树中)。</p> 
 <p>如果有一个分支也命名为<em>hello.c</em>，这一步将被混淆为一个指令切换到该分支。应该写：</p> 
 <pre><code class="lang-shell">$ git checkout -- hello.c
</code></pre> 
 <p><strong>示例-2</strong></p> 
 <p>在错误的分支工作后，想切换到正确的分支，则使用：</p> 
 <pre><code class="lang-shell">$ git checkout mytopic
</code></pre> 
 <p>但是，您的“错误”分支和正确的“<code>mytopic</code>”分支可能会在在本地修改的文件中有所不同，在这种情况下，上述检出将会失败：</p> 
 <pre><code class="lang-shell">$ git checkout mytopic
error: You have local changes to 'frotz'; not switching branches.
</code></pre> 
 <p>可以将<code>-m</code>标志赋给命令，这将尝试三路合并：</p>   
 <pre><code class="lang-shell">$ git checkout -m mytopic
Auto-merging frotz
</code></pre> 
 <p>在这种三路合并之后，本地的修改没有在索引文件中注册，所以<code>git diff</code>会显示从新分支的提示之后所做的更改。</p> 
 <p><strong>示例-3</strong></p> 
 <p>当使用<code>-m</code>选项切换分支时发生合并冲突时，会看到如下所示：</p> 
 <pre><code class="lang-shell">$ git checkout -m mytopic
Auto-merging frotz
ERROR: Merge conflict in frotz
fatal: merge program failed
</code></pre> 
 <p>此时，<code>git diff</code>会显示上一个示例中干净合并的更改以及冲突文件中的更改。 编辑并解决冲突，并用常规方式用<code>git add</code>来标记它：</p> 
 <pre><code class="lang-shell">$ edit frotz # 编辑 frotz 文件中内容，然后重新添加
$ git add frotz
</code></pre> 
 <p><strong>其它示例</strong></p> 
 <p><code>git checkout</code>的主要功能就是迁出一个分支的特定版本。默认是迁出分支的HEAD版本<br>一此用法示例：</p> 
 <pre><code class="lang-shell">$ git checkout master     #//取出master版本的head。
$ git checkout tag_name    #//在当前分支上 取出 tag_name 的版本
$ git checkout  master file_name  #//放弃当前对文件file_name的修改
$ git checkout  commit_id file_name  #//取文件file_name的 在commit_id是的版本。commit_id为 git commit 时的sha值。

$ git checkout -b dev/1.5.4 origin/dev/1.5.4

# 从远程dev/1.5.4分支取得到本地分支/dev/1.5.4
$ git checkout -- hello.rb
#这条命令把hello.rb从HEAD中签出.
$ git checkout .
#这条命令把 当前目录所有修改的文件 从HEAD中签出并且把它恢复成未修改时的样子.
#注意：在使用 git checkout 时，如果其对应的文件被修改过，那么该修改会被覆盖掉。
</code></pre>
 <br>      
</div></body></html>