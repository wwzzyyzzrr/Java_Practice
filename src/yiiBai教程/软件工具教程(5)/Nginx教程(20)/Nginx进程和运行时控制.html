<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Nginx进程和运行时控制</h1><div style="width:100%;float:left;" class="article-content">   
 <p>本节介绍NGINX在运行时启动的过程以及如何控制它们。</p> 
 <p>在这个部分中，主要涉及两个部分的内容：</p> 
 <ul> 
  <li>主进程和工作进程</li>
  <li>控制NGINX</li>
 </ul> 
 <h2 id="h2-1-"><a name="1. 主进程和工作进程" class="reference-link"></a><span class="header-link octicon octicon-link"></span>1. 主进程和工作进程</h2>
 <p>NGINX有一个主进程和一个或多个工作进程。 如果启用缓存，缓存加载程序和缓存管理器进程也将在启动时运行。<br>主程序的主要目的是读取和评估配置文件以及维护工作进程。</p> 
 <p>工作进程执行请求的实际处理。 NGINX依赖于操作系统的机制来有效地在工作进程之间分配请求。 工作进程的数量可在<code>nginx.conf</code>配置文件中定义，可以针对给定的配置进行修复，或者自动调整为可用CPU内核数(请参阅<a target="_blank" href="http://nginx.org/en/docs/ngx_core_module.html?&amp;_ga=1.19081464.1509956953.1490042234#worker_processes" title="worker_processes">worker_processes</a>)。</p> 
 <h2 id="h2-2-nginx"><a name="2. 控制NGINX" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2. 控制NGINX</h2>
 <p>要重新加载配置文件，可以停止或重新启动NGINX，或者发送信号到主进程。 可以使用<code>-s</code>参数运行nginx命令(调用NGINX可执行文件)来发送信号。</p> 
 <pre><code>nginx -s signal
</code></pre>
 <p>信号的值可以是以下之一：</p> 
 <ul> 
  <li><code>quit</code> – 正常地关闭</li>
  <li><code>reload</code> – 重新加载配置文件</li>
  <li><code>reopen</code> – 重新打开日志文件</li>
  <li><code>stop</code> – 立即关闭(快速关闭)</li>
 </ul> 
 <p>杀死实用程序也可以使用，将信号直接发送到主进程。 默认情况下，主进程的进程ID被写入位于<code>/usr/local/nginx/logs</code>或<code>/var/run</code>目录中的<code>nginx.pid</code>文件。<br>nginx可以用信号控制。 默认情况下，主进程的进程ID将写入文件<code>/usr/local/nginx/logs/nginx.pid</code>。 该名称可能在配置时更改，或使用<code>pid</code>指令在<code>nginx.conf</code>文件中进行更改。主程序支持以下信号：</p> 
 <ul> 
  <li><code>TERM</code>, <code>INT</code> - 快速关闭</li>
  <li><code>QUIT</code> - 正常关闭</li>
  <li><code>HUP</code> - 改变配置，跟上改变的时区(仅适用于FreeBSD和Linux)，使用新配置启动新的工作进程，正常关闭旧的工作进程</li>
  <li><code>USR1</code> - 重新打开日志文件</li>
  <li><code>USR2</code> - 升级可执行文件</li>
  <li><code>WINCH</code> - 正常关闭工作进程</li>
 </ul> 
 <p>个别工作进程可以用信号来控制，尽管这不是必需的。 支持的信号有：</p> 
 <ul> 
  <li>TERM, INT - 快速关闭</li>
  <li>QUIT - 正常关闭</li>
  <li>USR1 - 重新打开日志文件</li>
  <li>WINCH - 调试异常终止(需要启用<code>debug_points</code>)</li>
 </ul> 
 <p><strong>更改配置</strong></p> 
 <p>为了使nginx重新读取配置文件，应将HUP信号发送到主进程。 主进程首先检查语法有效性，然后尝试应用新配置，即打开日志文件和新的监听套接字。 如果失败，它会回滚更改，并继续使用旧配置。 如果此操作成功，它将启动新的工作进程，并向旧的工作进程发送消息，请求它们正常关闭。 旧工作进程密切监听套接字，并继续为旧客户端服务。 在所有客户端被服务之后，旧的工作进程被关闭。</p> 
 <p>我们来举例说明一下。 想象一下，nginx是在FreeBSD 4.x上运行，执行以下命令：</p>   
 <pre><code>ps axw -o pid,ppid,user,%cpu,vsz,wchan,command | egrep '(nginx|PID)'
</code></pre>
 <p>产生以下输出：</p> 
 <pre><code>  PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
33126     1 root     0.0  1148 pause  nginx: master process /usr/local/nginx/sbin/nginx
33127 33126 nobody   0.0  1380 kqread nginx: worker process (nginx)
33128 33126 nobody   0.0  1364 kqread nginx: worker process (nginx)
33129 33126 nobody   0.0  1364 kqread nginx: worker process (nginx)
</code></pre>
 <p>如果将HUP发送到主进程，则输出变为：</p> 
 <pre><code>  PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
33126     1 root     0.0  1164 pause  nginx: master process /usr/local/nginx/sbin/nginx
33129 33126 nobody   0.0  1380 kqread nginx: worker process is shutting down (nginx)
33134 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
33135 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
33136 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
</code></pre>
 <p>PID <code>33129</code>的老工作流程仍然继续运行。 一段时间后，它退出：</p> 
 <pre><code> PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
33126     1 root     0.0  1164 pause  nginx: master process /usr/local/nginx/sbin/nginx
33134 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
33135 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
33136 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
</code></pre>
 <p><strong>循环日志文件</strong><br>要循环日志文件，需要首先重命名。 之后，USR1信号应发送到主进程。 然后，主进程将重新打开所有当前打开的日志文件，并将其分配给正在运行的工作进程的非特权用户作为所有者。 成功重新打开后，主程序关闭所有打开的文件，并将消息发送到工作进程，要求他们重新打开文件。 工作进程也会打开新文件并立即关闭旧文件。 因此，旧文件几乎立即可用于后处理，如压缩。</p>
 <br>      
</div></body></html>