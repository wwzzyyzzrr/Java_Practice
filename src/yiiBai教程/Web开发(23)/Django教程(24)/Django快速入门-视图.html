<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Django快速入门-视图</h1><div style="width:100%;float:left;" class="article-content">   
 <div>
   视图是一个网页“类型”在Django应用程序，提供特定的功能，并且具有特定的模板。例如，在一个博客的应用程序，可能有以下几个视图： 
 </div> 
 <div> 
  <div> 
   <ul> 
    <li> 
     <div>
       博客首页&nbsp;-&nbsp;显示最后的几个文章。 
     </div> </li> 
    <li> 
     <div>
       进入“detail”页面-&nbsp;对单个项目永久链接页面。 
     </div> </li> 
    <li> 
     <div>
       年存档页&nbsp;-&nbsp;显示所有在给定年份各月的条目。 
     </div> </li> 
    <li> 
     <div>
       月存档页&nbsp;-&nbsp;显示所有给定月份各天的所有项。 
     </div> </li> 
    <li> 
     <div>
       天存档页&nbsp;-&nbsp;显示某一天所有条目。 
     </div> </li> 
    <li> 
     <div>
       评论操作&nbsp;-&nbsp;处理发布评论的一个给定输入。 
     </div> </li> 
   </ul> 
   <div>
     在我们的&nbsp;poll&nbsp;应用程序，有以下四个视图： 
   </div> 
   <ul> 
    <li> 
     <div>
       问题的“index”页-&nbsp;显示最后几个问题。 
     </div> </li> 
    <li> 
     <div>
       问题的“detail”页&nbsp;-&nbsp;显示一个问题文本，没有结果但有一个表单用来投票。 
     </div> </li> 
    <li> 
     <div>
       问题的“results”页面&nbsp;-&nbsp;显示结果一个特定问题。 
     </div> </li> 
    <li> 
     <div>
       投票操作&nbsp;-&nbsp;处理投票在一个特定的问题进行具体选择。 
     </div> </li> 
   </ul> 
   <p> 在Django中，网页和其他内容由视图提供。每个视图由一个简单的Python函数来表示(或方法，基于类的视图)。Django会选择一个视图通过考察多数民众赞成请求的URL(准确地说，在域名之后URL的一部分)。 </p> 
   <p> 一个URL模式是一个简单的URL的一般形式&nbsp;-&nbsp;例如：/newsarchive/&lt;year&gt;/&lt;month&gt;/. </p> 
  </div> 
  <div> 
   <h2> 
    <div>
      编写更多的视图 
    </div> </h2> 
   <div>
     现在，让我们添加一些视图在&nbsp;polls/views.py。这些视图略有不同，因为他们需要一个参数：
    <br> 
    <pre class="prettyprint lang-py">def detail(request, question_id):
    return HttpResponse("You're looking at question %s." % question_id)

def results(request, question_id):
    response = "You're looking at the results of question %s."
    return HttpResponse(response % question_id)

def vote(request, question_id):
    return HttpResponse("You're voting on question %s." % question_id)</pre> 
   </div> 
   <div> 
   </div> 
   <div>
     这些新的视图加入到&nbsp;polls.urls&nbsp;模块中如下的 url() 调用，polls/urls.py文件中的代码如下：
    <br> 
    <pre class="prettyprint lang-py">from django.conf.urls import url

from . import views

urlpatterns = [
    # ex: /polls/
    url(r'^$', views.index, name='index'),
    # ex: /polls/5/
    url(r'^(?P&lt;question_id&gt;[0-9]+)/$', views.detail, name='detail'),
    # ex: /polls/5/results/
    url(r'^(?P&lt;question_id&gt;[0-9]+)/results/$', views.results, name='results'),
    # ex: /polls/5/vote/
    url(r'^(?P&lt;question_id&gt;[0-9]+)/vote/$', views.vote, name='vote'),
]</pre> 
   </div> 
   <div style="background-color:#F8F8F8;font-family:Roboto, Corbel, Avenir, 'Lucida Grande', 'Lucida Sans',;"> 
   </div> 
   <p style="font-family:Roboto, Corbel, Avenir, 'Lucida Grande', 'Lucida Sans', background-color:inherit;"> <span style="font-family:微软雅黑;line-height:1.5;">您可以在浏览器打开“/polls/34/”。它会运行detail()方法，并显示任何提供的URL内容。</span>&nbsp;再次尝试访问 “/polls/34/results/” and “/polls/34/vote/” &nbsp;–&nbsp;<span style="font-family:微软雅黑;line-height:1.5;">这将显示占位符结果和投票页面。</span> </p> 
   <p style="font-family:Roboto, Corbel, Avenir, 'Lucida Grande', 'Lucida Sans', background-color:inherit;"> <span style="font-family:微软雅黑;line-height:1.5;">include() 可以很容易包含入插件和网址。</span><span style="font-family:微软雅黑;line-height:1.5;">因为polls是在它们自己的URL配置(polls/urls.py)，它们可以放置在“/polls/”，</span><span style="font-family:微软雅黑;line-height:1.5;">或&nbsp;“/fun_polls/”，或在“/content/polls/”，或任何其它路径的根，应用程序仍然可以工作。</span> </p> 
   <div style="background-color:inherit;">
     下面是如果用户进入“/polls/34/”，在这个系统会发生什么： 
   </div> 
   <ul style="background-color:inherit;font-family:Roboto, Corbel, Avenir, 'Lucida Grande', 'Lucida Sans',;"> 
    <li style="background-color:inherit;"> <p style="background-color:inherit;"> <span style="font-family:Roboto, Corbel, Avenir, 'Lucida Grande', 'Lucida Sans', color:#0C3C26;line-height:1.5;">Django会找到匹配</span>'^polls/' </p> </li> 
    <li style="background-color:inherit;"> <p style="background-color:inherit;"> <span style="line-height:1.5;">然后，Django会去掉匹配的文本("polls/")，并发送剩余的文本&nbsp;</span>–&nbsp;"34/"&nbsp;–&nbsp;<span style="line-height:1.5;">到'polls.urls'URL配置用于进一步处理相匹配</span><span style="line-height:1.5;">&nbsp;</span>r'^(?P&lt;question_id&gt;[0-9]+)/$'<span style="line-height:1.5;">从而调用detail()&nbsp;视图，如下所示：</span> </p> 
     <div style="background-color:#F8F8F8;"> 
      <pre>detail(request=&lt;HttpRequest object&gt;, question_id='34')<span style="background-color:inherit;font-size:1em;"></span></pre> 
     </div> </li> 
   </ul> 
   <p style="font-family:Roboto, Corbel, Avenir, 'Lucida Grande', 'Lucida Sans', background-color:inherit;"> question_id='34'&nbsp;是来自&nbsp;(?P&lt;question_id&gt;[0-9]+)的一部分，<span style="font-family:微软雅黑;line-height:1.5;">用周围的模式括号“捕捉”匹配该模式文本，并将其作为参数传递给视图函数;</span><span style="line-height:1.5;">&nbsp;&nbsp;</span>?P&lt;question_id&gt;<span style="line-height:1.5;">&nbsp;</span><span style="font-family:微软雅黑;line-height:1.5;">定义了将被用来识别所述匹配的模式的名称;</span><span style="line-height:1.5;">&nbsp; 以及</span>[0-9]+<span style="line-height:1.5;">&nbsp;</span><span style="font-family:微软雅黑;line-height:1.5;">正则表达式匹配一个数字序列(在一个数字)。</span> </p> 
   <p style="font-family:Roboto, Corbel, Avenir, 'Lucida Grande', 'Lucida Sans', background-color:inherit;"> <span style="font-family:微软雅黑;line-height:1.5;">由于URL模式是正则表达式，可以使用它来做一些事情，没有任何限制。而且也没有必要添加URL为.html</span>&nbsp;–&nbsp;<span style="font-family:微软雅黑;line-height:1.5;">除非你想，在这种情况下，你可以这样做：</span> </p> 
   <div> 
    <pre>url(r'^polls/latest\.html$', views.index),</pre> 
   </div> 
  </div> 
  <div> 
   <h2> 
    <div>
      编写视图实现功能 
    </div> </h2> 
   <p> 每个视图负责做两件事情之一：返回包含所请求的页面内容的 HttpResponse 对象，或抛出一个异常，如HTTP 404。&nbsp;修改polls/views.py文件代码如下： </p> 
   <pre class="prettyprint lang-py">from django.http import HttpResponse

from .models import Question

def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    output = ', '.join([q.question_text for q in latest_question_list])
    return HttpResponse(output)

# Leave the rest of the views (detail, results, vote) unchanged</pre> 
   <div style="background-color:#F8F8F8;"> 
   </div> 
   <p> 在这里有一个问题就，通过：网页设计是硬编码在视图中。如果想改变页面的样子，必须编辑这个 Python 代码。因此，让我们使用 Django 模板系统通过创建视图可以使用模板来分开Python 的代码。<span style="line-height:1.5;">polls/templates/polls/index.html&nbsp;</span><span style="line-height:1.5;">将下面的代码：</span> </p> 
   <pre class="prettyprint lang-html">{% if latest_question_list %}
    &lt;ul&gt;
    {% for question in latest_question_list %}
        &lt;li&gt;&lt;a href="/polls/{{ question.id }}/"&gt;{{ question.question_text }}&lt;/a&gt;&lt;/li&gt;
    {% endfor %}
    &lt;/ul&gt;
{% else %}
    &lt;p&gt;No polls are available.&lt;/p&gt;
{% endif %}</pre> 
   <div style="background-color:#F8F8F8;"> 
   </div> 
   <p style="background-color:inherit;"> 现在我们来更新首页视图 polls/views.py使用以下模板(代码)： </p> 
   <pre class="prettyprint lang-py">from django.http import HttpResponse
from django.template import loader

from .models import Question

def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    template = loader.get_template('polls/index.html')
    context = {
        'latest_question_list': latest_question_list,
    }
    return HttpResponse(template.render(context, request))</pre> 
   <div style="background-color:#F8F8F8;"> 
   </div> 
   <p> 该代码加载模板调用polls/index.html，然后传递给它的上下文。上下文是一个字典以Python对象映射模板变量名。现在访问URL（http://127.0.0.1:8000/polls/）查看结果 ： </p> 
   <p> <img src="/uploads/tutorial/20160131/1-160131120114922.png" alt=""> </p> 
   <div> 
    <h3> 快捷方式:&nbsp;<a target="_blank" href="https://docs.djangoproject.com/en/1.9/topics/http/shortcuts/#django.shortcuts.render">render()</a> </h3> 
    <p> 这是一个非常习惯用法来加载模板，填充上下文中和渲染模板的结果返回一个HttpResponse对象。Django提供了一个捷径。下面是完整的index() 视图，改写polls/views.py为： </p> 
    <pre class="prettyprint lang-py">from django.shortcuts import render

from .models import Question

def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    context = {'latest_question_list': latest_question_list}
    return render(request, 'polls/index.html', context)</pre> 
    <div style="background-color:#F8F8F8;"> 
    </div> 
    <div>
      请注意，当在各个视图做到了这一点，我们不再需要导入加载器和HttpResponse对象(想保留HttpResponse，如果仍然有短截&nbsp;detail,&nbsp;results,&nbsp;和&nbsp;vote&nbsp;方法。 
    </div> 
   </div> 
  </div> 
  <h2> 引发404错误 </h2> 
  <p style="font-family:Roboto, Corbel, Avenir, 'Lucida Grande', 'Lucida Sans', background-color:inherit;"> 现在，让我们来解决这个问题详细视图 - 显示为给定的民意调查问题文本的页面。这里添加视图代码（polls/views.py）： </p> 
  <pre class="prettyprint lang-py">from django.http import Http404
from django.shortcuts import render

from .models import Question
# ...
def detail(request, question_id):
    try:
        question = Question.objects.get(pk=question_id)
    except Question.DoesNotExist:
        raise Http404("Question does not exist")
    return render(request, 'polls/detail.html', {'question': question})</pre> 
  <div style="background-color:#F8F8F8;font-family:Roboto, Corbel, Avenir, 'Lucida Grande', 'Lucida Sans',;"> 
  </div> 
  <p style="font-family:Roboto, Corbel, Avenir, 'Lucida Grande', 'Lucida Sans', background-color:inherit;"> 注意这里：视图引发HTTP404异常，如果与请求ID的问题并不存在。 </p> 
  <p style="font-family:Roboto, Corbel, Avenir, 'Lucida Grande', 'Lucida Sans', background-color:inherit;"> 我们将讨论可以把 polls/detail.html 在后面做一些修改，但如果想快速使用上面的例子，polls/templates/polls/detail.html&nbsp;文件只需包含： </p> 
  <div>   
   <pre>{{question}}</pre> 
  </div> 
  <p style="font-family:Roboto, Corbel, Avenir, 'Lucida Grande', 'Lucida Sans', background-color:inherit;"> <img src="/uploads/tutorial/20160131/1-1601311213361a.png" alt=""><br> 引发 404&nbsp;错误，现在我们请求一个不存在问题，如：http://127.0.0.1:8000/polls/100/，显示结果如下： </p> 
  <p style="font-family:Roboto, Corbel, Avenir, 'Lucida Grande', 'Lucida Sans', background-color:inherit;"> <img src="/uploads/tutorial/20160131/1-160131121644P5.png" alt=""> </p> 
  <div> 
   <h3> 快捷方式:&nbsp;<a target="_blank" href="https://docs.djangoproject.com/en/1.9/topics/http/shortcuts/#django.shortcuts.get_object_or_404">get_object_or_404()</a> </h3> 
   <p> 如果对象不存在的一个非常习惯用法使用get()并引发HTTP404错误。Django提供了一个捷径。下面是 detail() 视图，<span style="color:#0C4B33;font-family:'Fira Mono', Consolas, Menlo, Monaco, 'Courier New', Courier, monospace;background-color:#C9F0DD;">polls/views.py&nbsp;</span>改写： </p> 
   <pre class="prettyprint lang-py">from django.shortcuts import get_object_or_404, render

from .models import Question
# ...
def detail(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    return render(request, 'polls/detail.html', {'question': question})</pre> get_object_or_404()函数接受一个Django模型作为第一个参数和关键字任意参数数量，它传递到模型管理的 get()函数。 
   <p> <a target="_blank" href="https://docs.djangoproject.com/en/1.9/topics/http/shortcuts/#django.shortcuts.get_object_or_404"></a>如果对象不存在将引发HTTP404。 </p> 
   <p> 还有一个get_list_or_404()函数，它的工作原理就像get_object_or_404()- 除了使用 filter()而不是get()方法。如果列表是空的它会引起HTTP404。 </p> 
  </div> 
  <div> 
   <h2> 使用模板系统 </h2> 
   <p> 回到我们的 polls&nbsp;应用程序&nbsp;detail()&nbsp;视图。由于上下文变量的问题，这里的 polls/detail.html&nbsp;模板看起来是这样的： </p> 
   <pre class="prettyprint lang-html">&lt;h1&gt;{{ question.question_text }}&lt;/h1&gt;
&lt;ul&gt;
{% for choice in question.choice_set.all %}
    &lt;li&gt;{{ choice.choice_text }}&lt;/li&gt;
{% endfor %}
&lt;/ul&gt;</pre> 
   <div style="background-color:#F8F8F8;"> 
   </div> 
   <p> 模板系统采用点查询语法来访问变量属性。在这个例子&nbsp;{{question.question_text }}，第一个Django确实在question对象字典查找。 如果找不到，它再尝试属性查询 – 如果属性查找失败，它会尝试一个列表索引查找。<br> 现在测试我们上面编写的代码，在浏览器中打开：http://127.0.0.1:8000/polls/5/ 得到结果如下：<br> <img src="/uploads/tutorial/20160131/1-1601311A34a30.png" alt=""> </p> 
  </div> 
  <div> 
   <h2> 删除模板硬编码网址 </h2> 
   <p> 请记住，当我们在 polls/index.html 链接到一个问题，链接被硬编码的部分是这样的： </p> 
   <div> 
    <pre>&lt;li&gt;&lt;ahref="/polls/{{question.id}}/"&gt;{{question.question_text}}&lt;/a&gt;&lt;/li&gt;</pre> 
   </div> 
   <p> 使用此硬编码，紧密耦合的方法的问题是：它在更改项目的URL用了很多模板。不过，既然 polls.urls模块中定义名称参数url() 函数，您可以通过使用 {% url %}模板删除标签在URL配置中定义的特定URL路径的依赖： </p> 
   <div> 
    <pre>&lt;li&gt;&lt;ahref="{%url'detail'question.id%}"&gt;{{question.question_text}}&lt;/a&gt;&lt;/li&gt;</pre> 
   </div> 
   <p> 这种工作方式是通过为polls.urls模块中指定查找的URL定义。可以准确地看到'detail'的URL名称定义如下： </p> 
   <pre class="prettyprint lang-py">...
# the 'name' value as called by the {% url %} template tag
url(r'^(?P&lt;question_id&gt;[0-9]+)/$', views.detail, name='detail'),
...</pre> 
   <div style="background-color:#F8F8F8;"> 
   </div> 
   <p> 如果你想要把投票详细视图的URL更改成其它的，也许像&nbsp;polls/specifics/12/&nbsp;取代在模板（或templates），需要在&nbsp;polls/urls.py&nbsp;改变它： </p> 
   <pre class="prettyprint lang-py">...
# added the word 'specifics'
url(r'^specifics/(?P&lt;question_id&gt;[0-9]+)/$', views.detail, name='detail'),
...</pre> 
   <div style="background-color:#F8F8F8;"> 
   </div> 
  </div> 
  <div> 
   <h2> 命名空间URL名称 </h2> 
   <p> 本教程项目只有一个应用程序 - polls。在实际的Django项目中，可能有五个，十个，二十个或更多的应用程序。Django&nbsp;如何区分它们的URL的名称？ 例如，投票应用程序有一个详细视图，因此可能会在一个博客的同一个项目也有相同的应用程序。如何使用 {% url %} 模板标签让Django知道创建一个URL哪些应用有这样视图？ </p> 
   <p> 答案就是将命名空间添加到URLconf。在polls/urls.py文件，继续前进，添加应用程序名称设置应用程序命名空间，打开&nbsp;polls/urls.py： </p> 
   <pre class="prettyprint lang-py">from django.conf.urls import url

from . import views

app_name = 'polls'
urlpatterns = [
    url(r'^$', views.index, name='index'),
    url(r'^(?P&lt;question_id&gt;[0-9]+)/$', views.detail, name='detail'),
    url(r'^(?P&lt;question_id&gt;[0-9]+)/results/$', views.results, name='results'),
    url(r'^(?P&lt;question_id&gt;[0-9]+)/vote/$', views.vote, name='vote'),
]</pre> 
   <div style="background-color:#F8F8F8;"> 
   </div> 
   <p> 现在修改 polls/index.html 模板，打开&nbsp;polls/templates/polls/index.html&nbsp;文件添加以下代码： </p> 
   <div> 
    <pre>&lt;li&gt;&lt;ahref="{%url'detail'question.id%}"&gt;{{question.question_text}}&lt;/a&gt;&lt;/li&gt;</pre> 
   </div> 
   <p> 使其指向在命名空间 detail&nbsp;视图，打开 polls/templates/polls/index.html 文件如下： </p> 
   <div> 
    <pre>&lt;li&gt;&lt;ahref="{%url'polls:detail'question.id%}"&gt;{{question.question_text}}&lt;/a&gt;&lt;/li&gt;</pre> 
   </div> 
  </div> 
 </div> 代码下载：
 <a target="_blank" href="http://pan.baidu.com/s/1o7iWsWi">http://pan.baidu.com/s/1o7iWsWi</a>
 <br>      
</div></body></html>