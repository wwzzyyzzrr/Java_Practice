<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Django快速入门-数据库模型</h1><div style="width:100%;float:left;" class="article-content">   本系列教程第一部分已经讲完了。在上一个教程的基础上，在这一讲中我们将建立数据库，创建第一个模型，并使用一个 Django&nbsp;快速自动生成的管理站点。 
 <div> 
  <div> 
   <h2> 数据库配置 </h2> 
   <div>
     现在，打开mysite/settings.py。Django设置模块级的变量与正常的Python模块一样。 
   </div> 
   <p> 默认情况下，配置使用SQLite。如果你是数据库新手，或者想尝试学习Django，这是最简单的选择。SQLite包含在Python，所以不需要安装任何东西来支持你的数据库。当开始你的第一个真正的项目，可能需要使用更强大的数据库如：PostgreSQL，MySQL等，可以配置数据库切换就可以了。 </p> 
   <div>
     如果你想使用其他数据库，请安装相应的数据库绑定，并更改以下键在数据库中“默认”的配置项，以适合您的数据库连接设置： 
   </div> 
   <ul> 
    <li> <a target="_blank" href="https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-DATABASE-ENGINE">ENGINE</a>&nbsp;– 输入'django.db.backends.sqlite3',&nbsp;'django.db.backends.postgresql','django.db.backends.mysql',或'django.db.backends.oracle' </li> 
    <li> <a target="_blank" href="https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-NAME">NAME</a>&nbsp;–&nbsp;数据库的名称。如果使用SQLite，数据库会在您的计算机上创建文件；在这种情况下，名称应该是完整的绝对路径的文件，包括文件名。默认值为 os.path.join(BASE_DIR，“db.sqlite3”)，将存储在您的项目目录中的文件。 </li> 
   </ul> 
   <p> 如果你不使用SQLite作为数据库，而使用其他设置，如USER,&nbsp;PASSWORD,&nbsp;和&nbsp;HOST&nbsp;必须加入。欲了解更多详细信息，请参阅用于<a target="_blank" href="https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-DATABASES">数据库的参考文档</a>。 </p> 
   <div>
     当你编辑&nbsp;mysite/settings.py，时区设置TIME_ZONE。 
   </div> 
   <p> 此外，请注意，在该文件的顶部的 INSTALLED_APPS 设置。它包含了很多在本Django示例中激活的所有 Django 的应用程序的名称。&nbsp;应用程序可以在多个项目中使用，你可以打包给别人并在他们的项目分发使用。 </p> 
   <div>
     默认情况下，INSTALLED_APPS包含以下内容的应用程序，这些都使用 Django ： 
   </div> 
   <ul> 
    <li> <a target="_blank" href="https://docs.djangoproject.com/en/1.9/ref/contrib/admin/#module-django.contrib.admin">django.contrib.admin</a>&nbsp;–&nbsp;管理站点，这里会很快使用它 </li> 
    <li> <a target="_blank" href="https://docs.djangoproject.com/en/1.9/topics/auth/#module-django.contrib.auth">django.contrib.auth</a>&nbsp;–&nbsp;认证系统 </li> 
    <li> <a target="_blank" href="https://docs.djangoproject.com/en/1.9/ref/contrib/contenttypes/#module-django.contrib.contenttypes">django.contrib.contenttypes</a>&nbsp;–&nbsp;一个框架，内容类型 </li> 
    <li> <a target="_blank" href="https://docs.djangoproject.com/en/1.9/topics/http/sessions/#module-django.contrib.sessions">django.contrib.sessions</a>&nbsp;–&nbsp;会话框架 </li> 
    <li> <a target="_blank" href="https://docs.djangoproject.com/en/1.9/ref/contrib/messages/#module-django.contrib.messages">django.contrib.messages</a>&nbsp;–&nbsp;消息传递框架 </li> 
    <li> <a target="_blank" href="https://docs.djangoproject.com/en/1.9/ref/contrib/staticfiles/#module-django.contrib.staticfiles">django.contrib.staticfiles</a>&nbsp;–&nbsp;一个框架用来管理静态文件 </li> 
   </ul> 
   <div>
     这些应用包括默认，作为一个方便常见的例子。 
   </div> 
   <p> 其中的一些应用程序使用至少一个数据库表，所以我们需要在数据库中创建的表才可以使用它们。要做到这一点，运行以下命令： </p> 
   <pre class="prettyprint lang-bsh">C:\Python27\mysite&gt;python manage.py migrate
Operations to perform:
  Apply all migrations: admin, contenttypes, auth, sessions
Running migrations:
  Rendering model states... DONE
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying sessions.0001_initial... OK

C:\Python27\mysite&gt;</pre> 
   <div style="background-color:#F8F8F8;"> 
   </div> 
   <p> migrate&nbsp;命令着眼于INSTALLED_APPS设置并创建根据您的 mysite/settings.py 文件数据库设置，并随应用程序数据库迁移任何数据库表(我们将在以后的教程讨论)。你会看到每个适用移植的消息。&nbsp;如果有兴趣，运行命令行在你的数据库客户端，列如类型\dt&nbsp;(PostgreSQL),&nbsp;SHOW&nbsp;TABLES;&nbsp;(MySQL),&nbsp;.schema&nbsp;(SQLite),&nbsp;或&nbsp;SELECT&nbsp;TABLE_NAME&nbsp;FROMUSER_TABLES;&nbsp;(Oracle)&nbsp;以显示Django所创建的表。 </p> 
  </div> 
  <div> 
   <h2> 创建模型 </h2> 
   <div>
     现在，我们将定义模型&nbsp;-&nbsp;本质上数据库进行设计，使用其他元数据。 
   </div> 
   <p> 在我们的简单调查的应用程序，我们将创建两个模型：Question&nbsp;和&nbsp;Choice。Question有一个问题标题和发布日期。Choice有两个字段：选择文本和票数。每个选项都与一个问题关联。 </p> 
   <div>
     这些概念由简单的Python类来表示。编辑 polls/models.py 文件，所以&nbsp;
    <span>polls/models.py&nbsp;</span>看起来是这样的： 
   </div> 
   <div> 
    <pre class="prettyprint lang-py">from django.db import models

class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField('date published')

class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)</pre> 
   </div> 
   <p> 该代码是直接的。每个模型是django.db.models.Model类的子类。&nbsp;每个模型具有许多类变量，每一个在模型变量与数据库表的字段关联。 </p> 
   <p> 每个字段由&nbsp;Field&nbsp;类实例表示&nbsp;–&nbsp;例如，CharField表示字符型字段，DateTimeField表示日期时间字段。这告诉Django 每个字段保存的数据类型。 </p> 
   <p> 每个Field实例(例如，question_text或pub_date)的名称是字段的名称，这是机器友好的格式。在Python代码中使用这个值，数据库将使用它作为列名。 </p> 
   <div>
     字段也可以有不同的可选参数；在本示例中，我们已经将票数的默认值设置为0。 
   </div> 
   <p> 最后，需要注意的是关系的定义，这里使用了外键。这告诉 Django 每个选项关联一个问题。&nbsp;Django支持所有常见的数据库关系：多对一，多对多以及一对之一。 </p> 
  </div> 
  <div> 
   <h2> 
    <div>
      激活模型 
    </div> </h2> 
   <div>
     模型代码很小，但表示了 Django 的很多信息。有了它 Django 可以： 
   </div> 
   <ul> 
    <li> 
     <div>
       为这个应用程序创建数据库(CREATE&nbsp;TABLE语句) 
     </div> </li> 
    <li> 创建访问&nbsp;Question&nbsp;和&nbsp;Choice对象的Python数据库访问API </li> 
   </ul> 
   <div>
     但首先我们需要告诉&nbsp;polls&nbsp;项安装了的应用程序。 
   </div> 
   <div>
     再次编辑&nbsp;mysite/settings.py&nbsp;文件，并更改INSTALLED_APPS设置包含字符串“polls.apps.PollsConfig”。结果如下所示： 
   </div> 
   <div>
     mysite/settings.py文件内容如下：
    <br> 
    <pre class="prettyprint lang-py">INSTALLED_APPS = [
    'polls.apps.PollsConfig',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]</pre> 
   </div> 
   <div style="background-color:#F8F8F8;"> 
   </div> 
   <div style="background-color:inherit;">
     现在Django知道&nbsp;polls&nbsp;投票程序。让我们运行另一个命令：
    <br> 
    <pre class="prettyprint lang-py">C:\Python27\mysite&gt;python manage.py makemigrations polls
Migrations for 'polls':
  0001_initial.py:
    - Create model Choice
    - Create model Question
    - Add field question to choice

C:\Python27\mysite&gt;</pre> 
   </div> 
   <div style="background-color:#F8F8F8;"> 
   </div> 
   <div>
     通过运行makemigrations，告诉Django你已经做了模型一些改动(在这种情况下，已经是最新的了)，并且你想更改存储作为一个移植。 
   </div> 
   <p> 迁移是Django怎么存储您更改的模型(由你的数据库架构决定)- 它们只是在磁盘上的文件。您如果喜欢可以读取移植新的模型，它在文件&nbsp;polls/migrations/0001_initial.py。你不会希望Django每一次都读取它们，不过将它们设计成人可编辑的，你要知道Django是如何变化的并手动调整。 </p> 
   <p> 还有将运行migrations，自动管理数据库模式(表)命令&nbsp;-&nbsp;这就是所谓的迁移，让我们看看SQL了解移植运行。&nbsp;sqlmigrate 命令将移植名称返回SQL显示： </p> 
   <div style="background-color:#F8F8F8;"> 
    <pre><span style="background-color:inherit;color:#000080;font-weight:bold;">$</span> python manage.py sqlmigrate polls 0001<span style="background-color:inherit;font-size:1em;"></span></pre> 
   </div> 
   <div style="background-color:inherit;">
     应该看到类似下面的东西(我们已经重新格式化它的可读性)：
    <br> 
    <pre class="prettyprint lang-py">C:\Python27\mysite&gt;python manage.py sqlmigrate polls 0001
BEGIN;
--
-- Create model Choice
--
CREATE TABLE "polls_choice" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "c
hoice_text" varchar(200) NOT NULL, "votes" integer NOT NULL);
--
-- Create model Question
--
CREATE TABLE "polls_question" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT,
"question_text" varchar(200) NOT NULL, "pub_date" datetime NOT NULL);
--
-- Add field question to choice
--
ALTER TABLE "polls_choice" RENAME TO "polls_choice__old";
CREATE TABLE "polls_choice" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "c
hoice_text" varchar(200) NOT NULL, "votes" integer NOT NULL, "question_id" integ
er NOT NULL REFERENCES "polls_question" ("id"));
INSERT INTO "polls_choice" ("choice_text", "votes", "id", "question_id") SELECT
"choice_text", "votes", "id", NULL FROM "polls_choice__old";
DROP TABLE "polls_choice__old";
CREATE INDEX "polls_choice_7aa0f6ee" ON "polls_choice" ("question_id");

COMMIT;

C:\Python27\mysite&gt;</pre> 
   </div> 
   <div style="background-color:#F8F8F8;"> 
   </div> 
   <p> 迁移命令将所有还没有被应用的迁移(Django跟踪哪些是使用数据库中的一个特殊的表名为django_migrations应用)运行它们在数据库中&nbsp;-&nbsp;基本上是，将使用模型在数据库模式的变化同步。 </p> 
  </div> 
  <p> <br> </p> 
  <h2> 使用API </h2> 
  <div>
    现在，让我们进入交互式 Python&nbsp;shell &nbsp;和 Django 所提供的API&nbsp;。要调用Python命令行，请使用以下命令：
   <br> 
   <pre class="prettyprint lang-py">C:\Python27\mysite&gt;python manage.py shell
Python 2.7.10 (default, May 23 2015, 09:44:00) [MSC v.1500 64 bit (AMD64)] on wi
n32
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
&gt;&gt;&gt;</pre> 
  </div> 
  <div style="background-color:#F8F8F8;"> 
  </div> 
  <p> 只需键入“python”&nbsp;来代替，因为manage.py设置DJANGO_SETTINGS_MODULE环境变量，这给Django&nbsp;Python&nbsp;导入路径到&nbsp;mysite/settings.py文件。 </p> 
  <pre class="prettyprint lang-py">&gt;&gt;&gt; import django
&gt;&gt;&gt; django.setup()</pre> 
  <pre class="prettyprint lang-py">&gt;&gt;&gt; from polls.models import Question, Choice   # Import the model classes we just wrote.

# No questions are in the system yet.
&gt;&gt;&gt; Question.objects.all()
[]

# Create a new Question.
# Support for time zones is enabled in the default settings file, so
# Django expects a datetime with tzinfo for pub_date. Use timezone.now()
# instead of datetime.datetime.now() and it will do the right thing.
&gt;&gt;&gt; from django.utils import timezone
&gt;&gt;&gt; q = Question(question_text="What's new?", pub_date=timezone.now())

# Save the object into the database. You have to call save() explicitly.
&gt;&gt;&gt; q.save()

# Now it has an ID. Note that this might say "1L" instead of "1", depending
# on which database you're using. That's no biggie; it just means your
# database backend prefers to return integers as Python long integer
# objects.
&gt;&gt;&gt; q.id
1

# Access model field values via Python attributes.
&gt;&gt;&gt; q.question_text
"What's new?"
&gt;&gt;&gt; q.pub_date
datetime.datetime(2012, 2, 26, 13, 0, 0, 775217, tzinfo=&lt;UTC&gt;)

# Change values by changing the attributes, then calling save().
&gt;&gt;&gt; q.question_text = "What's up?"
&gt;&gt;&gt; q.save()

# objects.all() displays all the questions in the database.
&gt;&gt;&gt; Question.objects.all()
[&lt;Question: Question object&gt;]</pre> 这里需要等待一会儿.&nbsp;&lt;Question:&nbsp;Question&nbsp;object&gt;完全是这个对象的无用表示。让我们来解决这个问题：通过编辑Question模型(在polls/models.py&nbsp;文件)，并添加一个__str__()&nbsp;方法到这两个Question&nbsp;和&nbsp;Choice&nbsp;模型：
  <span style="line-height:1.5;">polls/models.py文件内容如下：<br> <pre class="prettyprint lang-py">from django.db import models
from django.utils.encoding import python_2_unicode_compatible

@python_2_unicode_compatible  # only if you need to support Python 2
class Question(models.Model):
    # ...
    def __str__(self):
        return self.question_text

@python_2_unicode_compatible  # only if you need to support Python 2
class Choice(models.Model):
    # ...
    def __str__(self):
        return self.choice_text</pre> </span> 
  <div style="background-color:#F8F8F8;"> 
  </div> 
  <div>
    添加&nbsp;__str__()&nbsp;方法是非常重要的，使用交互式提示处理添加到模型中，不仅为自己方便，也是因为对象的表示用于整个 Django 自动生成管理。 
  </div> 
  <p> 注意，这些都是正常的Python方法。让我们添加一个自定义的方法，这里只是为了演示：polls/models.py </p> 
  <p> <br> </p> 
  <pre class="prettyprint lang-py">import datetime

from django.db import models
from django.utils import timezone


class Question(models.Model):
    # ...
    def was_published_recently(self):
        return self.pub_date &gt;= timezone.now() - datetime.timedelta(days=1)</pre> 
  <div> 
  </div> 
  <p> 注意这里增加&nbsp;import&nbsp;datetime&nbsp;和from&nbsp;django.utils&nbsp;import&nbsp;timezon，引用Python的标准的datetime模块和Django的时区相关的实用程序在django.utils.timezone，如果不熟悉在Python的时区处理，可以阅读<a target="_blank" href="https://docs.djangoproject.com/en/1.9/topics/i18n/timezones/">时区支持文档</a>。 </p> 
  <div>
    保存这些修改，并再次运行&nbsp;python&nbsp;manage.py&nbsp;shell&nbsp;启动一个新的Python交互shell：
   <br>   
   <pre class="prettyprint lang-py">&gt;&gt;&gt; from polls.models import Question, Choice

# Make sure our __str__() addition worked.
&gt;&gt;&gt; Question.objects.all()
[&lt;Question: What's up?&gt;]

# Django provides a rich database lookup API that's entirely driven by
# keyword arguments.
&gt;&gt;&gt; Question.objects.filter(id=1)
[&lt;Question: What's up?&gt;]
&gt;&gt;&gt; Question.objects.filter(question_text__startswith='What')
[&lt;Question: What's up?&gt;]

# Get the question that was published this year.
&gt;&gt;&gt; from django.utils import timezone
&gt;&gt;&gt; current_year = timezone.now().year
&gt;&gt;&gt; Question.objects.get(pub_date__year=current_year)
&lt;Question: What's up?&gt;

# Request an ID that doesn't exist, this will raise an exception.
&gt;&gt;&gt; Question.objects.get(id=2)
Traceback (most recent call last):
    ...
DoesNotExist: Question matching query does not exist.

# Lookup by a primary key is the most common case, so Django provides a
# shortcut for primary-key exact lookups.
# The following is identical to Question.objects.get(id=1).
&gt;&gt;&gt; Question.objects.get(pk=1)
&lt;Question: What's up?&gt;

# Make sure our custom method worked.
&gt;&gt;&gt; q = Question.objects.get(pk=1)
&gt;&gt;&gt; q.was_published_recently()
True

# Give the Question a couple of Choices. The create call constructs a new
# Choice object, does the INSERT statement, adds the choice to the set
# of available choices and returns the new Choice object. Django creates
# a set to hold the "other side" of a ForeignKey relation
# (e.g. a question's choice) which can be accessed via the API.
&gt;&gt;&gt; q = Question.objects.get(pk=1)

# Display any choices from the related object set -- none so far.
&gt;&gt;&gt; q.choice_set.all()
[]

# Create three choices.
&gt;&gt;&gt; q.choice_set.create(choice_text='Not much', votes=0)
&lt;Choice: Not much&gt;
&gt;&gt;&gt; q.choice_set.create(choice_text='The sky', votes=0)
&lt;Choice: The sky&gt;
&gt;&gt;&gt; c = q.choice_set.create(choice_text='Just hacking again', votes=0)

# Choice objects have API access to their related Question objects.
&gt;&gt;&gt; c.question
&lt;Question: What's up?&gt;

# And vice versa: Question objects get access to Choice objects.
&gt;&gt;&gt; q.choice_set.all()
[&lt;Choice: Not much&gt;, &lt;Choice: The sky&gt;, &lt;Choice: Just hacking again&gt;]
&gt;&gt;&gt; q.choice_set.count()
3

# The API automatically follows relationships as far as you need.
# Use double underscores to separate relationships.
# This works as many levels deep as you want; there's no limit.
# Find all Choices for any question whose pub_date is in this year
# (reusing the 'current_year' variable we created above).
&gt;&gt;&gt; Choice.objects.filter(question__pub_date__year=current_year)
[&lt;Choice: Not much&gt;, &lt;Choice: The sky&gt;, &lt;Choice: Just hacking again&gt;]

# Let's delete one of the choices. Use delete() for that.
&gt;&gt;&gt; c = q.choice_set.filter(choice_text__startswith='Just hacking')
&gt;&gt;&gt; c.delete()</pre> 
  </div> 
  <div> 
   <h2> 介绍 Django管理 </h2> 
   <div> 
    <h3> 
     <div>
       创建一个管理员用户 
     </div> </h3> 
    <div>
      首先，我们需要创建可以登录到管理界面的用户。运行以下命令： 
    </div> 
    <div style="background-color:#F8F8F8;"> 
     <pre><span><b>c:\python27\mysite&gt;</b></span> python manage.py createsuperuser<span style="background-color:inherit;font-size:1em;"></span></pre> 
    </div> 
    <div>
      输入你想要的用户名(随便一个)，然后按Enter。 
    </div> 
    <div style="background-color:#F8F8F8;"> 
     <pre>Username: admin<span style="background-color:inherit;font-size:1em;"></span></pre> 
    </div> 
    <div>
      然后，将提示输入电子邮件地址(随便一个)： 
    </div> 
    <div style="background-color:#F8F8F8;"> 
     <pre>Email address: admin@yiibai.com<span style="background-color:inherit;font-size:1em;"></span></pre> 
    </div> 
    <div style="background-color:inherit;">
      最后一步是要输入密码。它会要求输入密码两次，第二次为第一的确认。 
    </div> 
    <div style="background-color:#F8F8F8;"> 
     <pre>Password: **********
Password (again): *********
Superuser created successfully.<span style="background-color:inherit;font-size:1em;"></span></pre> 
    </div> 
   </div> 
   <div> 
    <h3> 
     <div>
       启动开发服务器 
     </div> </h3> 
    <div>
      Django管理站点默认激活。让我们启动开发服务器，并探索它。 
    </div> 
    <div>
      如果服务器未运行，启动它，如下所示： 
    </div> 
    <div style="background-color:#F8F8F8;"> 
     <pre>c:\python27\mysite&gt;python manage.py runserver<span style="background-color:inherit;font-size:1em;"></span></pre> 
    </div> 
    <p> 现在，打开Web浏览器，进入“/admin/”&nbsp;本地域名-&nbsp;例如，&nbsp;<a target="_blank" href="http://127.0.0.1:8000/admin/">http://127.0.0.1:8000/admin/</a>&nbsp;&nbsp;应该看到管理员登录界面：<br> <img src="/uploads/tutorial/20160131/1-16013110532Q39.png" alt=""> </p> 
    <img src="file://E:/data/youdao/qq24B39E2329F08D9F4C3146A571A415EF/37674ace7a1448949d368f123efc14fe/admin01.png" alt="Django admin login screen"> 
    <p> 由于移在默认情况下开启，登录屏幕可能会显示在你自己的语言，&nbsp;由于翻译在默认情况下开启，登录屏幕可能会显示在你自己的语言， </p> 
   </div> 
   <div> 
    <h3> 
     <div>
       输入管理员网站 
     </div> </h3> 
    <div>
      现在，尝试与在上一步中创建的超级用户帐号登录。应该会看到 Django 管理的首页：
     <br> 
     <img src="/uploads/tutorial/20160131/1-160131105451A4.png" alt="">
     <br> 
    </div> 
    <img src="file://E:/data/youdao/qq24B39E2329F08D9F4C3146A571A415EF/cc338b2718c74f2087c856e669258e22/admin02.png" alt="Django admin index page"> 
    <div>
      你应该看到一些可编辑内容：组和用户。它们由django.contrib.auth，Django的认证框架提供。 
    </div> 
   </div> 
   <div> 
    <h3> 
     <div>
       修改poll&nbsp;管理程序 
     </div> </h3> 
    <div>
      poll应用程序在哪里？它不会显示在管理索引页面上。 
    </div> 
    <p> 只有一件事要做：我们需要告诉管理员这个Question对象有一个管理界面。要做到这一点，打开 polls/admin.py文件，并修改它如下：<span style="line-height:1.5;"><br> </span> </p> 
    <pre class="prettyprint lang-py">from django.contrib import admin

from .models import Question

admin.site.register(Question)</pre> 
    <p> <br> </p> 
    <div style="background-color:#F8F8F8;"> 
    </div> 
   </div> 
   <div style="background-color:inherit;"> 
    <h3> 
     <div>
       浏览管理功能 
     </div> </h3> 
    <div>
      现在，我们已经注册Question，Django知道它应该在管理主页面上显示：
     <br> 
     <img src="/uploads/tutorial/20160131/1-160131105JO23.png" alt="">
     <br> 
    </div> 
    <img src="file://E:/data/youdao/qq24B39E2329F08D9F4C3146A571A415EF/65ab06238440402abb375297803baaf9/admin03t.png" alt="Django admin index page, now with polls displayed"> 
    <p> 点击“Questions”。现在，在“change&nbsp;list”页面查看问题。该页面显示数据库中的所有问题，并允许您选择其中一个进行更改。还有我们先前创建的问题：<br> <img src="/uploads/tutorial/20160131/1-16013111152N36.png" alt=""> </p> 
    <img src="file://E:/data/youdao/qq24B39E2329F08D9F4C3146A571A415EF/495da38b73164b8fafbf2a15e91fd1ae/admin04t.png" alt="Polls change list page"> 
    <div>
      点击“What's new?”这个问题进行编辑：
     <br> 
     <img src="/uploads/tutorial/20160131/1-16013111154W51.png" alt="">
     <br> 
    </div> 
    <img src="file://E:/data/youdao/qq24B39E2329F08D9F4C3146A571A415EF/0e005e7de9d64a9dba30d3254d3a42a9/admin05t.png" alt="Editing form for question object"> 
    <div>
      需要注意的事项在这里列出： 
    </div> 
    <ul> 
     <li> 
      <div>
        表单是从问题(Question)模型自动产生。 
      </div> </li> 
     <li> 
      <div>
        不同型号的字段类型(DateTimeField，CharField)对应相应的HTML输入部件。每个字段类型知道自己在Django管理中如何显示。 
      </div> </li> 
     <li> 每个DateTimeField字段得到 JavaScript 快捷方式。日期得到一个“Today”的快捷方式并且弹出日历，并多次获得了“Now”快捷方式并弹出窗口，列出了常用的输入时间。 </li> 
    </ul> 
    <p> 修改“Date&nbsp;published”点击“Today”和“Now”快捷方式。然后点击“Save&nbsp;and&nbsp;continue&nbsp;editing.”，然后点击“History”在右上角。你会看到一个页面，列出通过Django管理到这个对象的所有变化，修改人用户名和时间戳：<br> <img src="/uploads/tutorial/20160131/1-160131111Q5122.png" alt=""><br> 代码下载：<a target="_blank" href="http://pan.baidu.com/s/1jGR3wDg">http://pan.baidu.com/s/1jGR3wDg</a> </p> 
    <img src="file://E:/data/youdao/qq24B39E2329F08D9F4C3146A571A415EF/bc173ef463b044269dc77f24dc06708d/admin06t.png" alt="History page for question object"> 
   </div> 
  </div> 
 </div>
 <br>      
</div></body></html>