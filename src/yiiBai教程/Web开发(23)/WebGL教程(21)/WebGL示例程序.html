<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">WebGL示例程序</h1><div style="width:100%;float:left;" class="article-content">   
 <div> 
  <div>
    我们已经讨论过了WebGL和WebGL管道的基础知识(一个遵循的程序来渲染图形应用程序)。在本章中，我们将采取一个示例应用程序使用WebGL创建一个三角形，并观察遵循应用程序的步骤。
  </div> 
 </div> 
 <div> 
  <h2> WebGL应用程序的结构</h2> 
  <div>
    WebGL应用程序代码是JavaScript和OpenGL着色语言的组合。
  </div> 
  <ul> 
   <li> 
    <div>
      JavaScript是需要与CPU进行沟通
    </div> </li> 
   <li> 
    <div>
      OpenGL着色语言，需要与GPU通信
    </div> </li> 
  </ul> 
  <p> <img alt="" src="/uploads/tutorial/20151216/1-1512160H41Ia.jpg" style="width: 588px; height: 376px;"></p> 
  <h2> 示例应用程序</h2> 
  <div>
    现在让我们举一个简单的例子，来了解如何使用WebGL绘制一个简单的三角形二维坐标。
  </div> 
  <pre style="Menlo, Monaco, Consolas, 'Courier New', monospace; color: rgb(49, 49, 49); font-size: 14px;">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;body&gt;
      &lt;canvas width = "300" height = "300" id = "my_Canvas"&gt;&lt;/canvas&gt;
		
      &lt;script&gt;


         <b style="background-color: inherit;">/* Step1: Prepare the canvas and get WebGL context */</b>

         var canvas = document.getElementById('my_Canvas');
         var gl = canvas.getContext('experimental-webgl');


         <b style="background-color: inherit;">/* Step2: Define the geometry and store it in buffer objects */</b>

         var vertices = [-0.5, 0.5, -0.5, -0.5, 0.0, -0.5,];

         // Create a new buffer object
         var vertex_buffer = gl.createBuffer();

         // Bind an empty array buffer to it
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
         
         // Pass the vertices data to the buffer
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

         // Unbind the buffer
         gl.bindBuffer(gl.ARRAY_BUFFER, null);


         <b style="background-color: inherit;">/* Step3: Create and compile Shader programs */</b>

         // Vertex shader source code
         var vertCode =
            'attribute vec2 coordinates;' + 
            'void main(void) {' + ' gl_Position = vec4(coordinates,0.0, 1.0);' + '}';

         //Create a vertex shader object
         var vertShader = gl.createShader(gl.VERTEX_SHADER);

         //Attach vertex shader source code
         gl.shaderSource(vertShader, vertCode);

         //Compile the vertex shader
         gl.compileShader(vertShader);

         //Fragment shader source code
         var fragCode = 'void main(void) {' + 'gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);' + '}';

         // Create fragment shader object
         var fragShader = gl.createShader(gl.FRAGMENT_SHADER);

         // Attach fragment shader source code
         gl.shaderSource(fragShader, fragCode);

         // Compile the fragment shader
         gl.compileShader(fragShader);

         // Create a shader program object to store combined shader program
         var shaderProgram = gl.createProgram();

         // Attach a vertex shader
         gl.attachShader(shaderProgram, vertShader); 
         
         // Attach a fragment shader
         gl.attachShader(shaderProgram, fragShader);

         // Link both programs
         gl.linkProgram(shaderProgram);

         // Use the combined shader program object
         gl.useProgram(shaderProgram);


         <b style="background-color: inherit;">/* Step 4: Associate the shader programs to buffer objects */</b>

         //Bind vertex buffer object
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

         //Get the attribute location
         var coord = gl.getAttribLocation(shaderProgram, "coordinates");

         //point an attribute to the currently bound VBO
         gl.vertexAttribYiibaier(coord, 2, gl.FLOAT, false, 0, 0);

         //Enable the attribute
         gl.enableVertexAttribArray(coord);


         <b style="background-color: inherit;">/* Step5: Drawing the required object (triangle) */</b>

         // Clear the canvas
         gl.clearColor(0.5, 0.5, 0.5, 0.9);

         // Enable the depth test
         gl.enable(gl.DEPTH_TEST); 
         
         // Clear the color buffer bit
         gl.clear(gl.COLOR_BUFFER_BIT);

         // Set the view port
         gl.viewport(0,0,canvas.width,canvas.height);

         // Draw the triangle
         gl.drawArrays(gl.TRIANGLES, 0, 3);
         
      &lt;/script&gt;
      
   &lt;/body&gt;
&lt;/html&gt;</pre> 
  <div>
    这将产生以下结果&nbsp;-
  </div> 
  <p> <img alt="" src="/uploads/tutorial/20151216/1-1512160H645637.png" style="width: 638px; height: 421px;"></p> 
  <div>
    我们使用WebGL绘制一个简单的三角形遵循五个序列步骤。这些步骤的解释如下-
  </div> 
  <h4> 步骤1&nbsp;-&nbsp;准备画布，并得到WebGL的渲染上下文</h4> 
  <div>
    我们得到当前HTML&nbsp;Canvas对象并获取WebGL渲染环境。
  </div> 
  <h4> 步骤2&nbsp;-&nbsp;定义几何并将其存储在缓冲器的对象</h4> 
  <div>
    我们定义几何的如顶点，索引，颜色等的属性，并把它们存储在&nbsp;JavaScrip&nbsp;t数组。然后，我们创建一个或多个缓冲器的对象和传递包含数据到相应的缓冲对象的阵列。在这个例子中，我们存储一个三角形的顶点在JavaScript数组中，并传递这个数组到一个顶点缓冲区对象。
  </div> 
  <h4> 步骤3&nbsp;-&nbsp;创建和编译着色器程序</h4> 
  <div>
    我们写的顶点着色器和片段着色器程序，编译它们，并通过连接这两个程序将创建一个合并成程序。
  </div> 
  <h4> 步骤4&nbsp;-&nbsp;关联缓冲区对象和着色器程序</h4> 
  <div>
    我们关联缓冲器对象，并合并的着色器程序。
  </div> 
  <h4> 第5步&nbsp;-&nbsp;绘制所需的对象(三角形)</h4> 
  <p> 此步骤包括操作如：清除颜色，清除缓冲比特，启用深度测试，设置视图端口等。最后，使用其中一个方法所需要的原语来绘制&nbsp;−&nbsp;drawArrays()&nbsp;或&nbsp;drawElements().</p> 
  <div>
    所有这些步骤在本教程中进一步解释。
  </div> 
 </div> 
 <br> 
 <br>      
</div></body></html>