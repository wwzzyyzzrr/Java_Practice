<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Spring MVC概述</h1><div style="width:100%;float:left;" class="article-content">   
 <p><strong>Spring MVC</strong>框架是一个开源的Java平台，为开发强大的基于Java的Web应用程序提供全面的基础架构支持非常容易和非常快速。</p> 
 <p>Spring框架最初由<strong>Rod Johnson</strong>撰写，并于2003年6月根据<strong>Apache 2.0</strong>许可证首次发布。</p> 
 <p>本教程是基于2015年3月发布的<strong>Spring Framework</strong>版本<code>4.1.6</code>编写的。</p> 
 <p><strong>Spring web MVC</strong>框架提供了MVC(模型 - 视图 - 控制器)架构和用于开发灵活和松散耦合的Web应用程序的组件。 <strong>MVC</strong>模式导致应用程序的不同方面(输入逻辑，业务逻辑和UI逻辑)分离，同时提供这些元素之间的松散耦合。</p> 
 <ul> 
  <li><strong>模型(Model)</strong>封装了应用程序数据，通常它们将由<code>POJO</code>类组成。</li>
  <li><strong>视图(View)</strong>负责渲染模型数据，一般来说它生成客户端浏览器可以解释HTML输出。</li>
  <li><strong>控制器(Controller)</strong>负责处理用户请求并构建适当的模型，并将其传递给视图进行渲染。</li>
 </ul> 
 <h2 id="h2-dispatcherservlet-"><a name="DispatcherServlet组件类" class="reference-link"></a><span class="header-link octicon octicon-link"></span>DispatcherServlet组件类</h2>
 <p><strong>Spring Web</strong>模型 - 视图 - 控制器(MVC)框架是围绕<code>DispatcherServlet</code>设计的，它处理所有的HTTP请求和响应。 <strong>Spring Web MVC DispatcherServlet</strong>的请求处理工作流如下图所示：</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201701/18/451110124_66519.png" alt=""></p> 
 <p>以下是对应于到<code>DispatcherServlet</code>的传入HTTP请求的事件顺序：</p> 
 <ul> 
  <li>在接收到HTTP请求后，<code>DispatcherServlet</code>会查询<code>HandlerMapping</code>以调用相应的<code>Controller</code>。</li>
  <li><code>Controller</code>接受请求并根据使用的<code>GET</code>或<code>POST</code>方法调用相应的服务方法。 服务方法将基于定义的业务逻辑设置模型数据，并将视图名称返回给<code>DispatcherServlet</code>。</li>
  <li><code>DispatcherServlet</code>将从<code>ViewResolver</code>获取请求的定义视图。</li>
  <li>当视图完成，<code>DispatcherServlet</code>将模型数据传递到最终的视图，并在浏览器上呈现。</li>
 </ul> 
 <p>所有上述组件，即: <code>HandlerMapping</code>，<code>Controller</code>和<code>ViewResolver</code>是<code>WebApplicationContext</code>的一部分，它是普通<code>ApplicationContext</code>的扩展，带有Web应用程序所需的一些额外功能。</p> 
 <h2 id="h2-u5FC5u9700u7684u914Du7F6E"><a name="必需的配置" class="reference-link"></a><span class="header-link octicon octicon-link"></span>必需的配置</h2>
 <p>需要通过使用<code>web.xml</code>文件中的URL映射来映射希望<code>DispatcherServlet</code>处理的请求。 下面是一个示例来显示<code>HelloWeb DispatcherServlet</code>示例的声明和映射：</p> 
 <pre><code class="lang-xml">&lt;web-app id="WebApp_ID" version="2.4"
    xmlns="http://java.sun.com/xml/ns/j2ee" 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee 
    http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt;

    &lt;display-name&gt;Spring MVC Application&lt;/display-name&gt;

   &lt;servlet&gt;
      &lt;servlet-name&gt;HelloWeb&lt;/servlet-name&gt;
      &lt;servlet-class&gt;
         org.springframework.web.servlet.DispatcherServlet
      &lt;/servlet-class&gt;
      &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
   &lt;/servlet&gt;

   &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;HelloWeb&lt;/servlet-name&gt;
      &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;

&lt;/web-app&gt;
</code></pre> 
 <p><code>web.xml</code>文件将保存Web应用程序的<code>WebContent/WEB-INF</code>目录。在<code>HelloWeb DispatcherServlet</code>初始化时，框架将尝试从位于应用程序的<code>WebContent/WEB-INF</code>目录中的名为<code>[servlet-name]-servlet.xml</code>的文件加载应用程序上下文。在这个示例中，使用的文件将是<code>HelloWeb-servlet.xml</code>。</p> 
 <p>接下来，<code>&lt;servlet-mapping&gt;</code>标记指示哪些<code>URL</code>将由<code>DispatcherServlet</code>处理。 这里所有以<code>.jsp</code>结尾的HTTP请求都将由<code>HelloWeb DispatcherServlet</code>处理。</p> 
 <p>如果不想使用默认文件名为<code>[servlet-name]-servlet.xml</code>和默认位置为<code>WebContent/WEB-INF</code>，可以通过在<code>web.xml</code>文件中添加<code>servlet</code>侦听器<code>ContextLoaderListener</code>来自定义此文件名和位置 如下：</p> 
 <pre><code class="lang-java">&lt;web-app...&gt;

&lt;!-------- DispatcherServlet definition goes here-----&gt;
....
&lt;context-param&gt;
   &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
   &lt;param-value&gt;/WEB-INF/HelloWeb-servlet.xml&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;listener&gt;
   &lt;listener-class&gt;
      org.springframework.web.context.ContextLoaderListener
   &lt;/listener-class&gt;
&lt;/listener&gt;
&lt;/web-app&gt;
</code></pre> 
 <p>现在来看看<code>HelloWeb-servlet.xml</code>文件的必需配置，放在Web应用程序的<code>WebContent/WEB-INF</code>目录中：</p> 
 <pre><code class="lang-java">&lt;beans xmlns="http://www.springframework.org/schema/beans"
   xmlns:context="http://www.springframework.org/schema/context"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="
   http://www.springframework.org/schema/beans     
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
   http://www.springframework.org/schema/context 
   http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;

   &lt;context:component-scan base-package="com.yiibai" /&gt;

   &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
      &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt;
      &lt;property name="suffix" value=".jsp" /&gt;
   &lt;/bean&gt;

&lt;/beans&gt;
</code></pre> 
 <p>以下是有关<code>HelloWeb-servlet.xml</code>文件的重点说明：</p> 
 <ul> 
  <li><p><code>[servlet-name]-servlet.xml</code>文件将用于创建定义的<code>bean</code>，它会覆盖在全局范围中使用相同名称定义的任何<code>bean</code>的定义。</p> </li>
  <li><p><code>&lt;context：component-scan ...&gt;</code>标签将用于激活<code>Spring MVC</code>注释扫描功能，允许使用<code><a target="_blank" href="https://github.com/Controller" title="@Controller" class="at-link"></a><a target="_blank" href="https://github.com/Controller" title="@Controller" class="at-link">@Controller</a></code>和<code><a target="_blank" href="https://github.com/RequestMapping" title="@RequestMapping" class="at-link"></a><a target="_blank" href="https://github.com/RequestMapping" title="@RequestMapping" class="at-link">@RequestMapping</a></code>等注释。</p> </li>
  <li><p><code>InternalResourceViewResolver</code>将定义用于解析视图名称的规则。根据上面定义的规则，<code>hello</code>的逻辑视图将委托给位于<code>/WEB-INF/jsp/hello.jsp</code>这个视图来实现。</p> </li>
 </ul> 
 <p>下一节将演示如何创建实际组件。即：控制器，模型和视图。</p> 
 <h2 id="h2-u5B9Au4E49u63A7u5236u5668"><a name="定义控制器" class="reference-link"></a><span class="header-link octicon octicon-link"></span>定义控制器</h2>
 <p><code>DispatcherServlet</code>将请求委派给控制器以执行特定于其的功能。 <code><a target="_blank" href="https://github.com/Controller" title="@Controller" class="at-link">@Controller</a></code>注释指示特定类充当控制器的角色。<code><a target="_blank" href="https://github.com/RequestMapping" title="@RequestMapping" class="at-link">@RequestMapping</a></code>注释用于将URL映射到整个类或特定处理程序方法。</p>   
 <pre><code class="lang-java">@Controller
@RequestMapping("/hello")
public class HelloController{

   @RequestMapping(method = RequestMethod.GET)
   public String printHello(ModelMap model) {
      model.addAttribute("message", "Hello Spring MVC Framework!");
      return "hello";
   }

}
</code></pre> 
 <p><code><a target="_blank" href="https://github.com/Controller" title="@Controller" class="at-link">@Controller</a></code>注释将类定义为<code>Spring MVC</code>控制器。这里<code><a target="_blank" href="https://github.com/RequestMapping" title="@RequestMapping" class="at-link">@RequestMapping</a></code>的第一个用法表示此控制器上的所有处理方法都与<code>/hello</code>路径相关。 下一个注释<code><a target="_blank" href="https://github.com/RequestMapping" title="@RequestMapping" class="at-link">@RequestMapping</a>(method = RequestMethod.GET)</code>用于声明<code>printHello()</code>方法作为控制器的默认服务方法来处理HTTP GET请求。可以定义另一个方法来处理同一<code>URL</code>的任何POST请求。</p> 
 <p>可以以另一种形式在上面的控制器中编写，在<code><a target="_blank" href="https://github.com/RequestMapping" title="@RequestMapping" class="at-link">@RequestMapping</a></code>中添加其他属性，如下所示：</p> 
 <pre><code class="lang-java">@Controller
public class HelloController{

   @RequestMapping(value = "/hello", method = RequestMethod.GET)
   public String printHello(ModelMap model) {
      model.addAttribute("message", "Hello Spring MVC Framework!");
      return "hello";
   }

}
</code></pre> 
 <p><code>value</code>属性指示处理程序方法映射到的URL，<code>method</code>属性定义处理HTTP GET请求的服务方法。关于以上定义的控制器，需要注意以下几点：</p> 
 <ul> 
  <li>在服务方法中定义所需的业务逻辑。可以根据需要在此方法内调用其他方法。</li>
  <li>基于定义的业务逻辑，将在此方法中创建一个模型。可以设置不同的模型属性，这些属性将被视图访问以呈现最终结果。此示例创建且有属性“<code>message</code>”的模型。</li>
  <li>定义的服务方法可以返回一个<code>String</code>，它包含要用于渲染模型的视图的名称。此示例将“<code>hello</code>”返回为逻辑视图名称。</li>
 </ul> 
 <h2 id="h2--jsp-"><a name="创建JSP视图" class="reference-link"></a><span class="header-link octicon octicon-link"></span>创建JSP视图</h2>
 <p><strong>Spring MVC</strong>支持许多类型的视图用于不同的表示技术。包括 - JSP，HTML，PDF，Excel工作表，XML，Velocity模板，XSLT，JSON，Atom 和 RSS 源，JasperReports等。但最常见的是使用JSPL编写的JSP模板，这里使用的是JSP模板，并在<code>/WEB-INF/hello/hello.jsp</code>中写一个简单的<code>hello</code>视图：</p> 
 <pre><code class="lang-java">&lt;html&gt;
   &lt;head&gt;
   &lt;title&gt;Hello Spring MVC&lt;/title&gt;
   &lt;/head&gt;
   &lt;body&gt;
   &lt;h2&gt;${message}&lt;/h2&gt;
   &lt;/body&gt;
&lt;/html&gt;
</code></pre> 
 <p>这里<code>${message}</code>是在<code>Controller</code>中设置的属性。可以在视图中显示多个属性。</p>
 <br>      
</div></body></html>