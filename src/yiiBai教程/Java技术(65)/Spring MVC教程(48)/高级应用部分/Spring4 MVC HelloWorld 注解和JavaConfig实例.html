<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Spring4 MVC HelloWorld 注解和JavaConfig实例</h1><div style="width:100%;float:left;" class="article-content">   
 <div> 
  <div>
    在这一节中，我们以 Spring4&nbsp;MVC HelloWorld 注释/JavaConfig为示例，一步一步以简单的方式学习Spring4 MVC 的注解，项目设置，代码，部署和运行。 
  </div> 
 </div> 
 <p> <br> </p> 
 <p> 在先前的&nbsp;<a target="_blank" href="http://www.yiibai.com/spring_mvc/spring-mvc-tutorial-for-beginners.html">Spring MVC 4 Hello World XML教程示例中</a>,&nbsp;我们已经使用XML配置开发了一个Hello&nbsp;World&nbsp;Web应用程序。但是，XML不是配置Spring应用程序的唯一途径。或者，我们可以使用Java配置来配置应用程序。 </p> 
 <p> 如果回头看看之前的教程，你会发现我们已经使用XML配置在两个地方。第一个是&nbsp;spring-servlet.xml&nbsp;在这里我们定义的视图解析程序识别真正的视图，位置搜索，通过组件扫描Bean。第二个是&nbsp;web.xml,&nbsp;我们定义前端控制器配置和URL模式将被寻找匹配。 </p> 
 <p> 在本教程中，我们将再次创建一个Hello&nbsp;world的例子，但这个时候我们使用Java配置。&nbsp;我们将删除上面提到的XML文件，并通过它们对应的Java替换这些XML配置。 </p> 
 <hr> 
 <div>
   以下技术堆栈需要使用到： 
 </div> 
 <ul> 
  <li> Spring 4.0.6.RELEASE </li> 
  <li> Maven 3 </li> 
  <li> JDK 1.6 </li> 
  <li> Tomcat 8.0.21 </li> 
  <li> Eclipse JUNO Service Release 2 </li> 
 </ul> 
 <p> 现在我们开始！ </p> 
 <h4> 
  <div>
    第1步：创建所需的目录结构项目 
  </div> </h4> 
 <p> 文章&nbsp;<a target="_blank" href="http://www.yiibai.com/maven/create-a-maven-web-project-with-eclipse.html">使用Eclipse创建一个Maven web工程</a>&nbsp;包含使用Eclipse一步一步的向导来创建一个Maven项目。 </p> 
 <div>
   以下将是最后的项目结构。 
 </div> 
 <p> <img src="/uploads/tutorial/20160115/1-1601151F611956.png" alt=""> </p> 
 <div>
   现在，让我们来添加/更新上面讨论项目结构中每一个细节提到的内容。 
 </div> 
 <h4> 
  <div>
    第2步：使用Spring和Servlet依赖更新pom.xml 
  </div> </h4> 
 <p> 我们要讨论以 Spring&nbsp;Java为基础的配置取决于Servlet 3.0 的API，&nbsp;因此，我们需要包含的依赖在 pom.xml&nbsp;中。 </p> 
 <pre>&lt;?xml version="1.0"?&gt;
&lt;project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"
	xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
	&lt;groupId&gt;com.yiibai.springmvc&lt;/groupId&gt;
	&lt;artifactId&gt;Spring4MVCHelloWorldNoXMLDemo&lt;/artifactId&gt;
	&lt;packaging&gt;war&lt;/packaging&gt;
	&lt;version&gt;1.0.0&lt;/version&gt;
	&lt;name&gt;Spring4MVCHelloWorldNoXMLDemo&lt;/name&gt;

	&lt;properties&gt;
		&lt;springframework.version&gt;4.0.6.RELEASE&lt;/springframework.version&gt;
	&lt;/properties&gt;

	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework&lt;/groupId&gt;
			&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
			&lt;version&gt;${springframework.version}&lt;/version&gt;
		&lt;/dependency&gt;

		&lt;dependency&gt;
			&lt;groupId&gt;javax.servlet&lt;/groupId&gt;
			&lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
			&lt;version&gt;3.1.0&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
			&lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;
			&lt;version&gt;2.3.1&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;javax.servlet&lt;/groupId&gt;
			&lt;artifactId&gt;jstl&lt;/artifactId&gt;
			&lt;version&gt;1.2&lt;/version&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;

	&lt;build&gt;
		&lt;pluginManagement&gt;
			&lt;plugins&gt;
				&lt;plugin&gt;
					&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
					&lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
					&lt;version&gt;2.4&lt;/version&gt;
					&lt;configuration&gt;
						&lt;warSourceDirectory&gt;src/main/webapp&lt;/warSourceDirectory&gt;
						&lt;warName&gt;Spring4MVCHelloWorldNoXMLDemo&lt;/warName&gt;
						&lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;
					&lt;/configuration&gt;
				&lt;/plugin&gt;
			&lt;/plugins&gt;
		&lt;/pluginManagement&gt;
		&lt;finalName&gt;Spring4MVCHelloWorldNoXMLDemo&lt;/finalName&gt;
	&lt;/build&gt;
&lt;/project&gt;&nbsp;</pre> 
 <p> 首先要注意这里maven-war-plugin&nbsp;插件的声明。正如我们将完全删除web.xml&nbsp;，我们需要配置这个插件，以避免Maven构建war包失败。第二个变化是加入了JSP/Servlet/Jstl&nbsp;的依赖关系，这些我们可能需要，因为我们将要使用&nbsp;servlet&nbsp;API和JSTL视图在我们的代码中。在一般情况下，容器已经包含这些库，从而在pom.xml中为他们提供了，我们可以设置作用范围。 </p> 
 <h4> 
  <div>
    第3步：添加控制器 
  </div> </h4> 
 <div>
   在src/main/java下添加一个控制器类，如下所示： 
 </div> 
 <p> com.yiibai.springmvc.controller.HelloWorldController </p> 
 <pre>package com.yiibai.springmvc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.ModelMap;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

@Controller
@RequestMapping("/")
public class HelloWorldController {

	@RequestMapping(method = RequestMethod.GET)
	public String sayHello(ModelMap model) {
		model.addAttribute("greeting", "Hello World from Spring 4 MVC");
		return "welcome";
	}

	@RequestMapping(value = "/helloagain", method = RequestMethod.GET)
	public String sayHelloAgain(ModelMap model) {
		model.addAttribute("greeting", "Hello World Again, from Spring 4 MVC");
		return "welcome";
	}

}&nbsp;</pre> 
 <p> 在类名@Controller注解声明这个类的Spring&nbsp;bean&nbsp;以及&nbsp;@RequestMapping注解声明了这个类是默认处理程序键入“/”的所有请求。第一种方法没有声明因此任何映射，它将继承映射的映射声明是在类级别上，默认处理GET请求。方法二(由于额外的映射声明使用value属性)形式&nbsp;/hello&nbsp;将再次请求。属性方法说哪种类型的HTTP请求这种方法可以服务。 </p> 
 <p> 方法说哪种类型的HTTP请求这种方法可以服务。&nbsp;ModelMap是一个Map实现，在这里作为替代[request.getAttribute()/request.setAttribute()]&nbsp;设定值作为请求属性。请注意，我们从这个方法返回“welcome”字符串。此字符串将后缀和前缀后缀，在视图解析器定义的前缀(见上面的&nbsp;spring-servlet.xml)，形成真正的视图文件名。 </p> 
 <h4> 
  <div>
    第4步：添加视图 
  </div> </h4> 
 <p> 创建一个新的文件夹命名为views在WEB-INF目录下，并添加一个简单的JSP页面welcome.jsp&nbsp;(WEB-INF/views/welcome.jsp)从控制器到简单的访问模式值。 </p> 
 <pre>&lt;%@ page language="java" contentType="text/html; charset=utf-8"
    pageEncoding="utf-8"%&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;
&lt;title&gt;HelloWorld page&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
	Greeting : ${greeting}
&lt;/body&gt;
&lt;/html&gt;</pre> 
 <h4> 
  <div>
    第5步：添加配置类 
  </div> </h4> 
 <p> 在src/main/java下添加下面提到的类指定的包，如下图所示。这种构造类可以被看作是一个替代 spring-servlet.xml，因为它包含了所有必需的组件的扫描和视图解析器的信息。 </p> 
 <p> com.yiibai.springmvc.configuration.HelloWorldConfiguration </p> 
 <pre>package com.yiibai.springmvc.configuration;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.ViewResolver;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.view.InternalResourceViewResolver;
import org.springframework.web.servlet.view.JstlView;

@Configuration
@EnableWebMvc
@ComponentScan(basePackages = "com.yiibai.springmvc")
public class HelloWorldConfiguration {
	@Bean
	public ViewResolver viewResolver() {
		InternalResourceViewResolver viewResolver = new InternalResourceViewResolver();
		viewResolver.setViewClass(JstlView.class);
		viewResolver.setPrefix("/WEB-INF/views/");
		viewResolver.setSuffix(".jsp");

		return viewResolver;
	}

}&nbsp;</pre> 
 <p> @Configuration指明该类包含注解为@Bean 生产 bean管理是由Spring容器的一个或多个bean方法。&nbsp;以上配置类对应等同于以下XML： </p>   
 <pre>&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:mvc="http://www.springframework.org/schema/mvc"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
 	http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd
 	http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt;

	&lt;context:component-scan base-package="com.yiibai.springmvc" /&gt;

	&lt;mvc:annotation-driven /&gt;
	
	&lt;bean
		class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
		&lt;property name="prefix"&gt;
			&lt;value&gt;/WEB-INF/views/&lt;/value&gt;
		&lt;/property&gt;
		&lt;property name="suffix"&gt;
			&lt;value&gt;.jsp&lt;/value&gt;
		&lt;/property&gt;
	&lt;/bean&gt;

&lt;/beans&gt;</pre> 
 <p> @EnableWebMvc&nbsp;等同于&nbsp;mvc:annotation-driven 在XML中.&nbsp;它能够为使用@RequestMapping向特定的方法传入的请求映射@Controller-annotated&nbsp;类。 </p> 
 <p> @ComponentScan&nbsp;等同于&nbsp;context:component-scan base-package="..."&nbsp;提供&nbsp;spring&nbsp;在哪里寻找 管理&nbsp;beans/classes. </p> 
 <h4> 
  <div>
    第6步：添加初始化类 
  </div> </h4> 
 <p> 添加一个初始化类实现&nbsp;WebApplicationInitializer&nbsp;在src/main/java&nbsp;中使用如下图所示指定包(在这种情况下，作为替代在&nbsp;web.xml&nbsp;中定义的任何&nbsp;Spring&nbsp;配置)。在Servlet&nbsp;3.0的容器启动时，这个类将被加载并初始化，并在启动由servlet容器调用方法。 </p> 
 <p> com.yiibai.springmvc.configuration.HelloWorldInitializer </p> 
 <pre>package com.yiibai.springmvc.configuration;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletRegistration;

import org.springframework.web.WebApplicationInitializer;
import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;
import org.springframework.web.servlet.DispatcherServlet;

public class HelloWorldInitializer implements WebApplicationInitializer {

	public void onStartup(ServletContext container) throws ServletException {

		AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();
		ctx.register(HelloWorldConfiguration.class);
		ctx.setServletContext(container);

		ServletRegistration.Dynamic servlet = container.addServlet("dispatcher", new DispatcherServlet(ctx));

		servlet.setLoadOnStartup(1);
		servlet.addMapping("/");
	}

}
&nbsp;</pre> 
 <p> 内容上面类似 web.xml 在之前的教程中的内容，因为我们使用的是前端控制器 DispatcherServlet，分配映射(URL模式的XML)和而不是提供给&nbsp;Spring&nbsp;配置文件(spring-servlet.xml)的路径，在这里，我们正在注册的配置类。总体而言，我们都在做同样的事情，只是方式有所不同。 </p> 
 <p> 更新：请注意，现在你可以更简洁写上面的类[和它的最佳方法] 来扩展&nbsp;AbstractAnnotationConfigDispatcherServletInitializer&nbsp;类，如下所示： </p> 
 <pre>package com.yiibai.springmvc.configuration;

import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;

public class HelloWorldInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

	@Override
	protected Class&lt;?&gt;[] getRootConfigClasses() {
		return new Class[] { HelloWorldConfiguration.class };
	}
 
	@Override
	protected Class&lt;?&gt;[] getServletConfigClasses() {
		return null;
	}
 
	@Override
	protected String[] getServletMappings() {
		return new String[] { "/" };
	}

}</pre> 
 <h4> 
  <div>
    第7步：构建和部署应用程序 
  </div> </h4> 
 <p> 有一点要记住，像WebApplicationInitializer，Spring&nbsp;是基于Java&nbsp;的配置API依赖于&nbsp;Servlet3.0容器。确保你没有使用Servlet声明任何小于3.0。对于我们的情况，我们将从应用程序中删除 web.xml 文件。 </p> 
 <p> 现在构建war&nbsp;(无论是作为Eclipse中提到的最后一个教程)或通过Maven的命令行(mvn&nbsp;clean&nbsp;install)。部署war&nbsp;到Servlet3.0容器。由于我在这里使用Tomcat，我就干脆把这个 war 文件放到 Tomcat 的 webapps 文件夹，然后在 tomcat 的bin 目录里面点击 start.bat&nbsp;运行。 </p> 
 <p> 或者 右键工程 =&gt;Run As =&gt; Maven install 完成后，再次&nbsp;右键工程 =&gt;Run As =&gt; Maven build，弹出选择： </p> 
 <p> <img src="/uploads/tutorial/20160115/1-1601151FA0291.png" alt=""> </p> 
 <div>
   运行应用程序，现在我们来访问URL: http://localhost:8080/Spring4MVCHelloWorldNoXMLDemo，显示结果如下所示： 
 </div> 
 <p> <img src="/uploads/tutorial/20160115/1-1601151FH02K.png" alt=""><br> <img src="/uploads/tutorial/20160115/1-1601151FJ14W.png" alt=""> </p> 
 <p> 就这样，完成！ </p> 
 <p> 代码下载：<a target="_blank" href="http://pan.baidu.com/s/1nugPMcT">http://pan.baidu.com/s/1nugPMcT</a> </p> 
 <p> <br> </p>
 <br>      
</div></body></html>