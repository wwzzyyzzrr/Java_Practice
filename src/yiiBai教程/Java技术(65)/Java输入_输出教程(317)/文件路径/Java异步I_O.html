<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java异步I/O</h1><div style="width:100%;float:left;" class="article-content">   
 <p>在同步文件<code>I/O</code>中，对<code>I/O</code>操作的请求将等待，直到<code>I/O</code>操作完成。在异步文件<code>I/O</code>中，<code>I/O</code>操作的请求由系统异步执行。当系统完成文件<code>I/O</code>时，它通知应用程序其请求的完成。</p> 
 <p><code>java.nio.channels.AsynchronousFileChannel</code>类表示异步文件通道。使用<code>AsynchronousFileChannel</code>类的静态<code>open()</code>方法获取<code>AsynchronousFileChannel</code>类的实例。</p> 
 <p>以下代码显示了如何获取<code>WRITE</code>的异步文件通道。</p> 
 <pre><code class="lang-java">Path  path   = Paths.get("C:\\Java_Dev\\rainbow.txt");
AsynchronousFileChannel afc   = AsynchronousFileChannel.open(path, WRITE,  CREATE);
</code></pre> 
 <p><code>AsynchronousFileChannel</code>提供了两种方法来处理异步文件<code>I/O</code>操作的结果。</p> 
 <ul> 
  <li>使用<code>java.util.concurrent.Future</code>对象。</li>
  <li>使用<code>java.nio.channels.CompletionHandler</code> 对象。</li>
 </ul> 
 <p>支持异步文件<code>I/O</code>操作的<code>AsynchronousFileChannel</code>类的每个方法有两个版本。一个版本返回一个<code>Future</code>对象，可以使用它来处理所请求的异步操作的结果。</p> 
 <p><code>Future</code>对象的<code>get()</code>方法返回写入文件通道的字节数。以下代码使用返回<code>Future</code>对象的<code>write()</code>方法的版本：</p> 
 <pre><code class="lang-java">ByteBuffer dataBuffer  = a buffer;
long  startPosition = 0;
Future&lt;Integer&gt; result = afc.write(dataBuffer, startPosition);
</code></pre> 
 <p>当得到一个<code>Future</code>对象后，可以使用轮询方法或阻塞等待方法来处理异步文件<code>I/O</code>的结果。</p> 
 <p>下面的代码显示了轮询方法，它将继续调用<code>Future</code>对象的<code>isDone()</code>方法来检查<code>I/O</code>操作是否完成：</p> 
 <pre><code class="lang-java">while (!result.isDone()) {
}
int writtenNumberOfBytes = result.get();
</code></pre> 
 <p><code>AsynchronousFileChannel</code>类的另一个版本的方法获得一个<code>CompletionHandler</code>对象，当请求的异步<code>I/O</code>操作完成或失败时，该对象的方法被调用。</p> 
 <p><code>CompletionHandler</code>接口有两个方法：<code>completed()</code>和<code>failed()</code>。当所请求的<code>I/O</code>操作成功完成时，将调用<code>completed()</code>方法。当请求的<code>I/O</code>操作失败时，将调用<code>failed()</code>方法。</p> 
 <p>以下代码使用<code>Attachment</code>类的对象作为完成处理程序的附件：</p> 
 <pre><code class="lang-java">class  Attachment {
    public Path  path;
    public  ByteBuffer buffer;
    public  AsynchronousFileChannel asyncChannel;
}
class MyHandler implements CompletionHandler&lt;Integer,  Attachment&gt;   {
    @Override
    public void  completed(Integer result, Attachment attach)  {
        // Handle  completion of  the   I/O  operation
    }

    @Override
    public void  failed(Throwable e,  Attachment attach)  {
        // Handle  failure of  the   I/O  operation
    }
}
</code></pre> 
 <p>以下代码使用<code>MyHandler</code>实例作为异步写操作的完成处理程序。</p> 
 <pre><code class="lang-java">MyHandler handler = new MyHandler();
ByteBuffer dataBuffer  = get   a  data buffer;
Attachment attach  = new Attachment(); 
attach.asyncChannel = afc; 
attach.buffer = dataBuffer; 
attach.path = path;

// Perform  the   asynchronous write operation 
afc.write(dataBuffer, 0, attach, handler);
</code></pre> 
 <p>以下代码演示了如何使用<code>CompletionHandler</code>对象来处理对文件的异步写入的结果。</p> 
 <pre><code class="lang-java">import static java.nio.file.StandardOpenOption.CREATE;
import static java.nio.file.StandardOpenOption.WRITE;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousFileChannel;
import java.nio.channels.CompletionHandler;
import java.nio.charset.Charset;
import java.nio.file.Path;
import java.nio.file.Paths;
public class Main {
  public static void main(String[] args) throws Exception {
    Path path = Paths.get("test.txt");
    AsynchronousFileChannel afc = AsynchronousFileChannel.open(path, WRITE,
        CREATE);
    WriteHandler handler = new WriteHandler();
    ByteBuffer dataBuffer = getDataBuffer();
    Attachment attach = new Attachment();
    attach.asyncChannel = afc;
    attach.buffer = dataBuffer;
    attach.path = path;

    afc.write(dataBuffer, 0, attach, handler);

    System.out.println("Sleeping for 5  seconds...");
    Thread.sleep(5000);
  }
  public static ByteBuffer getDataBuffer() {
    String lineSeparator = System.getProperty("line.separator");
    StringBuilder sb = new StringBuilder();
    sb.append("test");
    sb.append(lineSeparator);
    sb.append("test");
    sb.append(lineSeparator);
    String str = sb.toString();
    Charset cs = Charset.forName("UTF-8");
    ByteBuffer bb = ByteBuffer.wrap(str.getBytes(cs));
    return bb;
  }
}
class Attachment {
  public Path path;
  public ByteBuffer buffer;
  public AsynchronousFileChannel asyncChannel;
}

class WriteHandler implements CompletionHandler&lt;Integer, Attachment&gt; {
  @Override
  public void completed(Integer result, Attachment attach) {
    System.out.format("%s bytes written  to  %s%n", result,
        attach.path.toAbsolutePath());
    try {
       attach.asyncChannel.close();
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  @Override
  public void failed(Throwable e, Attachment attach) {
    try {
      attach.asyncChannel.close();
    } catch (IOException e1) {
      e1.printStackTrace();
    }
  }
}
</code></pre> 
 <h2 id="h2-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h2>
 <p>以下代码演示了如何使用<code>Future</code>对象来处理对文件的异步写入的结果。</p> 
 <pre><code class="lang-java">import static java.nio.file.StandardOpenOption.CREATE;
import static java.nio.file.StandardOpenOption.WRITE;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousFileChannel;
import java.nio.charset.Charset;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.concurrent.Future;

public class Main {
    public static ByteBuffer getDataBuffer() {
        String lineSeparator = System.getProperty("line.separator");

        StringBuilder sb = new StringBuilder();
        sb.append("test");
        sb.append(lineSeparator);

        String str = sb.toString();
        Charset cs = Charset.forName("UTF-8");
        ByteBuffer bb = ByteBuffer.wrap(str.getBytes(cs));

        return bb;
    }

    public static void main(String[] args) throws Exception {
        Path path = Paths.get("test.txt");

        try (AsynchronousFileChannel afc = AsynchronousFileChannel.open(path, WRITE, CREATE)) {
            ByteBuffer dataBuffer = getDataBuffer();
            Future&lt;Integer&gt; result = afc.write(dataBuffer, 0);
            while (!result.isDone()) {
                System.out.println("Sleeping for 2  seconds...");
                Thread.sleep(2000);
            }
            int writtenBytes = result.get();
            System.out.format("%s bytes written  to  %s%n", writtenBytes, path.toAbsolutePath());

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre> 
 <p>上面的代码生成以下结果。</p>   
 <pre><code class="lang-java">Sleeping for 2  seconds...
6 bytes written  to  F:\website\yiibai\worksp\test.txt
</code></pre> 
 <h2 id="h2--2"><a name="实例-2" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例-2</h2>
 <p>以下代码演示了如何使用<code>CompletionHandler</code>对象来处理从文件进行异步读取的结果。</p> 
 <pre><code class="lang-java">import static java.nio.file.StandardOpenOption.READ;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousFileChannel;
import java.nio.channels.CompletionHandler;
import java.nio.charset.Charset;
import java.nio.file.Path;
import java.nio.file.Paths;

public class Main {
    public static void main(String[] args) throws Exception {
        Path path = Paths.get("test.txt");
        AsynchronousFileChannel afc = AsynchronousFileChannel.open(path, READ);
        ReadHandler handler = new ReadHandler();
        int fileSize = (int) afc.size();
        ByteBuffer dataBuffer = ByteBuffer.allocate(fileSize);

        Attachment attach = new Attachment();
        attach.asyncChannel = afc;
        attach.buffer = dataBuffer;
        attach.path = path;

        afc.read(dataBuffer, 0, attach, handler);

        System.out.println("Sleeping for 5  seconds...");
        Thread.sleep(5000);
    }
}

class Attachment {
    public Path path;
    public ByteBuffer buffer;
    public AsynchronousFileChannel asyncChannel;
}

class ReadHandler implements CompletionHandler&lt;Integer, Attachment&gt; {
    @Override
    public void completed(Integer result, Attachment attach) {
        System.out.format("%s bytes read   from  %s%n", result, attach.path);
        System.out.format("Read data is:%n");
        byte[] byteData = attach.buffer.array();
        Charset cs = Charset.forName("UTF-8");
        String data = new String(byteData, cs);
        System.out.println(data);
        try {
            // Close the channel
            attach.asyncChannel.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void failed(Throwable e, Attachment attach) {
        System.out.format("Read operation  on  %s  file failed." + "The  error is: %s%n", attach.path, e.getMessage());
        try {
            // Close the channel
            attach.asyncChannel.close();
        } catch (IOException e1) {
            e1.printStackTrace();
        }
    }
}
</code></pre> 
 <p>上面的代码生成以下结果。</p> 
 <pre><code class="lang-java">Sleeping for 5  seconds...
13 bytes read   from  test.txt
Read data is:
test
test2
</code></pre> 
 <h2 id="h2--3"><a name="实例-3" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例-3</h2>
 <p>以下代码显示了如何使用<code>Future</code>对象来处理从文件进行异步读取的结果。它使用等待方法(<code>Future.get()</code>方法调用)等待异步文件<code>I/O</code>完成。</p> 
 <pre><code class="lang-java">import static java.nio.file.StandardOpenOption.READ;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousFileChannel;
import java.nio.charset.Charset;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;

public class Main {
    public static void main(String[] args) throws Exception {
        Path path = Paths.get("test.txt");

        try (AsynchronousFileChannel afc = AsynchronousFileChannel.open(path, READ)) {
            int fileSize = (int) afc.size();
            ByteBuffer dataBuffer = ByteBuffer.allocate(fileSize);

            Future&lt;Integer&gt; result = afc.read(dataBuffer, 0);
            int readBytes = result.get();

            System.out.format("%s bytes read   from  %s%n", readBytes, path);
            System.out.format("Read data is:%n");

            byte[] byteData = dataBuffer.array();
            Charset cs = Charset.forName("UTF-8");
            String data = new String(byteData, cs);

            System.out.println(data);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }
}
</code></pre> 
 <p>上面的代码生成以下结果。</p> 
 <pre><code class="lang-java">13 bytes read   from  test.txt
Read data is:
test
test2
</code></pre>
 <br>      
</div></body></html>