<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java路径操作</h1><div style="width:100%;float:left;" class="article-content">   
 <h2 id="h2-u6BD4u8F83u8DEFu5F84"><a name="比较路径" class="reference-link"></a><span class="header-link octicon octicon-link"></span>比较路径</h2>
 <p>可以基于它们的文本表示来比较两个<code>Path</code>对象的相等性。<code>equals()</code>方法通过比较它们的字符串形式来测试两个<code>Path</code>对象的相等性。等式测试是否区分大小取决于文件系统。</p> 
 <p>以下代码显示如何比较Windows路径：</p> 
 <pre><code class="lang-java">import java.nio.file.Path;
import java.nio.file.Paths;

public class Main {
  public static void main(String[] args) throws Exception {
    Path  p1  = Paths.get("C:\\Java_Dev\\test1.txt"); 
    Path  p2  = Paths.get("C:\\Java_Dev\\LUCI1.TXT");
    Path  p3  = Paths.get("C:\\Java_Dev\\..\\Java_Dev\\test1.txt"); 
    boolean b1  = p1.equals(p2);
    System.out.println(b1);
    boolean b2  = p1.equals(p3);
    System.out.println(b2);
  }
}
</code></pre> 
 <p><code>equals()</code>方法在不解析实际文件引用的情况下以文本方式比较两个路径，并且不会测试文件系统中是否存在路径。</p> 
 <p><code>Path</code>接口实现<code>java.lang.Comparable</code>接口。可以使用它的<code>compareTo()</code>方法来与另一个<code>Path</code>对象进行文本比较。</p> 
 <p><code>compareTo()</code>方法返回一个<code>int</code>类型的值。</p> 
 <ul> 
  <li>0 - 表示两条路径相等。</li>
  <li>小于0 - 路径小于指定的路径。</li>
  <li>大于0 - 路径大于指定的路径。</li>
 </ul> 
 <p>上面的代码生成以下结果。</p> 
 <pre><code class="lang-java">false
false
</code></pre> 
 <h2 id="h2-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h2>
 <p>以下代码显示如何使用<code>compareTo()</code>方法：</p> 
 <pre><code class="lang-java">import java.nio.file.Path;
import java.nio.file.Paths;

public class Main {
    public static void main(String[] args) throws Exception {
        Path p1 = Paths.get("C:\\Java_Dev\\test1.txt");
        Path p2 = Paths.get("C:\\Java_Dev\\Test1.txt");
        Path p3 = Paths.get("C:\\Java_Dev\\..\\Java_Dev\\test1.txt");
        int v1 = p1.compareTo(p2);
        System.out.println(v1);
        int v2 = p1.compareTo(p3);
        System.out.println(v2);
    }
}
</code></pre> 
 <p>可以使用<code>endsWith()</code>和<code>startsWith()</code>方法分别测试路径是否以给定路径结尾和开始。<br>上面代码生成以下结果 - </p> 
 <pre><code class="lang-java">0
38
</code></pre> 
 <h2 id="h2--2"><a name="实例-2" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例-2</h2>
 <p>以下代码显示了如何在路径中使用<code>endsWith()</code>和<code>startsWith()</code>方法。</p> 
 <pre><code class="lang-java">import java.nio.file.Path;
import java.nio.file.Paths;

public class Main {
    public static void main(String[] args) throws Exception {
        Path p1 = Paths.get("C:\\Java_Dev\\test1.txt");
        Path p2 = Paths.get("test1.txt");
        Path p3 = Paths.get("Java_Dev\\test1.txt");
        Path p4 = Paths.get(".txt");

        // Using endsWith()
        boolean b1 = p1.endsWith(p2);
        System.out.println(b1);
        boolean b2 = p1.endsWith(p3);
        boolean b3 = p1.endsWith(p4);

        // Using startsWith()
        Path p5 = Paths.get("C:\\");
        Path p6 = Paths.get("C:\\Java_Dev");
        Path p7 = Paths.get("C:\\Java_Dev");

        boolean b4 = p1.startsWith(p5);
        boolean b5 = p1.startsWith(p6);
        boolean b6 = p1.startsWith(p7);
    }
}
</code></pre> 
 <p>上面的代码生成以下结果。</p> 
 <pre><code class="lang-java">true
</code></pre> 
 <h2 id="h2--3"><a name="实例-3" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例-3</h2>
 <p>以下代码演示了<code>isSameFile()</code>方法的工作原理。 它检查如果两个路径将找到相同的文件。</p> 
 <pre><code class="lang-java">import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class Main {
  public static void main(String[] args) {
    // Assume that C:\Java_Dev\test1.txt file exists
    Path p1 = Paths.get("C:\\Java_Dev\\test1.txt");
    Path p2 = Paths.get("C:\\Java_Dev\\..\\Java_Dev\\test1.txt");

    // Assume that C:\abc.txt file does not exist
    Path p3 = Paths.get("C:\\abc.txt");
    Path p4 = Paths.get("C:\\abc.txt");

    try {
      boolean isSame = Files.isSameFile(p1, p2);
      System.out.println("p1 and  p2  are   the   same:  " + isSame);

      isSame = Files.isSameFile(p3, p4);
      System.out.println("p3 and  p4  are   the   same:  " + isSame);
    }catch (IOException e) {
      e.printStackTrace();
    }
  }
}
</code></pre> 
 <h2 id="h2-u89C4u8303u5316u8DEFu5F84"><a name="规范化路径" class="reference-link"></a><span class="header-link octicon octicon-link"></span>规范化路径</h2>
 <p><code>Path</code>接口的<code>normalize()</code>方法在删除点字符后返回一个Path。此方法不访问文件系统。<br>以下代码显示了在Windows上标准化路径的一些示例。</p>   
 <pre><code class="lang-java">import java.nio.file.Path;
import java.nio.file.Paths;

public class Main {
    public static void main(String[] args) throws Exception {
        Path p1 = Paths.get("C:\\Java_Dev\\..\\\\Java_Dev\\test1.txt");
        Path p1n = p1.normalize();
        System.out.println(p1 + "  normalized to " + p1n);

        Path p2 = Paths.get("C:\\Java_Dev\\test1.txt");
        Path p2n = p2.normalize();
        System.out.println(p2 + "  normalized to " + p2n);

        Path p3 = Paths.get("\\..\\.\\test.txt");
        Path p3n = p3.normalize();
        System.out.println(p3 + "  normalized to " + p3n);
    }
}
</code></pre> 
 <p>执行上面的代码，生成以下结果 - </p> 
 <pre><code class="lang-java">C:\Java_Dev\..\Java_Dev\test1.txt  normalized to C:\Java_Dev\test1.txt
C:\Java_Dev\test1.txt  normalized to C:\Java_Dev\test1.txt
\..\.\test.txt  normalized to \test.txt
</code></pre> 
 <h2 id="h2-u89E3u51B3u8DEFu5F84"><a name="解决路径" class="reference-link"></a><span class="header-link octicon octicon-link"></span>解决路径</h2>
 <p>可以使用Path接口的<code>resolve(Path p)</code>方法组合两个路径。如果指定的路径是绝对路径，则返回指定的路径。如果指定的路径是空路径，则返回路径。</p> 
 <p>在其他情况下，它只是组合两个路径并返回结果，因此返回的路径以指定的路径结束。<br>以下代码具有一些解析路径的示例。</p> 
 <pre><code class="lang-java">import java.nio.file.Path;
import java.nio.file.Paths;

public class Main {
    public static void main(String[] args) throws Exception {
        Path p1 = Paths.get("C:\\Java_Dev");
        Path p2 = Paths.get("test1.txt");
        System.out.println(p1.resolve(p2));

        Path p3 = Paths.get("C:\\test.txt");
        System.out.println(p1.resolve(p3));

        Path p4 = Paths.get("");
        System.out.println(p1.resolve(p4));

        Path p5 = Paths.get("Java_Dev\\Test");
        Path p6 = Paths.get("test4.txt");
        System.out.println(p5.resolve(p6));
    }
}
</code></pre> 
 <p>上面的代码生成以下结果。</p> 
 <pre><code class="lang-java">C:\Java_Dev\test1.txt
C:\test.txt
C:\Java_Dev
Java_Dev\Test\test4.txt
</code></pre> 
 <h2 id="h2-u76F8u5BF9u8DEFu5F84"><a name="相对路径" class="reference-link"></a><span class="header-link octicon octicon-link"></span>相对路径</h2>
 <p>Path接口的<code>relativize(Path p)</code>方法获得给定路径相对于另一个路径的相对路径。<br>以下代码有一些获取相对路径的示例。</p> 
 <pre><code class="lang-java">import java.nio.file.Path;
import java.nio.file.Paths;

public class Main {
    public static void main(String[] args) throws Exception {
        Path p1 = Paths.get("Java_Dev");
        Path p2 = Paths.get("Java_Dev", "recent", "Test");
        System.out.println(p1.relativize(p2));
        System.out.println(p2.relativize(p1));

        Path p3 = Paths.get("Abc");
        Path p4 = Paths.get("Def");
        System.out.println(p3.relativize(p4));
        System.out.println(p4.relativize(p3));
    }
}
</code></pre> 
 <p>上面的代码生成以下结果。</p> 
 <pre><code class="lang-java">recent\Test
..\..
..\Def
..\Abc
</code></pre>
 <br>      
</div></body></html>