<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java文件树</h1><div style="width:100%;float:left;" class="article-content">   
 <p><code>FileVisitor</code> API可以递归地处理文件树中的所有文件和目录。当要对文件树中的所有或某些文件或目录执行某些操作时，<code>FileVisitor</code> API非常有用。</p> 
 <p><code>SimpleFileVisitor</code>类是<code>FileVisitor</code>接口的基本实现。当访问文件/目录时，<code>SimpleFileVisitor</code>类不执行任何操作。可以从<code>SimpleFileVisitor</code>类继承文件访问-<code>FileVisitor</code> 类，并且只覆盖需要的方法。</p> 
 <p><code>FileVisitor</code>接口的方法</p> 
 <table> 
  <thead> 
   <tr> 
    <th>编号</th> 
    <th>含义</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>1</td> 
    <td><code>FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs)</code>在访问目录中的条目之前调用一次。</td> 
   </tr> 
   <tr> 
    <td>2</td> 
    <td><code>FileVisitResult postVisitDirectory(T dir，IOException exc)</code>已访问目录中的后调用项。如果在目录的迭代期间抛出了任何异常，则将异常对象作为第二个参数传递给此方法。如果此方法的第二个参数为<code>null</code>，则在目录迭代期间没有异常。</td> 
   </tr> 
   <tr> 
    <td>3</td> 
    <td><code>FileVisitResult visitFile(T file, BasicFileAttributes attrs)</code> 是在当访问目录中的文件时调用。</td> 
   </tr> 
   <tr> 
    <td>4</td> 
    <td><code>FileVisitResult visitFileFailed(T file, IOException exc)</code>是当由于任何原因而无法访问文件或目录时调用。</td> 
   </tr> 
  </tbody> 
 </table> 
 <p>下表列出了<code>FileVisitResult</code>的枚举常量及其说明 - </p> 
 <table> 
  <thead> 
   <tr> 
    <th>枚举常量</th> 
    <th>描述/含义</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>CONTINUE</td> 
    <td>继续处理</td> 
   </tr> 
   <tr> 
    <td>SKIP_SIBLINGS</td> 
    <td>继续处理而不访问文件或目录的同级。</td> 
   </tr> 
   <tr> 
    <td>SKIP_SUBTREE</td> 
    <td>继续处理，而不访问目录中的条目。</td> 
   </tr> 
   <tr> 
    <td>TERMINATE</td> 
    <td>终止文件访问过程。</td> 
   </tr> 
  </tbody> 
 </table> 
 <p>不需要在文件访问类的所有四个方法中编写逻辑。要复制目录，请使用<code>preVisitDirectory()</code>方法来创建一个新目录，并使用<code>visitFile()</code>方法来复制该文件。</p> 
 <p>以下代码显示如何打印目录的子目录和文件的名称。</p> 
 <pre><code class="lang-java">import static java.nio.file.FileVisitResult.CONTINUE;
import java.io.IOException;
import java.nio.file.FileVisitResult;
import java.nio.file.FileVisitor;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;

public class Main {
    public static void main(String[] args) {
        Path startDir = Paths.get("");
        FileVisitor&lt;Path&gt; visitor = getFileVisitor();
        try {
            Files.walkFileTree(startDir, visitor);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static FileVisitor&lt;Path&gt; getFileVisitor() {
        class DirVisitor&lt;Path&gt; extends SimpleFileVisitor&lt;Path&gt; {
            @Override
            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {

                System.out.format("%s [Directory]%n", dir);
                return CONTINUE;
            }

            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
                System.out.format("%s [File,  Size: %s  bytes]%n", file, attrs.size());
                return CONTINUE;
            }
        }
        FileVisitor&lt;Path&gt; visitor = new DirVisitor&lt;&gt;();
        return visitor;
    }
}
</code></pre> 
 <p>上面的代码生成以下结果。</p> 
 <pre><code class="lang-java"> [Directory]
.classpath [File,  Size: 232  bytes]
.project [File,  Size: 382  bytes]
.settings [Directory]
.settings\org.eclipse.core.resources.prefs [File,  Size: 57  bytes]
bin [Directory]
bin\Main$1DirVisitor.class [File,  Size: 1648  bytes]
bin\Main.class [File,  Size: 1338  bytes]
destfile.txt [File,  Size: 25  bytes]
luci3.txt [File,  Size: 25  bytes]
my_second_file.txt [File,  Size: 0  bytes]
person.ser [File,  Size: 160  bytes]
personext.ser [File,  Size: 93  bytes]
primitives.dat [File,  Size: 42  bytes]
randomaccessfile.txt [File,  Size: 18  bytes]
src [Directory]
src\Calculator.java [File,  Size: 0  bytes]
src\Main.class [File,  Size: 1111  bytes]
src\Main.java [File,  Size: 1172  bytes]
stdout.txt [File,  Size: 34  bytes]
test.txt [File,  Size: 13  bytes]
ziptest.zip [File,  Size: 22  bytes]
</code></pre> 
 <h2 id="h2-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h2>
 <p>以下代码显示如何使用<code>FileVisitor</code> API删除目录树，把目录 <code>C:\Java_Dev</code> 和其中的所有内容删除。</p> 
 <pre><code class="lang-java">import static java.nio.file.FileVisitResult.CONTINUE;
import static java.nio.file.FileVisitResult.TERMINATE;
import java.io.IOException;
import java.nio.file.FileVisitResult;
import java.nio.file.FileVisitor;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;

public class Main {
    public static void main(String[] args) {
        Path dirToDelete = Paths.get("C:\\Java_Dev");
        FileVisitor&lt;Path&gt; visitor = getFileVisitor();

        try {
            Files.walkFileTree(dirToDelete, visitor);
        } catch (IOException e) {
            System.out.println(e.getMessage());
        }
    }

    public static FileVisitor&lt;Path&gt; getFileVisitor() {

        class DeleteDirVisitor extends SimpleFileVisitor&lt;Path&gt; {
            @Override
            public FileVisitResult postVisitDirectory(Path dir, IOException e) throws IOException {
                FileVisitResult result = CONTINUE;
                if (e != null) {
                    System.out.format("Error deleting  %s.  %s%n", dir, e.getMessage());
                    result = TERMINATE;
                } else {
                    Files.delete(dir);
                    System.out.format("Deleted directory  %s%n", dir);
                }
                return result;
            }

            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                Files.delete(file);
                System.out.format("Deleted file %s%n", file);
                return CONTINUE;
            }
        }
        FileVisitor&lt;Path&gt; visitor = new DeleteDirVisitor();
        return visitor;
    }
}
</code></pre> 
 <p>上面的代码生成以下结果。</p>   
 <pre><code class="lang-java">Deleted file C:\Java_Dev\dir1\test1.txt
Deleted directory  C:\Java_Dev\dir1
Deleted directory  C:\Java_Dev\dir1 - 副本
Deleted file C:\Java_Dev\dir2\test1.txt
Deleted directory  C:\Java_Dev\dir2
Deleted file C:\Java_Dev\test1.txt
Deleted file C:\Java_Dev\twinkle.txt
Deleted directory  C:\Java_Dev
</code></pre> 
 <h2 id="h2--2"><a name="实例-2" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例-2</h2>
 <p>以下代码显示如何使用<code>walkFileTree()</code>方法跟随符号链接。</p> 
 <pre><code class="lang-java">import java.nio.file.FileVisitOption;
import java.nio.file.FileVisitor;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.EnumSet;
import java.util.Set;
import static  java.nio.file.FileVisitOption.FOLLOW_LINKS;
public class Main {
  public static void main(String[] args) throws Exception {
    Path startDir = Paths.get("");
    FileVisitor&lt;Path&gt; visitor = create your visitor;

    Set&lt;FileVisitOption&gt; options = EnumSet.of(FOLLOW_LINKS);

    int depth = Integer.MAX_VALUE;

    Files.walkFileTree(startDir, options, depth, visitor);
  }
}
</code></pre> 
 <h2 id="h2-u6A21u5F0Fu5339u914D"><a name="模式匹配" class="reference-link"></a><span class="header-link octicon octicon-link"></span>模式匹配</h2>
 <p>可以使用<code>glob</code>和正则表达式模式对字符串形式的<code>Path</code>对象执行模式匹配。</p> 
 <p>功能接口<code>PathMatcher</code>用于执行匹配。它包含一个<code>matches(Path path)</code>方法，如果指定的路径匹配模式，则该方法返回<code>true</code>。<br>模式字符串由两部分组成，语法和模式由冒号分隔：</p> 
 <pre><code class="lang-java">syntax:pattern
</code></pre> 
 <p>语法的值是<code>glob</code>或<code>regex</code>。模式部分遵循取决于语法部分的值。<code>glob</code>模式使用以下语法规则：</p> 
 <ul> 
  <li><code>*</code> 匹配零个或多个字符，而不会交叉目录边界。</li>
  <li><code>**</code> 匹配零个或多个字符跨目录边界。</li>
  <li><code>?</code> 只匹配一个字符。</li>
  <li><code>\</code> 转义以下字符的特殊含义。</li>
  <li><code>\\</code> 匹配单个反斜杠</li>
  <li><code>\*</code> 匹配一个星号。</li>
 </ul> 
 <p>放在括号<code>[]</code>中的字符称为括号表达式，它匹配单个字符。如：<code>[aeiou]</code>将匹配<code>a</code>，<code>e</code>，<code>i</code>，<code>o</code>或<code>u</code>。</p> 
 <p>两个字符之间的破折号指定范围。<code>[a-z]</code>匹配<code>a</code>和<code>z</code>之间的所有字母。左括号后的感叹号(<code>！</code>)被视为否定。 <code>[!abc]</code>匹配除了<code>a</code>，<code>b</code>和<code>c</code>之外的所有字符。</p> 
 <p>通过在大括号(<code>{}</code>)中指定逗号分隔的子模式来使用一组子模式。 例如，<code>{txt，java，doc}</code>匹配<code>txt</code>，<code>java</code>和<code>doc</code>。</p> 
 <p>路径的根组件的匹配是实现相关的。以下代码显示了如何使用<code>PathMatcher</code>对象将路径与<code>glob</code>模式匹配。</p> 
 <pre><code class="lang-java">import java.nio.file.FileSystems;
import java.nio.file.Path;
import java.nio.file.PathMatcher;
import java.nio.file.Paths;

public class Main {
    public static void main(String[] args) {
        String globPattern = "glob:**txt";
        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(globPattern);
        Path path = Paths.get("C:\\Java_Dev\\test1.txt");
        boolean matched = matcher.matches(path);
        System.out.format("%s matches  %s:  %b%n", globPattern, path, matched);
    }
}
</code></pre> 
 <p>执行上面的代码，得到以下结果 - </p> 
 <pre><code class="lang-java">glob:**txt matches  C:\Java_Dev\test1.txt:  true
</code></pre>
 <br>      
</div></body></html>