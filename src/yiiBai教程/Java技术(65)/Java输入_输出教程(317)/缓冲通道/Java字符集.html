<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java字符集</h1><div style="width:100%;float:left;" class="article-content">   
 <p>可以使用编码方案将<code>Unicode</code>字符转换为字节序列，反之亦然。<code>java.nio.charset</code>包提供了将<code>CharBuffer</code>编码/解码为<code>ByteBuffer</code>类，反之亦然。</p> 
 <p><code>Charset</code>类的对象表示编码方案。<code>CharsetEncoder</code>类执行编码。<code>CharsetDecoder</code>类执行解码。可以通过传递字符集的名称作为它的参数，使用它的<code>forName()</code>方法获得<code>Charset</code>类的对象。</p> 
 <p>对于简单的编码和解码任务，可以使用<code>Charset</code>类的<code>encode()</code>和<code>decode()</code>方法。<br>以下代码显示如何对存储在字符缓冲区中的字符串<code>Hello</code>中的字符序列进行编码，并使用<code>UTF-8</code>编码方案对其进行解码。</p> 
 <pre><code class="lang-java">Charset cs  = Charset.forName("UTF-8");
CharBuffer cb  = CharBuffer.wrap("Hello");
ByteBuffer encodedData   = cs.encode(cb);
CharBuffer decodedData   = cs.decode(encodedData);
</code></pre> 
 <p><code>CharsetEncoder</code>和<code>CharsetDecoder</code>类接受要编码或解码的输入块。<code>Charset</code>类的<code>encode()</code>和<code>decode()</code>方法将编码和解码的缓冲区返回。</p> 
 <p>以下代码显示如何从<code>Charset</code>对象获取编码器和解码器对象。</p> 
 <pre><code class="lang-java">Charset cs  = Charset.forName("UTF-8"); 
CharsetEncoder encoder = cs.newEncoder(); 
CharsetDecoder decoder = cs.newDecoder();
</code></pre> 
 <p>以下代码演示如何列出JVM支持的所有字符集。</p> 
 <pre><code class="lang-java">import java.util.Map;
import java.nio.charset.Charset;
import java.util.Set;

public class Main {
  public static void main(String[] args) {
    Map&lt;String, Charset&gt; map = Charset.availableCharsets();
    Set&lt;String&gt; keys = map.keySet();
    System.out.println("Available  Character Set  Count:   " + keys.size());

    for (String charsetName : keys) {
      System.out.println(charsetName);
    }
  }
}
</code></pre> 
 <h2 id="h2-u5B57u8282u987Au5E8F"><a name="字节顺序" class="reference-link"></a><span class="header-link octicon octicon-link"></span>字节顺序</h2>
 <p>字节顺序仅在存储在字节缓冲器中的多字节值中有用。 要知道机器的字节顺序，请使用<code>ByteOrder</code>类的<code>nativeOrder()</code>方法。</p>   
 <pre><code class="lang-java">import java.nio.ByteOrder;

public class Main {
  public static void main(String args[]) {
    ByteOrder b = ByteOrder.nativeOrder();

    if (b.equals(ByteOrder.BIG_ENDIAN)) {
      System.out.println("Big endian");
    } else {

      System.out.println("Little  endian");
    }
  }
}
</code></pre> 
 <p>以下代码演示如何获取和设置字节缓冲区的字节顺序。使用<code>ByteBuffer</code>类对象的<code>order()</code>方法来获取或设置字节顺序。</p> 
 <pre><code class="lang-java">import java.nio.ByteBuffer;
import java.nio.ByteOrder;

public class Main {
  public static void main(String[] args) {
    ByteBuffer bb = ByteBuffer.allocate(2);
    System.out.println("Default  Byte  Order: " + bb.order());
    bb.putShort((short) 300);
    bb.flip();
    showByteOrder(bb);

    bb.clear();
    bb.order(ByteOrder.LITTLE_ENDIAN);
    bb.putShort((short) 300);
    bb.flip();
    showByteOrder(bb);
  }

  public static void showByteOrder(ByteBuffer bb) {
    System.out.println("Byte  Order: " + bb.order());
    while (bb.hasRemaining()) {
      System.out.print(bb.get() + "    ");
    }
    System.out.println();
  }
}
</code></pre> 
 <p>上面的代码生成以下结果。</p> 
 <pre><code class="lang-java">Default  Byte  Order: BIG_ENDIAN
Byte  Order: BIG_ENDIAN
1    44    
Byte  Order: LITTLE_ENDIAN
44    1
</code></pre>
 <br>      
</div></body></html>