<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java接口</h1><div style="width:100%;float:left;" class="article-content">   
 <p>java中的接口是类的蓝图。 它有静态常量和抽象方法。java中的接口是一种实现抽象的机制。 接口中只有抽象方法而不是方法体。接口用于在Java中实现抽象和多重继承。</p> 
 <p>Java接口也表示IS-A关系。它不能像抽象类一样被实例化。</p> 
 <h2 id="h2--java-"><a name="为什么要使用Java接口？" class="reference-link"></a><span class="header-link octicon octicon-link"></span>为什么要使用Java接口？</h2>
 <p>需要使用接口主要有三个原因。如下面给出。</p> 
 <ul> 
  <li>它用于实现抽象。</li>
  <li>通过接口，可以支持多重继承的功能。</li>
  <li>它可用于实现松耦合。</li>
 </ul> 
 <h2 id="h2-java-8-"><a name="Java 8接口的改进" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Java 8接口的改进</h2>
 <p>由于Java 8，接口可以有默认和静态方法，稍后讨论。</p> 
 <p><strong>由编译器内部添加</strong><br>java编译器在接口方法之前添加<code>public</code>和<code>abstract</code>关键字。还有，它在数据成员之前添加<code>public</code>，<code>static</code>和<code>final</code>关键字。</p> 
 <p>换句话说，接口字段默认是<code>public</code>，<code>static</code>和<code>final</code>，方法默认是<code>public</code>和<code>abstract</code>。</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201703/0703/957110359_32640.png" alt=""></p> 
 <h2 id="h2-u4E86u89E3u7C7Bu548Cu63A5u53E3u4E4Bu95F4u7684u5173u7CFB"><a name="了解类和接口之间的关系" class="reference-link"></a><span class="header-link octicon octicon-link"></span>了解类和接口之间的关系</h2>
 <p>如下图所示，一个类扩展了另一个类，一个接口扩展了另一个接口，一个类实现了一个接口。<br><img src="http://www.yiibai.com/uploads/images/201703/0703/573120302_99574.png" alt=""></p> 
 <p><strong>Java接口示例</strong></p> 
 <p>在这个例子中，<code>Printable</code>接口只有一个方法，它的实现是在<code>A</code>类中提供的。</p> 
 <pre><code class="lang-java">interface printable {
    void print();
}

class A6 implements printable {
    public void print() {
        System.out.println("Hello, Interface");
    }

    public static void main(String args[]) {
        A6 obj = new A6();
        obj.print();
    }
}
</code></pre> 
 <p>上面代码执行结果如下 - </p> 
 <pre><code class="lang-java">Hello, Interface
</code></pre> 
 <p><strong>Java接口示例：Drawable</strong></p> 
 <p>在这个例子中，<code>Drawable</code>接口只有一个方法。 它的实现由<code>Rectangle</code>和<code>Circle</code>类提供。 在实际情况下，接口由一些开发者定义，但实现由不同的实现提供者提供。 并且它被别人使用。实现部分被使用接口的用户隐藏。</p> 
 <p>创建一个 Java 文件：<code>TestInterface1.java</code>，其代码如下 -</p> 
 <pre><code class="lang-java">//Interface declaration: by first user  
interface Drawable {
    void draw();
}

// Implementation: by second user
class Rectangle implements Drawable {
    public void draw() {
        System.out.println("drawing rectangle");
    }
}

class Circle implements Drawable {
    public void draw() {
        System.out.println("drawing circle");
    }
}

// Using interface: by third user
class TestInterface1 {
    public static void main(String args[]) {
        Drawable d = new Circle();// In real scenario, object is provided by
                                    // method e.g. getDrawable()
        d.draw();
    }
}
</code></pre> 
 <p>执行上面代码得到以下结果 -</p> 
 <pre><code class="lang-java">drawing circle
</code></pre> 
 <p><strong>Java接口示例：Bank</strong></p> 
 <p>让我们来看看另一个提供了<code>Bank</code>接口实现的java接口的例子。创建一个 Java 文件：<code>TestInterface2.java</code>，其代码如下 -</p> 
 <pre><code class="lang-java">interface Bank {
    float rateOfInterest();
}

class SBI implements Bank {
    public float rateOfInterest() {
        return 9.15f;
    }
}

class PNB implements Bank {
    public float rateOfInterest() {
        return 9.7f;
    }
}

class TestInterface2 {
    public static void main(String[] args) {
        Bank b = new SBI();
        System.out.println("ROI: " + b.rateOfInterest());
    }
}
</code></pre> 
 <p>执行上面代码得到以下结果 -</p> 
 <pre><code class="lang-java">ROI: 9.15
</code></pre> 
 <h2 id="h2-java-"><a name="Java多继承接口" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Java多继承接口</h2>
 <p>如果一个类实现了多个接口，或者一个接口扩展了多个接口，即被称为多重继承。</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201703/0703/469120316_18026.png" alt=""></p> 
 <p>参考以下示例代码的实现 -</p> 
 <pre><code class="lang-java">interface Printable {
    void print();
}

interface Showable {
    void show();
}

class A7 implements Printable, Showable {
    public void print() {
        System.out.println("Hello");
    }

    public void show() {
        System.out.println("Welcome");
    }

    public static void main(String args[]) {
        A7 obj = new A7();
        obj.print();
        obj.show();
    }
}
</code></pre> 
 <p>执行上面代码得到以下结果 -</p> 
 <pre><code class="lang-java">Hello
Welcome
</code></pre> 
 <p><strong>问题：在java中不支持通过类实现多继承，但可通过接口实现，为什么？</strong></p> 
 <p>正如在继承章节中所解释的，在类中不支持多重继承是因为模糊。 但是在接口的情况下可以支持，因为接口没有歧义，接口的具体实现由实现类提供。 例如：</p> 
 <pre><code class="lang-java">interface Printable {
    void print();
}

interface Showable {
    void print();
}

class TestTnterface3 implements Printable, Showable {
    public void print() {
        System.out.println("Hello");
    }

    public static void main(String args[]) {
        TestTnterface1 obj = new TestTnterface1();
        obj.print();
    }
}
</code></pre> 
 <p>上面代码执行得到以下结果 -</p>   
 <pre><code class="lang-java">Hello
</code></pre> 
 <p>从上面的例子可以看到，<code>Printable</code>和<code>Showable</code>接口有相同的方法，但它的实现是由<code>TestTnterface1</code>类提供的，所以没有歧义。</p> 
 <h2 id="h2-u63A5u53E3u7EE7u627F"><a name="接口继承" class="reference-link"></a><span class="header-link octicon octicon-link"></span>接口继承</h2>
 <p>类可以实现多个接口，但接口也扩展另一个接口。</p> 
 <pre><code class="lang-java">interface Printable {
    void print();
}

interface Showable extends Printable {
    void show();
}

class TestInterface4 implements Showable {
    public void print() {
        System.out.println("Hello");
    }

    public void show() {
        System.out.println("Welcome");
    }

    public static void main(String args[]) {
        TestInterface4 obj = new TestInterface4();
        obj.print();
        obj.show();
    }
}
</code></pre> 
 <p>执行上面代码，得到如下结果 -</p> 
 <pre><code class="lang-java">Hello
Welcome
</code></pre> 
 <h3 id="h3-java-8-"><a name="Java 8接口中的默认方法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Java 8接口中的默认方法</h3>
 <p>从Java 8开始，我们可以在接口中有方法体。 但需要使其为默认方法。现在来看看一个例子，创建一个Java文件：<code>TestInterfaceDefault.java</code>，其代码如下 -</p> 
 <pre><code class="lang-java">interface Drawable {
    void draw();

    default void msg() {
        System.out.println("default method");
    }
}

class Rectangle implements Drawable {
    public void draw() {
        System.out.println("drawing rectangle");
    }
}

class TestInterfaceDefault {
    public static void main(String args[]) {
        Drawable d = new Rectangle();
        d.draw();
        d.msg();
    }
}
</code></pre> 
 <p>执行上面代码，得到如下结果 -</p> 
 <pre><code class="lang-java">drawing rectangle
default method
</code></pre> 
 <h3 id="h3-java-8-"><a name="Java 8接口中的静态方法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Java 8接口中的静态方法</h3>
 <p>从Java 8开始，我们可以在接口中有静态方法。 让我们来看看下面的一个例子，创建一个Java文件：<code>TestInterfaceStatic.java</code> 其代码如下：</p> 
 <pre><code class="lang-java">interface Drawable {
    void draw();

    static int cube(int x) {
        return x * x * x;
    }
}

class Rectangle implements Drawable {
    public void draw() {
        System.out.println("drawing rectangle");
    }
}

class TestInterfaceStatic {
    public static void main(String args[]) {
        Drawable d = new Rectangle();
        d.draw();
        System.out.println(Drawable.cube(3));
    }
}
</code></pre> 
 <p>执行上面代码，得到如下结果 -</p> 
 <pre><code class="lang-java">drawing rectangle
27
</code></pre> 
 <p><strong>问题：什么是标记或标记的接口？</strong></p> 
 <p>没有成员的接口(仅定义一个空的接口)称为标记或标记接口。 例如：可序列化，可克隆，远程等。它们用于向JVM提供一些基本信息，以便JVM可以执行一些有用的操作。</p> 
 <pre><code class="lang-java">//How Serializable interface is written?  
public interface Serializable{  
}
</code></pre> 
 <p><strong>Java嵌套接口</strong></p> 
 <p><strong>注意：</strong> 一个接口中可以有另一个接口，即被称为嵌套接口。有关于这方面的知识，将在<a target="_blank" href="http://www.yiibai.com/java/nested-interface.html" title="嵌套类">嵌套类</a>的章节中详细学习。 例如：</p> 
 <pre><code class="lang-java">interface printable {
    void print();

    interface MessagePrintable {
        void msg();
    }
}
</code></pre>
 <br>      
</div></body></html>