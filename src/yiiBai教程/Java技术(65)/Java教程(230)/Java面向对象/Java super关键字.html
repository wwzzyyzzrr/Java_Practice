<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java super关键字</h1><div style="width:100%;float:left;" class="article-content">   
 <p>java中的<code>super</code>关键字是一个引用变量，用于引用直接父类对象。</p> 
 <p>每当创建子类的实例时，父类的实例被隐式创建，由<code>super</code>关键字引用变量引用。</p> 
 <p>java <code>super</code>关键字的用法如下：</p> 
 <ul> 
  <li><code>super</code>可以用来引用直接父类的实例变量。</li>
  <li><code>super</code>可以用来调用直接父类方法。</li>
  <li><code>super()</code>可以用于调用直接父类构造函数。</li>
 </ul> 
 <h2 id="h2-1-super-"><a name="1. super用于引用直接父类实例变量" class="reference-link"></a><span class="header-link octicon octicon-link"></span>1. super用于引用直接父类实例变量</h2>
 <p>可以使用<code>super</code>关键字来访问父类的数据成员或字段。 如果父类和子类具有相同的字段，则使用<code>super</code>来指定为父类数据成员或字段。</p> 
 <pre><code class="lang-java">class Animal {
    String color = "white";
}

class Dog extends Animal {
    String color = "black";

    void printColor() {
        System.out.println(color);// prints color of Dog class
        System.out.println(super.color);// prints color of Animal class
    }
}

class TestSuper1 {
    public static void main(String args[]) {
        Dog d = new Dog();
        d.printColor();
    }
}
</code></pre> 
 <p>执行上面代码，输出结果如下 -</p> 
 <pre><code class="lang-java">black
white
</code></pre> 
 <p>在上面的例子中，<code>Animal</code>和<code>Dog</code>都有一个共同的属性：<code>color</code>。 如果我们打印<code>color</code>属性，它将默认打印当前类的颜色。 要访问父属性，需要使用<code>super</code>关键字指定。</p> 
 <h2 id="h2-2-super-"><a name="2. 通过 super 来调用父类方法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2. 通过 super 来调用父类方法</h2>
 <p><code>super</code>关键字也可以用于调用父类方法。 如果子类包含与父类相同的方法，则应使用<code>super</code>关键字指定父类的方法。 换句话说，如果方法被覆盖就可以使用 <code>super</code> 关键字来指定父类方法。</p> 
 <pre><code class="lang-java">class Animal {
    void eat() {
        System.out.println("eating...");
    }
}

class Dog extends Animal {
    void eat() {
        System.out.println("eating bread...");
    }

    void bark() {
        System.out.println("barking...");
    }

    void work() {
        super.eat();
        bark();
    }
}

class TestSuper2 {
    public static void main(String args[]) {
        Dog d = new Dog();
        d.work();
    }
}
</code></pre> 
 <p>执行上面代码，输出结果如下 -</p> 
 <pre><code class="lang-java">black
white
</code></pre> 
 <p>在上面的例子中，<code>Animal</code>和<code>Dog</code>两个类都有<code>eat()</code>方法，如果要调用<code>Dog</code>类中的<code>eat()</code>方法，它将默认调用<code>Dog</code>类的<code>eat()</code>方法，因为当前类的优先级比父类的高。<br>所以要调用父类方法，需要使用<code>super</code>关键字指定。</p> 
 <h2 id="h2-3-super-"><a name="3. 使用 super 来调用父类构造函数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>3. 使用 super 来调用父类构造函数</h2>
 <p><code>super</code>关键字也可以用于调用父类构造函数。下面来看一个简单的例子：</p> 
 <pre><code class="lang-java">class Animal {
    Animal() {
        System.out.println("animal is created");
    }
}

class Dog extends Animal {
    Dog() {
        super();
        System.out.println("dog is created");
    }
}

class TestSuper3 {
    public static void main(String args[]) {
        Dog d = new Dog();
    }
}
</code></pre> 
 <blockquote> 
  <p>注意：如果没有使用<code>super()</code>或<code>this()</code>，则<code>super()</code>在每个类构造函数中由编译器自动添加。</p> 
 </blockquote> 
 <p><img src="http://www.yiibai.com/uploads/images/201703/0603/850160347_42602.jpg" alt=""></p> 
 <p>我们知道，如果没有构造函数，编译器会自动提供默认构造函数。 但是，它还添加了<code>super()</code>作为第一个语句。</p> 
 <p>下面是<code>super</code>关键字的另一个例子，这里<code>super()</code>由编译器隐式提供。</p>   
 <pre><code class="lang-java">class Animal {
    Animal() {
        System.out.println("animal is created");
    }
}

class Dog extends Animal {
    Dog() {
        System.out.println("dog is created");
    }
}

class TestSuper4 {
    public static void main(String args[]) {
        Dog d = new Dog();
    }
}
</code></pre> 
 <p>执行上面代码，输出结果如下 -</p> 
 <pre><code class="lang-java">animal is created
dog is created
</code></pre> 
 <h2 id="h2-super-"><a name="super实际使用示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>super实际使用示例</h2>
 <p>下面来看看<code>super</code>关键字的实际用法。 在这里，<code>Emp</code>类继承了<code>Person</code>类，所以<code>Person</code>的所有属性都将默认继承到<code>Emp</code>。 要初始化所有的属性，可使用子类的父类构造函数。 这样，我们重用了父类的构造函数。</p> 
 <pre><code class="lang-java">class Person {
    int id;
    String name;

    Person(int id, String name) {
        this.id = id;
        this.name = name;
    }
}

class Emp extends Person {
    float salary;

    Emp(int id, String name, float salary) {
        super(id, name);// reusing parent constructor
        this.salary = salary;
    }

    void display() {
        System.out.println(id + " " + name + " " + salary);
    }
}

class TestSuper5 {
    public static void main(String[] args) {
        Emp e1 = new Emp(1, "ankit", 45000f);
        e1.display();
    }
}
</code></pre> 
 <p>执行上面代码，输出结果如下 -</p> 
 <pre><code class="lang-java">1 ankit 45000
</code></pre>
 <br>      
</div></body></html>