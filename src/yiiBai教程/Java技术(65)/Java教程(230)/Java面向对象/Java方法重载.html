<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java方法重载</h1><div style="width:100%;float:left;" class="article-content">   
 <p>如果一个类中有多个具有相同名称但参数不同的方法，则称为方法重载。如果只需要执行一个操作，具有相同的方法名称将增加程序的可读性。</p> 
 <p>假设必须执行给定数值的添加操作(求和)，但是参数的数量不固定，如果为两个参数编写<code>add1(int，int)</code>方法，为三个参数编写<code>add2(int，int，int)</code>方法，可能对其他程序员来说很难理解这样的方法的行为，因为它的名称不同。</p> 
 <p>因此，执行方法重载能比较容易理解程序含义。</p> 
 <p><strong>方法重载的优点</strong></p> 
 <ul> 
  <li>方法重载提高了程序的可读性。</li>
 </ul> 
 <p><strong>重载方法不同的方式</strong></p> 
 <p>在java中重载方法有两种方式，它们分别是：</p> 
 <ul> 
  <li>通过改变参数的数量</li>
  <li>通过更改数据类型</li>
 </ul> 
 <blockquote> 
  <p>注意：在java中，只通过更改方法的返回类型来实现方法重载是不可以的。</p> 
 </blockquote> 
 <h2 id="h2-1-"><a name="1. 方法重载： 修改参数的数量" class="reference-link"></a><span class="header-link octicon octicon-link"></span>1. 方法重载： 修改参数的数量</h2>
 <p>在这个例子中，我们将创建了两个方法，第一个<code>add()</code>方法执行两个数值的相加操作，第二个<code>add()</code>方法执行三个数值的相加操作。</p> 
 <p>在这个例子中，我们创建静态方法，所以不需要创建实例来调用方法。</p> 
 <pre><code class="lang-java">class Adder {
    static int add(int a, int b) {
        return a + b;
    }

    static int add(int a, int b, int c) {
        return a + b + c;
    }
}

class TestOverloading1 {
    public static void main(String[] args) {
        System.out.println(Adder.add(11, 11));
        System.out.println(Adder.add(11, 11, 11));
    }
}
</code></pre> 
 <p>上面代码执行后，输出结果如下 -</p> 
 <pre><code class="lang-java">22
33
</code></pre> 
 <h2 id="h2-2-"><a name="2. 方法重载：更改参数的数据类型" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2. 方法重载：更改参数的数据类型</h2>
 <p>在这个例子中，创建了两种数据类型不同的方法。 第一个<code>add</code>方法接收两个整数参数，第二个<code>add</code>方法接收两个双精度型参数。</p> 
 <pre><code class="lang-java">class Adder {
    static int add(int a, int b) {
        return a + b;
    }

    static double add(double a, double b) {
        return a + b;
    }
}

class TestOverloading2 {
    public static void main(String[] args) {
        System.out.println(Adder.add(11, 11));
        System.out.println(Adder.add(12.3, 12.6));
    }
}
</code></pre> 
 <p>上面代码执行后，输出结果如下 -</p> 
 <pre><code class="lang-java">22
24.9
</code></pre> 
 <p><strong>问题：为什么方法重载不能通过更改方法的返回类型？</strong></p> 
 <p>在java中，只通过改变方法的返回类型来实现方法重载是不可能的，因为这样具有模糊性。 让我们来看看模糊性是怎么样发生的：</p> 
 <pre><code class="lang-java">class Adder {
    static int add(int a, int b) {
        return a + b;
    }

    static double add(int a, int b) {
        return a + b;
    }
}

class TestOverloading3 {
    public static void main(String[] args) {
        System.out.println(Adder.add(11, 11));// ambiguity
    }
}
</code></pre> 
 <p>上面代码执行后，输出结果如下 -</p> 
 <pre><code class="lang-java">Compile Time Error: method add(int,int) is already defined in class Adder
</code></pre> 
 <p><code>System.out.println(Adder.add(11,11));</code>//这里，java如何确定应该调用哪个<code>sum()</code>方法？</p> 
 <blockquote> 
  <p>注意：编译时错误优于运行时错误。 所以，如果你声明相同的方法具有相同的参数，java编译器渲染编译器时间错误。</p> 
 </blockquote> 
 <p><strong>可以重载java main()方法吗？</strong></p> 
 <p>这是完全可以的。 可以通过方法重载在类中有任意数量的<code>main</code>方法。 但是JVM调用<code>main()</code>方法，它只接收字符串数组作为参数。 让我们来看一个简单的例子：</p> 
 <pre><code class="lang-java">class TestOverloading4{  
    public static void main(String[] args){System.out.println("main with String[]");}  
    public static void main(String args){System.out.println("main with String");}  
    public static void main(){System.out.println("main without args");}  
}
</code></pre> 
 <p>上面代码执行后，输出结果如下 -</p> 
 <pre><code class="lang-java">main with String[]
</code></pre> 
 <h2 id="h2-u65B9u6CD5u91CDu8F7Du548Cu7C7Bu578Bu63D0u5347"><a name="方法重载和类型提升" class="reference-link"></a><span class="header-link octicon octicon-link"></span>方法重载和类型提升</h2>
 <p>如果没有找到匹配的数据类型，那么会隐式地将一个类型提升到另一个类型。 让我们通过下面的图示来理解这个概念：<br><img src="http://www.yiibai.com/uploads/images/201703/0603/289110316_15512.jpg" alt=""></p> 
 <p>如上图所示，<code>byte</code>可以被提升为<code>short</code>，<code>int</code>，<code>long</code>，<code>float</code>或<code>double</code>。 <code>short</code>数据类型可以提升为<code>int</code>，<code>long</code>，<code>float</code>或<code>double</code>。 <code>char</code>数据类型可以提升为<code>int</code>，<code>long</code>，<code>float</code>或<code>double</code>等等。</p> 
 <p><strong>使用类型提升方法重载的示例</strong></p>   
 <pre><code class="lang-java">class OverloadingCalculation1 {
    void sum(int a, long b) {
        System.out.println(a + b);
    }

    void sum(int a, int b, int c) {
        System.out.println(a + b + c);
    }

    public static void main(String args[]) {
        OverloadingCalculation1 obj = new OverloadingCalculation1();
        obj.sum(20, 20);// now second int literal will be promoted to long
        obj.sum(20, 20, 20);

    }
}
</code></pre> 
 <p>上面代码执行后，输出结果如下 -</p> 
 <pre><code class="lang-java">40
60
</code></pre> 
 <p><strong>如果找到匹配使用类型提升方法重载示例</strong><br>如果方法中存在匹配类型参数，则不会执行类型提升方法重载。</p> 
 <pre><code class="lang-java">class OverloadingCalculation2 {
    void sum(int a, int b) {
        System.out.println("int arg method invoked");
    }

    void sum(long a, long b) {
        System.out.println("long arg method invoked");
    }

    public static void main(String args[]) {
        OverloadingCalculation2 obj = new OverloadingCalculation2();
        obj.sum(20, 20);// now int arg sum() method gets invoked
    }
}
</code></pre> 
 <p>上面代码执行后，输出结果如下 -</p> 
 <pre><code class="lang-java">Output:int arg method invoked
</code></pre> 
 <p><strong>在模糊的情况下使用类型提升来实现方法重载的示例</strong></p> 
 <p>如果在方法中没有匹配的类型参数，并且每个方法都会提升相同数量的参数，那么会出现歧义。如下示例代码，将会产生编译时错误。</p> 
 <pre><code class="lang-java">class OverloadingCalculation3 {
    void sum(int a, long b) {
        System.out.println("a method invoked");
    }

    void sum(long a, int b) {
        System.out.println("b method invoked");
    }

    public static void main(String args[]) {
        OverloadingCalculation3 obj = new OverloadingCalculation3();
        obj.sum(20, 20);// now ambiguity
    }
}
</code></pre> 
 <blockquote> 
  <p>注意： 只有一种类型不被隐式地去提升，例如<code>double</code>不能被隐含地提升到任何类型。</p> 
 </blockquote>
 <br>      
</div></body></html>