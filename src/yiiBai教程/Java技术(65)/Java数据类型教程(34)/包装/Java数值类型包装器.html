<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java数值类型包装器</h1><div style="width:100%;float:left;" class="article-content">   
 <p><code>Byte</code>, <code>Short</code>, <code>Integer</code>, <code>Long</code>, <code>Float</code> 和 <code>Double</code> 类类是数字包装类。<br>它们都继承自<code>Number</code>抽象类。但是不能创建<code>Number</code>类的对象。 但是，我们可以声明<code>Number</code>类的引用变量。可以将六个数值包装类中的任何一个的对象引用分配给<code>Number</code>类的引用。<br><code>Number</code>类包含六个方法。 它们被命名为<code>xxxValue()</code>，其中<code>xxx</code>是六种基本数据类型之一(<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>float</code>和<code>double</code>)。这些方法的返回类型与<code>xxx</code>相同。</p> 
 <h2 id="h2-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h2>
 <p>以下代码显示如何从数字包装器对象检索不同的原始数据类型值：</p> 
 <pre><code class="lang-java">public class Main {
  public static void main(String[] args) {
    Integer intObj = Integer.valueOf(100);
    // Gets byte from Integer
    byte b = intObj.byteValue();

    // Gets double from Integer
    double dd = intObj.doubleValue();
    System.out.println("intObj = " + intObj);
    System.out.println("byte from  intObj = " + b);
    System.out.println("double from  intObj = " + dd);

    // Creates a Double object
    Double doubleObj = Double.valueOf("123.45");

    // Gets different types of primitive values from Double
    double d = doubleObj.doubleValue();
    float f = doubleObj.floatValue();
    int i = doubleObj.intValue();
    long l = doubleObj.longValue();

    System.out.println("doubleObj = " + doubleObj);
    System.out.println("double from  doubleObj   = " + d);
    System.out.println("float from  doubleObj   = " + f);
    System.out.println("int from  doubleObj   = " + i);
    System.out.println("long from  doubleObj   = " + l);
  }
}
</code></pre> 
 <p>上面的代码生成以下结果。</p> 
 <pre><code class="lang-java">intObj = 100
byte from  intObj = 100
double from  intObj = 100.0
doubleObj = 123.45
double from  doubleObj   = 123.45
float from  doubleObj   = 123.45
int from  doubleObj   = 123
long from  doubleObj   = 123
</code></pre> 
 <h2 id="h2-u65B9u6CD5"><a name="方法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>方法</h2>
 <p>在Java8在一些数值包装类(如<code>Integer</code>，<code>Long</code>，<code>Float</code>和<code>Double</code>)中添加了一些方法，如：<code>sum()</code>，<code>max()</code>和<code>min()</code>。</p> 
 <p>例如，<code>Integer.sum(10，20)</code>简单地返回<code>10 + 20</code>的求值结果。</p> 
 <p>它们的引用使用集合<code>lambda</code>表达式。包装器类处理包含原始值的字符串。</p> 
 <ul> 
  <li>使用<code>valueOf()</code>方法将字符串转换成包装器对象。</li>
  <li>使用<code>parseXxx()</code>方法将字符串转换为原始值。</li>
 </ul> 
 <p><code>Byte</code>, <code>Short</code>, <code>Integer</code>, <code>Long</code>, <code>Float</code> 和 <code>Double</code> 类分别包含<code>parseByte()</code>，<code>parseShort()</code>，<code>parseInt()</code>，<code>parseLong()</code>，<code>parseFloat()</code>和<code>parseDouble()</code>方法将字符串解析为原始值。</p> 
 <p>以下代码是将包含二进制格式的整数的字符串转换为<code>Integer</code>对象和<code>int</code>值：</p>   
 <pre><code class="lang-java">public class Main {
  public static void main(String[] args) {
    String str = "01111111";
    int radix = 2;

    // Creates an Integer object from the string
    Integer intObject = Integer.valueOf(str, radix);

    // Extracts the int value from the string
    int intValue = Integer.parseInt(str, 2);

    System.out.println("str = " + str);
    System.out.println("intObject = " + intObject);
    System.out.println("intValue = " + intValue);

  }
}
</code></pre> 
 <p>执行上面的示例代码，得到如下结果 - </p> 
 <pre><code class="lang-java">str = 01111111
intObject = 127
intValue = 127
</code></pre> 
 <h2 id="h2-u503C"><a name="值" class="reference-link"></a><span class="header-link octicon octicon-link"></span>值</h2>
 <p>所有数值包装类都包含几个有用的常量。它们的<code>MIN_VALUE</code>和<code>MAX_VALUE</code>个常数表示最小值和最大值。它们还有<code>SIZE</code>常数，其表示对应原始类型的变量占据的位的大小。</p> 
 <p>以下代码尝试将两个字符串解析为双精度(<code>double</code>)值。</p> 
 <p>第一个字符串包含有效的<code>double</code>值，第二个字符串包含无效的<code>double</code>值。 当调用<code>parseDouble()</code>方法来解析第二个字符串时，就会抛出<code>NumberFormatException</code>。</p> 
 <pre><code class="lang-java">public class Main {
  public static void main(String[] args) {
    String str1 = "123.45";
    try {
      double value1 = Double.parseDouble(str1);
      System.out.println("value1 = " + value1);
    } catch (NumberFormatException e) {
      System.out.println("Error in parsing " + str1);
    }

    String str2 = "8B.99"; // An invalid double
    try {
      double value2 = Double.parseDouble(str2);
      System.out.println("value2 = " + value2);
    } catch (NumberFormatException e) {
      System.out.println("Error in parsing " + str2);
    }

  }
}
</code></pre> 
 <p>执行上面的示例代码，得到如下结果 - </p> 
 <pre><code class="lang-java">value1 = 123.45
Error in parsing 8B.99
</code></pre>
 <br>      
</div></body></html>