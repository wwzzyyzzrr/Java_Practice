<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">HttpClient忽略证书错误</h1><div style="width:100%;float:left;" class="article-content">   
 <p>通常，开发人员将在本地机器上或项目的开发阶段使用自签名证书。 默认情况下，HttpClient(和Web浏览器)不会接受不可信的连接。 但是，可以配置<code>HttpClient</code>以允许不可信的自签名证书。</p> 
 <p>注意:这是一个可能存在安全风险，因为您将其用于生产时，基本上会禁用所有的认证检查，这可通导致受到攻击。</p> 
 <p>在这个例子中，我们演示了如何忽略Apache HttpClient 4.5中的SSL / TLS证书错误。</p> 
 <h2 id="h2-u81EAu7B7Eu540Du8BC1u4E66u9519u8BEF"><a name="自签名证书错误" class="reference-link"></a><span class="header-link octicon octicon-link"></span>自签名证书错误</h2>
 <p>当您尝试向使用自签名证书的服务器发出请求并且证书未被客户端知晓时，将收到以下异常 - </p> 
 <pre><code class="lang-shell">Caused by: 
javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: 
PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: 
unable to find valid certification path to requested target
</code></pre> 
 <h2 id="h2-maven-"><a name="Maven依赖关系" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Maven依赖关系</h2>
 <p>我们使用maven来管理依赖关系，并使用Apache HttpClient 4.5版本。 将以下依赖项添加到您的项目中。</p> 
 <p><em>pom.xml</em> 文件的内容如下 - </p> 
 <pre><code class="lang-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;

    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;com.yiibai.httpclient.httmethods&lt;/groupId&gt;
    &lt;artifactId&gt;http-get&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
    &lt;url&gt;https://memorynotfound.com&lt;/url&gt;
    &lt;name&gt;httpclient - ${project.artifactId}&lt;/name&gt;

    &lt;dependencies&gt;
        &lt;!-- Apache Commons IO --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;
            &lt;artifactId&gt;httpclient&lt;/artifactId&gt;
            &lt;version&gt;4.5.2&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.5.1&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;source&gt;1.8&lt;/source&gt;
                    &lt;target&gt;1.8&lt;/target&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre> 
 <h2 id="h2-u63A5u53D7u81EAu7B7Eu540Du8BC1u4E66"><a name="接受自签名证书" class="reference-link"></a><span class="header-link octicon octicon-link"></span>接受自签名证书</h2>
 <p>我们配置一个自定义的HttpClient。 首先使用<code>SSLContextBuilder</code>设置SSLContext并使用<code>TrustSelfSignedStrategy</code>类来允许自签名证书。 使用<code>NoopHostnameVerifier</code>本质上关闭主机名验证。 创建<code>SSLConnectionSocketFactory</code>并传入SSLContext和<code>HostNameVerifier</code>，并使用工厂方法构建HttpClient。</p> 
 <p>文件:<em>HttpClientAcceptSelfSignedCertificate.java</em> - </p> 
 <pre><code class="lang-java">package com.yiibai.httpdemo;

import org.apache.http.client.methods.HttpGet;
import org.apache.http.conn.ssl.*;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.ssl.SSLContextBuilder;
import javax.net.ssl.*;
import java.io.IOException;
import java.security.KeyManagementException;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;

/**
 * This example demonstrates how to ignore certificate errors.
 * These errors include self signed certificate errors and hostname verification errors.
 */
public class HttpClientAcceptSelfSignedCertificate {

    public static void main(String... args)  {

        try (CloseableHttpClient httpclient = createAcceptSelfSignedCertificateClient()) {
            HttpGet httpget = new HttpGet("https://www.yiibai.com");
            System.out.println("Executing request " + httpget.getRequestLine());

            httpclient.execute(httpget);
            System.out.println("----------------------------------------");
        } catch (NoSuchAlgorithmException | KeyStoreException | KeyManagementException | IOException e) {
            throw new RuntimeException(e);
        }
    }

    private static CloseableHttpClient createAcceptSelfSignedCertificateClient()
            throws KeyManagementException, NoSuchAlgorithmException, KeyStoreException {

        // use the TrustSelfSignedStrategy to allow Self Signed Certificates
        SSLContext sslContext = SSLContextBuilder
                .create()
                .loadTrustMaterial(new TrustSelfSignedStrategy())
                .build();

        // we can optionally disable hostname verification. 
        // if you don't want to further weaken the security, you don't have to include this.
        HostnameVerifier allowAllHosts = new NoopHostnameVerifier();

        // create an SSL Socket Factory to use the SSLContext with the trust self signed certificate strategy
        // and allow all hosts verifier.
        SSLConnectionSocketFactory connectionFactory = new SSLConnectionSocketFactory(sslContext, allowAllHosts);

        // finally create the HttpClient using HttpClient factory methods and assign the ssl socket factory
        return HttpClients
                .custom()
                .setSSLSocketFactory(connectionFactory)
                .build();
    }
}
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p>   
 <pre><code class="lang-shell">Executing request GET https://www.yiibai.com HTTP/1.1
----------------------------------------
</code></pre>
 <br>      
</div></body></html>