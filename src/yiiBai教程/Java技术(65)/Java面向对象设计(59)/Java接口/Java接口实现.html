<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java接口实现</h1><div style="width:100%;float:left;" class="article-content">   
 <h2 id="h2-u5B9Eu73B0u63A5u53E3"><a name="实现接口" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实现接口</h2>
 <p>接口指定对象必须提供的协议。类可以提供接口的抽象方法的部分实现，并且在这种情况下，类必须将自身声明为抽象。</p> 
 <p>实现接口的类使用“<code>implements</code>”子句来指定接口的名称。“<code>implements</code>”子句由关键字<code>implements</code>，后跟逗号分隔的接口类型列表组成。</p> 
 <p>一个类可以实现多个接口。实现接口的类声明的一般语法如下：</p> 
 <pre><code class="lang-java">&lt;modifiers&gt; class  &lt;class-Name&gt;  implements &lt;comma-separated-list-of-interfaces&gt;  {
    // Class body  goes  here
}
</code></pre> 
 <p>假设有一个<code>Circle</code>类。</p> 
 <pre><code class="lang-java">public class Circle implements Shape {
   void  draw(){
      System.out.println("draw circle");
   }
}
</code></pre> 
 <p>实现接口的类必须重写以实现接口中声明的所有抽象方法。 否则，类必须声明为<code>abstract</code>。接口的默认方法也由实现类继承。植入类可以选择不需要重写默认方法。接口中的静态方法不会被实现类继承。<br>下面的代码定义了两种引用类型，一种来自<code>Circle</code>类，另一种来自接口类型。</p> 
 <pre><code class="lang-java">Circle c = new Circle(); 
Shape shape = new Circle();
</code></pre> 
 <p>变量<code>c</code>是<code>Circle</code>类型。它指的是<code>Circle</code>对象。第二个赋值也是有效的，因为<code>Circle</code>类实现了<code>Shape</code>接口，而<code>Circle</code>类的每个对象也都是<code>Shape</code>类型。</p> 
 <h2 id="h2-u5B9Eu73B0u63A5u53E3u65B9u6CD5"><a name="实现接口方法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实现接口方法</h2>
 <p>当一个类完全实现了一个接口时，它为所实现的接口的所有抽象方法提供一个实现。接口中的方法声明包括方法的约束。例如，方法声明中的<code>throws</code>子句是方法的约束。</p> 
 <pre><code class="lang-java">import java.io.IOException;
interface Shape {
  void draw(double amount) throws IOException;
}
class Main implements Shape{

  @Override
  public void draw(double amount) {
    // TODO Auto-generated method stub
  }  
}
</code></pre> 
 <p><code>Main</code>的代码是有效的，即使它丢弃了<code>throws</code>子句。当类覆盖接口方法时，允许删除约束异常。如果使用<code>Shape</code>类型，必须处理<code>IOException</code>。</p>   
 <pre><code class="lang-java">import java.io.IOException;

interface Shape {
  void draw(double amount) throws IOException;
}
class Main implements Shape{

  @Override
  public void draw(double amount) {
    // TODO Auto-generated method stub

  }
  public void anotherMethod(){
    Shape s = new Main();
    try {
      s.draw(0);
    } catch (IOException e) {
      e.printStackTrace();
    }
    draw(0); 
  }
}
</code></pre> 
 <h2 id="h2-u5B9Eu73B0u591Au4E2Au63A5u53E3"><a name="实现多个接口" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实现多个接口</h2>
 <p>一个类可以实现多个接口。类实现的所有接口都在类声明中的关键字<code>implements</code>之后列出。<br>通过实现多个接口，类为所有接口中的所有抽象方法提供实现。</p> 
 <pre><code class="lang-java">interface Adder {
  int add(int n1, int n2);
}
interface Subtractor {
  int subtract(int n1, int n2);
}
class Main implements Adder, Subtractor {
  public int add(int n1, int n2) {
    return n1 + n2;
  }
  public int subtract(int n1, int n2) {
    return n1 - n2;
  }
}
</code></pre> 
 <h2 id="h2-u90E8u5206u5B9Eu73B0u63A5u53E3"><a name="部分实现接口" class="reference-link"></a><span class="header-link octicon octicon-link"></span>部分实现接口</h2>
 <p>类不必为所有方法提供实现。如果一个类不提供接口的完全实现，它必须声明为<code>abstract</code>。</p> 
 <pre><code class="lang-java">interface Calculator {
  int add(int n1, int n2);

  int subtract(int n1, int n2);
}
abstract class Main implements Calculator{
  public int add(int n1, int n2) {
    return n1 + n2;
  }
}
</code></pre>
 <br>      
</div></body></html>