<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java接口方法</h1><div style="width:100%;float:left;" class="article-content">   
 <h2 id="h2-u63A5u53E3u65B9u6CD5u58F0u660E"><a name="接口方法声明" class="reference-link"></a><span class="header-link octicon octicon-link"></span>接口方法声明</h2>
 <p>可以在接口中声明三种类型的方法：</p> 
 <ul> 
  <li>抽象方法</li>
  <li>静态方法</li>
  <li>默认方法</li>
 </ul> 
 <p>在Java 8之前，只能在接口中声明抽象方法。 修饰符<code>static</code>和<code>default</code>用于分别声明静态和默认方法。<br>不使用<code>static</code>和<code>default</code>修饰符就是方法抽象。</p> 
 <p>以下是具有所有三种类型方法的接口的示例：</p> 
 <pre><code class="lang-java">interface AnInterface {
  // An abstract method
  int m1();

  // A static method 
  static int m2()  {
    // The method  implementation goes  here
  }

  // A default method
  default int m3() {
    // The method implementation goes here
  }
}
</code></pre> 
 <h2 id="h2-u62BDu8C61u65B9u6CD5u58F0u660E"><a name="抽象方法声明" class="reference-link"></a><span class="header-link octicon octicon-link"></span>抽象方法声明</h2>
 <p>接口中的所有方法声明都是隐式抽象和公开的，除非它们声明为<code>static</code>或<code>default</code>。接口中的抽象方法没有实现。抽象方法的主体总是由分号表示，而不是一对大括号。<br>下面的代码声明一个名为<code>Player</code>的接口：</p> 
 <pre><code class="lang-java">public interface Player {
  public abstract void play();

  public abstract void stop();

  public abstract void forward();

  public abstract void rewind();
}
</code></pre> 
 <p><code>Player</code> 接口是音频/视频播放器的规范。真实的播放器，例如<code>DVD</code>播放器，将通过实现 <code>Player</code> 接口的所有四个方法来提供规范的具体实现。<br>在接口中使用 <code>abstract</code> 和 <code>public</code> 关键字声明方法中是多余的。上面的<code>Player</code>接口的声明可以改写如下，而不改变其含义：</p> 
 <pre><code class="lang-java">public interface  Player {
    void  play(); 
    void  stop(); 
    void  forward(); 
    void  rewind();
}
</code></pre> 
 <p>接口中的抽象方法声明可以包括参数，返回类型和<code>throws</code>子句。</p> 
 <pre><code class="lang-java">public interface NewPlayer {
  boolean play(int account) throws AccountNotFoundException;

  boolean stop(double amount);

  boolean forward(double amount) throws InsufficientBalanceException;

  double rewind();
}
</code></pre> 
 <p>接口的抽象方法由实现接口的类来实现，类重写它们以提供方法并实现。接口中的抽象方法不能声明为<code>final</code>。<br>类可以重写声明接口的方法为<code>final</code>，指示子类不能覆盖该方法。</p> 
 <h2 id="h2-u9759u6001u65B9u6CD5u58F0u660E"><a name="静态方法声明" class="reference-link"></a><span class="header-link octicon octicon-link"></span>静态方法声明</h2>
 <p>从Java 8，我们可以在接口中创建静态方法。静态方法包含静态修饰符- <code>static</code> ，并且是隐式公开的。可以重新定义<code>Walkable</code>接口以包括<code>letThemWalk()</code>方法。</p> 
 <pre><code class="lang-java">interface Walkable {
  // An abstract method 
  void walk();

  // A static convenience method
  public static void letThemWalk(Walkable[] list) {
    for (int i = 0; i &lt; list.length; i++) {
      list[i].walk();
    }
  }
}
</code></pre> 
 <p>可以使用点表示法使用接口的静态方法。如下代码 - </p> 
 <pre><code class="lang-java">&lt;interface-name&gt;.&lt;static-method&gt;
</code></pre> 
 <p>与类中的静态方法不同，接口中的静态方法不能通过实现类或子接口来继承。从另一个接口继承的接口称为子接口。 只有一种方法来调用接口的静态方法：使用接口名称。例如：<br>必须使用<code>MyInterface.myStaticMethod()</code>调用接口<code>MyInterface</code>的静态方法<code>myStaticMethod()</code>。</p> 
 <p>可以使用方法的非限定名称<code>myStaticMethod()</code>来调用它，这仅在接口的主体中，或者当使用静态<code>import</code>语句导入方法时可这样使用。</p> 
 <h2 id="h2-u9ED8u8BA4u65B9u6CD5u58F0u660E"><a name="默认方法声明" class="reference-link"></a><span class="header-link octicon octicon-link"></span>默认方法声明</h2>
 <p>接口中的默认方法使用修辞符-<code>default</code>来声明。默认方法是在Java 8中添加新功能。默认方法为实现接口的类提供了一个默认实现，但不覆盖默认方法。<br>假设，有以下的一个接口。</p> 
 <pre><code class="lang-java">interface Shape{
  void setX(double x);
  void setY(double y);
  double getX();
  double getY();
}
</code></pre> 
 <p>下面的代码显示了 <code>Circle</code> 类实现了 <code>Shape</code> 接口。</p> 
 <pre><code class="lang-java">class Circle implements Movable {
  private double x;
  private double y;

  public Circle() {
  }

  public Circle(double x, double y) {
    this.x = x;
    this.y = y;
  }

  public void setX(double x) {
    this.x = x;
  }

  public void setY(double y) {
    this.y = y;
  }

  public double getX() {
    return x;
  }

  public double getY() {
    return y;
  }

  public String toString() {
    return "Circle(" + x + ", " + y + ")";
  }
}
</code></pre> 
 <p>如果向<code>Shape</code>添加一个新方法如下。</p>   
 <pre><code class="lang-java">interface Shape {
  void setX(double x);

  void setY(double y);

  double getX();

  double getY();

  void move(double deltaX, double deltaY);
}
</code></pre> 
 <p>在Java 8之前，新方法<code>move()</code>是一个抽象方法。 所有实现<code>Shape</code>接口的类都必须提供这个新方法的实现。<br>实现<code>Shape</code>接口的<code>Pen</code>类将不能通过编译，除非将新方法添加实现到这些类中。在Java 8之前，在将接口分配给公共接口之后，在中断实现接口方法代码的情况下，向接口添加方法是不可能的。<br>所以，引入了Java接口默认方法这个解决方案。可以将默认方法添加到现有接口，并为该方法提供默认实现而不用在实现接口的类中实现这个默认方法。</p> 
 <p>所有实现接口的类都将继承默认实现。类可以选择覆盖默认实现或使用方法的默认实现。</p> 
 <p>默认方法使用关键字<code>default</code>声明。 默认方法不能声明为<code>abstract</code>或<code>static</code>。 它必须提供一个实现。 否则将在编译时发生错误。<br>以下代码使用默认方法更改<code>Shape</code>接口。</p> 
 <pre><code class="lang-java">interface Movable {
  void setX(double x);

  void setY(double y);

  double getX();

  double getY();

  // 一个默认的方法
  default void move(double deltaX, double deltaY) {
    double newX = getX() + deltaX;
    double newY = getY() + deltaY;
    setX(newX);
    setY(newY);
  }
}
</code></pre> 
 <p>以下项目列出了类方法和接口默认方法之间的相似点和差异。</p> 
 <ul> 
  <li>两者都可以以相同的方式访问关键字<code>this</code>。 关键字<code>this</code>是调用方法的对象的引用。</li>
  <li>类一个具体方法可以访问类的实例变量。</li>
  <li>默认方法不能访问实现接口的类的变量的实例。</li>
  <li>默认方法可以访问接口的其他成员。</li>
  <li>两种类型的方法都可以使用它们的参数。</li>
  <li>两个方法都可以有一个<code>throws</code>子句。</li>
  <li>接口中的嵌套类型声明定义了一个新的引用类型。</li>
  <li>可以将一个类，接口，枚举和注释声明为嵌套类型。</li>
  <li>在接口内声明的接口/类称为嵌套接口/类。</li>
  <li>接口和类定义新的引用类型，因此做嵌套接口和嵌套类。</li>
  <li>嵌套接口始终通过其封装接口访问。</li>
  <li>可以在接口中声明一个嵌套类。</li>
 </ul> 
 <p>参考以下一个具有嵌套类和常量字段的<code>Task</code>接口。</p> 
 <pre><code class="lang-java">interface Task {
  class EmptyTask implements Task {
    private EmptyTask() {
    }
    public void runJob() {
      System.out.println("Empty...");
    }
  }
  // A constant field
  Task EMPTY_JOB = new EmptyTask();
  void runJob();
}

public class Main {
  public static void main(String[] args) {
    submitJob(Task.EMPTY_JOB);
  }
  public static void submitJob(Task job) {
    job.runJob();
  }
}
</code></pre> 
 <blockquote> 
  <p>Java接口方法 # Java_interface_Methods</p> 
 </blockquote>
 <br>      
</div></body></html>