<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java接口教程</h1><div style="width:100%;float:left;" class="article-content">   
 <h2 id="h2-java-"><a name="Java接口教程" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Java接口教程</h2>
 <h2 id="h2--"><a name="接口是什么？" class="reference-link"></a><span class="header-link octicon octicon-link"></span>　接口是什么？</h2>
 <p>Java中的接口定义了一个引用类型来创建抽象概念。 接口由类实现，它是用来提供概念的实现。</p> 
 <p>在Java 8之前，一个接口只能包含抽象方法。 Java 8允许接口具有实现的静态和默认方法。</p> 
 <p>接口通过抽象概念定义不相关类之间的关系。例如，可以创建一个<code>Person</code>类来表示一个人，也可以创建一个<code>Dog</code>类来表示一只狗。</p> 
 <p>人和狗都可以走路。 这里的<strong>走路</strong>是一个抽象的概念。 狗可以<strong>走路</strong>，人也是<strong>走路</strong>。这里可以创建一个名为<code>Walkable</code>的接口来表示<strong>走路</strong>这个概念。然后在<code>Person</code>类和<code>Dog</code>类中各自实现<code>Walkable</code>概念(如：实现怎么走路)。 <code>Person</code>类实现了<code>Walkable</code>接口以人的方式走路(如：用两条腿走路)。 <code>Dog</code>类可以实现<code>Walkable</code>接口以狗的方式走路(如：用四条腿走路)。</p> 
 <h2 id="h2--1"><a name="示例-1" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例-1</h2>
 <p>下面将使用一个例子来说明为什么需要接口。<br>假设<code>Person</code>类有一个<code>walk()</code>方法。<br>在相同的包下创建一个接口文件 - Walkable.java 并使用以下代码 - </p> 
 <pre><code class="lang-java">public interface Walkable {
  void walk(); // 接口中只有一个方法
}
</code></pre> 
 <p>在相同的包下创建一个主类 -Main.java 并使用以下代码 - </p> 
 <pre><code class="lang-java">

class Person implements Walkable {
    public Person() {
    }

    public void walk() {
        System.out.println("人走路：使用两条腿足路.");
    }
}

class Dog implements Walkable {
    public Dog() {
    }

    public void walk() {
        System.out.println("狗走路：使用四条腿足路.");
    }
}

public class Main {
    public static void main(String[] args) {
        Walkable[] w = new Walkable[2];
        w[0] = new Person();
        w[1] = new Dog();
        w[0].walk();
        w[1].walk();
        // 或者
        // Person p = new Person();
        // p.walk();
    }
}
</code></pre> 
 <p>上面的代码输出结果如下 - </p> 
 <pre><code class="lang-java">人走路：使用两条腿足路.
狗走路：使用四条腿足路.
</code></pre> 
 <p>类可以在其声明中使用关键字<code>implements</code>实现一个或多个接口。通过实现一个接口，类保证它将为接口中声明的所有方法提供一个实现，或者类将自己声明为抽象。<br>如果一个类实现了<code>Walkable</code>接口，它必须提供<code>walk()</code>方法的具体实现。</p> 
 <p>像类一样，接口定义了一个新的引用类型。当定义一个新的接口(例如，<code>Walkable</code>)时，定义一个新的参考接口类型。<br>以下声明有效：</p> 
 <pre><code class="lang-java">Walkable  w;  // w  is a  reference variable of  type   Walkable
</code></pre> 
 <p>但是不能创建接口类型的对象，因为接口是定义抽象概念。 以下代码无效，编译会出错：</p> 
 <pre><code class="lang-java">new Walkable(); // A  compile-time error
</code></pre> 
 <p>只能为类类型创建对象，但是可以使用一个接口类型变量来引用那些类实现该接口的任何对象。<br>如：<code>Person</code>和<code>Dog</code>类都实现了<code>Walkable</code>接口，所以<code>Walkable</code>类型的引用变量可以引用这两个类的对象。如下代码是没有问题的：</p> 
 <pre><code class="lang-java">Walkable  w1  = new Person(); // OK 
Walkable  w2  = new Dog();     // OK
</code></pre> 
 <p>可以使用它的引用类型变量访问接口的任何成员。 由于<code>Walkable</code>接口只有一个成员，也就是<code>walk()</code>方法，所以这里可以编写如下代码：</p> 
 <pre><code class="lang-java">// Let  the   person  walk 
w1.walk();
// Let  the   dog walk 
w2.walk();
</code></pre> 
 <p>当调用<code>w1</code>的<code>walk()</code>方法时，它调用<code>Person</code>对象的<code>walk()</code>方法，因为<code>w1</code>指的是<code>Person</code>对象。当调用<code>w2</code>的<code>walk()</code>方法时，它调用<code>Dog</code>对象的<code>walk()</code>方法，因为<code>w2</code>指的是<code>Dog</code>对象。</p> 
 <p>当使用接口类型的引用变量调用方法时，它将调用它所引用的对象的方法。</p> 
 <h2 id="h2--2"><a name="实例-2" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例-2</h2>
 <p>下面的代码创建了一个方法来使用接口参数类型。</p> 
 <pre><code class="lang-java">public class Main{
  public static void main(String[] args) {
    Walkable[] w = new Walkable[2];
    w[0] = new Person();
    w[1] = new Dog();

    Walkables.letThemWalk(w);
  }
}

class Walkables {
  public static void letThemWalk(Walkable[] list) {
    for (Walkable w : list) {
      w.walk();
    }
  }
}
</code></pre> 
 <h2 id="h2-u58F0u660Eu63A5u53E3"><a name="声明接口" class="reference-link"></a><span class="header-link octicon octicon-link"></span>声明接口</h2>
 <p>声明接口的一般语法是 - </p>   
 <pre><code class="lang-java">&lt;modifiers&gt; interface &lt;interface-name&gt;  { 
    Constant-Declaration
    Method-Declaration
    Nested-Type-Declaration
}
</code></pre> 
 <p>接口声明以修饰符列表开头，也可以为空(不写)。像类一样，一个接口可以有一个公共或包级别的范围。<br>关键字<code>public</code>用于指示接口具有公共范围。缺少范围(不使用)修饰符表示接口具有包级别作用域。 具有包级别作用域的接口只能在其包的成员内引用。<br>关键字<code>interface</code>用于声明接口，后面是接口的名称。</p> 
 <p>接口的名称必须是有效的Java标识符。接口主体跟在其名称后面并放在大括号内。接口的主体可以为空。 以下是最简单的接口声明：</p> 
 <pre><code class="lang-java">package com.yiibai;

interface Updatable  {
    // The interface body  is empty
}
</code></pre> 
 <p>像类一样，一个接口有一个简单的名称和一个完全限定名。关键字<code>interface</code>后面的标识符是其简单名称。接口的完全限定名称通过使用其包名称和用点分隔的简单名称组成。</p> 
 <p>在上面的示例中，<code>Updatable</code>是简单的名称，<code>com.yiibai.Updatable</code>是完全限定名称。使用接口的简单和完全限定名的规则与类的规则相同。<br>下面的代码声明一个名为<code>ReadOnly</code>的接口。 它有一个公共(<code>public</code>)范围。</p> 
 <pre><code class="lang-java">package  com.yiibai;

public interface  ReadOnly {
    // The interface body  is empty
}
</code></pre> 
 <p>接口声明总是抽象的，无论是否明确声明它为抽象。</p> 
 <h2 id="h2-u6807u8BB0u63A5u53E3"><a name="标记接口" class="reference-link"></a><span class="header-link octicon octicon-link"></span>标记接口</h2>
 <p>标记接口是没有成员的接口。标记接口用来标记类具有特殊含义。</p> 
 <pre><code class="lang-java">interface  Shape {
}
class Circle implements Shape{
}

Shape c = new Circle();

if (c instanceof Shape)  {
   System.out.println("Using a  Shape object");
}
</code></pre> 
 <p>Java API有许多标记接口。如：<code>java.lang.Cloneable</code>，<code>java.io.Serializable</code>和<code>java.rmi.Remote</code>都是标记接口。</p> 
 <h2 id="h2-u529Fu80FDu63A5u53E3"><a name="功能接口" class="reference-link"></a><span class="header-link octicon octicon-link"></span>功能接口</h2>
 <p>仅具有一个抽象方法的接口被称为功能接口。</p> 
 <h2 id="h2--"><a name="多态性 - 一个对象，许多视图" class="reference-link"></a><span class="header-link octicon octicon-link"></span>多态性 - 一个对象，许多视图</h2>
 <p>多态性是指对象具有多种形式的能力。多态性是对象提供其不同视图的能力。使用接口使得我们可以创建一个多态对象。</p>
 <br>      
</div></body></html>