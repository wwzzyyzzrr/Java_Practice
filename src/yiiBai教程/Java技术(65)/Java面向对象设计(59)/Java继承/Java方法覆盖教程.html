<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java方法覆盖教程</h1><div style="width:100%;float:left;" class="article-content">   
 <h2 id="h2-u65B9u6CD5u8986u76D6"><a name="方法覆盖" class="reference-link"></a><span class="header-link octicon octicon-link"></span>方法覆盖</h2>
 <p>重新定义来自超类(父类)继承的类中的实例方法称为方法覆盖。</p> 
 <h2 id="h2-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h2>
 <p>现在来看看，类<code>A</code>和类<code>B</code>的以下声明，覆盖了 <code>print()</code> 方法 ：</p> 
 <pre><code class="lang-java">public class A  {
    public void  print() { 
        System.out.println("A");
    }
}

public class B  extends A  {
    public void  print() { 
        System.out.println("B");
    }
}
</code></pre> 
 <p>类<code>B</code>是类<code>A</code>的子类。类<code>B</code>从其超类继承<code>print()</code>方法并重新定义它。类<code>B</code>中的<code>print()</code>方法覆盖类<code>A</code>的<code>print()</code>方法。</p> 
 <p>如果一个类覆盖了一个方法，它会影响覆盖的类及其子类。 考虑下面的类<code>C</code>的声明：</p> 
 <pre><code class="lang-java">public class C  extends B  {
   // Inherits B.print()
}
</code></pre> 
 <p>类<code>C</code>不声明任何方法。但它继承类<code>B</code>中的<code>print()</code>方法。看看下面的代码，猜想它输出结果应该是什么？</p> 
 <pre><code class="lang-java">class A {
    public void print() {
        System.out.println("A");
    }
}

class B extends A {
    public void print() {
        System.out.println("B");
    }
}

class C extends B {
    public void print() {
        System.out.println("B");
    }
}

public class Main {
    public static void main(String[] args) {
        // Create an object of the Manager class
        A aObj = new A();
        B bObj = new B();
        C cObj = new C();
        aObj.print();
        bObj.print();
        cObj.print();
    }
}
</code></pre> 
 <p>执行上面的代码，得到以下输出结果 - </p> 
 <pre><code class="lang-java">A
B
B
</code></pre> 
 <blockquote> 
  <p>注意, 类总是继承它的直接超类的方法。</p> 
 </blockquote> 
 <p>方法必须是实例方法。 覆盖不适用于静态方法。重写方法必须具有与重写方法相同的名称。重写方法必须具有与重写方法相同顺序的相同类型和相同数量的参数。</p> 
 <p>当方法的参数使用通用类型时，与其他方法比较时考虑将泛型类型参数的擦除。参数的名称是无关紧要的，不会影响方法的覆盖。</p> 
 <h2 id="h2-u8BBFu95EEu7EA7u522B"><a name="访问级别" class="reference-link"></a><span class="header-link octicon octicon-link"></span>访问级别</h2>
 <p>覆盖方法的访问级别必须至少与被覆盖方法的访问级别相同或更宽松。下表列出了覆盖方法允许的访问级别 - </p> 
 <table> 
  <thead> 
   <tr> 
    <th>覆盖方法访问级别</th> 
    <th>允许覆盖方法访问级别</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>public</td> 
    <td>public</td> 
   </tr> 
   <tr> 
    <td>protected</td> 
    <td>public, protected</td> 
   </tr> 
   <tr> 
    <td>package-level</td> 
    <td>public, protected, package-level</td> 
   </tr> 
  </tbody> 
 </table> 
 <p>方法可以在其throws子句中包括检查异常的列表。覆盖方法无法向覆盖方法中的异常列表添加新的异常。</p> 
 <p>它可以删除一个或所有异常，或者可以用另一个异常替换异常。</p> 
 <h2 id="h2-u8BBFu95EEu8986u76D6u65B9u6CD5"><a name="访问覆盖方法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>访问覆盖方法</h2>
 <p>从子类访问重写的方法。在子类中可以使用关键字<code>super</code>作为限定符来调用超类的重写方法。</p>   
 <pre><code class="lang-java">class MySuperClass {
  public void print() {
    System.out.println("Inside MySuperClass");
  }
}

class MySubClass extends MySuperClass {
  public void print() {
    // Call print() method of MySuperClass class
    super.print();
    // Print a message
    System.out.println("Inside MySubClass.print()");
  }

  public void callOverridenPrint() {
    // Call print() method of MySuperClass class 
    super.print();
  }
}

public class Main {
  public static void main(String[] args) {
    MySubClass aoSub = new MySubClass();
    aoSub.print();
    aoSub.callOverridenPrint();
  }
}
</code></pre> 
 <p>上面的代码生成以下结果。</p> 
 <pre><code class="lang-java">Inside MySuperClass
Inside MySubClass.print()
Inside MySuperClass
</code></pre>
 <br>      
</div></body></html>