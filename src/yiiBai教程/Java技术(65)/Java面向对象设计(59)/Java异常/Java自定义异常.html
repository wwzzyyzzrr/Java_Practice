<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java自定义异常</h1><div style="width:100%;float:left;" class="article-content">   
 <p>我们可以创建自己(自定义)的异常类。它们必须扩展现有的异常类。</p> 
 <pre><code class="lang-java">&lt;Class Modifiers&gt; class &lt;Class Name&gt; extends &lt;Exception Class Name&gt; {

}
</code></pre> 
 <p><code>&lt;Class Name&gt;</code>是异常类名。在接下来的示例中，将创建一个<code>MyException</code>类，它扩展了<code>java.lang.Exception</code>类。</p> 
 <h2 id="h2-u8BEDu6CD5"><a name="语法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>语法</h2>
 <p>自定义一个异常类的语法如下：</p> 
 <pre><code class="lang-java">public class MyException  extends  Exception  {
}
</code></pre> 
 <p>异常类与Java中的任何其他类一样。 通常不向异常类中添加任何方法。许多可用于查询异常对象状态的有用方法已经在<code>Throwable</code>类中声明了。</p> 
 <h2 id="h2-u81EAu5B9Au4E49u5F02u5E38u7C7Bu6784u9020u51FDu6570"><a name="自定义异常类构造函数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>自定义异常类构造函数</h2>
 <p>通常，异常类包括四个构造函数。所有构造函数将使用<code>super</code>关键字调用其超类的相应构造函数。</p> 
 <pre><code class="lang-java">class MyException extends Exception {
  public MyException() {
    super();
  }

  public MyException(String message) {
    super(message);
  }

  public MyException(String message, Throwable cause) {
    super(message, cause);
  }

  public MyException(Throwable cause) {
    super(cause);
  }
}
</code></pre> 
 <p>第一个构造函数创建一个具有<code>null</code>的异常作为其详细消息。<br>第二个构造函数创建一个具有详细消息的异常。<br>第三和第四个构造函数允许通过包装/不包含详细消息的另一个异常来创建异常。</p> 
 <p>自定义异常类之后，就可以抛出<code>MyException</code>类型的异常。</p> 
 <pre><code class="lang-java">throw new MyException("Your  message  goes  here");
</code></pre> 
 <p>可以在方法/构造函数声明中的<code>throws</code>子句中使用<code>MyException</code>类，或者在<code>catch</code>块中使用参数类型。</p> 
 <pre><code class="lang-java">public void  m1()  throws   MyException  {
}
</code></pre> 
 <p>或捕获异常类</p> 
 <pre><code class="lang-java">try  {

}catch(MyException e)  {

}
</code></pre> 
 <h2 id="h2-throwable-"><a name="Throwable类" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Throwable类</h2>
 <p>下面的列表显示了<code>Throwable</code>类的一些常用方法。<br><code>Throwable</code>类是Java中所有异常类的超类。此表中显示的所有方法在所有异常类中都可用。</p> 
 <table> 
  <thead> 
   <tr> 
    <th>方法</th> 
    <th>方法描述</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>Throwable getCause()</td> 
    <td>返回异常的原因。如果未设置异常的原因，则返回<code>null</code>。</td> 
   </tr> 
   <tr> 
    <td>String getMessage()</td> 
    <td>返回异常的详细消息。</td> 
   </tr> 
   <tr> 
    <td>StackTraceElement[] getStackTrace()</td> 
    <td>返回堆栈跟踪元素的数组。</td> 
   </tr> 
   <tr> 
    <td>Throwable initCause(Throwable cause)</td> 
    <td>设置异常的原因。有两种方法可以将异常设置为异常的原因。 其他方法是使用构造函数，它接受原因作为参数。</td> 
   </tr> 
   <tr> 
    <td>void printStackTrace()</td> 
    <td>在标准错误流上打印堆栈跟踪。</td> 
   </tr> 
   <tr> 
    <td>void printStackTrace(PrintStream s)</td> 
    <td>将堆栈跟踪打印到指定的<code>PrintStream</code>对象。</td> 
   </tr> 
   <tr> 
    <td>void printStackTrace(PrintWriter s)</td> 
    <td>将堆栈跟踪打印到指定的<code>PrintWriter</code>对象。</td> 
   </tr> 
   <tr> 
    <td>String toString()</td> 
    <td>返回异常对象的简短描述。</td> 
   </tr> 
  </tbody> 
 </table> 
 <h2 id="h2--1"><a name="实例-1" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例-1</h2>
 <p>以下代码演示了使用异常类的<code>printStackTrace()</code>方法。</p>   
 <pre><code class="lang-java">public class Main {
  public static void main(String[] args) {
    try {
      m1();
    } catch (MyException e) {
      e.printStackTrace(); // Print the stack trace
    }
  }

  public static void m1() throws MyException {
    m2();
  }

  public static void m2() throws MyException {
    throw new MyException("有异常或错误发生，鬼知道发生了什么，先抛出来再说！");
  }
}
class MyException extends Exception {
  public MyException() {
    super();
  }

  public MyException(String message) {
    super(message);
  }

  public MyException(String message, Throwable cause) {
    super(message, cause);
  }

  public MyException(Throwable cause) {
    super(cause);
  }
}
</code></pre> 
 <p>上面的代码生成以下结果。</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201612/14/275081252_52877.png" alt=""></p> 
 <h2 id="h2--2"><a name="实例-2" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例-2</h2>
 <p>以下代码显示了如何将异常的堆栈跟踪写入字符串中。</p> 
 <pre><code class="lang-java">import java.io.PrintWriter;
import java.io.StringWriter;

public class Main {
  public static void main(String[] args) {
    try {
      m1();
    } catch (MyException e) {
      String str = getStackTrace(e);
      System.out.println(str);
    }
  }
  public static void m1() throws MyException {
    m2();
  }

  public static void m2() throws MyException {
    throw new MyException("有异常或错误发生，鬼知道发生了什么，先抛出来再说！");
  }

  public static String getStackTrace(Throwable e) {
    StringWriter strWriter = new StringWriter();
    PrintWriter printWriter = new PrintWriter(strWriter);
    e.printStackTrace(printWriter);

    // Get the stack trace as a string
    String str = strWriter.toString();

    return str;
  }
}

class MyException extends Exception {
  public MyException() {
    super();
  }

  public MyException(String message) {
    super(message);
  }

  public MyException(String message, Throwable cause) {
    super(message, cause);
  }

  public MyException(Throwable cause) {
    super(cause);
  }
}
</code></pre> 
 <p>上面的代码生成以下结果。</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201612/14/303081253_90130.png" alt=""></p>
 <br>      
</div></body></html>