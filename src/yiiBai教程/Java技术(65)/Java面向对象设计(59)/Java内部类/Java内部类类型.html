<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java内部类类型</h1><div style="width:100%;float:left;" class="article-content">   
 <p>可以在类中的任何位置定义内部类，并在其中编写Java语句。有三种类型的内部类。 内部类的类型取决于位置和声明的方式。</p> 
 <ul> 
  <li>成员内部类</li>
  <li>局部内部类</li>
  <li>匿名内部类</li>
 </ul> 
 <h2 id="h2-u6210u5458u5185u90E8u7C7B"><a name="成员内部类" class="reference-link"></a><span class="header-link octicon octicon-link"></span>成员内部类</h2>
 <p>成员内部类在类中声明的方式与声明成员字段或成员方法相同。它可以声明为<code>public</code>，<code>private</code>，<code>protected</code>或<code>package-level</code>。成员内部类的实例可以仅存在于其封闭类的实例内。</p> 
 <p>以下代码创建了一个成员内部类。</p> 
 <pre><code class="lang-java">class Car {
  private int year;

  // A member inner class named Tire public
  class Tire {
    private double radius;
    public Tire(double radius) {
      this.radius = radius;
    }
    public double getRadius() {
      return radius;
    }
  } // Member inner class declaration ends here

  // A constructor for the Car class
  public Car(int year) {
    this.year = year;
  }
  public int getYear() {
    return year;
  }
}
</code></pre> 
 <h2 id="h2-u5C40u90E8u5185u5728u7C7B"><a name="局部内在类" class="reference-link"></a><span class="header-link octicon octicon-link"></span>局部内在类</h2>
 <p>一个局部内部类在块中声明。 其范围仅限于声明它的块。由于其范围限于其封闭块，因此其声明不能使用任何访问修饰符，例如<code>public</code>，<code>private</code>或<code>protected</code>。<br>通常，在方法内定义局部内部类。 但是，它也可以在静态初始化器，非静态初始化器和构造器中定义。下面的代码显示了一个局部内部类的例子。</p> 
 <pre><code class="lang-java">import java.util.ArrayList;
import java.util.Iterator;

public class Main {
  public static void main(String[] args) {
    StringList tl = new StringList();
    tl.addTitle("A");
    tl.addTitle("B");

    Iterator iterator = tl.titleIterator();
    while (iterator.hasNext()) {
      System.out.println(iterator.next());
    }
  }
}
class StringList {
  private ArrayList&lt;String&gt; titleList = new ArrayList&lt;&gt;();

  public void addTitle(String title) {
    titleList.add(title);
  }

  public void removeTitle(String title) {
    titleList.remove(title);
  }

  public Iterator&lt;String&gt; titleIterator() {
    // A local inner class - TitleIterator
    class TitleIterator implements Iterator&lt;String&gt; {
      int count = 0;
      @Override
      public boolean hasNext() {
        return (count &lt; titleList.size());
      }

      @Override
      public String next() {
        return titleList.get(count++);
      }
    }

    TitleIterator titleIterator = new TitleIterator();
    return titleIterator;
  }
}
</code></pre> 
 <p>上面的代码生成以下结果。</p> 
 <pre><code class="lang-java">A
B
</code></pre> 
 <h2 id="h2-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h2>
 <p>下面的代码有一个局部内部类继承自另一个公共类。</p> 
 <pre><code class="lang-java">import java.util.Random;

abstract class IntGenerator {
  public abstract int getValue() ;
}
class LocalGen {
  public IntGenerator getRandomInteger() {
    class RandomIntegerLocal extends IntGenerator {
      @Override
      public int getValue() {
        Random rand = new Random();
        long n1 = rand.nextInt();
        long n2 = rand.nextInt();
        int value = (int) ((n1 + n2) / 2);
        return value;
      }
    }

    return new RandomIntegerLocal();
  } // End of getRandomInteger() method
}

public class Main {
  public static void main(String[] args) {
    LocalGen local = new LocalGen();
    IntGenerator rLocal = local.getRandomInteger();
    System.out.println(rLocal.getValue());
    System.out.println(rLocal.getValue());
  }
}
</code></pre> 
 <p>上面的代码生成以下结果(每次的结果可能不太一样)。</p> 
 <pre><code class="lang-java">453673065
1036946998
</code></pre> 
 <h2 id="h2-u533Fu540Du5185u90E8u7C7B"><a name="匿名内部类" class="reference-link"></a><span class="header-link octicon octicon-link"></span>匿名内部类</h2>
 <p>匿名内部类没有名称。 因为它没有名称，所以它不能有构造函数。匿名类是一次性类。定义一个匿名类并同时创建它的对象。<br>创建匿名类及其对象的一般语法如下：</p>   
 <pre><code class="lang-java">new Interface()  {
// Anonymous  class body  goes  here
}
</code></pre> 
 <p>或者 - </p> 
 <pre><code class="lang-java">new Superclass(&lt;argument-list-for-a-superclass-constructor&gt;)  {
// Anonymous  class body  goes  here
}
</code></pre> 
 <p><code>new</code>运算符用于创建匿名类的实例。它后面是现有的接口名称或现有的类名称。接口名称或类名称不是新创建的匿名类的名称。如果使用接口名称，则匿名类实现接口。如果使用类名，则匿名类继承自其它类。<br>仅当新运算符后面跟有类名时，才使用<code>&lt;argument-list&gt;</code>。 如果新运算符后跟接口名称，则它为空。<br>如果<code>&lt;argument-list&gt;</code>存在，它包含要调用的现有类的构造函数的实际参数列表。</p> 
 <p>匿名类主体像往常一样在大括号中。匿名类主体应该简短，以便更好的可读性。下面的代码包含一个简单的匿名类，它在标准输出上打印一条消息。</p> 
 <pre><code class="lang-java">public class Main {
  public static void main(String[] args) {
    new Object() {
      // An instance initializer

        System.out.println("Hello from  an  anonymous class.");
      }
    }; // A semi-colon is necessary to end the statement
  }
}
</code></pre> 
 <p>上面的代码生成以下结果。</p> 
 <pre><code class="lang-java">Hello from  an  anonymous class.
</code></pre> 
 <h2 id="h2--2"><a name="实例-2" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例-2</h2>
 <p>以下代码使用匿名类来创建迭代器(<code>Iterator</code>)。</p> 
 <pre><code class="lang-java">import java.util.ArrayList;
import java.util.Iterator;

public class Main {
  private ArrayList&lt;String&gt; titleList = new ArrayList&lt;&gt;();

  public void addTitle(String title) {
    titleList.add(title);
  }

  public void removeTitle(String title) {
    titleList.remove(title);
  }

  public Iterator&lt;String&gt; titleIterator() {
    // An anonymous class
    Iterator&lt;String&gt; iterator = new Iterator&lt;String&gt;() {
      int count = 0;

      @Override
      public boolean hasNext() {
        return (count &lt; titleList.size());
      }

      @Override
      public String next() {
        return titleList.get(count++);
      }
    }; // Anonymous inner class ends here

    return iterator;
  }
}
</code></pre>
 <br>      
</div></body></html>