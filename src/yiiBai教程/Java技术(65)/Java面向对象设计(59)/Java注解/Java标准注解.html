<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java标准注解</h1><div style="width:100%;float:left;" class="article-content">   
 <p>Java API定义了许多标准注解类型。</p> 
 <p>以下部分将讨论在<code>java.lang</code>包中定义的四种最常用的标准注解。</p> 
 <ul> 
  <li>Deprecated</li>
  <li>Override</li>
  <li>SuppressWarnings</li>
  <li>FunctionalInterface</li>
 </ul> 
 <h2 id="h2--deprecated"><a name="已弃用的注解类型 - Deprecated" class="reference-link"></a><span class="header-link octicon octicon-link"></span>已弃用的注解类型 - Deprecated</h2>
 <p>弃用的注解类型是标记注解类型。 它标记了已弃用的代码元素。使用已弃用的程序元素将导致编译器生成警告。</p> 
 <pre><code class="lang-java">@Deprecated
class MyClass {
  private MyClass() {
  }

  public static MyClass getInstance() {
    MyClass dt = new MyClass();
    return dt;
  }
}

public class Main {
  public static void main(String[] args) {
    MyClass dt; // Generates a compile-time note
  }
}
</code></pre> 
 <h2 id="h2--override"><a name="覆盖注解类型 - Override" class="reference-link"></a><span class="header-link octicon octicon-link"></span>覆盖注解类型 - Override</h2>
 <p>覆盖注解类型是只能在方法上使用的标记注解类型。它表示方法覆盖在其超类中声明的方法。<br>如果要覆盖超类中的一个方法，建议使用<code><a target="_blank" href="https://github.com/Override" title="@Override" class="at-link">@Override</a></code>注解覆盖的方法。编译器将确保注解的方法真正覆盖超类中的一个方法。</p> 
 <p>如果注解的方法不覆盖超类中的方法，编译器将生成错误。</p> 
 <pre><code class="lang-java">class A {
  public void m1() {
  }
}

class B extends A {
  @Override
  public void m1() {
  }
}
</code></pre> 
 <h2 id="h2--suppresswarnings"><a name="抑制警告注解类型 - SuppressWarnings" class="reference-link"></a><span class="header-link octicon octicon-link"></span>抑制警告注解类型 - SuppressWarnings</h2>
 <p>抑制警告(<em>SuppressWarnings</em>)注解类型用于抑制命名编译器警告。它声明一个名为<code>value</code>的元素，其数据类型是一个<code>String</code>数组。</p> 
 <pre><code class="lang-java">import java.util.ArrayList;

public class Main {
  @SuppressWarnings("unchecked")
  public void test() {
    @SuppressWarnings("rawtypes")
    ArrayList list = new ArrayList();
    list.add("Hello"); // The compiler issues an unchecked warning
  }
}
</code></pre> 
 <h2 id="h2--functionalinterface"><a name="功能接口注解类型 - FunctionalInterface" class="reference-link"></a><span class="header-link octicon octicon-link"></span>功能接口注解类型 - FunctionalInterface</h2>
 <p>具有一个抽象方法声明的接口被称为功能接口( - <em>FunctionalInterface</em>)。如果使用此注解的接口不是函数接口，则会生成编译时错误。</p>   
 <pre><code class="lang-java">@FunctionalInterface 
interface  MyThread{
    void  run();
}
</code></pre> 
 <p>只有抽象方法的接口是一个功能接口，不管它是否用<code><a target="_blank" href="https://github.com/FunctionalInterface" title="@FunctionalInterface" class="at-link">@FunctionalInterface</a></code>注解。</p> 
 <h2 id="h2--java-"><a name="注解Java包" class="reference-link"></a><span class="header-link octicon octicon-link"></span>注解Java包</h2>
 <p>要注解一个Java包，创建一个名为<code>package-info.java</code>的文件，并将注解包声明放在这个文件中。以下代码显示了<code>package-info.java</code>文件的内容。</p> 
 <pre><code class="lang-java">// package-info.java
@Version(major=1, minor=0)
package  com.yiibai.annotation;
</code></pre>
 <br>      
</div></body></html>