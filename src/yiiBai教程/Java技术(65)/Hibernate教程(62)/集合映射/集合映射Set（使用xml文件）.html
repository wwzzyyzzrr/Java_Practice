<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">集合映射Set（使用xml文件）</h1><div style="width:100%;float:left;" class="article-content">   
 <p>如果持久类具有<code>Set</code>对象，可以在映射文件中使用<code>set</code>元素映射Set集合。 <code>set</code>元素不需要索引元素。 <code>List</code>和<code>Set</code>之间的区别是： Set只存储唯一的值。</p> 
 <p>我们来看看我们如何在映射文件中实现集合：</p> 
 <pre><code class="lang-xml">&lt;class name="com.yiibai.Question" table="q102"&gt;  
       ...        
          &lt;set name="answers" table="ans102"&gt;  
          &lt;key column="qid"&gt;&lt;/key&gt;  
          &lt;element column="answer" type="string"&gt;&lt;/element&gt;  
          &lt;/set&gt;  

       ...  
&lt;/class&gt;
</code></pre> 
 <h2 id="h2-u96C6u5408u6620u5C04u4E2Du6620u5C04u96C6u5408u7684u793Au4F8B"><a name="集合映射中映射集合的示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>集合映射中映射集合的示例</h2>
 <p>在这个例子中，我们将看到<code>set</code>的集合映射的完整示例。 这是存储值不是实体引用的集合的示例，这就是为什么要使用 <code>element</code> 而不是<code>one-to-many</code>。</p> 
 <p>在这里，我们使用论坛的场景：论坛中一个问题有多个答案。</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201703/2603/317090320_26735.png" alt=""></p> 
 <p>创建一个Java项目：setstring，完整的项目结果如下所示 -</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201703/2603/577100327_49172.png" alt=""></p> 
 <h3 id="h3-1-"><a name="1)创建持久化类" class="reference-link"></a><span class="header-link octicon octicon-link"></span>1)创建持久化类</h3>
 <p>这个持久化类定义了包含<code>Set</code>的类的属性。<em>Question.java</em>代码如下 -</p> 
 <pre><code class="lang-java">package com.yiibai;

import java.util.List;

public class Question {
    private int id;
    private String qname;
    private List&lt;String&gt; answers;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getQname() {
        return qname;
    }

    public void setQname(String qname) {
        this.qname = qname;
    }

    public List&lt;String&gt; getAnswers() {
        return answers;
    }

    public void setAnswers(List&lt;String&gt; answers) {
        this.answers = answers;
    }

}
</code></pre> 
 <h3 id="h3-2-"><a name="2)创建持久化类的映射文件" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2)创建持久化类的映射文件</h3>
 <p>在这里，我们创建了用于定义列表的<code>question.hbm.xml</code>文件。</p> 
 <pre><code class="lang-xml">&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
          "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
          "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping&gt;
    &lt;class name="com.yiibai.Question" table="q102"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="increment"&gt;&lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="qname"&gt;&lt;/property&gt;

        &lt;set name="answers" table="ans102"&gt;
            &lt;key column="qid"&gt;&lt;/key&gt;
            &lt;element column="answer" type="string"&gt;&lt;/element&gt;
        &lt;/set&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;
</code></pre> 
 <h2 id="h2-3-"><a name="3)创建配置文件" class="reference-link"></a><span class="header-link octicon octicon-link"></span>3)创建配置文件</h2>
 <p>此文件包含有关数据库和映射文件的信息。<em>hibernate.cfg.xml</em>文件的代码如下所示 -</p> 
 <pre><code class="lang-xml">&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
          "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
          "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;

&lt;!-- Generated by MyEclipse Hibernate Tools. --&gt;
&lt;hibernate-configuration&gt;

    &lt;session-factory&gt;
        &lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt;
        &lt;property name="connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt;
        &lt;property name="connection.url"&gt;jdbc:mysql://localhost:3306/test&lt;/property&gt;
        &lt;property name="connection.username"&gt;root&lt;/property&gt;
        &lt;property name="connection.password"&gt;123456&lt;/property&gt;
        &lt;property name="dialect"&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/property&gt;
        &lt;property name="show_sql"&gt;true&lt;/property&gt;
        &lt;mapping resource="question.hbm.xml" /&gt;
    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;
</code></pre> 
 <h3 id="h3-4-"><a name="4)创建存储数据的类" class="reference-link"></a><span class="header-link octicon octicon-link"></span>4)创建存储数据的类</h3>
 <p>在这个类中，我们存储<code>Question</code>类的数据。<code>MainTest.java</code>文件中的代码如下所示 -</p> 
 <pre><code class="lang-java">package com.yiibai;

import java.util.ArrayList;
import java.util.HashSet;

import org.hibernate.*;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistry;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.cfg.*;

public class MainTest {
    public static void main(String[] args) {
        // 但在5.1.0版本汇总，hibernate则采用如下新方式获取：
        // 1. 配置类型安全的准服务注册类，这是当前应用的单例对象，不作修改，所以声明为final
        // 在configure("cfg/hibernate.cfg.xml")方法中，如果不指定资源路径，默认在类路径下寻找名为hibernate.cfg.xml的文件
        final StandardServiceRegistry registry = new StandardServiceRegistryBuilder()
                .configure("hibernate.cfg.xml").build();
        // 2. 根据服务注册类创建一个元数据资源集，同时构建元数据并生成应用一般唯一的的session工厂
        SessionFactory sessionFactory = new MetadataSources(registry)
                .buildMetadata().buildSessionFactory();

        /**** 上面是配置准备，下面开始我们的数据库操作 ******/
        Session session = sessionFactory.openSession();// 从会话工厂获取一个session

        // creating transaction object
        Transaction t = session.beginTransaction();

        HashSet&lt;String&gt; set1=new HashSet&lt;String&gt;();
        set1.add("java is a programming language");
        set1.add("java is a platform");

        HashSet&lt;String&gt; set2=new HashSet&lt;String&gt;();
        set2.add("Servlet is an Interface");
        set2.add("Servlet is an API");

        Question question1=new Question();
        question1.setQname("What is Java?");
        question1.setAnswers(set1);

        Question question2=new Question();
        question2.setQname("What is Servlet?");
        question2.setAnswers(set2);

        session.persist(question1);
        session.persist(question2);

        t.commit();
        session.close();
        System.out.println("success");

    }
}
</code></pre> 
 <h3 id="h3-u5982u4F55u83B7u53D6u5217u8868u7684u6570u636E"><a name="如何获取列表的数据" class="reference-link"></a><span class="header-link octicon octicon-link"></span>如何获取列表的数据</h3>
 <p>在这里，我们使用HQL来获取<code>Question</code>类的所有记录，包括答案。 在这种情况下，它从功能相关的两个表中获取数据。</p> 
 <p><em>FetchData.java</em> 代码如下 -</p>   
 <pre><code class="lang-java">package com.yiibai;

import java.util.*;

import org.hibernate.*;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistry;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.cfg.*;

public class FetchData {
    public static void main(String[] args) {

        // 但在5.1.0版本汇总，hibernate则采用如下新方式获取：
        // 1. 配置类型安全的准服务注册类，这是当前应用的单例对象，不作修改，所以声明为final
        // 在configure("cfg/hibernate.cfg.xml")方法中，如果不指定资源路径，默认在类路径下寻找名为hibernate.cfg.xml的文件
        final StandardServiceRegistry registry = new StandardServiceRegistryBuilder()
                .configure("hibernate.cfg.xml").build();
        // 2. 根据服务注册类创建一个元数据资源集，同时构建元数据并生成应用一般唯一的的session工厂
        SessionFactory sessionFactory = new MetadataSources(registry)
                .buildMetadata().buildSessionFactory();

        /**** 上面是配置准备，下面开始我们的数据库操作 ******/
        Session session = sessionFactory.openSession();// 从会话工厂获取一个session

        // creating transaction object
        Transaction t = session.beginTransaction();

        Query query = session.createQuery("from Question");
        List&lt;Question&gt; list = query.list();

        Iterator&lt;Question&gt; itr = list.iterator();
        while (itr.hasNext()) {
            Question q = itr.next();
            System.out.println("Question Name: " + q.getQname());

            // printing answers
            Set&lt;String&gt; set = q.getAnswers();
            Iterator&lt;String&gt; itr2 = set.iterator();
            while (itr2.hasNext()) {
                System.out.println(itr2.next());
            }

        }
        session.close();
        System.out.println("success");

    }
}
</code></pre> 
 <h3 id="h3-u8FD0u884Cu793Au4F8B"><a name="运行示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>运行示例</h3>
 <p>首先运行 <code>MainTest.java</code> 等到以下结果 -</p> 
 <pre><code class="lang-shell">log4j:WARN No appenders could be found for logger (org.jboss.logging).
log4j:WARN Please initialize the log4j system properly.
log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
Sun Mar 26 22:25:20 CST 2017 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.
Hibernate: create table ans102 (qid integer not null, answer varchar(255)) engine=InnoDB
Hibernate: create table q102 (id integer not null, qname varchar(255), primary key (id)) engine=InnoDB
Hibernate: alter table ans102 add constraint FKce1yv9t7up0lavpmh8ry2gph5 foreign key (qid) references q102 (id)
Hibernate: select max(id) from q102
Hibernate: insert into q102 (qname, id) values (?, ?)
Hibernate: insert into q102 (qname, id) values (?, ?)
Hibernate: insert into ans102 (qid, answer) values (?, ?)
Hibernate: insert into ans102 (qid, answer) values (?, ?)
Hibernate: insert into ans102 (qid, answer) values (?, ?)
Hibernate: insert into ans102 (qid, answer) values (?, ?)
success
</code></pre> 
 <p>运行 <code>FetchData.java</code> 读取信息，到以下结果 -</p> 
 <pre><code class="lang-shell">log4j:WARN No appenders could be found for logger (org.jboss.logging).
log4j:WARN Please initialize the log4j system properly.
log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
Sun Mar 26 22:26:33 CST 2017 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.
Hibernate: select question0_.id as id1_1_, question0_.qname as qname2_1_ from q102 question0_
Question Name: What is Java?
Hibernate: select answers0_.qid as qid1_0_0_, answers0_.answer as answer2_0_0_ from ans102 answers0_ where answers0_.qid=?
java is a programming language
java is a platform
Question Name: What is Servlet?
Hibernate: select answers0_.qid as qid1_0_0_, answers0_.answer as answer2_0_0_ from ans102 answers0_ where answers0_.qid=?
Servlet is an Interface
Servlet is an API
success
</code></pre>
 <br>      
</div></body></html>