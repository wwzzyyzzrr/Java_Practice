<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">通过Bag一对多映射示例（使用xml文件）</h1><div style="width:100%;float:left;" class="article-content">   
 <p>如果持久化类具有包含实体引用的列表对象，则需要使用一对多关联来映射列表元素。 我们可以通过列表(list)或包(bag)来映射这个列表对象。</p> 
 <blockquote> 
  <p>请注意，<code>bag</code>不是基于索引的，而<code>list</code>是基于索引的。</p> 
 </blockquote> 
 <p>在这里，我们使用论坛的场景：论坛中一个问题有多个答案。</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201703/2603/317090320_26735.png" alt=""></p> 
 <p>下面来看看看具有列表对象的持久化类。 在这种情况下，一个问题可以有多个答案，每个答案可能有自己的信息，这就是为什么这里要使用列表(list)元素(包含答案对象)代表一个答案集合。<br><code>Question</code>类代码如下 - </p> 
 <pre><code class="lang-java">package com.yiibai;

import java.util.List;

public class Question {
    private int id;
    private String qname;
    private List&lt;String&gt; answers;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getQname() {
        return qname;
    }

    public void setQname(String qname) {
        this.qname = qname;
    }

    public List&lt;String&gt; getAnswers() {
        return answers;
    }

    public void setAnswers(List&lt;String&gt; answers) {
        this.answers = answers;
    }

}
</code></pre> 
 <p><code>Question</code>类有自己的信息，如<code>id</code>，<code>answername</code>，<code>postedBy</code>等。</p> 
 <pre><code class="lang-java">package com.yiibai;

public class Answer {
    private int id;
    private String answername;
    private String postedBy;
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getAnswername() {
        return answername;
    }
    public void setAnswername(String answername) {
        this.answername = answername;
    }
    public String getPostedBy() {
        return postedBy;
    }
    public void setPostedBy(String postedBy) {
        this.postedBy = postedBy;
    }

}
</code></pre> 
 <p><code>Question</code>类具有包含实体引用的列表对象(即<code>Answer</code>类对象)。 在这种情况下，我们需要使用一对多的<code>bag</code>标签来映射此对象。 下面来看看看我们如何映射它。</p> 
 <pre><code class="lang-xml">&lt;bag name="answers" cascade="all"&gt;  
    &lt;key column="qid"&gt;&lt;/key&gt;  
    &lt;one-to-many class="com.yiibai.Answer"/&gt;  
&lt;/bag&gt;
</code></pre> 
 <h2 id="h2-u901Au8FC7u4E00u5BF9u591Au5173u8054u5728u96C6u5408u6620u5C04u4E2Du6620u5C04u5305u7684u793Au4F8B"><a name="通过一对多关联在集合映射中映射包的示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>通过一对多关联在集合映射中映射包的示例</h2>
 <p>在这个例子中，我们将看到包含实体引用的映射列表的完整示例。创建一个Java项目：<code>bagonetomany</code>，其完整的目录结构如下 -</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201703/2603/518090355_59117.png" alt=""></p> 
 <h3 id="h3-1-"><a name="1)创建持久化类" class="reference-link"></a><span class="header-link octicon octicon-link"></span>1)创建持久化类</h3>
 <p>这个持久化类定义了类的属性，包括<code>List</code>。</p> 
 <p><em>Question.java</em> 代码如下所示 -</p> 
 <pre><code class="lang-java">package com.yiibai;

import java.util.List;

public class Question {
    private int id;
    private String qname;
    private List&lt;String&gt; answers;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getQname() {
        return qname;
    }

    public void setQname(String qname) {
        this.qname = qname;
    }

    public List&lt;String&gt; getAnswers() {
        return answers;
    }

    public void setAnswers(List&lt;String&gt; answers) {
        this.answers = answers;
    }

}
</code></pre> 
 <p><em>Answer.java</em> 代码如下所示 -</p> 
 <pre><code class="lang-java">package com.yiibai;

public class Answer {
    private int id;
    private String answername;
    private String postedBy;
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getAnswername() {
        return answername;
    }
    public void setAnswername(String answername) {
        this.answername = answername;
    }
    public String getPostedBy() {
        return postedBy;
    }
    public void setPostedBy(String postedBy) {
        this.postedBy = postedBy;
    }

    public String toString(){
        return this.answername+", PostedBy "+this.postedBy;
    }
}
</code></pre> 
 <h2 id="h2-2-"><a name="2)创建持久化类的映射文件" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2)创建持久化类的映射文件</h2>
 <p>在这里，我们创建了用于定义列表的<code>question.hbm.xml</code>文件。</p> 
 <pre><code class="lang-xml">&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
          "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
          "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping&gt;
    &lt;class name="com.yiibai.Question" table="q501"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="increment"&gt;&lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="qname"&gt;&lt;/property&gt;

        &lt;bag name="answers" cascade="all"&gt;
            &lt;key column="type"&gt;&lt;/key&gt;
            &lt;one-to-many class="com.yiibai.Answer" /&gt;
        &lt;/bag&gt;

    &lt;/class&gt;

    &lt;class name="com.yiibai.Answer" table="ans501"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="increment"&gt;&lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="answername"&gt;&lt;/property&gt;
        &lt;property name="postedBy"&gt;&lt;/property&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;
</code></pre> 
 <h2 id="h2-3-"><a name="3)创建配置文件" class="reference-link"></a><span class="header-link octicon octicon-link"></span>3)创建配置文件</h2>
 <p>此文件包含有关数据库和映射文件的信息。<em>hibernate.cfg.xml</em>文件的代码如下所示 -</p> 
 <pre><code class="lang-xml">&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
          "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
          "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;

&lt;!-- Generated by MyEclipse Hibernate Tools. --&gt;
&lt;hibernate-configuration&gt;

    &lt;session-factory&gt;
        &lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt;

        &lt;property name="connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt;
        &lt;property name="connection.url"&gt;jdbc:mysql://localhost:3306/test&lt;/property&gt;
        &lt;property name="connection.username"&gt;root&lt;/property&gt;
        &lt;property name="connection.password"&gt;123456&lt;/property&gt;
        &lt;property name="dialect"&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/property&gt;
        &lt;property name="show_sql"&gt;true&lt;/property&gt;

        &lt;mapping resource="question.hbm.xml" /&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;
</code></pre> 
 <h3 id="h3-4-"><a name="4)创建存储数据的类" class="reference-link"></a><span class="header-link octicon octicon-link"></span>4)创建存储数据的类</h3>
 <p>在这个类中，我们存储<code>Question</code>类的数据。<code>MainTest.java</code>文件中的代码如下所示 -</p> 
 <pre><code class="lang-java">package com.yiibai;

import java.util.ArrayList;

import org.hibernate.*;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistry;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.cfg.*;

public class MainTest {
    public static void main(String[] args) {
        // 但在5.1.0版本汇总，hibernate则采用如下新方式获取：
        // 1. 配置类型安全的准服务注册类，这是当前应用的单例对象，不作修改，所以声明为final
        // 在configure("cfg/hibernate.cfg.xml")方法中，如果不指定资源路径，默认在类路径下寻找名为hibernate.cfg.xml的文件
        final StandardServiceRegistry registry = new StandardServiceRegistryBuilder()
                .configure("hibernate.cfg.xml").build();
        // 2. 根据服务注册类创建一个元数据资源集，同时构建元数据并生成应用一般唯一的的session工厂
        SessionFactory sessionFactory = new MetadataSources(registry)
                .buildMetadata().buildSessionFactory();

        /**** 上面是配置准备，下面开始我们的数据库操作 ******/
        Session session = sessionFactory.openSession();// 从会话工厂获取一个session

        // creating transaction object
        Transaction t = session.beginTransaction();

        Answer ans1 = new Answer();
        ans1.setAnswername("java is a programming language");
        ans1.setPostedBy("Ravi Su");

        Answer ans2 = new Answer();
        ans2.setAnswername("java is a platform");
        ans2.setPostedBy("Sudhir Lee");

        Answer ans3 = new Answer();
        ans3.setAnswername("Servlet is an Interface");
        ans3.setPostedBy("Jai Wong");

        Answer ans4 = new Answer();
        ans4.setAnswername("Servlet is an API");
        ans4.setPostedBy("Arun");

        ArrayList&lt;Answer&gt; list1 = new ArrayList&lt;Answer&gt;();
        list1.add(ans1);
        list1.add(ans2);

        ArrayList&lt;Answer&gt; list2 = new ArrayList&lt;Answer&gt;();
        list2.add(ans3);
        list2.add(ans4);

        Question question1 = new Question();
        question1.setQname("What is Java?");
        question1.setAnswers(list1);

        Question question2 = new Question();
        question2.setQname("What is Servlet?");
        question2.setAnswers(list2);

        session.persist(question1);
        session.persist(question2);

        t.commit();
        session.close();

        System.out.println("success");

    }
}
</code></pre> 
 <h2 id="h2-u5982u4F55u83B7u53D6u5217u8868u7684u6570u636E"><a name="如何获取列表的数据" class="reference-link"></a><span class="header-link octicon octicon-link"></span>如何获取列表的数据</h2>
 <p>在这里，我们使用HQL来获取<code>Question</code>类的所有记录，包括答案。 在这种情况下，它从功能相关的两个表中获取数据。 在这里，我们直接打印答案类的对象，但是我们已经在Answer类中覆盖了返回 <code>answername</code> 和 <code>postername</code> 的<code>toString()</code>方法。 所以它打印<code>answername</code> 和 <code>postername</code> 而不是参考ID。</p> 
 <p><em>FetchData.java</em> 代码如下 -</p>   
 <pre><code class="lang-java">package com.yiibai;

import java.util.*;

import org.hibernate.*;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistry;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.cfg.*;

public class FetchData {
    public static void main(String[] args) {

        // 但在5.1.0版本汇总，hibernate则采用如下新方式获取：
        // 1. 配置类型安全的准服务注册类，这是当前应用的单例对象，不作修改，所以声明为final
        // 在configure("cfg/hibernate.cfg.xml")方法中，如果不指定资源路径，默认在类路径下寻找名为hibernate.cfg.xml的文件
        final StandardServiceRegistry registry = new StandardServiceRegistryBuilder()
                .configure("hibernate.cfg.xml").build();
        // 2. 根据服务注册类创建一个元数据资源集，同时构建元数据并生成应用一般唯一的的session工厂
        SessionFactory sessionFactory = new MetadataSources(registry)
                .buildMetadata().buildSessionFactory();

        /**** 上面是配置准备，下面开始我们的数据库操作 ******/
        Session session = sessionFactory.openSession();// 从会话工厂获取一个session

        // creating transaction object
        Transaction t = session.beginTransaction();

        Query query = session.createQuery("from Question");
        List&lt;Question&gt; list = query.list();

        Iterator&lt;Question&gt; itr = list.iterator();
        while (itr.hasNext()) {
            Question q = itr.next();
            System.out.println("Question Name: " + q.getQname());

            // printing answers
            List&lt;Answer&gt; list2 = q.getAnswers();
            Iterator&lt;Answer&gt; itr2 = list2.iterator();
            while (itr2.hasNext()) {
                System.out.println(itr2.next());
            }

        }
        session.close();
        System.out.println("success");

    }
}
</code></pre> 
 <h3 id="h3-u8FD0u884Cu793Au4F8B"><a name="运行示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>运行示例</h3>
 <p>首先运行 <code>MainTest.java</code> 等到以下结果 -</p> 
 <pre><code class="lang-shell">log4j:WARN No appenders could be found for logger (org.jboss.logging).
log4j:WARN Please initialize the log4j system properly.
log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
Sun Mar 26 21:54:43 CST 2017 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.
Hibernate: alter table ans501 add constraint FKtppk9gq3v1rge6ntclgp1jucm foreign key (type) references q501 (id)
Hibernate: select max(id) from q501
Hibernate: select max(id) from ans501
Hibernate: insert into q501 (qname, id) values (?, ?)
Hibernate: insert into ans501 (answername, postedBy, id) values (?, ?, ?)
Hibernate: insert into ans501 (answername, postedBy, id) values (?, ?, ?)
Hibernate: insert into q501 (qname, id) values (?, ?)
Hibernate: insert into ans501 (answername, postedBy, id) values (?, ?, ?)
Hibernate: insert into ans501 (answername, postedBy, id) values (?, ?, ?)
Hibernate: update ans501 set type=? where id=?
Hibernate: update ans501 set type=? where id=?
Hibernate: update ans501 set type=? where id=?
Hibernate: update ans501 set type=? where id=?
success
</code></pre> 
 <p>再读取上一步中存储的信息，运行 <code>FetchData.java</code> 得到以下结果 -</p> 
 <pre><code class="lang-shell">log4j:WARN No appenders could be found for logger (org.jboss.logging).
log4j:WARN Please initialize the log4j system properly.
log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
Sun Mar 26 21:51:56 CST 2017 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.
Hibernate: alter table ans501 add constraint FKtppk9gq3v1rge6ntclgp1jucm foreign key (type) references q501 (id)
Hibernate: select question0_.id as id1_1_, question0_.qname as qname2_1_ from q501 question0_
Question Name: What is Java?
Hibernate: select answers0_.type as type4_0_0_, answers0_.id as id1_0_0_, answers0_.id as id1_0_1_, answers0_.answername as answerna2_0_1_, answers0_.postedBy as postedBy3_0_1_ from ans501 answers0_ where answers0_.type=?
java is a platform, PostedBy Sudhir Wong
Servlet is an API, PostedBy Arun
Question Name: What is Servlet?
Hibernate: select answers0_.type as type4_0_0_, answers0_.id as id1_0_0_, answers0_.id as id1_0_1_, answers0_.answername as answerna2_0_1_, answers0_.postedBy as postedBy3_0_1_ from ans501 answers0_ where answers0_.type=?
Question Name: What is Java?
Hibernate: select answers0_.type as type4_0_0_, answers0_.id as id1_0_0_, answers0_.id as id1_0_1_, answers0_.answername as answerna2_0_1_, answers0_.postedBy as postedBy3_0_1_ from ans501 answers0_ where answers0_.type=?
java is a programming language, PostedBy Ravi Su
java is a platform, PostedBy Sudhir Lee
Question Name: What is Servlet?
Hibernate: select answers0_.type as type4_0_0_, answers0_.id as id1_0_0_, answers0_.id as id1_0_1_, answers0_.answername as answerna2_0_1_, answers0_.postedBy as postedBy3_0_1_ from ans501 answers0_ where answers0_.type=?
Servlet is an Interface, PostedBy Jai Wong
Servlet is an API, PostedBy Arun
success
</code></pre>
 <br>      
</div></body></html>