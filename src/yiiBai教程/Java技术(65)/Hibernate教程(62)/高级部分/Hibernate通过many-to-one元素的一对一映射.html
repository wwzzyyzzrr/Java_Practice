<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Hibernate通过many-to-one元素的一对一映射</h1><div style="width:100%;float:left;" class="article-content">   
 <p> 在hibernate中我们可以通过两种方式来执行一对一映射： </p> 
 <ul> 
  <li> 通过many-to-one元素标签 </li> 
  <li> 通过one-to-one元素标签 </li> 
 </ul> 
 <p> 在这里，我们将通过多对一的many-to-one元素进行一对一的映射。 在这种情况下，在主表中创建外键。 </p> 
 <p> 在这个例子中，一个员工只能有一个地址，一个地址只能属于一个员工。 在这里使用双向关联。 我们来看看持久化类。 </p> 
 <h2 id="h2-u4E00u5BF9u4E00u6620u5C04u793Au4F8B"> <a name="一对一映射示例"></a><span class="header-link octicon octicon-link"></span>一对一映射示例 </h2> 
 <p> 创建一个名称为：onetoonemappingforeign的java项目，其项目文件目录结构如下 - </p> 
 <p> <img src="http://www.yiibai.com/uploads/images/201703/2703/549110341_86694.png" alt=""> </p> 
 <h3 id="h3-1-"> <a name="1)一对一映射的持久类"></a><span class="header-link octicon octicon-link"></span>1)一对一映射的持久类 </h3> 
 <p> 有两个持久化类Employee.java和Address.java。Employee类包含Address类引用，反之亦然(Address类包含Employee类引用)。下面我们来看看它们的代码实现。 </p> 
 <p> <em>文件：Employee.java</em> </p> 
 <pre>package com.yiibai;

public class Employee {
    private int employeeId;
    private String name, email;

    private Address address;

    public int getEmployeeId() {
        return employeeId;
    }

    public void setEmployeeId(int employeeId) {
        this.employeeId = employeeId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }

}</pre> 
 <p> <em>文件：Address.java</em> </p> 
 <pre>package com.yiibai;

public class Address {
    private int addressId;
    private String addressLine1, city, state, country;
    private int pincode;
    private Employee employee;

    public int getAddressId() {
        return addressId;
    }

    public void setAddressId(int addressId) {
        this.addressId = addressId;
    }

    public String getAddressLine1() {
        return addressLine1;
    }

    public void setAddressLine1(String addressLine1) {
        this.addressLine1 = addressLine1;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }

    public String getCountry() {
        return country;
    }

    public void setCountry(String country) {
        this.country = country;
    }

    public int getPincode() {
        return pincode;
    }

    public void setPincode(int pincode) {
        this.pincode = pincode;
    }

    public Employee getEmployee() {
        return employee;
    }

    public void setEmployee(Employee employee) {
        this.employee = employee;
    }

}</pre> 
 <h3 id="h3-2-"> <a name="2)持久化类映射文件"></a><span class="header-link octicon octicon-link"></span>2)持久化类映射文件 </h3> 
 <p> 两个映射文件是employee.hbm.xml和address.hbm.xml。 在employee.hbm.xml映射文件中，many-to-one元素标签使用unique =“true”属性进行一对一映射。 </p> 
 <p> <em>文件：employee.hbm.xml</em> </p> 
 <pre>&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
          "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
          "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping&gt;
    &lt;class name="com.yiibai.Employee" table="emp_2110"&gt;
        &lt;id name="employeeId"&gt;
            &lt;generator class="increment"&gt;&lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="name"&gt;&lt;/property&gt;
        &lt;property name="email"&gt;&lt;/property&gt;

        &lt;many-to-one name="address" unique="true" cascade="all"&gt;&lt;/many-to-one&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre> 
 <p> <em>文件：address.hbm.xml</em><br> 这是Address类的简单映射文件。 </p> 
 <pre>&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
          "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
          "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping&gt;
    &lt;class name="com.yiibai.Address" table="address_2110"&gt;
        &lt;id name="addressId"&gt;
            &lt;generator class="increment"&gt;&lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="addressLine1"&gt;&lt;/property&gt;
        &lt;property name="city"&gt;&lt;/property&gt;
        &lt;property name="state"&gt;&lt;/property&gt;
        &lt;property name="country"&gt;&lt;/property&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre> 
 <h3 id="h3-3-"> <a name="3)配置文件"></a><span class="header-link octicon octicon-link"></span>3)配置文件 </h3> 
 <p> 此文件包含有关数据库和映射文件的信息。 </p> 
 <p> <em>文件：hibernate.cfg.xml</em> </p> 
 <pre>&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
          "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
          "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;

&lt;!-- Generated by MyEclipse Hibernate Tools. --&gt;
&lt;hibernate-configuration&gt;

    &lt;session-factory&gt;
        &lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt;

        &lt;property name="connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt;
        &lt;property name="connection.url"&gt;jdbc:mysql://localhost:3306/test&lt;/property&gt;
        &lt;property name="connection.username"&gt;root&lt;/property&gt;
        &lt;property name="connection.password"&gt;123456&lt;/property&gt;
        &lt;property name="dialect"&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/property&gt;
        &lt;property name="show_sql"&gt;true&lt;/property&gt;

        &lt;mapping resource="employee.hbm.xml" /&gt;
        &lt;mapping resource="address.hbm.xml" /&gt;
    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre> 
 <h3 id="h3-4-"> <a name="4)存储和获取数据的用户类"></a><span class="header-link octicon octicon-link"></span>4)存储和获取数据的用户类 </h3> 
 <p> <em>文件：MainTest.java</em> 的代码如下 - </p> 
 <pre>package com.yiibai;

import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistry;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.cfg.*;
import org.hibernate.*;

public class MainTest {
    public static void main(String[] args) {
        // 在5.1.0版本汇总，hibernate则采用如下新方式获取：
        // 1. 配置类型安全的准服务注册类，这是当前应用的单例对象，不作修改，所以声明为final
        // 在configure("cfg/hibernate.cfg.xml")方法中，如果不指定资源路径，默认在类路径下寻找名为hibernate.cfg.xml的文件
        final StandardServiceRegistry registry = new StandardServiceRegistryBuilder()
                .configure("hibernate.cfg.xml").build();
        // 2. 根据服务注册类创建一个元数据资源集，同时构建元数据并生成应用一般唯一的的session工厂
        SessionFactory sessionFactory = new MetadataSources(registry)
                .buildMetadata().buildSessionFactory();

        /**** 上面是配置准备，下面开始我们的数据库操作 ******/
        Session session = sessionFactory.openSession();// 从会话工厂获取一个session
        // creating transaction object
        Transaction t = session.beginTransaction();

        Employee e1 = new Employee();
        e1.setName("Max Su");
        e1.setEmail("maxsu@gmail.com");

        Address address1 = new Address();
        address1.setAddressLine1("1688, RenMin Road");
        address1.setCity("Haikou");
        address1.setState("Hainan");
        address1.setCountry("China");
        address1.setPincode(201301);

        e1.setAddress(address1);
        address1.setEmployee(e1);

        session.persist(e1);
        t.commit();

        session.close();
        System.out.println("success");
    }
}</pre> 
 <p> <em>文件：FetchTest.java</em> 的代码如下 - </p>   
 <pre>package com.yiibai;

import java.util.Iterator;
import java.util.List;
import org.hibernate.Query;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistry;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.cfg.Configuration;

public class FetchTest {
    public static void main(String[] args) {
        // 在5.1.0版本汇总，hibernate则采用如下新方式获取：
        // 1. 配置类型安全的准服务注册类，这是当前应用的单例对象，不作修改，所以声明为final
        // 在configure("cfg/hibernate.cfg.xml")方法中，如果不指定资源路径，默认在类路径下寻找名为hibernate.cfg.xml的文件
        final StandardServiceRegistry registry = new StandardServiceRegistryBuilder()
                .configure("hibernate.cfg.xml").build();
        // 2. 根据服务注册类创建一个元数据资源集，同时构建元数据并生成应用一般唯一的的session工厂
        SessionFactory sessionFactory = new MetadataSources(registry)
                .buildMetadata().buildSessionFactory();

        /**** 上面是配置准备，下面开始我们的数据库操作 ******/
        Session session = sessionFactory.openSession();// 从会话工厂获取一个session

        Query query = session.createQuery("from Employee e");
        List&lt;Employee&gt; list = query.list();

        Iterator&lt;Employee&gt; itr = list.iterator();
        while (itr.hasNext()) {
            Employee emp = itr.next();
            System.out.println(emp.getEmployeeId() + " " + emp.getName() + " "
                    + emp.getEmail());
            Address address = emp.getAddress();
            System.out.println(address.getAddressLine1() + " "
                    + address.getCity() + " " + address.getState() + " "
                    + address.getCountry());
        }

        session.close();
        System.out.println("success");
    }
}</pre> 
 <h3 id="h3-u8FD0u884Cu6D4Bu8BD5"> <a name="运行测试"></a><span class="header-link octicon octicon-link"></span>运行测试 </h3> 
 <p> 首先运行MainTest.java类，得到输出结果如下 - </p> 
 <pre>log4j:WARN No appenders could be found for logger (org.jboss.logging).
log4j:WARN Please initialize the log4j system properly.
log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
Mon Mar 27 23:24:53 CST 2017 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.
Hibernate: create table address_2110 (addressId integer not null, addressLine1 varchar(255), city varchar(255), state varchar(255), country varchar(255), primary key (addressId)) engine=InnoDB
Hibernate: create table emp_2110 (employeeId integer not null, name varchar(255), email varchar(255), address integer, primary key (employeeId)) engine=InnoDB
Hibernate: alter table emp_2110 drop index UK_o59xt2yukiefdxhv7bx8u0o3a
Hibernate: alter table emp_2110 add constraint UK_o59xt2yukiefdxhv7bx8u0o3a unique (address)
Hibernate: alter table emp_2110 add constraint FKplaygd7gpfedy290hg81wi1ba foreign key (address) references address_2110 (addressId)
Hibernate: select max(employeeId) from emp_2110
Hibernate: select max(addressId) from address_2110
Hibernate: insert into address_2110 (addressLine1, city, state, country, addressId) values (?, ?, ?, ?, ?)
Hibernate: insert into emp_2110 (name, email, address, employeeId) values (?, ?, ?, ?)
success</pre>
 <br>      
</div></body></html>