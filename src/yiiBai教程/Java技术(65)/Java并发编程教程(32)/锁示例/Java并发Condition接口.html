<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java并发Condition接口</h1><div style="width:100%;float:left;" class="article-content">   
 <p><code>java.util.concurrent.locks.Condition</code>接口提供一个线程挂起执行的能力，直到给定的条件为真。 <code>Condition</code>对象必须绑定到<code>Lock</code>，并使用<code>newCondition()</code>方法获取对象。</p> 
 <h2 id="h2-condition-"><a name="Condition类的方法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Condition类的方法</h2>
 <p>以下是<code>Condition</code>类中可用的重要方法的列表。</p> 
 <table> 
  <thead> 
   <tr> 
    <th>序号</th> 
    <th>方法名称</th> 
    <th>描述</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>1</td> 
    <td><code>public void await()</code></td> 
    <td>使当前线程等待，直到发出信号或中断信号。</td> 
   </tr> 
   <tr> 
    <td>2</td> 
    <td><code>public boolean await(long time, TimeUnit unit)</code></td> 
    <td>使当前线程等待直到发出信号或中断，或指定的等待时间过去。</td> 
   </tr> 
   <tr> 
    <td>3</td> 
    <td><code>public long awaitNanos(long nanosTimeout)</code></td> 
    <td>使当前线程等待直到发出信号或中断，或指定的等待时间过去。</td> 
   </tr> 
   <tr> 
    <td>4</td> 
    <td><code>public long awaitUninterruptibly()</code></td> 
    <td>使当前线程等待直到发出信号。</td> 
   </tr> 
   <tr> 
    <td>5</td> 
    <td><code>public long awaitUntil()</code></td> 
    <td>使当前线程等待直到发出信号或中断，或者指定的最后期限过去。</td> 
   </tr> 
   <tr> 
    <td>6</td> 
    <td><code>public void signal()</code></td> 
    <td>唤醒一个等待线程。</td> 
   </tr> 
   <tr> 
    <td>7</td> 
    <td><code>public void signalAll()</code></td> 
    <td>唤醒所有等待线程。</td> 
   </tr> 
  </tbody> 
 </table> 
 <h2 id="h2-u5B9Eu4F8B"><a name="实例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例</h2>
 <p>以下<code>TestThread</code>程序演示了<code>Condition</code>接口的这些方法。这里我们使用<code>signal()</code>通知和<code>await()</code>挂起线程。</p> 
 <pre><code class="lang-java">import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class TestThread {

   public static void main(String[] args) throws InterruptedException{
      ItemQueue itemQueue = new ItemQueue(10);

      //Create a producer and a consumer.
      Thread producer = new Producer(itemQueue);
      Thread consumer = new Consumer(itemQueue);

      //Start both threads.
      producer.start();
      consumer.start();

      //Wait for both threads to terminate.
      producer.join();
      consumer.join();
   }

   static class ItemQueue {

      private Object[] items = null;
      private int current = 0;
      private int placeIndex = 0;
      private int removeIndex = 0;

      private final Lock lock;
      private final Condition isEmpty;
      private final Condition isFull;

      public ItemQueue(int capacity) {
         this.items = new Object[capacity];
         lock = new ReentrantLock();
         isEmpty = lock.newCondition();
         isFull = lock.newCondition();
      }

      public void add(Object item) throws InterruptedException {
         lock.lock();
         while(current &gt;= items.length)
            isFull.await();

         items[placeIndex] = item;

         placeIndex = (placeIndex + 1) % items.length;

         ++current;

         //Notify the consumer that there is data available.
         isEmpty.signal();

         lock.unlock();
      }

      public Object remove() throws InterruptedException {
         Object item = null;

         lock.lock();
         while(current &lt;= 0){
            isEmpty.await();
         }
         item = items[removeIndex];

         removeIndex = (removeIndex + 1) % items.length;

         --current;

         //Notify the producer that there is space available.
         isFull.signal();
         lock.unlock();

         return item;
      }

      public boolean isEmpty(){
         return (items.length == 0);
      }
   }

   static class Producer extends Thread {

      private final ItemQueue queue;
      public Producer(ItemQueue queue) {
         this.queue = queue;
      }

      @Override
      public void run() {
         String[] numbers = {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"};

         try {
            for(String number: numbers){
               queue.add(number);
               System.out.println("[Producer]: " + number);
            }
            queue.add(null);
         }
         catch (InterruptedException ex) {
            ex.printStackTrace();
         } 
      }
   }

   static class Consumer extends Thread {

      private final ItemQueue queue;
      public Consumer(ItemQueue queue) {
         this.queue = queue;
      }

      @Override
      public void run() {
         try {
            do {
               Object number = queue.remove();
               System.out.println("[Consumer]: " + number);
               if(number == null){
                  return;
               }
            } while(!queue.isEmpty());
         }
         catch (InterruptedException ex) {
            ex.printStackTrace();
         }
      }
   }
}
</code></pre> 
 <p>这将产生以下结果。</p>   
 <pre><code class="lang-shell">[Producer]: 1
[Consumer]: 1
[Producer]: 2
[Consumer]: 2
[Producer]: 3
[Consumer]: 3
[Producer]: 4
[Consumer]: 4
[Producer]: 5
[Producer]: 6
[Consumer]: 5
[Producer]: 7
[Consumer]: 6
[Consumer]: 7
[Producer]: 8
[Consumer]: 8
[Producer]: 9
[Consumer]: 9
[Producer]: 10
[Consumer]: 10
[Producer]: 11
[Consumer]: 11
[Producer]: 12
[Consumer]: 12
[Consumer]: null
</code></pre>
 <br>      
</div></body></html>