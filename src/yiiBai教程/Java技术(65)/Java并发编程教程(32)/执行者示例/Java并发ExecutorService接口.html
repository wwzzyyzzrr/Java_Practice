<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java并发ExecutorService接口</h1><div style="width:100%;float:left;" class="article-content">   
 <p><code>java.util.concurrent.ExecutorService</code>接口是<code>Executor</code>接口的子接口，并添加了功能来管理生命周期，这两个单独的任务和执行器本身。</p> 
 <h2 id="h2-executorservice-"><a name="ExecutorService接口的方法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>ExecutorService接口的方法</h2>
 <table> 
  <thead> 
   <tr> 
    <th>序号</th> 
    <th>方法</th> 
    <th>描述</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>1</td> 
    <td><code>boolean awaitTermination(long timeout, TimeUnit unit)</code></td> 
    <td>阻止所有任务在关闭请求完成后执行，或发生超时，或当前线程中断，以先到者为准。</td> 
   </tr> 
   <tr> 
    <td>2</td> 
    <td><code>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</code></td> 
    <td>执行给定的任务，返回持有它们的状态和结果的所有完成的列表。</td> 
   </tr> 
   <tr> 
    <td>3</td> 
    <td><code>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)</code></td> 
    <td>执行给定的任务，返回在所有完成或超时到期时持有其状态和结果的列表，以先发生者为准。</td> 
   </tr> 
   <tr> 
    <td>4</td> 
    <td><code>&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</code></td> 
    <td>执行给定的任务，返回一个已经成功完成的结果(即不抛出异常)。</td> 
   </tr> 
   <tr> 
    <td>5</td> 
    <td><code>&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)</code></td> 
    <td>执行给定的任务，返回一个已经成功完成的结果(即，不抛出异常)，如果有则在给定的超时过去之前。</td> 
   </tr> 
   <tr> 
    <td>6</td> 
    <td><code>boolean isShutdown()</code></td> 
    <td>如果执行程序已关闭，则返回<code>true</code>。</td> 
   </tr> 
   <tr> 
    <td>7</td> 
    <td><code>boolean isTerminated()</code></td> 
    <td>如果所有任务在关闭后完成，则返回<code>true</code>。</td> 
   </tr> 
   <tr> 
    <td>8</td> 
    <td><code>void shutdown()</code></td> 
    <td>启动有序关闭，其中先前提交的任务将被执行，但不会接受任何新任务。</td> 
   </tr> 
   <tr> 
    <td>9</td> 
    <td><code>List&lt;Runnable&gt; shutdownNow()</code></td> 
    <td>尝试停止所有主动执行的任务，停止等待任务的处理，并返回正在等待执行的任务列表。</td> 
   </tr> 
   <tr> 
    <td>10</td> 
    <td><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code></td> 
    <td>提交值返回任务以执行，并返回代表任务待处理结果。</td> 
   </tr> 
   <tr> 
    <td>11</td> 
    <td><code>Future&lt;?&gt; submit(Runnable task)</code></td> 
    <td>提交一个可运行的任务执行，并返回一个表示该任务的<code>Future</code>。</td> 
   </tr> 
   <tr> 
    <td>12</td> 
    <td><code>&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)</code></td> 
    <td>提交一个可运行的任务执行，并返回一个表示该任务的<code>Future</code>。</td> 
   </tr> 
  </tbody> 
 </table> 
 <h2 id="h2-u5B9Eu4F8B"><a name="实例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例</h2>
 <p>以下<code>TestThread</code>程序显示了基于线程的环境中<code>ExecutorService</code>接口的使用。</p>   
 <pre><code class="lang-java">import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class TestThread {

   public static void main(final String[] arguments) throws InterruptedException {

      ExecutorService executor = Executors.newSingleThreadExecutor();

      try {
         executor.submit(new Task());
         System.out.println("Shutdown executor");
         executor.shutdown();
         executor.awaitTermination(5, TimeUnit.SECONDS);
      }
      catch (InterruptedException e) {
         System.err.println("tasks interrupted");
      }
      finally {
         if (!executor.isTerminated()) {
            System.err.println("cancel non-finished tasks");
         }
         executor.shutdownNow();
         System.out.println("shutdown finished");
      }
   }

   static class Task implements Runnable {
      public void run() {
         try {
            Long duration = (long) (Math.random() * 20);
            System.out.println("Running Task!");
            TimeUnit.SECONDS.sleep(duration);
         } 
         catch (InterruptedException e) {
            e.printStackTrace();
         }
      }
   }       
}
</code></pre> 
 <p>执行上面代码，得到以下结果 -</p> 
 <pre><code class="lang-shell">Shutdown executor
Running Task!
shutdown finished
cancel non-finished tasks
java.lang.InterruptedException: sleep interrupted
    at java.lang.Thread.sleep(Native Method)
    at java.lang.Thread.sleep(Thread.java:302)
    at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:328)
    at TestThread$Task.run(TestThread.java:39)
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:439)
    at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)
    at java.util.concurrent.FutureTask.run(FutureTask.java:138)
    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:895)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:918)
    at java.lang.Thread.run(Thread.java:662)
</code></pre>
 <br>      
</div></body></html>