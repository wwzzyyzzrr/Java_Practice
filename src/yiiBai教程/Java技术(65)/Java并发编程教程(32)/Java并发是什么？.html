<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java并发是什么？</h1><div style="width:100%;float:left;" class="article-content">   
 <p>Java是一种多线程编程语言，我们可以使用Java来开发多线程程序。 多线程程序包含两个或多个可同时运行的部分，每个部分可以同时处理不同的任务，从而能更好地利用可用资源，特别是当您的计算机有多个CPU时。多线程使您能够写入多个活动，可以在同一程序中同时进行操作处理。</p> 
 <p>根据定义，多任务是当多个进程共享，如CPU处理公共资源。 多线程将多任务的概念扩展到可以将单个应用程序中的特定操作细分为单个线程的应用程序。每个线程可以并行运行。 操作系统不仅在不同的应用程序之间划分处理时间，而且在应用程序中的每个线程之间划分处理时间。</p> 
 <p>多线程能够在同一程序同中，进行多个活动的方式进行写入。</p> 
 <h2 id="h2-u7EBFu7A0Bu7684u751Fu547Du5468u671F"><a name="线程的生命周期" class="reference-link"></a><span class="header-link octicon octicon-link"></span>线程的生命周期</h2>
 <p>线程在其生命周期中经历各个阶段。 例如，线程诞生，启动，运行，然后死亡。 下图显示了线程的完整生命周期。</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201704/1304/832110400_15852.jpg" alt=""></p> 
 <p>以下是线程生命周期的阶段 - </p> 
 <ul> 
  <li><p><strong>新线程(New)</strong> - 新线程在新的状态下开始其生命周期。直到程序启动线程为止，它保持在这种状态。它也被称为<strong>出生线程</strong>。</p> </li>
  <li><p><strong>可运行(Runnable)</strong> - 新诞生的线程启动后，该线程可以运行。状态的线程被认为正在执行其任务。</p> </li>
  <li><p><strong>等待(Waiting)</strong> - 有时，线程会转换到等待状态，而线程等待另一个线程执行任务。 只有当另一个线程发信号通知等待线程才能继续执行时，线程才转回到可运行状态。</p> </li>
  <li><p><strong>定时等待(Timed Waiting)</strong> - 可运行的线程可以在指定的时间间隔内进入定时等待状态。 当该时间间隔到期或发生等待的事件时，此状态的线程将转换回可运行状态。</p> </li>
  <li><p><strong>终止(Dead)</strong> - 可执行线程在完成任务或以其他方式终止时进入终止状态。</p> </li>
 </ul> 
 <h2 id="h2-u7EBFu7A0Bu4F18u5148u7EA7"><a name="线程优先级" class="reference-link"></a><span class="header-link octicon octicon-link"></span>线程优先级</h2>
 <p>每个Java线程都有一个优先级，可以帮助操作系统确定安排线程的顺序。Java线程优先级在<code>MIN_PRIORITY</code>(常数为<code>1</code>)和<code>MAX_PRIORITY</code>(常数为<code>10</code>)之间的范围内。 默认情况下，每个线程都被赋予优先级<code>NORM_PRIORITY</code>(常数为<code>5</code>)。</p> 
 <p>具有较高优先级的线程对于一个程序来说更重要，应该在低优先级线程之前分配处理器时间。 然而，线程优先级不能保证线程执行的顺序，并且依赖于平台。</p> 
 <h2 id="h2--runnable-"><a name="通过实现Runnable接口创建一个线程" class="reference-link"></a><span class="header-link octicon octicon-link"></span>通过实现Runnable接口创建一个线程</h2>
 <p>如果想让一个类作为线程执行，那么您可以通过实现<code>Runnable</code>接口来实现此目的。 您将需要遵循三个基本步骤 -</p> 
 <h3 id="h3--1-"><a name="第1步" class="reference-link"></a><span class="header-link octicon octicon-link"></span>第1步</h3>
 <p>在第一步中，您需要实现由<code>Runnable</code>接口提供的<code>run()</code>方法。 该方法为线程提供了一个入口点，您可将把完整的业务逻辑放在此方法中。 以下是<code>run()</code>方法的简单语法 -</p> 
 <pre><code class="lang-java">public void run( )
</code></pre> 
 <h3 id="h3--2-"><a name="第2步" class="reference-link"></a><span class="header-link octicon octicon-link"></span>第2步</h3>
 <p>在第二步中，您将使用以下构造函数实例化一个<code>Thread</code>对象 -</p> 
 <pre><code class="lang-java">Thread(Runnable threadObj, String threadName);
</code></pre> 
 <p>其中，<code>threadObj</code>是实现<code>Runnable</code>接口的类的实例，<code>threadName</code>是给予新线程的名称。</p> 
 <h3 id="h3--3-"><a name="第3步" class="reference-link"></a><span class="header-link octicon octicon-link"></span>第3步</h3>
 <p>当创建了一个线程对象，可以通过调用<code>start()</code>方法启动它，该方法执行对<code>run()</code>方法的调用。 以下是一个简单的语法<code>start()</code>方法 -</p> 
 <pre><code class="lang-java">void start();
</code></pre> 
 <h3 id="h3-u5B9Eu4F8B"><a name="实例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例</h3>
 <p>这是一个创建一个新线程并开始运行的示例 -</p> 
 <pre><code class="lang-java">class RunnableDemo implements Runnable {
   private Thread t;
   private String threadName;

   RunnableDemo( String name) {
      threadName = name;
      System.out.println("Creating " +  threadName );
   }

   public void run() {
      System.out.println("Running " +  threadName );
      try {
         for(int i = 4; i &gt; 0; i--) {
            System.out.println("Thread: " + threadName + ", " + i);
            // Let the thread sleep for a while.
            Thread.sleep(50);
         }
      }catch (InterruptedException e) {
         System.out.println("Thread " +  threadName + " interrupted.");
      }
      System.out.println("Thread " +  threadName + " exiting.");
   }

   public void start () {
      System.out.println("Starting " +  threadName );
      if (t == null) {
         t = new Thread (this, threadName);
         t.start ();
      }
   }
}

public class TestThread {

   public static void main(String args[]) {
      RunnableDemo R1 = new RunnableDemo( "Thread-1");
      R1.start();

      RunnableDemo R2 = new RunnableDemo( "Thread-2");
      R2.start();
   }   
}
</code></pre> 
 <p>这将产生以下结果 - </p>   
 <pre><code class="lang-shell">Creating Thread-1
Starting Thread-1
Creating Thread-2
Starting Thread-2
Running Thread-1
Thread: Thread-1, 4
Running Thread-2
Thread: Thread-2, 4
Thread: Thread-1, 3
Thread: Thread-2, 3
Thread: Thread-1, 2
Thread: Thread-2, 2
Thread: Thread-1, 1
Thread: Thread-2, 1
Thread Thread-1 exiting.
Thread Thread-2 exiting.
</code></pre> 
 <h2 id="h2--thread-"><a name="通过扩展Thread类创建一个线程" class="reference-link"></a><span class="header-link octicon octicon-link"></span>通过扩展Thread类创建一个线程</h2>
 <p>创建线程的第二种方法是创建一个新类，使用以下两个简单的步骤来扩展<code>Thread</code>类。 这种方法在处理使用<code>Thread</code>类中可用的方法创建的多个线程时提供了更多的灵活性。</p> 
 <h3 id="h3--1-"><a name="第1步" class="reference-link"></a><span class="header-link octicon octicon-link"></span>第1步</h3>
 <p>需要覆盖<code>Thread</code>类中的<code>run()</code>方法。 该方法为线程提供了一个入口点，您将把完整的业务逻辑放在此方法中。 以下是<code>run()</code>方法的简单语法 -</p> 
 <pre><code class="lang-java">public void run( )
</code></pre> 
 <h3 id="h3--2-"><a name="第2步" class="reference-link"></a><span class="header-link octicon octicon-link"></span>第2步</h3>
 <p>当创建了<code>Thread</code>对象，您可以通过调用<code>start()</code>方法启动它，该方法执行对<code>run()</code>方法的调用。以下是一个简单的语法<code>start()</code>方法 -</p> 
 <pre><code class="lang-java">void start( );
</code></pre> 
 <h3 id="h3-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h3>
 <p>这是上面示例程序中重写扩展<code>Thread</code>代码如下 -</p> 
 <pre><code class="lang-java">class ThreadDemo extends Thread {
   private Thread t;
   private String threadName;

   ThreadDemo( String name) {
      threadName = name;
      System.out.println("Creating " +  threadName );
   }

   public void run() {
      System.out.println("Running " +  threadName );
      try {
         for(int i = 4; i &gt; 0; i--) {
            System.out.println("Thread: " + threadName + ", " + i);
            // Let the thread sleep for a while.
            Thread.sleep(50);
         }
      }catch (InterruptedException e) {
         System.out.println("Thread " +  threadName + " interrupted.");
      }
      System.out.println("Thread " +  threadName + " exiting.");
   }

   public void start () {
      System.out.println("Starting " +  threadName );
      if (t == null) {
         t = new Thread (this, threadName);
         t.start ();
      }
   }
}

public class TestThread {

   public static void main(String args[]) {
      ThreadDemo T1 = new ThreadDemo( "Thread-1");
      T1.start();

      ThreadDemo T2 = new ThreadDemo( "Thread-2");
      T2.start();
   }   
}
</code></pre> 
 <p>运行上面代码，这将产生以下结果 -</p> 
 <pre><code class="lang-java">Creating Thread-1
Starting Thread-1
Creating Thread-2
Starting Thread-2
Running Thread-1
Thread: Thread-1, 4
Running Thread-2
Thread: Thread-2, 4
Thread: Thread-1, 3
Thread: Thread-2, 3
Thread: Thread-1, 2
Thread: Thread-2, 2
Thread: Thread-1, 1
Thread: Thread-2, 1
Thread Thread-1 exiting.
Thread Thread-2 exiting.
</code></pre>
 <br>      
</div></body></html>