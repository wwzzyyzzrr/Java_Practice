<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java并发ThreadLocalRandom类</h1><div style="width:100%;float:left;" class="article-content">   
 <p><code>java.util.concurrent.ThreadLocalRandom</code>是从<code>jdk 1.7</code>开始引入的实用程序类，当需要多个线程或<code>ForkJoinTasks</code>来生成随机数时很有用。 它提高了性能，并且比<code>Math.random()</code>方法占用更少的资源。</p> 
 <h2 id="h2-threadlocalrandom-"><a name="ThreadLocalRandom方法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>ThreadLocalRandom方法</h2>
 <p>以下是<code>ThreadLocalRandom</code>类中可用的重要方法的列表。</p> 
 <table> 
  <thead> 
   <tr> 
    <th>编号</th> 
    <th>方法</th> 
    <th>说明</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>1</td> 
    <td><code>public static ThreadLocalRandom current()</code></td> 
    <td>返回当前线程的<code>ThreadLocalRandom</code>。</td> 
   </tr> 
   <tr> 
    <td>2</td> 
    <td><code>protected int next(int bits)</code></td> 
    <td>生成下一个伪随机数。</td> 
   </tr> 
   <tr> 
    <td>3</td> 
    <td><code>public double nextDouble(double n)</code></td> 
    <td>返回伪随机，均匀分布在0(含)和指定值(独占)之间的<code>double</code>值。</td> 
   </tr> 
   <tr> 
    <td>4</td> 
    <td><code>public double nextDouble(double least, double bound)</code></td> 
    <td>返回在给定的<code>least</code>值(包括)和<code>bound</code>(不包括)之间的伪随机均匀分布的值。</td> 
   </tr> 
   <tr> 
    <td>5</td> 
    <td><code>public int nextInt(int least, int bound)</code></td> 
    <td>返回在给定的<code>least</code>值(包括)和<code>bound</code>(不包括)之间的伪随机均匀分布的整数值。</td> 
   </tr> 
   <tr> 
    <td>6</td> 
    <td><code>public long nextLong(long n)</code></td> 
    <td>返回伪随机均匀分布的值在0(含)和指定值(不包括)之间的长整数值。</td> 
   </tr> 
   <tr> 
    <td>7</td> 
    <td><code>public long nextLong(long least, long bound)</code></td> 
    <td>返回在给定的最小值(包括)和<code>bound</code>(不包括)之间的伪随机均匀分布的长整数值。</td> 
   </tr> 
   <tr> 
    <td>8</td> 
    <td><code>public void setSeed(long seed)</code></td> 
    <td>设置伪随机的种子值，抛出<code>UnsupportedOperationException</code>异常。</td> 
   </tr> 
  </tbody> 
 </table> 
 <h2 id="h2-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h2>
 <p>以下<code>TestThread</code>程序演示了<code>Lock</code>接口的一些方法。 这里我们使用<code>lock()</code>获取锁和<code>unlock()</code>来释放锁。</p>   
 <pre><code class="lang-java">import java.util.Random;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.ThreadLocalRandom;

public class TestThread {

   public static void main(final String[] arguments) {
      System.out.println("Random Integer: " + new Random().nextInt());  
      System.out.println("Seeded Random Integer: " + new Random(15).nextInt());  
      System.out.println("Thread Local Random Integer: " + ThreadLocalRandom.current().nextInt());  
      final ThreadLocalRandom random = ThreadLocalRandom.current();  
      random.setSeed(15);  //exception will come as seeding is not allowed in ThreadLocalRandom.
      System.out.println( "Seeded Thread Local Random Integer: " + random.nextInt());  
   }
}
</code></pre> 
 <p>执行上面代码，将产生以下结果 -</p> 
 <pre><code class="lang-java">Random Integer: 694316820
Seeded Random Integer: -1159716814
Exception in thread "main" Thread Local Random Integer: -1324834819
java.lang.UnsupportedOperationException
    at java.util.concurrent.ThreadLocalRandom.setSeed(ThreadLocalRandom.java:236)
    at com.yiibai.TestThread.main(TestThread.java:18)
</code></pre>
 <br>      
</div></body></html>