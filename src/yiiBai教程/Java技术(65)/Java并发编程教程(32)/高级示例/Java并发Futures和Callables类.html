<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java并发Futures和Callables类</h1><div style="width:100%;float:left;" class="article-content">   
 <p><code>java.util.concurrent.Callable</code>对象可以返回由线程完成的计算结果，而<code>runnable</code>接口只能运行线程。 <code>Callable</code>对象返回<code>Future</code>对象，该对象提供监视线程执行的任务进度的方法。 <code>Future</code>对象可用于检查<code>Callable</code>的状态，然后线程完成后从<code>Callable</code>中检索结果。 它还提供超时功能。</p> 
 <p><strong>语法</strong></p> 
 <pre><code class="lang-java">//submit the callable using ThreadExecutor
//and get the result as a Future object
Future result10 = executor.submit(new FactorialService(10));

//get the result using get method of the Future object
//get method waits till the thread execution and then return the result of the execution. 
Long factorial10 = result10.get();
</code></pre> 
 <h2 id="h2-u5B9Eu4F8B"><a name="实例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例</h2>
 <p>以下<code>TestThread</code>程序显示了基于线程的环境中<code>Futures</code>和<code>Callables</code>的使用。</p> 
 <pre><code class="lang-java">import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class TestThread {

   public static void main(final String[] arguments) throws InterruptedException, ExecutionException {
      ExecutorService executor = Executors.newSingleThreadExecutor();

      System.out.println("Factorial Service called for 10!");
      Future&lt;Long&gt; result10 = executor.submit(new FactorialService(10));

      System.out.println("Factorial Service called for 20!");
      Future&lt;Long&gt; result20 = executor.submit(new FactorialService(20));

      Long factorial10 = result10.get();
      System.out.println("10! = " + factorial10);

      Long factorial20 = result20.get();
      System.out.println("20! = " + factorial20);

      executor.shutdown();
   }  

   static class FactorialService implements Callable&lt;Long&gt;{
      private int number;
      public FactorialService(int number) {
         this.number = number;
      }

      @Override
      public Long call() throws Exception {
         return factorial();
      }

      private Long factorial() throws InterruptedException{
         long result = 1; 
         while (number != 0) { 
            result = number * result; 
            number--; 
            Thread.sleep(100); 
         } 
         return result;    
      }
   }
}
</code></pre> 
 <p>这将产生以下结果。</p>   
 <pre><code class="lang-java">Factorial Service called for 10!
Factorial Service called for 20!
10! = 3628800
20! = 2432902008176640000
</code></pre>
 <br>      
</div></body></html>