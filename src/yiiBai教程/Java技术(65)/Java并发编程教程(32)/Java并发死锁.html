<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java并发死锁</h1><div style="width:100%;float:left;" class="article-content">   
 <p>死锁描述了两个或多个线程等待彼此而被永久阻塞的情况。 当多个线程需要相同的锁定但以不同的顺序获取时，会发生死锁。 Java多线程程序可能会遇到死锁状况，因为<code>synchronized</code>关键字会导致执行线程在等待与指定对象相关联的锁定或监视时出现阻止情况。 看看下面一个例子。</p> 
 <h2 id="h2-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h2>
 <pre><code class="lang-java">public class TestThread {
   public static Object Lock1 = new Object();
   public static Object Lock2 = new Object();

   public static void main(String args[]) {
      ThreadDemo1 T1 = new ThreadDemo1();
      ThreadDemo2 T2 = new ThreadDemo2();
      T1.start();
      T2.start();
   }

   private static class ThreadDemo1 extends Thread {
      public void run() {
         synchronized (Lock1) {
            System.out.println("Thread 1: Holding lock 1...");

            try { Thread.sleep(10); }
            catch (InterruptedException e) {}
            System.out.println("Thread 1: Waiting for lock 2...");

            synchronized (Lock2) {
               System.out.println("Thread 1: Holding lock 1 &amp; 2...");
            }
         }
      }
   }
   private static class ThreadDemo2 extends Thread {
      public void run() {
         synchronized (Lock2) {
            System.out.println("Thread 2: Holding lock 2...");

            try { Thread.sleep(10); }
            catch (InterruptedException e) {}
            System.out.println("Thread 2: Waiting for lock 1...");

            synchronized (Lock1) {
               System.out.println("Thread 2: Holding lock 1 &amp; 2...");
            }
         }
      }
   } 
}
</code></pre> 
 <p>当您编译并执行上述程序时，会出现死锁情况，以下是程序生成的输出 -</p> 
 <pre><code class="lang-shell">Thread 1: Holding lock 1...
Thread 2: Holding lock 2...
Thread 1: Waiting for lock 2...
Thread 2: Waiting for lock 1...
</code></pre> 
 <p>上述程序将永久挂起，因为两个线程都不能继续进行，等待彼此释放锁定，所以您可以按<code>CTRL + C</code>退出程序。</p> 
 <h2 id="h2-u6B7Bu9501u89E3u51B3u65B9u6848u793Au4F8B"><a name="死锁解决方案示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>死锁解决方案示例</h2>
 <p>下面我们修改锁的顺序并运行相同的程序，看看这两个线程是否仍然相互等待 -</p> 
 <h3 id="h3-u5B9Eu4F8B"><a name="实例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例</h3>
 <pre><code class="lang-java">public class TestThread {
   public static Object Lock1 = new Object();
   public static Object Lock2 = new Object();

   public static void main(String args[]) {
      ThreadDemo1 T1 = new ThreadDemo1();
      ThreadDemo2 T2 = new ThreadDemo2();
      T1.start();
      T2.start();
   }

   private static class ThreadDemo1 extends Thread {
      public void run() {
         synchronized (Lock1) {
            System.out.println("Thread 1: Holding lock 1...");

            try {
               Thread.sleep(10);
            }catch (InterruptedException e) {}
            System.out.println("Thread 1: Waiting for lock 2...");

            synchronized (Lock2) {
               System.out.println("Thread 1: Holding lock 1 &amp; 2...");
            }
         }
      }
   }
   private static class ThreadDemo2 extends Thread {
      public void run() {
         synchronized (Lock1) {
            System.out.println("Thread 2: Holding lock 1...");

            try {
               Thread.sleep(10);
            }catch (InterruptedException e) {}
            System.out.println("Thread 2: Waiting for lock 2...");

            synchronized (Lock2) {
               System.out.println("Thread 2: Holding lock 1 &amp; 2...");
            }
         }
      }
   } 
}
</code></pre> 
 <p>所以只是改变锁的顺序防止程序进入死锁情况并完成以下结果 -</p>   
 <pre><code class="lang-shell">Thread 1: Holding lock 1...
Thread 1: Waiting for lock 2...
Thread 1: Holding lock 1 &amp; 2...
Thread 2: Holding lock 1...
Thread 2: Waiting for lock 2...
Thread 2: Holding lock 1 &amp; 2...
</code></pre> 
 <p>上面的例子只是为了更容易理解这个解决死锁的概念，然而，这是一个复杂的概念，应该深入了解它，然后才能再开发应用程序来处理死锁情况。</p>
 <br>      
</div></body></html>