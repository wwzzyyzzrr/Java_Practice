<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java并发AtomicLong接口</h1><div style="width:100%;float:left;" class="article-content">   
 <p><code>java.util.concurrent.atomic.AtomicLong</code>类提供了可以被原子地读取和写入的底层<code>long</code>值的操作，并且还包含高级原子操作。 <code>AtomicLong</code>支持基础<code>long</code>类型变量上的原子操作。 它具有获取和设置方法，如在<code>volatile</code>变量上的读取和写入。 也就是说，一个集合与同一变量上的任何后续<code>get</code>相关联。 原子<code>compareAndSet</code>方法也具有这些内存一致性功能。</p> 
 <h2 id="h2-atomiclong-"><a name="AtomicLong类中的方法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>AtomicLong类中的方法</h2>
 <p>以下是<code>AtomicLong</code>类中可用的重要方法的列表。</p> 
 <table> 
  <thead> 
   <tr> 
    <th>序号</th> 
    <th>方法</th> 
    <th>描述</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>1</td> 
    <td><code>public long addAndGet(long delta)</code></td> 
    <td>将给定值原子地添加到当前值。</td> 
   </tr> 
   <tr> 
    <td>2</td> 
    <td><code>public boolean compareAndSet(long expect, long update)</code></td> 
    <td>如果当前值与预期值相同，则将该值原子设置为给定的更新值。</td> 
   </tr> 
   <tr> 
    <td>3</td> 
    <td><code>public long decrementAndGet()</code></td> 
    <td>当前值原子减<code>1</code>。</td> 
   </tr> 
   <tr> 
    <td>4</td> 
    <td><code>public double doubleValue()</code></td> 
    <td>以<code>double</code>形式返回指定数字的值。</td> 
   </tr> 
   <tr> 
    <td>5</td> 
    <td><code>public float floatValue()</code></td> 
    <td>以<code>float</code>形式返回指定数字的值。</td> 
   </tr> 
   <tr> 
    <td>6</td> 
    <td><code>public long get()</code></td> 
    <td>获取当前值。</td> 
   </tr> 
   <tr> 
    <td>7</td> 
    <td><code>public long getAndAdd(long delta)</code></td> 
    <td>自动将给定值添加到当前值。</td> 
   </tr> 
   <tr> 
    <td>8</td> 
    <td><code>public long getAndDecrement()</code></td> 
    <td>当前值原子减<code>1</code>。</td> 
   </tr> 
   <tr> 
    <td>9</td> 
    <td><code>public long getAndIncrement()</code></td> 
    <td>当前值原子增加<code>1</code>。</td> 
   </tr> 
   <tr> 
    <td>10</td> 
    <td><code>public long getAndSet(long newValue)</code></td> 
    <td>将原子设置为给定值并返回旧值。</td> 
   </tr> 
   <tr> 
    <td>11</td> 
    <td><code>public long incrementAndGet()</code></td> 
    <td>原子上增加一个当前值。</td> 
   </tr> 
   <tr> 
    <td>12</td> 
    <td><code>public int intValue()</code></td> 
    <td>以<code>int</code>形式返回指定数字的值。</td> 
   </tr> 
   <tr> 
    <td>13</td> 
    <td><code>public void lazySet(long newValue)</code></td> 
    <td>最终设定为给定值。</td> 
   </tr> 
   <tr> 
    <td>14</td> 
    <td><code>public long longValue()</code></td> 
    <td>返回指定数字的值为<code>long</code>类型。</td> 
   </tr> 
   <tr> 
    <td>15</td> 
    <td><code>public void set(long newValue)</code></td> 
    <td>设置为给定值。</td> 
   </tr> 
   <tr> 
    <td>16</td> 
    <td><code>public String toString()</code></td> 
    <td>返回当前值的<code>String</code>表示形式。</td> 
   </tr> 
   <tr> 
    <td>17</td> 
    <td><code>public boolean weakCompareAndSet(long expect, long update)</code></td> 
    <td>如果当前值与预期值相同，则将该值原子设置为给定的更新值。</td> 
   </tr> 
  </tbody> 
 </table> 
 <h2 id="h2-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h2>
 <p>以下<code>TestThread</code>程序显示了在基于线程的环境中使用<code>AtomicLong</code>的计数器的安全实现。</p>   
 <pre><code class="lang-java">import java.util.concurrent.atomic.AtomicLong;

public class TestThread {

   static class Counter {
      private AtomicLong c = new AtomicLong(0);

      public void increment() {
         c.getAndIncrement();
      }

      public long value() {
         return c.get();
      }
   }
   public static void main(final String[] arguments) throws InterruptedException {
      final Counter counter = new Counter();
      //1000 threads
      for(int i = 0; i &lt; 1000 ; i++) {
         new Thread(new Runnable() {
            public void run() {
               counter.increment();
            }
         }).start();
      }  
      Thread.sleep(6000);

      System.out.println("Final number (should be 1000): " + counter.value());
   }  
}
</code></pre> 
 <p>这将产生以下结果 -</p> 
 <pre><code>Final number (should be 1000): 1000
</code></pre>
 <br>      
</div></body></html>