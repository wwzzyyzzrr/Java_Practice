<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java并发AtomicIntegerArray类</h1><div style="width:100%;float:left;" class="article-content">   
 <p><code>java.util.concurrent.atomic.AtomicIntegerArray</code>类提供了可以以原子方式读取和写入的底层<code>int</code>数组的操作，还包含高级原子操作。 <code>AtomicIntegerArray</code>支持对底层<code>int</code>数组变量的原子操作。 它具有获取和设置方法，如在变量上的读取和写入。 也就是说，一个集合与同一变量上的任何后续<code>get</code>相关联。 原子<code>compareAndSet</code>方法也具有这些内存一致性功能。</p> 
 <table> 
  <thead> 
   <tr> 
    <th>序号</th> 
    <th>方法</th> 
    <th>描述</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>1</td> 
    <td><code>public int addAndGet(int i, int delta)</code></td> 
    <td>原子地将给定的值添加到索引<code>i</code>的元素。</td> 
   </tr> 
   <tr> 
    <td>2</td> 
    <td><code>public boolean compareAndSet(int i, int expect, int update)</code></td> 
    <td>如果当前值<code>==</code>期望值，则将位置<code>i</code>处的元素原子设置为给定的更新值。</td> 
   </tr> 
   <tr> 
    <td>3</td> 
    <td><code>public int decrementAndGet(int i)</code></td> 
    <td>索引<code>i</code>处的元素原子并自减<code>1</code>。</td> 
   </tr> 
   <tr> 
    <td>4</td> 
    <td><code>public int get(int i)</code></td> 
    <td>获取位置<code>i</code>的当前值。</td> 
   </tr> 
   <tr> 
    <td>5</td> 
    <td><code>public int getAndAdd(int i, int delta)</code></td> 
    <td>原子地将给定的值添加到索引<code>i</code>的元素。</td> 
   </tr> 
   <tr> 
    <td>6</td> 
    <td><code>public int getAndDecrement(int i)</code></td> 
    <td>索引<code>i</code>处的元素原子并自减<code>1</code>，并返回旧值。</td> 
   </tr> 
   <tr> 
    <td>7</td> 
    <td><code>public int getAndIncrement(int i)</code></td> 
    <td>将位置<code>i</code>处的元素原子设置为给定值，并返回旧值。</td> 
   </tr> 
   <tr> 
    <td>8</td> 
    <td><code>public int getAndSet(int i, int newValue)</code></td> 
    <td>将位置<code>i</code>处的元素原子设置为给定值，并返回旧值。</td> 
   </tr> 
   <tr> 
    <td>9</td> 
    <td><code>public int incrementAndGet(int i)</code></td> 
    <td>在索引<code>i</code>处以原子方式自增元素。</td> 
   </tr> 
   <tr> 
    <td>10</td> 
    <td><code>public void lazySet(int i, int newValue)</code></td> 
    <td>最终将位置<code>i</code>处的元素设置为给定值。</td> 
   </tr> 
   <tr> 
    <td>11</td> 
    <td><code>public int length()</code></td> 
    <td>返回数组的长度。</td> 
   </tr> 
   <tr> 
    <td>12</td> 
    <td><code>public void set(int i, int newValue)</code></td> 
    <td>将位置<code>i</code>处的元素设置为给定值。</td> 
   </tr> 
   <tr> 
    <td>13</td> 
    <td><code>public String toString()</code></td> 
    <td>返回数组的当前值的<code>String</code>表示形式。</td> 
   </tr> 
   <tr> 
    <td>14</td> 
    <td><code>public boolean weakCompareAndSet(int i, int expect, int update)</code></td> 
    <td>如果当前值<code>==</code>期望值，则将位置<code>i</code>处的元素原子设置为给定的更新值。</td> 
   </tr> 
  </tbody> 
 </table> 
 <h2 id="h2-u5B9Eu4F8B"><a name="实例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例</h2>
 <p>以下<code>TestThread</code>程序显示了基于线程的环境中<code>AtomicIntegerArray</code>变量的使用。</p> 
 <pre><code class="lang-java">import java.util.concurrent.atomic.AtomicIntegerArray;

public class TestThread {

   private static AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(10);

   public static void main(final String[] arguments) throws InterruptedException {
      for (int i=0; i&lt;atomicIntegerArray.length(); i++) {
         atomicIntegerArray.set(i, 1);
      }

      Thread t1 = new Thread(new Increment());
      Thread t2 = new Thread(new Compare());
      t1.start();
      t2.start();

      t1.join();
      t2.join();

      System.out.println("Values: ");
      for (int i=0; i&lt;atomicIntegerArray.length(); i++) {
         System.out.print(atomicIntegerArray.get(i) + " ");
      }
   }  

   static class Increment implements Runnable {

      public void run() {
         for(int i=0; i&lt;atomicIntegerArray.length(); i++) {
            int add = atomicIntegerArray.incrementAndGet(i);
            System.out.println("Thread " + Thread.currentThread().getId() 
               + ", index " +i + ", value: "+ add);
         }
      }
   }

   static class Compare implements Runnable {

      public void run() {
         for(int i=0; i&lt;atomicIntegerArray.length(); i++) {
            boolean swapped = atomicIntegerArray.compareAndSet(i, 2, 3);
            if(swapped){
               System.out.println("Thread " + Thread.currentThread().getId()
                  + ", index " +i + ", value: 3");
            }
         }
      }
   }
}
</code></pre> 
 <p>这将产生以下结果 -</p>   
 <pre><code class="lang-shell">Thread 10, index 0, value: 2
Thread 10, index 1, value: 2
Thread 10, index 2, value: 2
Thread 11, index 0, value: 3
Thread 10, index 3, value: 2
Thread 11, index 1, value: 3
Thread 11, index 2, value: 3
Thread 10, index 4, value: 2
Thread 11, index 3, value: 3
Thread 10, index 5, value: 2
Thread 10, index 6, value: 2
Thread 11, index 4, value: 3
Thread 10, index 7, value: 2
Thread 11, index 5, value: 3
Thread 10, index 8, value: 2
Thread 11, index 6, value: 3
Thread 10, index 9, value: 2
Thread 11, index 7, value: 3
Thread 11, index 8, value: 3
Thread 11, index 9, value: 3
Values:
3 3 3 3 3 3 3 3 3 3
</code></pre>
 <br>      
</div></body></html>