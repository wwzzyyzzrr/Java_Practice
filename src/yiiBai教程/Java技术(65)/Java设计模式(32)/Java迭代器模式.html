<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java迭代器模式</h1><div style="width:100%;float:left;" class="article-content">   
 <p>迭代器模式是<code>Java</code>和<code>.Net</code>编程环境中非常常用的设计模式。此模式用于以顺序方式访问集合对象的元素，而不需要知道其底层表示。</p> 
 <p>迭代器模式属于行为模式类别。</p> 
 <h2 id="h2-u5B9Eu73B0u5B9Eu4F8B"><a name="实现实例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实现实例</h2>
 <p>在这个实例中，将创建一个<code>Iterator</code>接口，它陈述了一个导航方法和一个<code>Container</code>接口，以及返回迭代器。 实现<code>Container</code>接口的具体类将负责实现<code>Iterator</code>接口并使用它。</p> 
 <p><code>IteratorPatternDemo</code>这是一个演示类，将使用一个具体的实现类-<code>NamesRepository</code>，打印一个存储在<code>NamesRepository</code>集合中的<code>Names</code>。</p> 
 <p>迭代器模式的实现实例结构如下图中所示 -</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201612/08/359161239_40192.jpg" alt=""></p> 
 <h3 id="h3--1-"><a name="第1步" class="reference-link"></a><span class="header-link octicon octicon-link"></span>第1步</h3>
 <p>创建两个简单的接口，如下代码所示 -<br><em>Iterator.java</em></p> 
 <pre><code class="lang-java">public interface Iterator {
   public boolean hasNext();
   public Object next();
}
</code></pre> 
 <p><em>Container.java</em></p> 
 <pre><code class="lang-java">public interface Container {
   public Iterator getIterator();
}
</code></pre> 
 <h3 id="h3--2-"><a name="第2步" class="reference-link"></a><span class="header-link octicon octicon-link"></span>第2步</h3>
 <p>创建实现<code>Container</code>接口的具体类。 这个类有一个内部类<code>NameIterator</code>，它实现了<code>Iterator</code>接口。<br><em>NameRepository.java</em></p> 
 <pre><code class="lang-java">public class NameRepository implements Container {
   public String names[] = {"Robert" , "John" ,"Julie" , "Lora"};

   @Override
   public Iterator getIterator() {
      return new NameIterator();
   }

   private class NameIterator implements Iterator {

      int index;

      @Override
      public boolean hasNext() {

         if(index &lt; names.length){
            return true;
         }
         return false;
      }

      @Override
      public Object next() {

         if(this.hasNext()){
            return names[index++];
         }
         return null;
      }        
   }
}
</code></pre> 
 <h3 id="h3--3-"><a name="第3步" class="reference-link"></a><span class="header-link octicon octicon-link"></span>第3步</h3>
 <p>使用<code>NameRepository</code>获取迭代器并打印其名称。<br><em>IteratorPatternDemo.java</em></p>   
 <pre><code class="lang-java">public class IteratorPatternDemo {

   public static void main(String[] args) {
      NameRepository namesRepository = new NameRepository();

      for(Iterator iter = namesRepository.getIterator(); iter.hasNext();){
         String name = (String)iter.next();
         System.out.println("Name : " + name);
      }     
   }
}
</code></pre> 
 <h3 id="h3--4-"><a name="第4步" class="reference-link"></a><span class="header-link octicon octicon-link"></span>第4步</h3>
 <p>验证输出，执行上面的代码得到以下结果 -</p> 
 <pre><code class="lang-java">Name : Robert
Name : John
Name : Julie
Name : Lora
</code></pre>
 <br>      
</div></body></html>