<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java解释器模式</h1><div style="width:100%;float:left;" class="article-content">   
 <p>解释器模式提供了一种评估计算语言语法或表达式的方法。 这种类型的模式属于行为模式。 这种模式涉及实现一个表达式接口，它告诉解释一个指定的上下文。 此模式用于SQL解析，符号处理引擎等。</p> 
 <h2 id="h2-u5B9Eu73B0u793Au4F8B"><a name="实现示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实现示例</h2>
 <p>我们将创建一个接口<code>Expression</code>并且在具体的类实现这个<code>Expression</code>接口。 定义了一个<code>TerminalExpression</code>类，用作所讨论的上下文的主解释器。 其他的类 - <code>OrExpression</code>和<code>AndExpression</code>用于创建组合表达式。</p> 
 <p><code>InterpreterPatternDemo</code>这是一个演示类，将使用<code>Expression</code>类来创建规则并演示表达式的解析。</p> 
 <p>实现解释器模式的结构如下图所示 - </p> 
 <p><img src="http://www.yiibai.com/uploads/images/201612/07/603221204_82999.jpg" alt=""></p> 
 <h3 id="h3--1-"><a name="第1步" class="reference-link"></a><span class="header-link octicon octicon-link"></span>第1步</h3>
 <p>创建表达式接口 -<br><em>Expression.java</em></p> 
 <pre><code class="lang-java">public interface Expression {
   public boolean interpret(String context);
}
</code></pre> 
 <h3 id="h3--2-"><a name="第2步" class="reference-link"></a><span class="header-link octicon octicon-link"></span>第2步</h3>
 <p>创建实现上述接口的具体类。<br><em>TerminalExpression.java</em></p> 
 <pre><code class="lang-java">public class TerminalExpression implements Expression {

   private String data;

   public TerminalExpression(String data){
      this.data = data; 
   }

   @Override
   public boolean interpret(String context) {

      if(context.contains(data)){
         return true;
      }
      return false;
   }
}
</code></pre> 
 <p><em>OrExpression.java</em></p> 
 <pre><code class="lang-java">public class OrExpression implements Expression {

   private Expression expr1 = null;
   private Expression expr2 = null;

   public OrExpression(Expression expr1, Expression expr2) { 
      this.expr1 = expr1;
      this.expr2 = expr2;
   }

   @Override
   public boolean interpret(String context) {        
      return expr1.interpret(context) || expr2.interpret(context);
   }
}
</code></pre> 
 <p><em>AndExpression.java</em></p> 
 <pre><code class="lang-java">public class AndExpression implements Expression {

   private Expression expr1 = null;
   private Expression expr2 = null;

   public AndExpression(Expression expr1, Expression expr2) { 
      this.expr1 = expr1;
      this.expr2 = expr2;
   }

   @Override
   public boolean interpret(String context) {        
      return expr1.interpret(context) &amp;&amp; expr2.interpret(context);
   }
}
</code></pre> 
 <h3 id="h3--3-"><a name="第3步" class="reference-link"></a><span class="header-link octicon octicon-link"></span>第3步</h3>
 <p><code>reterPatternDemo</code>使用<code>Expression</code>类来创建规则，然后解析它们。</p> 
 <p><em>InterpreterPatternDemo.java</em></p>   
 <pre><code class="lang-java">public class InterpreterPatternDemo {

   //Rule: Robert and John are male
   public static Expression getMaleExpression(){
      Expression robert = new TerminalExpression("Robert");
      Expression john = new TerminalExpression("John");
      return new OrExpression(robert, john);        
   }

   //Rule: Julie is a married women
   public static Expression getMarriedWomanExpression(){
      Expression julie = new TerminalExpression("Julie");
      Expression married = new TerminalExpression("Married");
      return new AndExpression(julie, married);        
   }

   public static void main(String[] args) {
      Expression isMale = getMaleExpression();
      Expression isMarriedWoman = getMarriedWomanExpression();

      System.out.println("John is male? " + isMale.interpret("John"));
      System.out.println("Julie is a married women? " + isMarriedWoman.interpret("Married Julie"));
   }
}
</code></pre> 
 <h3 id="h3--4-"><a name="第4步" class="reference-link"></a><span class="header-link octicon octicon-link"></span>第4步</h3>
 <p>验证输出 - </p> 
 <pre><code class="lang-java">John is male? true
Julie is a married women? true
</code></pre>
 <br>      
</div></body></html>