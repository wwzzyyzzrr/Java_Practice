<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java桥接模式</h1><div style="width:100%;float:left;" class="article-content">   
 <p>桥接模式将定义与其实现分离。 它是一种结构模式。<br>桥接（<code>Bridge</code>）模式涉及充当桥接的接口。桥接使得具体类与接口实现者类无关。<br>这两种类型的类可以改变但不会影响对方。</p> 
 <p>当需要将抽象与其实现去耦合时使用桥接解耦（分离），使得两者可以独立地变化。这种类型的设计模式属于结构模式，因为此模式通过在它们之间提供桥接结构来将实现类和抽象类解耦（分离）。</p> 
 <p>这种模式涉及一个接口，作为一个桥梁，使得具体类的功能独立于接口实现类。两种类型的类可以在结构上改变而不彼此影响。</p> 
 <p>通过以下示例展示了桥接（<code>Bridge</code>）模式的使用，实现使用相同的抽象类方法但不同的网桥实现器类来绘制不同颜色的圆形。</p> 
 <h2 id="h2-u5B9Eu73B0u5B9Eu4F8B"><a name="实现实例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实现实例</h2>
 <p>假设有一个<code>DrawAPI</code>接口作为一个桥梁实现者，具体类<code>RedCircle</code>，<code>GreenCircle</code>实现这个<code>DrawAPI</code>接口。 <code>Shape</code>是一个抽象类，将使用<code>DrawAPI</code>的对象。 <code>BridgePatternDemo</code>这是一个演示类，将使用<code>Shape</code>类来绘制不同彩色的圆形。实现结果图如下 - </p> 
 <p><img src="http://www.yiibai.com/uploads/images/201612/08/436111242_75573.jpg" alt=""></p> 
 <h3 id="h3--1-"><a name="第1步" class="reference-link"></a><span class="header-link octicon octicon-link"></span>第1步</h3>
 <p>创建桥实现者接口。</p> 
 <p><em>DrawAPI.java</em></p> 
 <pre><code class="lang-java">public interface DrawAPI {
   public void drawCircle(int radius, int x, int y);
}
</code></pre> 
 <h3 id="h3--2-"><a name="第2步" class="reference-link"></a><span class="header-link octicon octicon-link"></span>第2步</h3>
 <p>创建实现<code>DrawAPI</code>接口的具体桥接实现者类。</p> 
 <p><em>RedCircle.java</em></p> 
 <pre><code class="lang-java">public class RedCircle implements DrawAPI {
   @Override
   public void drawCircle(int radius, int x, int y) {
      System.out.println("Drawing Circle[ color: red, radius: " + radius + ", x: " + x + ", " + y + "]");
   }
}
</code></pre> 
 <p><em>GreenCircle.java</em></p> 
 <pre><code class="lang-java">public class GreenCircle implements DrawAPI {
   @Override
   public void drawCircle(int radius, int x, int y) {
      System.out.println("Drawing Circle[ color: green, radius: " + radius + ", x: " + x + ", " + y + "]");
   }
}
</code></pre> 
 <h3 id="h3--3-"><a name="第3步" class="reference-link"></a><span class="header-link octicon octicon-link"></span>第3步</h3>
 <p>使用<code>DrawAPI</code>接口创建一个抽象类<code>Shape</code>。<br><em>Shape.java</em></p>   
 <pre><code class="lang-java">public abstract class Shape {
   protected DrawAPI drawAPI;

   protected Shape(DrawAPI drawAPI){
      this.drawAPI = drawAPI;
   }
   public abstract void draw();    
}
</code></pre> 
 <h3 id="h3--4-"><a name="第4步" class="reference-link"></a><span class="header-link octicon octicon-link"></span>第4步</h3>
 <p>创建实现<code>Shape</code>接口的具体类。</p> 
 <p><em>Circle.java</em></p> 
 <pre><code class="lang-java">public class Circle extends Shape {
   private int x, y, radius;

   public Circle(int x, int y, int radius, DrawAPI drawAPI) {
      super(drawAPI);
      this.x = x;  
      this.y = y;  
      this.radius = radius;
   }

   public void draw() {
      drawAPI.drawCircle(radius,x,y);
   }
}
</code></pre> 
 <h3 id="h3--5-"><a name="第5步" class="reference-link"></a><span class="header-link octicon octicon-link"></span>第5步</h3>
 <p>使用<code>Shape</code>和<code>DrawAPI</code>类来绘制不同的彩色圆形。</p> 
 <p><em>BridgePatternDemo.java</em></p> 
 <pre><code class="lang-java">public class BridgePatternDemo {
   public static void main(String[] args) {
      Shape redCircle = new Circle(100,100, 10, new RedCircle());
      Shape greenCircle = new Circle(100,100, 10, new GreenCircle());

      redCircle.draw();
      greenCircle.draw();
   }
}
</code></pre> 
 <h3 id="h3--6-"><a name="第6步" class="reference-link"></a><span class="header-link octicon octicon-link"></span>第6步</h3>
 <p>验证输出结果，执行上面的代码得到结果如下 - </p> 
 <pre><code class="lang-java">Drawing Circle[ color: red, radius: 10, x: 100, 100]
Drawing Circle[  color: green, radius: 10, x: 100, 100]
</code></pre>
 <br>      
</div></body></html>