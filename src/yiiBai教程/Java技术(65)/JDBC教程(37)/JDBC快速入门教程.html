<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">JDBC快速入门教程</h1><div style="width:100%;float:left;" class="article-content">   
 <h2 id="h2-jdbc-"><a name="JDBC是什么?" class="reference-link"></a><span class="header-link octicon octicon-link"></span>JDBC是什么?</h2>
 <p>JDBC API是一个Java API，可以访问任何类型表列数据，特别是存储在关系数据库中的数据。JDBC代表Java数据库连接。</p> 
 <p>JDBC库中所包含的API通常与数据库使用于：</p> 
 <ul> 
  <li>连接到数据库</li>
  <li>创建SQL或MySQL语句</li>
  <li>在数据库中执行SQL或MySQL查询</li>
  <li>查看和修改数据库中的数据记录</li>
 </ul> 
 <h2 id="h2--jdbc-"><a name="使用JDBC前提条件" class="reference-link"></a><span class="header-link octicon octicon-link"></span>使用JDBC前提条件</h2>
 <p>在学习JDBC之前，需要对以下两个编程知识有一定的了解：</p> 
 <ul> 
  <li>JAVA核心编程</li>
  <li>SQL语句或一种数据库系统(如：MySQL,Oracle数据库)</li>
 </ul> 
 <h2 id="h2-jdbc-"><a name="JDBC环境设置" class="reference-link"></a><span class="header-link octicon octicon-link"></span>JDBC环境设置</h2>
 <p>请确认您已完成以下设置：</p> 
 <ul> 
  <li>JAVA(JDK)安装</li>
  <li>数据库系统的安装(如：MySQL的安装)</li>
 </ul> 
 <p>除上述者外环境配置外，还需要建立一个数据库，为本程项目作为测试使用。假设创建一个数据库：<code>test</code>，在这个数据库上创建一张表：<code>employees</code>。</p> 
 <h2 id="h2--jdbc-"><a name="创建JDBC应用程序" class="reference-link"></a><span class="header-link octicon octicon-link"></span>创建JDBC应用程序</h2>
 <p>建立一个JDBC应用程序，本教程中以Java连接MySQL为一个示例，分六个步骤进行：</p> 
 <h3 id="h3-1-"><a name="1. 导入包" class="reference-link"></a><span class="header-link octicon octicon-link"></span>1. 导入包</h3>
 <p>在程序中包含数据库编程所需的JDBC类。大多数情况下，使用 <code>import java.sql.*</code> 就足够了，如下所示：</p> 
 <pre><code class="lang-java">//STEP 1. Import required packages
import java.sql.*;
</code></pre> 
 <h3 id="h3-2-jdbc-"><a name="2. 注册JDBC驱动程序" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2. 注册JDBC驱动程序</h3>
 <p>需要初始化驱动程序，这样就可以打开与数据库的通信。以下是代码片段实现这一目标：</p> 
 <pre><code class="lang-java">//STEP 2: Register JDBC driver
Class.forName("com.mysql.jdbc.Driver");
</code></pre> 
 <h3 id="h3-3-"><a name="3. 打开一个连接" class="reference-link"></a><span class="header-link octicon octicon-link"></span>3. 打开一个连接</h3>
 <p>使用<code>DriverManager.getConnection()</code>方法来创建一个<code>Connection</code>对象，它代表一个数据库的物理连接，如下所示：</p> 
 <pre><code class="lang-java">//STEP 3: Open a connection
//  Database credentials
static final String USER = "root";
static final String PASS = "pwd123456";
System.out.println("Connecting to database...");
conn = DriverManager.getConnection(DB_URL,USER,PASS);
</code></pre> 
 <h3 id="h3-4-"><a name="4. 执行一个查询" class="reference-link"></a><span class="header-link octicon octicon-link"></span>4. 执行一个查询</h3>
 <p>需要使用一个类型为<code>Statement</code>或<code>PreparedStatement</code>的对象，并提交一个SQL语句到数据库执行查询。如下：</p> 
 <pre><code class="lang-java">//STEP 4: Execute a query
System.out.println("Creating statement...");
stmt = conn.createStatement();
String sql;
sql = "SELECT id, first, last, age FROM Employees";
ResultSet rs = stmt.executeQuery(sql);
</code></pre> 
 <p>如果要执行一个SQL语句：<code>UPDATE</code>，<code>INSERT</code>或<code>DELETE</code>语句，那么需要下面的代码片段：</p> 
 <pre><code class="lang-java">//STEP 4: Execute a query
System.out.println("Creating statement...");
stmt = conn.createStatement();
String sql;
sql = "DELETE FROM Employees";
ResultSet rs = stmt.executeUpdate(sql);
</code></pre> 
 <h3 id="h3-5-"><a name="5. 从结果集中提取数据" class="reference-link"></a><span class="header-link octicon octicon-link"></span>5. 从结果集中提取数据</h3>
 <p>这一步中演示如何从数据库中获取查询结果的数据。可以使用适当的<code>ResultSet.getXXX()</code>方法来检索的数据结果如下：</p> 
 <pre><code class="lang-java">//STEP 5: Extract data from result set
while(rs.next()){
    //Retrieve by column name
    int id  = rs.getInt("id");
    int age = rs.getInt("age");
    String first = rs.getString("first");
    String last = rs.getString("last");

    //Display values
    System.out.print("ID: " + id);
    System.out.print(", Age: " + age);
    System.out.print(", First: " + first);
    System.out.println(", Last: " + last);
}
</code></pre> 
 <h3 id="h3-6-"><a name="6. 清理环境资源" class="reference-link"></a><span class="header-link octicon octicon-link"></span>6. 清理环境资源</h3>
 <p>在使用JDBC与数据交互操作数据库中的数据后，应该明确地关闭所有的数据库资源以减少资源的浪费，对依赖于JVM的垃圾收集如下：</p> 
 <pre><code class="lang-java">//STEP 6: Clean-up environment
rs.close();
stmt.close();
conn.close();
</code></pre> 
 <h2 id="h2--jdbc-"><a name="第一个JDBC 程序实例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>第一个JDBC 程序实例</h2>
 <p>基于上面的步骤，我们可以综合示例代码，您可以使用以下代码作为模板来编写JDBC代码。</p> 
 <blockquote> 
  <p>注意：此示例代码基于环境和数据库环境设置完成的前提下使用。</p> 
 </blockquote> 
 <pre><code class="lang-java">//STEP 1. Import required packages
import java.sql.*;

public class FirstExample {
   // JDBC driver name and database URL
   static final String JDBC_DRIVER = "com.mysql.jdbc.Driver";  
   static final String DB_URL = "jdbc:mysql://localhost/test";

   //  Database credentials -- 数据库名和密码自己修改
   static final String USER = "username";
   static final String PASS = "password";

   public static void main(String[] args) {
   Connection conn = null;
   Statement stmt = null;
   try{
      //STEP 2: Register JDBC driver
      Class.forName("com.mysql.jdbc.Driver");

      //STEP 3: Open a connection
      System.out.println("Connecting to database...");
      conn = DriverManager.getConnection(DB_URL,USER,PASS);

      //STEP 4: Execute a query
      System.out.println("Creating statement...");
      stmt = conn.createStatement();
      String sql;
      sql = "SELECT id, first, last, age FROM Employees";
      ResultSet rs = stmt.executeQuery(sql);

      //STEP 5: Extract data from result set
      while(rs.next()){
         //Retrieve by column name
         int id  = rs.getInt("id");
         int age = rs.getInt("age");
         String first = rs.getString("first");
         String last = rs.getString("last");

         //Display values
         System.out.print("ID: " + id);
         System.out.print(", Age: " + age);
         System.out.print(", First: " + first);
         System.out.println(", Last: " + last);
      }
      //STEP 6: Clean-up environment
      rs.close();
      stmt.close();
      conn.close();
   }catch(SQLException se){
      //Handle errors for JDBC
      se.printStackTrace();
   }catch(Exception e){
      //Handle errors for Class.forName
      e.printStackTrace();
   }finally{
      //finally block used to close resources
      try{
         if(stmt!=null)
            stmt.close();
      }catch(SQLException se2){
      }// nothing we can do
      try{
         if(conn!=null)
            conn.close();
      }catch(SQLException se){
         se.printStackTrace();
      }//end finally try
   }//end try
   System.out.println("Goodbye!");
}//end main
}//end FirstExample - by www.yiibai.com
</code></pre> 
 <p>如果使用IDE，可将上面代码可放在IDE(如：Eclipse/Netbeans)中加入<code>mysql-connector-java-5.1.37-bin.jar</code> 库并执行。</p> 
 <p>如果手动编译，需要把上面代码存放到 <code>F:\worksp\jdbc\FirstExample.java</code> 文件中，并创建一个目录：<code>F:\worksp\jdbc\libs</code>，把下载的<code>mysql-connector-java-5.1.40-bin.jar</code>库(下载地址：<a target="_blank" href="http://downloads.mysql.com/archives/c-j/)放入到">http://downloads.mysql.com/archives/c-j/)放入到</a> <code>F:\worksp\jdbc\libs</code> 目录中。</p> 
 <p>使用命令行编译Java程序并加载指定目录中的Jar包(mysql-connector-java-5.1.40-bin.jar)，现在编译上面的例子如下：</p> 
 <pre><code class="lang-shell">F:\worksp\jdbc&gt; javac -Djava.ext.dirs=F:\worksp\jdbc\libs FirstExample.java
F:\worksp\jdbc&gt;
</code></pre> 
 <p>当运行<code>FirstExample</code>后，它会产生类似以下结果：</p> 
 <pre><code class="lang-java">F:\worksp\jdbc&gt; java -Djava.ext.dirs=F:\worksp\jdbc\libs FirstExample
Connecting to database...
Creating statement...
ID: 100, Age: 18, First: Zara, Last: Ali
ID: 101, Age: 25, First: Mahnaz, Last: Fatma
ID: 102, Age: 30, First: Zaid, Last: Khan
ID: 103, Age: 28, First: Sumit, Last: Mittal
F:\worksp\jdbc&gt;
</code></pre> 
 <h3 id="h3-sqlexception-"><a name="SQLException中的方法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>SQLException中的方法</h3>
 <p>一个<code>SQLException</code>类既可以发生在驱动程序和数据库中。当这样的异常时，SQLException类型的对象将被传递到<code>catch</code>子句。<br>通过<code>SQLException</code>对象有以下几种方法可用于获取更多的关于异常的信息：</p> 
 <table> 
  <thead> 
   <tr> 
    <th>方法</th> 
    <th>描述</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>getErrorCode()</td> 
    <td>获取与异常关联的错误代码</td> 
   </tr> 
   <tr> 
    <td>getMessage()</td> 
    <td>获取JDBC驱动程序的错误处理错误消息，或获取Oracle错误代码和数据库的错误消息。</td> 
   </tr> 
   <tr> 
    <td>getSQLState()</td> 
    <td>获取<code>XOPEN SQLSTATE</code>字符串。对于JDBC驱动程序错误，从该方法返回的可能是无用的信息。对于一个数据库错误，返回一个五位的<code>XOPEN SQLSTATE</code>代码。这种方法可以返回<code>null</code>。</td> 
   </tr> 
   <tr> 
    <td>getNextException()</td> 
    <td>获取异常链中的下一个<code>Exception</code>对象</td> 
   </tr> 
   <tr> 
    <td>printStackTrace()</td> 
    <td>打印当前的异常，或也可以抛出，并回溯到标准错误流</td> 
   </tr> 
   <tr> 
    <td>printStackTrace(PrintStream s)</td> 
    <td>打印此抛出对象及其回溯到指定的打印流</td> 
   </tr> 
   <tr> 
    <td>printStackTrace(PrintWriter w)</td> 
    <td>打印此抛出对象及其回溯到指定打印写入流</td> 
   </tr> 
  </tbody> 
 </table> 
 <p>通过利用从<code>Exception</code>对象提供的信息，可以捕获一个异常，并适当地继续运行程序。这是一个<code>try</code>块中的一般形式：</p> 
 <pre><code class="lang-java">try {
   // Your risky code goes between these curly braces!!!
}
catch(Exception ex) {
   // Your exception handling code goes between these 
   // curly braces, similar to the exception clause 
   // in a PL/SQL block.
}
finally {
   // Your must-always-be-executed code goes between these 
   // curly braces. Like closing database connection.
}
</code></pre> 
 <h2 id="h2-jdbc-"><a name="JDBC数据类型" class="reference-link"></a><span class="header-link octicon octicon-link"></span>JDBC数据类型</h2>
 <p>下表列出了默认的JDBC数据类型与Java数据类型转换，当使用<code>PreparedStatement</code>或<code>CallableStatement</code>对象时可调用<code>setXXX()</code>方法或<code>ResultSet.updateXXX()</code>方法。</p> 
 <table> 
  <thead> 
   <tr> 
    <th>SQL</th> 
    <th>JDBC/Java</th> 
    <th>setXXX</th> 
    <th>updateXXX</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>VARCHAR</td> 
    <td>java.lang.String</td> 
    <td>setString</td> 
    <td>updateString</td> 
   </tr> 
   <tr> 
    <td>CHAR</td> 
    <td>java.lang.String</td> 
    <td>setString</td> 
    <td>updateString</td> 
   </tr> 
   <tr> 
    <td>LONGVARCHAR</td> 
    <td>java.lang.String</td> 
    <td>setString</td> 
    <td>updateString</td> 
   </tr> 
   <tr> 
    <td>BIT</td> 
    <td>boolean</td> 
    <td>setBoolean</td> 
    <td>updateBoolean</td> 
   </tr> 
   <tr> 
    <td>NUMERIC</td> 
    <td>java.math.BigDecimal</td> 
    <td>setBigDecimal</td> 
    <td>updateBigDecimal</td> 
   </tr> 
   <tr> 
    <td>TINYINT</td> 
    <td>byte</td> 
    <td>setByte</td> 
    <td>updateByte</td> 
   </tr> 
   <tr> 
    <td>SMALLINT</td> 
    <td>short</td> 
    <td>setShort</td> 
    <td>updateShort</td> 
   </tr> 
   <tr> 
    <td>INTEGER</td> 
    <td>int</td> 
    <td>setInt</td> 
    <td>updateInt</td> 
   </tr> 
   <tr> 
    <td>BIGINT</td> 
    <td>long</td> 
    <td>setLong</td> 
    <td>updateLong</td> 
   </tr> 
   <tr> 
    <td>REAL</td> 
    <td>float</td> 
    <td>setFloat</td> 
    <td>updateFloat</td> 
   </tr> 
   <tr> 
    <td>FLOAT</td> 
    <td>float</td> 
    <td>setFloat</td> 
    <td>updateFloat</td> 
   </tr> 
   <tr> 
    <td>DOUBLE</td> 
    <td>double</td> 
    <td>setDouble</td> 
    <td>updateDouble</td> 
   </tr> 
   <tr> 
    <td>VARBINARY</td> 
    <td>byte[ ]</td> 
    <td>setBytes</td> 
    <td>updateBytes</td> 
   </tr> 
   <tr> 
    <td>BINARY</td> 
    <td>byte[ ]</td> 
    <td>setBytes</td> 
    <td>updateBytes</td> 
   </tr> 
   <tr> 
    <td>DATE</td> 
    <td>java.sql.Date</td> 
    <td>setDate</td> 
    <td>updateDate</td> 
   </tr> 
   <tr> 
    <td>TIME</td> 
    <td>java.sql.Time</td> 
    <td>setTime</td> 
    <td>updateTime</td> 
   </tr> 
   <tr> 
    <td>TIMESTAMP</td> 
    <td>java.sql.Timestamp</td> 
    <td>setTimestamp</td> 
    <td>updateTimestamp</td> 
   </tr> 
   <tr> 
    <td>CLOB</td> 
    <td>java.sql.Clob</td> 
    <td>setClob</td> 
    <td>updateClob</td> 
   </tr> 
   <tr> 
    <td>BLOB</td> 
    <td>java.sql.Blob</td> 
    <td>setBlob</td> 
    <td>updateBlob</td> 
   </tr> 
   <tr> 
    <td>ARRAY</td> 
    <td>java.sql.Array</td> 
    <td>setARRAY</td> 
    <td>updateARRAY</td> 
   </tr> 
   <tr> 
    <td>REF</td> 
    <td>java.sql.Ref</td> 
    <td>SetRef</td> 
    <td>updateRef</td> 
   </tr> 
   <tr> 
    <td>STRUCT</td> 
    <td>java.sql.Struct</td> 
    <td>SetStruct</td> 
    <td>updateStruct</td> 
   </tr> 
  </tbody> 
 </table> 
 <p>在<strong>JDBC3.0</strong>中增强支持<code>BLOB</code>，<code>CLOB</code>，<code>ARRAY</code>，<code>REF</code>等数据类型。<code>ResultSet</code>对象可调用<code>UPDATEBLOB()</code>，<code>updateCLOB()</code>，<code>updateArray()</code>和<code>updateRef()</code>方法，使您可以在数据库服务器上直接操作相应的数据。</p> 
 <p>对于<code>setXXX()</code>和<code>updateXXX()</code>方法，可以转换成特定的Java类型到特定的JDBC数据类型。而使用<code>setObject()</code>和<code>updateObject()</code>方法，几乎所有的Java类型映射到JDBC数据类型。</p> 
 <p><code>ResultSet</code>对象提供相应的<code>getXXX()</code>方法为每个数据类型来检索列值。每一种类型方法，可以使用与列名或由列的序号位置来获取列的数据。</p> 
 <table> 
  <thead> 
   <tr> 
    <th>SQL</th> 
    <th>JDBC/Java</th> 
    <th>setXXX</th> 
    <th>getXXX</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>VARCHAR</td> 
    <td>java.lang.String</td> 
    <td>setString</td> 
    <td>getString</td> 
   </tr> 
   <tr> 
    <td>CHAR</td> 
    <td>java.lang.String</td> 
    <td>setString</td> 
    <td>getString</td> 
   </tr> 
   <tr> 
    <td>LONGVARCHAR</td> 
    <td>java.lang.String</td> 
    <td>setString</td> 
    <td>getString</td> 
   </tr> 
   <tr> 
    <td>BIT</td> 
    <td>boolean</td> 
    <td>setBoolean</td> 
    <td>getBoolean</td> 
   </tr> 
   <tr> 
    <td>NUMERIC</td> 
    <td>java.math.BigDecimal</td> 
    <td>setBigDecimal</td> 
    <td>getBigDecimal</td> 
   </tr> 
   <tr> 
    <td>TINYINT</td> 
    <td>byte</td> 
    <td>setByte</td> 
    <td>getByte</td> 
   </tr> 
   <tr> 
    <td>SMALLINT</td> 
    <td>short</td> 
    <td>setShort</td> 
    <td>getShort</td> 
   </tr> 
   <tr> 
    <td>INTEGER</td> 
    <td>int</td> 
    <td>setInt</td> 
    <td>getInt</td> 
   </tr> 
   <tr> 
    <td>BIGINT</td> 
    <td>long</td> 
    <td>setLong</td> 
    <td>getLong</td> 
   </tr> 
   <tr> 
    <td>REAL</td> 
    <td>float</td> 
    <td>setFloat</td> 
    <td>getFloat</td> 
   </tr> 
   <tr> 
    <td>FLOAT</td> 
    <td>float</td> 
    <td>setFloat</td> 
    <td>getFloat</td> 
   </tr> 
   <tr> 
    <td>DOUBLE</td> 
    <td>double</td> 
    <td>setDouble</td> 
    <td>getDouble</td> 
   </tr> 
   <tr> 
    <td>VARBINARY</td> 
    <td>byte[ ]</td> 
    <td>setBytes</td> 
    <td>getBytes</td> 
   </tr> 
   <tr> 
    <td>BINARY</td> 
    <td>byte[ ]</td> 
    <td>setBytes</td> 
    <td>getBytes</td> 
   </tr> 
   <tr> 
    <td>DATE</td> 
    <td>java.sql.Date</td> 
    <td>setDate</td> 
    <td>getDate</td> 
   </tr> 
   <tr> 
    <td>TIME</td> 
    <td>java.sql.Time</td> 
    <td>setTime</td> 
    <td>getTime</td> 
   </tr> 
   <tr> 
    <td>TIMESTAMP</td> 
    <td>java.sql.Timestamp</td> 
    <td>setTimestamp</td> 
    <td>getTimestamp</td> 
   </tr> 
   <tr> 
    <td>CLOB</td> 
    <td>java.sql.Clob</td> 
    <td>setClob</td> 
    <td>getClob</td> 
   </tr> 
   <tr> 
    <td>BLOB</td> 
    <td>java.sql.Blob</td> 
    <td>setBlob</td> 
    <td>getBlob</td> 
   </tr> 
   <tr> 
    <td>ARRAY</td> 
    <td>java.sql.Array</td> 
    <td>setARRAY</td> 
    <td>getARRAY</td> 
   </tr> 
   <tr> 
    <td>REF</td> 
    <td>java.sql.Ref</td> 
    <td>SetRef</td> 
    <td>getRef</td> 
   </tr> 
   <tr> 
    <td>STRUCT</td> 
    <td>java.sql.Struct</td> 
    <td>SetStruct</td> 
    <td>getStruct</td> 
   </tr> 
  </tbody> 
 </table> 
 <h2 id="h2-jdbc-"><a name="JDBC批量处理" class="reference-link"></a><span class="header-link octicon octicon-link"></span>JDBC批量处理</h2>
 <p>批处理允许执行一个批处理组相关的SQL语句，并将其一次提交到数据库中执行。当几个SQL语句一次发送到数据库中时，可以减少通信开销，从而提高性能。</p> 
 <ul> 
  <li>JDBC驱动程序不支持此功能。您应该使用<code>DatabaseMetaData.supportsBatchUpdates()</code>方法来确定目标数据库支持批量更新处理。如果JDBC驱动程序支持此功能，则该方法返回<code>true</code>。</li>
  <li><p><code>addBatch()</code>方法是<code>PreparedStatement</code>和<code>CallableStatementis</code>类中用于添加单个语句的批处理的声明。 <code>executeBatch()</code>将开始将所有语句组合到一起并执行。</p> </li>
  <li><p><code>executeBatch()</code>将返回一个整数数组，每个数组元素的表示为相应的更新语句的更新计数。</p> </li>
  <li><p>添加语句进行批处理时，可以使用<code>clearBatch()</code>方法删除它们。此方法将删除<code>addBatch()</code>方法添加的所有语句。但是不能有选择性地选择某个语句来删除。</p> </li>
 </ul> 
 <h2 id="h2-jdbc-"><a name="JDBC数据流" class="reference-link"></a><span class="header-link octicon octicon-link"></span>JDBC数据流</h2>
 <p><code>PreparedStatement</code>对象有能力使用提供参数数据的输入和输出流。这使您可以将整个文件到数据库中，可容纳较大的值，如<code>CLOB</code>和<code>BLOB</code>数据类型的列。</p> 
 <p>有下列方法可用于流数据：</p> 
 <ol> 
  <li><code>setAsciiStream()</code>: 此方法用于提供大的<code>ASCII</code>数据值。</li>
  <li><code>setCharacterStream()</code>: 此方法用于提供大的<code>UNICODE</code>数据值。</li>
  <li><code>setBinaryStream()</code>: 使用此方法用于提供大的二进制数据值。</li>
 </ol> 
 <p><code>setXXXStream()</code>方法需要一个额外的参数，文件大小(除了参数占位符)。此参数通知应发送多少数据到数据库来使用流的驱动程序。</p> 
 <p>对于一个详细的关于所有这些概念，这里只是一个简单的入门教程，还需要读者去学习完整的教程，有关JDBC的后续教程，可以从左侧文章中了解和学习。</p>
 <br>      
</div></body></html>