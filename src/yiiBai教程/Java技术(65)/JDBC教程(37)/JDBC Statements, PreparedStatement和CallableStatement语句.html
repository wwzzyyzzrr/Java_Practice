<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">JDBC Statements, PreparedStatement和CallableStatement语句</h1><div style="width:100%;float:left;" class="article-content">   
 <p>当获得了与数据库的连接后，就可以与数据库进行交互了。 JDBC <code>Statement</code>，<code>CallableStatement</code>和<code>PreparedStatement</code>接口定义了可用于发送SQL或<em>PL/SQL</em>命令，并从数据库接收数据的方法和属性。</p> 
 <p>它们还定义了有助于在Java和SQL数据类型的数据类型差异转换的方法。<br>下表提供了每个接口定义，以及使用这些接口的目的的总结。</p> 
 <table> 
  <thead> 
   <tr> 
    <th>接口</th> 
    <th>推荐使用</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td><code>Statement</code></td> 
    <td>用于对数据库进行通用访问，在运行时使用静态SQL语句时很有用。 <code>Statement</code>接口不能接受参数。</td> 
   </tr> 
   <tr> 
    <td><code>PreparedStatement</code></td> 
    <td>当计划要多次使用SQL语句时使用。<code>PreparedStatement</code>接口在运行时接受输入参数。</td> 
   </tr> 
   <tr> 
    <td><code>CallableStatement</code></td> 
    <td>当想要访问数据库存储过程时使用。<code>CallableStatement</code>接口也可以接受运行时输入参数。</td> 
   </tr> 
  </tbody> 
 </table> 
 <h2 id="h2-1-statement-"><a name="1. Statement对象" class="reference-link"></a><span class="header-link octicon octicon-link"></span>1. Statement对象</h2>
 <h3 id="h3-1-1-statement-"><a name="1.1. 创建Statement对象" class="reference-link"></a><span class="header-link octicon octicon-link"></span>1.1. 创建Statement对象</h3>
 <p>在使用<code>Statement</code>对象执行SQL语句之前，需要使用<code>Connection</code>对象的<code>createStatement()</code>方法创建一个<code>Statement</code>对象，如以下示例所示：</p> 
 <pre><code class="lang-java">Statement stmt = null;
try {
   stmt = conn.createStatement( );
   . . .
}
catch (SQLException e) {
   . . .
}
finally {
   . . .
}
</code></pre> 
 <p>在创建<code>Statement</code>对象后，可以使用它来执行一个SQL语句，它有三个执行方法可以执行。它们分别是 - </p> 
 <ul> 
  <li><code>boolean execute (String SQL)</code> ： 如果可以检索到<code>ResultSet</code>对象，则返回一个布尔值<code>true</code>; 否则返回<code>false</code>。使用此方法执行SQL<code>DDL</code>语句或需要使用真正的动态SQL，可使用于执行创建数据库，创建表的SQL语句等等。</li>
  <li><code>int executeUpdate (String SQL):</code> 返回受SQL语句执行影响的行数。使用此方法执行预期会影响多行的SQL语句，例如:<code>INSERT</code>，<code>UPDATE</code>或<code>DELETE</code>语句。</li>
  <li><code>ResultSet executeQuery(String SQL)：</code>返回一个<code>ResultSet</code>对象。 当您希望获得结果集时，请使用此方法，就像使用<code>SELECT</code>语句一样。</li>
 </ul> 
 <h3 id="h3-1-2-statement-"><a name="1.2. 关闭Statement对象" class="reference-link"></a><span class="header-link octicon octicon-link"></span>1.2. 关闭Statement对象</h3>
 <p>就像关闭一个<code>Connection</code>对象一样，以保存数据库资源一样，由于同样的原因，还应该关闭<code>Statement</code>对象。</p> 
 <p>一个简单的调用<code>close()</code>方法将执行该作业(工作)。 如果先关闭<code>Connection</code>对象，它也会关闭<code>Statement</code>对象。 但是，应该始终显式关闭<code>Statement</code>对象，以确保正确的清理顺序。</p> 
 <pre><code class="lang-java">Statement stmt = null;
try {
   stmt = conn.createStatement( );
   . . .
}
catch (SQLException e) {
   . . .
}
finally {
   stmt.close();
}
</code></pre> 
 <p>为了更好的理解，建议学习<a target="_blank" href="http://www.yiibai.com/jdbc/statement-object-example.html" title="Statment示例教程">Statment示例教程</a> 。 </p> 
 <h2 id="h2-2-preparedstatement-"><a name="2. PreparedStatement对象" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2. PreparedStatement对象</h2>
 <p><code>PreparedStatement</code>接口扩展了<code>Statement</code>接口，它添加了比<code>Statement</code>对象更好一些优点的功能。</p> 
 <p>此语句可以动态地提供/接受参数。</p> 
 <h3 id="h3-2-1-preparedstatement-"><a name="2.1 创建PreparedStatement对象" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2.1 创建PreparedStatement对象</h3>
 <pre><code class="lang-java">PreparedStatement pstmt = null;
try {
   String SQL = "Update Employees SET age = ? WHERE id = ?";
   pstmt = conn.prepareStatement(SQL);
   . . .
}
catch (SQLException e) {
   . . .
}
finally {
   . . .
}
</code></pre> 
 <p>JDBC中的所有参数都由 <code>?</code> 符号作为占位符，这被称为参数标记。 在执行SQL语句之前，必须为每个参数(占位符)提供值。</p> 
 <p><code>setXXX()</code>方法将值绑定到参数，其中<code>XXX</code>表示要绑定到输入参数的值的Java数据类型。 如果忘记提供绑定值，则将会抛出一个<code>SQLException</code>。</p> 
 <p>每个参数标记是它其顺序位置引用。第一个标记表示位置<code>1</code>，下一个位置<code>2</code>等等。 该方法与Java数组索引不同(它不从<code>0</code>开始)。</p> 
 <p>所有<code>Statement</code>对象与数据库交互的方法(a)<code>execute()</code>，(b)<code>executeQuery()</code>和(c)<code>executeUpdate()</code>也可以用于<code>PreparedStatement</code>对象。 但是，这些方法被修改为可以使用输入参数的SQL语句。</p> 
 <h3 id="h3-2-2-preparedstatement-"><a name="2.2. 关闭PreparedStatement对象" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2.2. 关闭PreparedStatement对象</h3>
 <p>就像关闭<code>Statement</code>对象一样，由于同样的原因(节省数据库系统资源)，也应该关闭<code>PreparedStatement</code>对象。</p> 
 <p>简单的调用<code>close()</code>方法将执行关闭。 如果先关闭<code>Connection</code>对象，它也会关闭<code>PreparedStatement</code>对象。 但是，应该始终显式关闭<code>PreparedStatement</code>对象，以确保以正确顺序清理资源。</p> 
 <pre><code class="lang-java">PreparedStatement pstmt = null;
try {
   String SQL = "Update Employees SET age = ? WHERE id = ?";
   pstmt = conn.prepareStatement(SQL);
   . . .
}
catch (SQLException e) {
   . . .
}
finally {
   pstmt.close();
}
</code></pre> 
 <p>为了更好的理解，建议学习<a target="_blank" href="http://www.yiibai.com/jdbc/preparestatement-object-example.html" title="PreparedStatement示例代码">PreparedStatement示例代码</a> 。</p> 
 <h2 id="h2-3-callablestatement-"><a name="3. CallableStatement对象" class="reference-link"></a><span class="header-link octicon octicon-link"></span>3. CallableStatement对象</h2>
 <p>类似<code>Connection</code>对象创建<code>Statement</code>和<code>PreparedStatement</code>对象一样，它还可以使用同样的方式创建<code>CallableStatement</code>对象，该对象将用于执行对数据库存储过程的调用。</p> 
 <h3 id="h3-3-1-callablestatement-"><a name="3.1. 创建CallableStatement对象" class="reference-link"></a><span class="header-link octicon octicon-link"></span>3.1. 创建CallableStatement对象</h3>
 <p>假设需要执行以下Oracle存储过程 -</p>   
 <pre><code class="lang-sql">CREATE OR REPLACE PROCEDURE getEmpName 
   (EMP_ID IN NUMBER, EMP_FIRST OUT VARCHAR) AS
BEGIN
   SELECT first INTO EMP_FIRST
   FROM Employees
   WHERE ID = EMP_ID;
END;
</code></pre> 
 <blockquote> 
  <p>注意：上面的存储过程是针对Oracle编写的，但是如果您使用MySQL数据库，可使用以下方式来编写MySQL相同的存储过程，如下在EMP数据库中创建它 -</p> 
 </blockquote> 
 <pre><code class="lang-sql">DELIMITER $$

DROP PROCEDURE IF EXISTS `EMP`.`getEmpName` $$
CREATE PROCEDURE `EMP`.`getEmpName` 
   (IN EMP_ID INT, OUT EMP_FIRST VARCHAR(255))
BEGIN
   SELECT first INTO EMP_FIRST
   FROM Employees
   WHERE ID = EMP_ID;
END $$

DELIMITER ;
</code></pre> 
 <p>存在三种类型的参数：<code>IN</code>，<code>OUT</code>和<code>INOUT</code>。 <code>PreparedStatement</code>对象只使用<code>IN</code>参数。<code>CallableStatement</code>对象可以使用上面三个参数类型。</p> 
 <p>以下是上面三种类型参数的定义 -</p> 
 <table> 
  <thead> 
   <tr> 
    <th>参数</th> 
    <th>描述</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>IN</td> 
    <td>创建SQL语句时其参数值是未知的。 使用<code>setXXX()</code>方法将值绑定到<code>IN</code>参数。</td> 
   </tr> 
   <tr> 
    <td>OUT</td> 
    <td>由SQL语句返回的参数值。可以使用<code>getXXX()</code>方法从OUT参数中检索值。</td> 
   </tr> 
   <tr> 
    <td>INOUT</td> 
    <td>提供输入和输出值的参数。使用<code>setXXX()</code>方法绑定变量并使用<code>getXXX()</code>方法检索值。</td> 
   </tr> 
  </tbody> 
 </table> 
 <p>以下代码片段显示了如何使用<code>Connection.prepareCall()</code>方法根据上述存储过程来实例化一个<code>CallableStatement</code>对象 -</p> 
 <pre><code class="lang-java">CallableStatement cstmt = null;
try {
   String strSQL = "{call getEmpName (?, ?)}";
   cstmt = conn.prepareCall (SQL);
   . . .
}
catch (SQLException e) {
   . . .
}
finally {
   . . .
}
</code></pre> 
 <p>String变量<code>strSQL</code>表示存储过程，带有两个参数占位符。</p> 
 <p>使用<code>CallableStatement</code>对象就像使用<code>PreparedStatement</code>对象一样。 在执行语句之前，必须将值绑定到所有参数，否则将抛出一个<code>SQLException</code>异常。</p> 
 <p>如果有<code>IN</code>参数，只需遵循适用于<code>PreparedStatement</code>对象的相同规则和技术; 使用与绑定的Java数据类型相对应的<code>setXXX()</code>方法。</p> 
 <p>使用<code>OUT</code>和<code>INOUT</code>参数时，必须使用一个额外的<code>CallableStatement</code>对象方法<code>registerOutParameter()</code>。 <code>registerOutParameter()</code>方法将JDBC数据类型绑定到存储过程并返回预期数据类型。</p> 
 <p>当调用存储过程，可以使用适当的<code>getXXX()</code>方法从<code>OUT</code>参数中检索该值。 此方法将检索到的SQL类型的值转换为对应的Java数据类型。</p> 
 <h2 id="h2--callablestatement-"><a name="关闭CallableStatement对象" class="reference-link"></a><span class="header-link octicon octicon-link"></span>关闭CallableStatement对象</h2>
 <p>就像关闭其他<code>Statement</code>对象一样，由于同样的原因(节省数据库系统资源)，还应该关闭<code>CallableStatement</code>对象。</p> 
 <p>简单的调用<code>close()</code>方法将执行关闭<code>CallableStatemen</code>t对象。 如果先关闭<code>Connection</code>对象，它也会关闭<code>CallableStatement</code>对象。 但是，应该始终显式关闭<code>CallableStatement</code>对象，以确保按正确顺序的清理资源。</p> 
 <pre><code class="lang-java">CallableStatement cstmt = null;
try {
   String SQL = "{call getEmpName (?, ?)}";
   cstmt = conn.prepareCall (SQL);
   . . .
}
catch (SQLException e) {
   . . .
}
finally {
   cstmt.close();
}
</code></pre> 
 <p>为了更好的理解，建议参考学习<a target="_blank" href="http://www.yiibai.com/jdbc/callablestatement-object-example.html" title="Callable示例代码">Callable示例代码</a>。</p>
 <br>      
</div></body></html>