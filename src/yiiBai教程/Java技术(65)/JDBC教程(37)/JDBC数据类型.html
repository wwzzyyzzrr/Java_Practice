<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">JDBC数据类型</h1><div style="width:100%;float:left;" class="article-content">   
 <p>JDBC驱动程序将Java数据类型转换为适当的JDBC类型，然后将其发送到数据库。 它为大多数数据类型提供并使用默认映射。 例如，Java <code>int</code>类型会被转换为SQL <code>INTEGER</code>。 创建默认映射以提供到驱动程序时保持一致性。</p> 
 <p>下表总结了当调用<code>PreparedStatement</code>或<code>CallableStatement</code>对象或<code>ResultSet.updateXXX()</code>方法的<code>setXXX()</code>方法时，将Java数据类型转换为的默认JDBC数据类型。</p> 
 <table> 
  <thead> 
   <tr> 
    <th>SQL类型</th> 
    <th>JDBC/Java类型</th> 
    <th>setXXX</th> 
    <th>updateXXX</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>VARCHAR</td> 
    <td>java.lang.String</td> 
    <td>setString</td> 
    <td>updateString</td> 
   </tr> 
   <tr> 
    <td>CHAR</td> 
    <td>java.lang.String</td> 
    <td>setString</td> 
    <td>updateString</td> 
   </tr> 
   <tr> 
    <td>LONGVARCHAR</td> 
    <td>java.lang.String</td> 
    <td>setString</td> 
    <td>updateString</td> 
   </tr> 
   <tr> 
    <td>BIT</td> 
    <td>boolean</td> 
    <td>setBoolean</td> 
    <td>updateBoolean</td> 
   </tr> 
   <tr> 
    <td>NUMERIC</td> 
    <td>java.math.BigDecimal</td> 
    <td>setBigDecimal</td> 
    <td>updateBigDecimal</td> 
   </tr> 
   <tr> 
    <td>TINYINT</td> 
    <td>byte</td> 
    <td>setByte</td> 
    <td>updateByte</td> 
   </tr> 
   <tr> 
    <td>SMALLINT</td> 
    <td>short</td> 
    <td>setShort</td> 
    <td>updateShort</td> 
   </tr> 
   <tr> 
    <td>INTEGER</td> 
    <td>int</td> 
    <td>setInt</td> 
    <td>updateInt</td> 
   </tr> 
   <tr> 
    <td>BIGINT</td> 
    <td>long</td> 
    <td>setLong</td> 
    <td>updateLong</td> 
   </tr> 
   <tr> 
    <td>REAL</td> 
    <td>float</td> 
    <td>setFloat</td> 
    <td>updateFloat</td> 
   </tr> 
   <tr> 
    <td>FLOAT</td> 
    <td>float</td> 
    <td>setFloat</td> 
    <td>updateFloat</td> 
   </tr> 
   <tr> 
    <td>DOUBLE</td> 
    <td>double</td> 
    <td>setDouble</td> 
    <td>updateDouble</td> 
   </tr> 
   <tr> 
    <td>VARBINARY</td> 
    <td>byte[ ]</td> 
    <td>setBytes</td> 
    <td>updateBytes</td> 
   </tr> 
   <tr> 
    <td>BINARY</td> 
    <td>byte[ ]</td> 
    <td>setBytes</td> 
    <td>updateBytes</td> 
   </tr> 
   <tr> 
    <td>DATE</td> 
    <td>java.sql.Date</td> 
    <td>setDate</td> 
    <td>updateDate</td> 
   </tr> 
   <tr> 
    <td>TIME</td> 
    <td>java.sql.Time</td> 
    <td>setTime</td> 
    <td>updateTime</td> 
   </tr> 
   <tr> 
    <td>TIMESTAMP</td> 
    <td>java.sql.Timestamp</td> 
    <td>setTimestamp</td> 
    <td>updateTimestamp</td> 
   </tr> 
   <tr> 
    <td>CLOB</td> 
    <td>java.sql.Clob</td> 
    <td>setClob</td> 
    <td>updateClob</td> 
   </tr> 
   <tr> 
    <td>BLOB</td> 
    <td>java.sql.Blob</td> 
    <td>setBlob</td> 
    <td>updateBlob</td> 
   </tr> 
   <tr> 
    <td>ARRAY</td> 
    <td>java.sql.Array</td> 
    <td>setARRAY</td> 
    <td>updateARRAY</td> 
   </tr> 
   <tr> 
    <td>REF</td> 
    <td>java.sql.Ref</td> 
    <td>SetRef</td> 
    <td>updateRef</td> 
   </tr> 
   <tr> 
    <td>STRUCT</td> 
    <td>java.sql.Struct</td> 
    <td>SetStruct</td> 
    <td>updateStruct</td> 
   </tr> 
  </tbody> 
 </table> 
 <p>JDBC 3.0增强了对<code>BLOB</code>，<code>CLOB</code>，<code>ARRAY</code>和<code>REF</code>数据类型的支持。 <code>ResultSet</code>对象现在具有<code>updateBLOB()</code>，<code>updateCLOB()</code>，<code>updateArray()</code>和<code>updateRef()</code>方法，使您能够直接操作数据库服务器上的相应数据。</p> 
 <p><code>setXXX()</code>和<code>updateXXX()</code>方法可以将特定的Java类型转换为特定的JDBC数据类型。 方法<code>setObject()</code>和<code>updateObject()</code>可以将几乎任何Java类型映射到JDBC数据类型。</p> 
 <p><code>ResultSet</code>对象为每个数据类型提供相应的<code>getXXX()</code>方法来检索列值。每个方法都可以使用列名或其序数位置来检索列值。</p> 
 <table> 
  <thead> 
   <tr> 
    <th>SQL类型</th> 
    <th>JDBC/Java类型</th> 
    <th>setXXX</th> 
    <th>updateXXX</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>VARCHAR</td> 
    <td>java.lang.String</td> 
    <td>setString</td> 
    <td>getString</td> 
   </tr> 
   <tr> 
    <td>CHAR</td> 
    <td>java.lang.String</td> 
    <td>setString</td> 
    <td>getString</td> 
   </tr> 
   <tr> 
    <td>LONGVARCHAR</td> 
    <td>java.lang.String</td> 
    <td>setString</td> 
    <td>getString</td> 
   </tr> 
   <tr> 
    <td>BIT</td> 
    <td>boolean</td> 
    <td>setBoolean</td> 
    <td>getBoolean</td> 
   </tr> 
   <tr> 
    <td>NUMERIC</td> 
    <td>java.math.BigDecimal</td> 
    <td>setBigDecimal</td> 
    <td>getBigDecimal</td> 
   </tr> 
   <tr> 
    <td>TINYINT</td> 
    <td>byte</td> 
    <td>setByte</td> 
    <td>getByte</td> 
   </tr> 
   <tr> 
    <td>SMALLINT</td> 
    <td>short</td> 
    <td>setShort</td> 
    <td>getShort</td> 
   </tr> 
   <tr> 
    <td>INTEGER</td> 
    <td>int</td> 
    <td>setInt</td> 
    <td>getInt</td> 
   </tr> 
   <tr> 
    <td>BIGINT</td> 
    <td>long</td> 
    <td>setLong</td> 
    <td>getLong</td> 
   </tr> 
   <tr> 
    <td>REAL</td> 
    <td>float</td> 
    <td>setFloat</td> 
    <td>getFloat</td> 
   </tr> 
   <tr> 
    <td>FLOAT</td> 
    <td>float</td> 
    <td>setFloat</td> 
    <td>getFloat</td> 
   </tr> 
   <tr> 
    <td>DOUBLE</td> 
    <td>double</td> 
    <td>setDouble</td> 
    <td>getDouble</td> 
   </tr> 
   <tr> 
    <td>VARBINARY</td> 
    <td>byte[ ]</td> 
    <td>setBytes</td> 
    <td>getBytes</td> 
   </tr> 
   <tr> 
    <td>BINARY</td> 
    <td>byte[ ]</td> 
    <td>setBytes</td> 
    <td>getBytes</td> 
   </tr> 
   <tr> 
    <td>DATE</td> 
    <td>java.sql.Date</td> 
    <td>setDate</td> 
    <td>getDate</td> 
   </tr> 
   <tr> 
    <td>TIME</td> 
    <td>java.sql.Time</td> 
    <td>setTime</td> 
    <td>getTime</td> 
   </tr> 
   <tr> 
    <td>TIMESTAMP</td> 
    <td>java.sql.Timestamp</td> 
    <td>setTimestamp</td> 
    <td>getTimestamp</td> 
   </tr> 
   <tr> 
    <td>CLOB</td> 
    <td>java.sql.Clob</td> 
    <td>setClob</td> 
    <td>getClob</td> 
   </tr> 
   <tr> 
    <td>BLOB</td> 
    <td>java.sql.Blob</td> 
    <td>setBlob</td> 
    <td>getBlob</td> 
   </tr> 
   <tr> 
    <td>ARRAY</td> 
    <td>java.sql.Array</td> 
    <td>setARRAY</td> 
    <td>getARRAY</td> 
   </tr> 
   <tr> 
    <td>REF</td> 
    <td>java.sql.Ref</td> 
    <td>SetRef</td> 
    <td>getRef</td> 
   </tr> 
   <tr> 
    <td>STRUCT</td> 
    <td>java.sql.Struct</td> 
    <td>SetStruct</td> 
    <td>getStruct</td> 
   </tr> 
  </tbody> 
 </table> 
 <h2 id="h2-u65E5u671Fu548Cu65F6u95F4u6570u636Eu7C7Bu578B"><a name="日期和时间数据类型" class="reference-link"></a><span class="header-link octicon octicon-link"></span>日期和时间数据类型</h2>
 <p><code>java.sql.Date</code>类映射到SQL <code>DATE</code>类型，<code>java.sql.Time</code>和<code>java.sql.Timestamp</code>类分别映射到SQL <code>TIME</code>和SQL <code>TIMESTAMP</code>数据类型。</p> 
 <p>以下示例显示了<code>Date</code>和<code>Time</code>类如何格式化为标准Java日期和时间值以匹配SQL数据类型要求。</p>   
 <pre><code class="lang-java">import java.sql.Date;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.*;

public class SqlDateTime {
   public static void main(String[] args) {
      //Get standard date and time
      java.util.Date javaDate = new java.util.Date();
      long javaTime = javaDate.getTime();
      System.out.println("The Java Date is:" + 
             javaDate.toString());

      //Get and display SQL DATE
      java.sql.Date sqlDate = new java.sql.Date(javaTime);
      System.out.println("The SQL DATE is: " + 
             sqlDate.toString());

      //Get and display SQL TIME
      java.sql.Time sqlTime = new java.sql.Time(javaTime);
      System.out.println("The SQL TIME is: " + 
             sqlTime.toString());
      //Get and display SQL TIMESTAMP
      java.sql.Timestamp sqlTimestamp =
      new java.sql.Timestamp(javaTime);
      System.out.println("The SQL TIMESTAMP is: " + 
             sqlTimestamp.toString());
     }//end main
}//end SqlDateTime
</code></pre> 
 <p>编译并执行上面代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">F:\worksp\jdbc&gt;javac SqlDateTime.java

F:\worksp\jdbc&gt;java SqlDateTime
The Java Date is:Wed May 31 23:54:57 CST 2017
The SQL DATE is: 2017-05-31
The SQL TIME is: 23:54:57
The SQL TIMESTAMP is: 2017-05-31 23:54:57.937

F:\worksp\jdbc&gt;
</code></pre> 
 <h2 id="h2--null-"><a name="处理NULL值" class="reference-link"></a><span class="header-link octicon octicon-link"></span>处理NULL值</h2>
 <p>SQL使用<code>NULL</code>值和Java使用<code>null</code>是不同的概念。 所以，要在Java中处理SQL <code>NULL</code>值，可以使用三种策略 -</p> 
 <ul> 
  <li>避免使用返回原始数据类型的<code>getXXX()</code>方法。</li>
  <li>对原始数据类型使用包装类，并使用<code>ResultSet</code>对象的<code>wasNull()</code>方法来测试接收<code>getXXX()</code>方法的返回值的包装器类变量是否应设置为<code>null</code>。</li>
  <li>使用原始数据类型和<code>ResultSet</code>对象的<code>wasNull()</code>方法来测试接收到由<code>getXXX()</code>方法返回的值的原始变量是否应设置为表示<code>NULL</code>的可接受值。</li>
 </ul> 
 <p>下面是一个用来处理<code>NULL</code>值的例子 -</p> 
 <pre><code class="lang-java">Statement stmt = conn.createStatement( );
String sql = "SELECT id, first, last, age FROM Employees";
ResultSet rs = stmt.executeQuery(sql);

int id = rs.getInt(1);
if( rs.wasNull( ) ) {
   id = 0;
}
</code></pre>
 <br>      
</div></body></html>