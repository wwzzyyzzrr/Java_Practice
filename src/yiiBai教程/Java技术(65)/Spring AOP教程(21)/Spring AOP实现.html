<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Spring AOP实现</h1><div style="width:100%;float:left;" class="article-content">   
 <p>Spring支持使用<code><a target="_blank" href="https://github.com/AspectJ" title="@AspectJ" class="at-link">@AspectJ</a></code>注释样式方法和基于模式的方法来实现自定义方面。</p> 
 <h2 id="h2--xml-"><a name="基于XML模式" class="reference-link"></a><span class="header-link octicon octicon-link"></span>基于XML模式</h2>
 <p>方面(<code>Aspects</code>)使用常规类以及基于XML的配置来实现。<br>要使用本节中描述的<code>aop</code>命名空间标签，您需要按照以下所述导入<code>spring-aop</code>模式：</p> 
 <pre><code class="lang-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
    http://www.springframework.org/schema/aop 
    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd "&gt;

   &lt;!-- bean definition &amp; AOP specific configuration --&gt;

&lt;/beans&gt;
</code></pre> 
 <h2 id="h2--code-aspects-code-"><a name="声明一个方面(<code>Aspects</code>)" class="reference-link"></a><span class="header-link octicon octicon-link"></span>声明一个方面(<code>Aspects</code>)</h2>
 <p>使用<code>&lt;aop：aspect&gt;</code>元素声明一个方面(<code>Aspects</code>)，并使用<code>ref</code>属性引用后台<code>bean</code>，如下所示：</p> 
 <pre><code class="lang-xml">&lt;aop:config&gt;
   &lt;aop:aspect id="myAspect" ref="aBean"&gt;
   ...
   &lt;/aop:aspect&gt;
&lt;/aop:config&gt;

&lt;bean id="aBean" class="..."&gt;
...
&lt;/bean&gt;
</code></pre> 
 <p>这个“<code>aBean</code>”将被配置和依赖注入就像任何其他的<code>Spring Bean</code>一样，就像在前几章中看到的一样。</p> 
 <h2 id="h2-u58F0u660Eu4E00u4E2Au5207u5165u70B9"><a name="声明一个切入点" class="reference-link"></a><span class="header-link octicon octicon-link"></span>声明一个切入点</h2>
 <p>切入点(<code>pointcut</code>)有助于确定要用不同建议执行的关联点(即方法)。 在使用基于XML模式的配置时，切入点将定义如下：</p> 
 <pre><code class="lang-xml">&lt;aop:config&gt;
   &lt;aop:aspect id="myAspect" ref="aBean"&gt;

   &lt;aop:pointcut id="businessService"
      expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;
   ...
   &lt;/aop:aspect&gt;
&lt;/aop:config&gt;

&lt;bean id="aBean" class="..."&gt;
...
&lt;/bean&gt;
</code></pre> 
 <p>以下示例定义了一个名为“<code>businessService</code>”的切入点，该切入点将匹配<code>com.yiibai</code>包中<code>Student</code>类中的<code>getName()</code>方法的执行：</p> 
 <pre><code class="lang-xml">&lt;aop:config&gt;
   &lt;aop:aspect id="myAspect" ref="aBean"&gt;

   &lt;aop:pointcut id="businessService"
      expression="execution(* com.yiibai.Student.getName(..))"/&gt;
   ...
   &lt;/aop:aspect&gt;
&lt;/aop:config&gt;

&lt;bean id="aBean" class="..."&gt;
...
&lt;/bean&gt;
</code></pre> 
 <h2 id="h2-u58F0u660Eu901Au77E5"><a name="声明通知" class="reference-link"></a><span class="header-link octicon octicon-link"></span>声明通知</h2>
 <p>您可以使用<code>&lt;aop：{ADVICE NAME}&gt;</code>元素在<code>&lt;aop：aspect&gt;</code>内的五个通知中的任何一个声明如下：</p> 
 <pre><code class="lang-xml">&lt;aop:config&gt;
   &lt;aop:aspect id="myAspect" ref="aBean"&gt;
      &lt;aop:pointcut id="businessService"
         expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;

      &lt;!-- a before advice definition --&gt;
      &lt;aop:before pointcut-ref="businessService" 
         method="doRequiredTask"/&gt;

      &lt;!-- an after advice definition --&gt;
      &lt;aop:after pointcut-ref="businessService" 
         method="doRequiredTask"/&gt;

      &lt;!-- an after-returning advice definition --&gt;
      &lt;!--The doRequiredTask method must have parameter named retVal --&gt;
      &lt;aop:after-returning pointcut-ref="businessService"
         returning="retVal"
         method="doRequiredTask"/&gt;

      &lt;!-- an after-throwing advice definition --&gt;
      &lt;!--The doRequiredTask method must have parameter named ex --&gt;
      &lt;aop:after-throwing pointcut-ref="businessService"
         throwing="ex"
         method="doRequiredTask"/&gt;

      &lt;!-- an around advice definition --&gt;
      &lt;aop:around pointcut-ref="businessService" 
         method="doRequiredTask"/&gt;
   ...
   &lt;/aop:aspect&gt;
&lt;/aop:config&gt;

&lt;bean id="aBean" class="..."&gt;
...
&lt;/bean&gt;
</code></pre> 
 <p>可以对不同的通知使用相同<code>doRequiredTask</code>或不同的方法。 这些方法将被定义为方面模块的一部分。</p> 
 <h2 id="h2--aspectj"><a name="基于@AspectJ" class="reference-link"></a><span class="header-link octicon octicon-link"></span>基于<a target="_blank" href="https://github.com/AspectJ" title="@AspectJ" class="at-link">@AspectJ</a></h2>
 <p><code><a target="_blank" href="https://github.com/AspectJ" title="@AspectJ" class="at-link">@AspectJ</a></code>是指将Java方法注释为Java 5注释的常规Java类的方式。 <code><a target="_blank" href="https://github.com/AspectJ" title="@AspectJ" class="at-link">@AspectJ</a></code>是指将Java方法注释为Java 5注释的常规Java类的方式。通过在基于XML Schema的配置文件中包含以下元素来启用<code><a target="_blank" href="https://github.com/AspectJ" title="@AspectJ" class="at-link">@AspectJ</a></code>支持。</p>   
 <pre><code class="lang-xml">&lt;aop:aspectj-autoproxy/&gt;
</code></pre> 
 <h2 id="h2--aspect-"><a name="声明一个方面(aspect)" class="reference-link"></a><span class="header-link octicon octicon-link"></span>声明一个方面(aspect)</h2>
 <p>方面(<code>aspect</code>)的类就像任何其他正常的bean一样，并且可以像任何其他类一样具有方法和字段，不过它们使用<code><a target="_blank" href="https://github.com/Aspect" title="@Aspect" class="at-link">@Aspect</a></code>进行注释，如下所示：</p> 
 <pre><code class="lang-java">package org.xyz;

import org.aspectj.lang.annotation.Aspect;

@Aspect
public class AspectModule {

}
</code></pre> 
 <p>它们就像任何其他以XML格式配置的<code>bean</code>一样，如下所示：</p> 
 <pre><code class="lang-xml">&lt;bean id="myAspect" class="org.xyz.AspectModule"&gt;
   &lt;!-- configure properties of aspect here as normal --&gt;
&lt;/bean&gt;
</code></pre> 
 <h2 id="h2-u58F0u660Eu4E00u4E2Au5207u5165u70B9"><a name="声明一个切入点" class="reference-link"></a><span class="header-link octicon octicon-link"></span>声明一个切入点</h2>
 <p>切入点(<code>pointcut</code>)有助于确定要用不同通知执行的关联点(即方法)。 在使用基于<code><a target="_blank" href="https://github.com/AspectJ" title="@AspectJ" class="at-link">@AspectJ</a></code>的配置时，切入点声明有两部分：</p> 
 <ul> 
  <li>一个切入点表达式，确定哪些方法执行。</li>
  <li>切入点签名包括名称和任意数量的参数。 该方法的实体是无关紧要的，也可以是空的。</li>
 </ul> 
 <p>以下示例定义了一个名为“<code>businessService</code>”的切入点，该切入点将匹配<code>com.xyz.myapp.service</code>包下的类中可用的每个方法的执行：</p> 
 <pre><code class="lang-java">import org.aspectj.lang.annotation.Pointcut;

@Pointcut("execution(* com.xyz.myapp.service.*.*(..))") // expression 
private void businessService() {}  // signature
</code></pre> 
 <p>以下示例定义了一个名为“<code>getname</code>”的切入点，该切入点将与<code>com.yiibai</code>包下的<code>Student</code>类中的<code>getName()</code>方法的执行相匹配：</p> 
 <pre><code class="lang-java">import org.aspectj.lang.annotation.Pointcut;

@Pointcut("execution(* com.yiibai.Student.getName(..))") 
private void getname() {}
</code></pre> 
 <h2 id="h2-u58F0u660Eu901Au77E5"><a name="声明通知" class="reference-link"></a><span class="header-link octicon octicon-link"></span>声明通知</h2>
 <p>您可以使用<code>@{ADVICE-NAME}</code>注释在以下所述的五个建议中声明任何一个。假设您已经定义了一个切入点签名方法为<code>businessService()</code>，参考以下配置：</p> 
 <pre><code class="lang-java">@Before("businessService()")
public void doBeforeTask(){
 ...
}

@After("businessService()")
public void doAfterTask(){
 ...
}

@AfterReturning(pointcut = "businessService()", returning="retVal")
public void doAfterReturnningTask(Object retVal){
  // you can intercept retVal here.
  ...
}

@AfterThrowing(pointcut = "businessService()", throwing="ex")
public void doAfterThrowingTask(Exception ex){
  // you can intercept thrown exception here.
  ...
}

@Around("businessService()")
public void doAroundTask(){
 ...
}
</code></pre> 
 <p>可以为任何通知定义切入点内嵌。 下面是一个为之前通知定义的内联切入点的示例：</p> 
 <pre><code class="lang-java">@Before("execution(* com.xyz.myapp.service.*.*(..))")
public doBeforeTask(){
 ...
}
</code></pre>
 <br>      
</div></body></html>