<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">JavaFX属性</h1><div style="width:100%;float:left;" class="article-content">   
 <p><strong>JavaFX</strong>属性存储控件的内部状态，并允许我们监听来自JavaFX UI控件的状态更改。<strong>JavaFX</strong>属性可以彼此绑定。绑定行为允许属性根据来自另一个属性的更改值来同步其值。</p> 
 <h2 id="h2-javafx-"><a name="JavaFX属性的类型" class="reference-link"></a><span class="header-link octicon octicon-link"></span>JavaFX属性的类型</h2>
 <p>有两种类型的<strong>JavaFX</strong>属性：</p> 
 <ul> 
  <li>读写(Read/Writable)</li>
  <li>只读(Read-Only)</li>
 </ul> 
 <p>JavaFX的属性包含实际值，并提供更改支持，无效支持和绑定功能。所有JavaFX属性类都位于<code>javafx.beans.property.*</code>包命名空间中。<br>下面的列表是常用的属性类。</p> 
 <ul> 
  <li>javafx.beans.property.SimpleBooleanProperty</li>
  <li>javafx.beans.property.ReadOnlyBooleanWrapper</li>
  <li>javafx.beans.property.SimpleintegerProperty</li>
  <li>javafx.beans.property.ReadOnlyintegerWrapper</li>
  <li>javafx.beans.property.SimpleDoubleProperty</li>
  <li>javafx.beans.property.ReadOnlyDoubleWrapper</li>
  <li>javafx.beans.property.SimpleStringProperty</li>
  <li>javafx.beans.property.ReadOnlyStringWrapper</li>
 </ul> 
 <p><code>Simple</code>的属性是读/写属性类。拥有<code>ReadOnly</code>的属性是只读属性。</p> 
 <h2 id="h2--"><a name="读/可写属性" class="reference-link"></a><span class="header-link octicon octicon-link"></span>读/可写属性</h2>
 <p>读/写属性是可以读取和修改的属性值。例如，<code>SimpleStringProperty</code>类创建一个字符串属性，该属性对包装的字符串值是可读写的。<br>以下代码演示了<code>SimpleStringProperty</code>类的一个实例，并通过<code>set()</code>方法修改该属性。</p> 
 <pre><code class="lang-java">import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;

public class Main{
  public static void main(String[] args) {
    StringProperty password  = new SimpleStringProperty("yiibai.com");
    password.set("example.com");
    System.out.println("Modified StringProperty "  + password.get() );
  }
}
</code></pre> 
 <p>上面的代码生成以下结果。</p> 
 <pre><code class="lang-java">Modified StringProperty example.com
</code></pre> 
 <p>上面的代码声明了类型为<code>StringProperty</code>的变量<code>password</code>，并分配给<code>SimpleStringProperty</code>类的实例。实际的值是字符串“yiibai.com”，它被传递到<code>SimpleStringProperty</code>类的构造函数中。</p> 
 <p>要读取值，请调用<code>get()</code>方法或<code>getValue()</code>方法，该方法返回实际的包装值。如果要修改这个值，请调用<code>set()</code>方法或<code>setValue()</code>并传入一个字符串值。</p> 
 <h2 id="h2-u53EAu8BFBu5C5Eu6027"><a name="只读属性" class="reference-link"></a><span class="header-link octicon octicon-link"></span>只读属性</h2>
 <p>要创建只读属性，请使用以<code>ReadOnly</code>作为前缀的包装类。创建只读属性需要两个步骤。</p> 
 <ol> 
  <li>实例化只读包装类</li>
  <li>调用方法<code>getReadOnlyProperty()</code>返回一个真正的只读属性对象</li>
 </ol> 
 <pre><code class="lang-java">ReadOnlyStringWrapper userName = new ReadOnlyStringWrapper("yiibai.com"); 
ReadOnlyStringProperty readOnlyUserName  = userName.getReadOnlyProperty();
</code></pre> 
 <h2 id="h2-javafx-javabean"><a name="JavaFX JavaBean" class="reference-link"></a><span class="header-link octicon octicon-link"></span>JavaFX JavaBean</h2>
 <p>以下代码显示了如何创建JavaFX JavaBean。当构建基于Swing的应用程序时，我们使用<code>getter</code>和<code>setter</code>创建<code>JavaBean</code>。</p> 
 <p>然后我们必须通过Swing模型类在UI逻辑中获取和设置数据。通过使用<strong>JavaFX</strong>属性创建JavaFX JavaBean，<strong>JavaFX</strong>将执行数据绑定，并完成域模型类和UI控件之间的数据交换作业。参考以下代码 - </p> 
 <pre><code class="lang-java">import javafx.beans.property.ReadOnlyStringProperty;
import javafx.beans.property.ReadOnlyStringWrapper;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;

class User {
  private final static String USERNAME_PROP_NAME = "userName";
  private final ReadOnlyStringWrapper userName;
  private final static String PASSWORD_PROP_NAME = "password";
  private StringProperty password;

  public User() {
    userName = new ReadOnlyStringWrapper(this, USERNAME_PROP_NAME,"fake user");
    password = new SimpleStringProperty(this, PASSWORD_PROP_NAME, "");
  }
  public final String getUserName() {
    return userName.get();
  }

  public ReadOnlyStringProperty userNameProperty() {
    return userName.getReadOnlyProperty();
  }

  public final String getPassword() {
    return password.get();
  }

  public final void setPassword(String password) {
    this.password.set(password);
  }

  public StringProperty passwordProperty() {
    return password;
  }
}
</code></pre> 
 <h2 id="h2-u5C5Eu6027u66F4u6539u4E8Bu4EF6"><a name="属性更改事件" class="reference-link"></a><span class="header-link octicon octicon-link"></span>属性更改事件</h2>
 <p>属性可以通知值更改的事件处理程序，以便在属性更改时进行响应处理相关操作。JavaFX属性对象包含一个<code>addListener()</code>方法，它接受两种类型的功能接口：<code>ChangeListener</code>和<code>invalidationListener</code>。<br>所有JavaFX属性都是实现了<code>ObservableValue</code>和<code>Observable</code>接口，它们分别为<code>ChangeListener</code>和<code>invalidationListener</code>提供了<code>addListener()</code>方法。</p> 
 <p>以下代码显示如何创建<code>ChangeListener</code>来注册到属性。当属性的值发生改变时，将调用<code>change()</code>方法。</p>   
 <pre><code class="lang-java">import javafx.beans.property.SimpleIntegerProperty;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;

public class Main {// copyright w  w w .Yi I b A I .COm 
  public static void main(String[] args) {
    SimpleIntegerProperty xProperty = new SimpleIntegerProperty(0);

    // Adding a change listener with anonymous inner class
    xProperty.addListener(new ChangeListener&lt;Number&gt;() {
      @Override
      public void changed(ObservableValue&lt;? extends Number&gt; ov, Number oldVal,
          Number newVal) {
        System.out.println("old value:"+oldVal);
        System.out.println("new value:"+newVal);
      }
    });

    // Adding a change listener with lambda expression
    xProperty.addListener((ObservableValue&lt;? extends Number&gt; ov, Number oldVal,
        Number newVal) -&gt; {
          System.out.println("old value:"+oldVal);
          System.out.println("new value:"+newVal);
      });
  }
}
</code></pre> 
 <p>以下代码显示了如何创建一个<code>invalidationListener</code>以向属性注册。随着属性的值改变，将调用<code>invalidated()</code>方法。</p> 
 <pre><code class="lang-java">import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.property.SimpleIntegerProperty;

public class Main {
  public static void main(String[] args) {
    SimpleIntegerProperty xProperty = new SimpleIntegerProperty(0);

    // Adding a invalidation listener (anonymous inner class)
    xProperty.addListener(new InvalidationListener() {
      @Override
      public void invalidated(Observable o) {
        System.out.println(o.toString());
      }
    });

    // Adding a invalidation listener (lambda expression)
    xProperty.addListener((Observable o) -&gt; {
      System.out.println(o.toString());
    });

  }
}
</code></pre> 
 <p><code>ChangeListener</code>和<code>invalidationListener</code>之间的区别。</p> 
 <ul> 
  <li>使用<code>ChangeListener</code>将可获取<code>Observable(ObservableValue)</code>的旧值和新值。</li>
  <li>使用<code>invalidationListener</code>只获取<code>Observable</code>对象(属性)</li>
 </ul>
 <br>      
</div></body></html>