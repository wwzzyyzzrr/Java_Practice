<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Gradle任务</h1><div style="width:100%;float:left;" class="article-content">   
 <p>Gradle构建脚本描述一个或多个项目。每个项目都由不同的任务组成。任务是构建执行的一项工作。任务可以是编译一些类，将类文件存储到单独的目标文件夹中，创建JAR，生成Javadoc或将一些归档发布到存储库。</p> 
 <h2 id="h2-u5B9Au4E49u4EFBu52A1"><a name="定义任务" class="reference-link"></a><span class="header-link octicon octicon-link"></span>定义任务</h2>
 <p>任务是用于将任务定义到构建脚本中的关键字。看看下面的例子，它是一个叫作 hello 的任务，将打印一个字符串：<code>hello world</code>。将以下脚本复制并保存到 <code>build.gradle</code> 文件中。 此构建脚本定义一个名称为 “hello” 的任务，用于打印<code>hello world</code>字符串。</p> 
 <pre><code class="lang-shell">task hello {
   doLast {
      println 'hello world'
   }
}
</code></pre> 
 <p>在存储 <code>build.gradle</code> 文件的目录位置执行以下命令，应该看到输出结果如下 - </p> 
 <pre><code class="lang-shell">D:/worksp/yiibai.com/gradle-3.1/study/script&gt;gradle -q hello
hello world
</code></pre> 
 <p>可以通过为 <code>doLast</code> 语句指定快捷方式（表示符号 <code>&lt;&lt;</code>）来简化此 <code>hello</code> 任务。如果添加这个快捷方式到上面的 hello 任务中，参考如下脚本。</p> 
 <pre><code class="lang-shell">task hello &lt;&lt; {
   println 'hello world'
}
</code></pre> 
 <p>在存储 <code>build.gradle</code> 文件的目录位置执行以下命令，应该看到输出结果如下 - </p> 
 <pre><code class="lang-shell">D:/worksp/yiibai.com/gradle-3.1/study/script&gt;gradle -q hello
hello world
</code></pre> 
 <h2 id="h2-u4EFBu52A1u4F9Du8D56u5173u7CFB"><a name="任务依赖关系" class="reference-link"></a><span class="header-link octicon octicon-link"></span>任务依赖关系</h2>
 <p>您可能已经猜到，可以声明依赖于其他任务的任务。下面声明依赖于其他任务的任务，将以下代码复制并保存到<code>build.gradle</code>文件中。</p> 
 <pre><code class="lang-shell">task hello &lt;&lt; {
    println 'Hello world!'
}
task intro(dependsOn: hello) &lt;&lt; {
    println "I'm Gradle"
}
</code></pre> 
 <p>在存储 <code>build.gradle</code> 文件的目录位置执行以下命令，应该看到输出结果如下 - </p> 
 <pre><code class="lang-shell">D:/worksp/yiibai.com/gradle-3.1/study/script&gt;gradle -q intro
Hello world!
I'm Gradle
</code></pre> 
 <p>要添加依赖关系，相应的任务不需要存在。懒依赖 - 其他任务不存在，将以下代码复制并保存到<code>build.gradle</code>文件中。</p> 
 <pre><code class="lang-shell">task taskX(dependsOn: 'taskY') &lt;&lt; {
    println 'taskX'
}
task taskY &lt;&lt; {
    println 'taskY'
}
</code></pre> 
 <p>在存储 <code>build.gradle</code> 文件的目录位置执行以下命令，应该看到输出结果如下 - </p> 
 <pre><code class="lang-shell">D:/worksp/yiibai.com/gradle-3.1/study/script&gt;gradle -q taskX
taskY
taskX
</code></pre> 
 <h2 id="h2-u5B9Au4F4Du4EFBu52A1"><a name="定位任务" class="reference-link"></a><span class="header-link octicon octicon-link"></span>定位任务</h2>
 <p>如果要查找在构建文件中定义的任务，则必须使用相应的标准项目属性。这意味着每个任务都可以作为项目的属性，使用任务名称作为属性名称。<br>看看下面的代码访问任务作为属性。将以下代码复制并保存到<code>build.gradle</code>文件中。</p> 
 <pre><code class="lang-shell">task hello

println hello.name
println project.hello.name
</code></pre> 
 <p>在存储 <code>build.gradle</code> 文件的目录位置执行以下命令，应该看到输出结果如下 - </p> 
 <pre><code class="lang-shell">D:/worksp/yiibai.com/gradle-3.1/study/script&gt;gradle -q hello
hello
hello
</code></pre> 
 <p>您还可以通过任务集合使用所有属性。<br>将以下代码复制并保存到<code>build.gradle</code>文件中。</p> 
 <pre><code class="lang-shell">task hello

println tasks.hello.name
println tasks['hello'].name
</code></pre> 
 <p>在存储 <code>build.gradle</code> 文件的目录位置执行以下命令，应该看到输出结果如下 - </p> 
 <pre><code class="lang-shell">D:/worksp/yiibai.com/gradle-3.1/study/script&gt;gradle -q hello
hello
hello
</code></pre> 
 <h2 id="h2-u5411u4EFBu52A1u6DFBu52A0u4F9Du8D56u5173u7CFB"><a name="向任务添加依赖关系" class="reference-link"></a><span class="header-link octicon octicon-link"></span>向任务添加依赖关系</h2>
 <p>要将一个任务依赖于另一个任务，这意味着当一个任务完成时，另一个任务将开始。 每个任务都使用任务名称进行区分。 任务名称集合由其任务集合引用。 要引用另一个项目中的任务，应该使用项目路径作为相应任务名称的前缀。<br>以下示例将从任务<code>taskX</code>添加依赖项到任务<code>taskY</code>。</p> 
 <pre><code class="lang-shell">task taskX &lt;&lt; {
   println 'taskX'
}
task taskY(dependsOn: 'taskX') &lt;&lt; {
   println "taskY"
}
</code></pre> 
 <p>在存储 <code>build.gradle</code> 文件的目录位置执行以下命令，应该看到输出结果如下 - </p> 
 <pre><code class="lang-shell">D:/worksp/yiibai.com/gradle-3.1/study/script&gt;gradle -q taskY
taskX
taskY
</code></pre> 
 <p>上面的例子是通过使用名字添加对任务的依赖。 还有另一种方法实现任务依赖性，即使用Task对象定义依赖性。<br>现在采用上面任务的相同示例，但是使用任务对象而不是任务参考名称来实现依懒关系。<br>将以下代码复制并保存到<code>build.gradle</code>文件中。</p> 
 <pre><code class="lang-shell">task taskY &lt;&lt; {
   println 'taskY'
}
task taskX &lt;&lt; {
   println 'taskX'
}
taskY.dependsOn taskX
</code></pre> 
 <p>在存储 <code>build.gradle</code> 文件的目录位置执行以下命令，应该看到输出结果如下 - </p>   
 <pre><code class="lang-shell">D:/worksp/yiibai.com/gradle-3.1/study/script&gt;gradle -q taskY
taskX
taskY
</code></pre> 
 <p>还有另一种方法来添加任务依赖，它就是通过使用闭包。在这种情况下，任务通过闭包释放如果您在构建脚本中使用闭包，那么应该返回任务对象的单个任务或集合。以下示例将任务中从<code>taskX</code>添加依赖项到项目中的所有任务，其名称以“<code>lib</code>”开头。<br>将以下代码复制并保存到<code>build.gradle</code>文件中。</p> 
 <pre><code class="lang-shell">task taskX &lt;&lt; {
   println 'taskX'
}

taskX.dependsOn {
   tasks.findAll { 
     task -&gt; task.name.startsWith('lib') 
   }
}
task lib1 &lt;&lt; {
   println 'lib1'
}
task lib2 &lt;&lt; {
   println 'lib2'
}
task notALib &lt;&lt; {
   println 'notALib'
}
</code></pre> 
 <p>在存储 <code>build.gradle</code> 文件的目录位置执行以下命令，应该看到输出结果如下 - </p> 
 <pre><code class="lang-shell">D:/worksp/yiibai.com/gradle-3.1/study/script&gt;gradle -q taskX
lib1
lib2
taskX
</code></pre> 
 <h2 id="h2-u5411u4EFBu52A1u6DFBu52A0u63CFu8FF0"><a name="向任务添加描述" class="reference-link"></a><span class="header-link octicon octicon-link"></span>向任务添加描述</h2>
 <p>可以向任务添加描述。 执行<code>Gradle</code>任务时会显示此描述。 这可以通过使用<code>description</code>关键字。<br>将以下代码复制并保存到<code>build.gradle</code>文件中。</p> 
 <pre><code class="lang-shell">task copy(type: Copy) {
   description 'Copies the resource directory to the target directory.'
   from 'resources'
   into 'target'
   include('**/*.txt', '**/*.xml', '**/*.properties')
   println("description applied")
}
</code></pre> 
 <p>在存储 <code>build.gradle</code> 文件的目录位置执行以下命令，应该看到输出结果如下 - </p> 
 <pre><code class="lang-shell">D:/worksp/yiibai.com/gradle-3.1/study/script&gt;gradle -q taskX
description applied
</code></pre> 
 <h2 id="h2-u8DF3u8FC7u4EFBu52A1"><a name="跳过任务" class="reference-link"></a><span class="header-link octicon octicon-link"></span>跳过任务</h2>
 <p>如果用于跳过任务的逻辑不能用谓词表示，则可以使用<code>StopExecutionException</code>。 如果操作抛出此异常，则会跳过此操作的进一步执行以及此任务的任何后续操作的执行。 构建继续执行下一个任务。<br>将以下代码复制并保存到<code>build.gradle</code>文件中。</p> 
 <pre><code class="lang-sql">task compile &lt;&lt; {
    println 'We are doing the compile.'
}

compile.doFirst {
    // Here you would put arbitrary conditions in real life.
    // But this is used in an integration test so we want defined behavior.
    if (true) { throw new StopExecutionException() }
}
task myTask(dependsOn: 'compile') &lt;&lt; {
   println 'I am not affected'
}
</code></pre> 
 <p>在存储 <code>build.gradle</code> 文件的目录位置执行以下命令，应该看到输出结果如下 - </p> 
 <pre><code class="lang-shell">D:/worksp/yiibai.com/gradle-3.1/study/script&gt;gradle -q myTask
I am not affected
</code></pre> 
 <p>Gradle在处理任务时有不同的阶段。 首先，有一个配置阶段，其中直接在任务的闭包中指定的代码被执行。 针对每个可用任务执行配置块，而不仅针对稍后实际执行的那些任务。</p> 
 <h2 id="h2--"><a name="参考 -" class="reference-link"></a><span class="header-link octicon octicon-link"></span>参考 -</h2>
 <ul> 
  <li><a target="_blank" href="https://docs.gradle.org/current/userguide/more_about_tasks.html">https://docs.gradle.org/current/userguide/more_about_tasks.html</a></li>
  <li><a target="_blank" href="https://docs.gradle.org/current/userguide/tutorial_using_tasks.html">https://docs.gradle.org/current/userguide/tutorial_using_tasks.html</a></li>
 </ul>
 <br>      
</div></body></html>