<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java RMI介绍</h1><div style="width:100%;float:left;" class="article-content">   
 <p><em>RMI</em>代表远程方法调用。 这是一种允许位于在一个系统(JVM)中的对象访问/调用在另一个JVM上运行的对象的机制。</p> 
 <p><em>RMI</em>用于构建分布式应用程序; 它提供Java程序之间的远程通信。 它在<code>java.rmi</code>包中提供。</p> 
 <h2 id="h2-rmi-"><a name="RMI应用程序的体系结构" class="reference-link"></a><span class="header-link octicon octicon-link"></span>RMI应用程序的体系结构</h2>
 <p>在<em>RMI</em>应用程序中，我们编写了两个程序，一个服务器程序(位于服务器上)和一个客户机程序(位于客户端上)。</p> 
 <ul> 
  <li>在服务器程序中，创建一个远程对象，该对象的引用可被客户端(使用注册表)使用。</li>
  <li>客户端程序请求服务器上的远程对象，并尝试调用其方法。</li>
 </ul> 
 <p>下图显示了<em>RMI</em>应用程序的体系结构。</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201707/1607/666220746_84205.jpg" alt=""></p> 
 <p>下面我们来讨论这个架构的组件。</p> 
 <ul> 
  <li><strong>传输层(<em>Transport Layer</em>)</strong> - 此层连接客户端和服务器。它管理现有的连接，并设置新的连接。</li>
  <li><strong>存根(<em>Stub</em>)</strong> - 存根是客户端上的远程对象的表示(代理)。 它位于客户端系统中; 它作为客户端程序的网关。</li>
  <li><strong>骨架(<em>Skeleton</em>)</strong> - 它位于服务器端的对象。 存根与此骨架通信以将请求传递给远程对象。</li>
  <li><strong>RRL(远程参考层)</strong> - 它是管理客户端对远程对象的引用的层。</li>
 </ul> 
 <h2 id="h2-rmi-"><a name="RMI应用程序的工作" class="reference-link"></a><span class="header-link octicon octicon-link"></span>RMI应用程序的工作</h2>
 <p>以下几点总结了RMI应用程序的工作原理 -</p> 
 <ul> 
  <li>当客户端调用远程对象时，它被存根最终传递给RRL。</li>
  <li>当客户端RRL接收到请求时，它会调用对象<code>remoteRef</code>的一个名为<code>invoke()</code>的方法。 它将请求传递到服务器端的RRL。</li>
  <li>服务器端的RRL将请求传递到服务器上的最后调用所需对象的<em>Skeleton</em>(服务器上的代理)。</li>
  <li>结果一直传递给客户端。</li>
 </ul> 
 <h2 id="h2-u7F16u7EC4u548Cu89E3u7EC4"><a name="编组和解组" class="reference-link"></a><span class="header-link octicon octicon-link"></span>编组和解组</h2>  
 <p>每当客户端调用接受远程对象上的参数的方法时，在通过网络发送之前，将参数捆绑到消息中。 这些参数可能是原始类型或对象。 在原始类型的情况下，将参数放在一起并附加标题。 如果参数是对象，那么它们被序列化。 这个过程被称为编组。</p> 
 <p>在服务器端，打包参数是未分组的，然后调用所需的方法。这个过程被称为解组。</p> 
 <h2 id="h2-rmi-"><a name="RMI注册表" class="reference-link"></a><span class="header-link octicon octicon-link"></span>RMI注册表</h2>
 <p>RMI注册表是放置所有服务器对象的命名空间。 每次服务器创建一个对象时，它会使用<code>RMIregistry</code>(使用<code>bind()</code>或<code>reBind()</code>方法)注册此对象。 这些使用叫作绑定名称(<strong>bind name</strong>)的唯一名称进行注册。</p> 
 <p>要调用远程对象，客户端需要该对象的引用。客户端使用其绑定名称(使用<code>lookup()</code>方法)从注册表中获取对象。</p> 
 <p>下图说明了整个过程 -</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201707/1607/887070758_42575.jpg" alt=""></p> 
 <h2 id="h2-rmi-"><a name="RMI目标" class="reference-link"></a><span class="header-link octicon octicon-link"></span>RMI目标</h2>
 <p>以下是RMI的目标 - </p> 
 <ul> 
  <li>最小化应用程序的复杂性。</li>
  <li>保护类型安全。</li>
  <li>分布式垃圾收集。</li>
  <li>最小化使用本地和远程对象之间的区别。</li>
 </ul>
 <br>      
</div></body></html>