<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java9特性及示例</h1><div style="width:100%;float:left;" class="article-content">   
 <p>Java 9已经发布了有一段时间了，现在让我们来看看Java 9中的功能特性，看看它带给我们的哪些重大变化。</p> 
 <p>一些重要的Java 9特性是如下所示 - </p> 
 <ul> 
  <li>Java 9 REPL(JShell)</li>
  <li>用于列表，集合，映射和Map.Entry的工厂方法</li>
  <li>接口的私有方法</li>
  <li>Java 9模块系统</li>
  <li>Process API改进</li>
  <li>Try With Resources改进</li>
  <li>CompletableFuture API改进</li>
  <li>反应流</li>
  <li>菱形运算符和匿名内部类</li>
  <li>Optional类改进</li>
  <li>流API改进</li>
  <li>增强了<a target="_blank" href="https://github.com/Deprecated" title="@Deprecated" class="at-link">@Deprecated</a>注释</li>
  <li>HTTP 2客户端</li>
  <li>多分辨率图像API</li>
  <li>其它杂项Java 9特性</li>
 </ul> 
 <p>Oracle公司将在2017年3月底前发布Java SE 9。在本文中，将通过一些示例简要讨论“Java 9功能”。</p> 
 <h2 id="h2-1-java-9-repl-jshell-"><a name="1. Java 9 REPL(JShell)" class="reference-link"></a><span class="header-link octicon octicon-link"></span>1. Java 9 REPL(JShell)</h2>
 <p>Oracle公司推出了一种名为“jshell”的新工具。 它代表Java Shell，也称为REPL(Read Evaluate Print Loop)。 它用于非常容易地执行和测试任何Java结构，如类，接口，枚举，对象，语句等。</p> 
 <p>运行效果如下所示 -<br><img src="http://www.yiibai.com/uploads/images/201802/2802/670140250_74780.png" alt=""></p> 
 <p>Oracle Corp引入了一些便利的工厂方法来创建<code>Immutable List</code>，<code>Set</code>，<code>Map</code>和<code>Map.Entry</code>对象。 这些实用程序方法用于创建空的或非空的集合对象。</p> 
 <h2 id="h2-2-map-entry-"><a name="2. 用于不可变列表，集合，映射和Map.Entry的工厂方法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2. 用于不可变列表，集合，映射和Map.Entry的工厂方法</h2>
 <p>在Java SE 8和更早的版本中，我们可以使用不可修改的<code>Collections</code>类实用程序方法来创建<code>Immutable Collection</code>对象。 例如，如果想创建一个不可变列表，那么可以使用<code>Collections.unmodifiableList</code>方法。</p> 
 <p>然而这些<code>Collections.unmodifiableXXX</code>方法是非常繁琐和冗长的方法。为了克服这些缺点，Oracle公司在List，Set和Map接口中增加了一些实用方法。</p> 
 <p>List和Set接口具有<code>of()</code>方法来创建一个空的或不空的不可变列表或<code>Set</code>对象，如下所示:</p> 
 <p><strong>空列表示例</strong></p> 
 <pre><code class="lang-java">List immutableList = List.of();
</code></pre> 
 <p><strong>非空列表示例</strong></p> 
 <pre><code class="lang-java">List immutableList = List.of("one","two","three");
</code></pre> 
 <p>Map有两套方法:分别创建<code>Immutable Map</code>对象和<code>Immutable Map.Entry</code>对象的<code>of()</code>方法和<code>Entries()</code>方法。</p> 
 <p><strong>空Map示例</strong></p> 
 <pre><code class="lang-java">jshell&gt; Map emptyImmutableMap = Map.of()
emptyImmutableMap ==&gt; {}
</code></pre> 
 <p><strong>非空映射示例</strong></p> 
 <pre><code class="lang-java">jshell&gt; Map nonemptyImmutableMap = Map.of(1, "one", 2, "two", 3, "three")
nonemptyImmutableMap ==&gt; {2=two, 3=three, 1=one}
</code></pre> 
 <h2 id="h2-3-"><a name="3. 接口的私有方法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>3. 接口的私有方法</h2>
 <p>在Java 8中，可以使用<code>Default</code>和<code>Static</code>方法在接口中提供方法实现。 但是不能在接口中创建私有方法。</p> 
 <p>为了避免冗余代码和更多的重用性，Oracle公司将在Java SE 9接口中引入私有方法。 从Java SE 9开始，我们可以使用<code>'private'</code>关键字在接口中编写私有和私有静态方法。</p> 
 <p>这些私有方法与其他类私有方法相似，它们之间没有区别。</p> 
 <pre><code class="lang-java">public interface Card{

  private Long createCardID(){
    // Method implementation goes here.
  }

  private static void displayCardDetails(){
    // Method implementation goes here.
  }

}
</code></pre> 
 <h2 id="h2-4-java-9-"><a name="4. Java 9模块系统" class="reference-link"></a><span class="header-link octicon octicon-link"></span>4. Java 9模块系统</h2>
 <p>模块系统是Java 9特性之一。 Oracle公司将引入以下功能作为<code>Jigsaw</code>项目的一部分。</p> 
 <ul> 
  <li>模块化JDK</li>
  <li>模块化Java源代码</li>
  <li>模块化运行时图像</li>
  <li>封装Java内部API</li>
  <li>Java平台模块系统</li>
 </ul> 
 <p>在Java SE 9版本之前，使用Monolithic Jars来开发基于Java的应用程序。 这种架构有很多限制和缺点。 为了避免所有这些缺陷，Java SE 9随模块系统一起提供。</p> 
 <p>JDK 9即将推出<code>92</code>个模块(可能会在最终版本中发生变化)。 我们可以使用JDK模块，也可以创建自己的模块，如下所示:</p> 
 <p><strong>简单模块示例</strong></p> 
 <pre><code class="lang-java">module com.foo.bar { }
</code></pre> 
 <p>这里我们使用<code>'module'</code>关键字来创建一个简单的模块。 每个模块都有一个名称，相关的代码和其他资源。</p> 
 <h2 id="h2-5-process-api-"><a name="5. Process API改进" class="reference-link"></a><span class="header-link octicon octicon-link"></span>5. Process API改进</h2>
 <p>Java SE 9即将在Process API中进行一些改进。他们增加了一些新的类和方法来简化操作系统进程的控制和管理。</p> 
 <p>Process API中有两个新的接口:</p> 
 <pre><code class="lang-java">java.lang.ProcessHandle
java.lang.ProcessHandle.Info
</code></pre> 
 <p><strong>Process API示例</strong></p> 
 <pre><code class="lang-java">ProcessHandle currentProcess = ProcessHandle.current();
System.out.println("Current Process Id: = " + currentProcess.getPid());
</code></pre> 
 <h2 id="h2-6-try-with-resources-"><a name="6. Try-With-Resources改进" class="reference-link"></a><span class="header-link octicon octicon-link"></span>6. Try-With-Resources改进</h2>
 <p>我们知道，Java SE 7引入了一个新的异常处理结构:<code>Try-With-Resources</code>来自动管理资源。 这个新声明的主要目标是“自动更好的资源管理”。</p> 
 <p>Java SE 9将对此语句进行一些改进，以避免更多冗长并提高某些可读性。</p> 
 <p><strong>Java SE 7示例</strong></p> 
 <pre><code class="lang-java">void testARM_Before_Java9() throws IOException{
 BufferedReader reader1 = new BufferedReader(new FileReader("journaldev.txt"));
 try (BufferedReader reader2 = reader1) {
   System.out.println(reader2.readLine());
 }
}
</code></pre> 
 <p><strong>Java SE 9示例</strong></p> 
 <pre><code class="lang-java">void testARM_Java9() throws IOException{
 BufferedReader reader1 = new BufferedReader(new FileReader("journaldev.txt"));
 try (reader1) {
   System.out.println(reader1.readLine());
 }
}
</code></pre> 
 <h2 id="h2-7-completablefuture-api-"><a name="7. CompletableFuture API改进" class="reference-link"></a><span class="header-link octicon octicon-link"></span>7. CompletableFuture API改进</h2>
 <p>在Java SE 9中，Oracle Corp将改进<code>CompletableFuture API</code>来解决Java SE 8中出现的一些问题。它们将增加支持一些延迟和超时，一些实用方法和更好的子分类。</p> 
 <pre><code class="lang-java">Executor exe = CompletableFuture.delayedExecutor(50L, TimeUnit.SECONDS);
</code></pre> 
 <p>这里<code>delayedExecutor()</code>是静态工具方法，用于返回一个新的<code>Executor</code>，它在给定的延迟后将任务提交给缺省执行程序。</p> 
 <h2 id="h2-8-"><a name="8. 反应流" class="reference-link"></a><span class="header-link octicon octicon-link"></span>8. 反应流</h2>
 <p>现在，反应式编程在开发应用程序以获得一些优点方面变得非常流行。 Scala，Play，Akka等。框架已经集成了Reactive Streams并获得许多好处。 Oracle Corps还在Java SE 9中引入了新的Reactive Streams API。</p> 
 <p>Java SE 9 Reactive Streams API是一个发布/订阅框架，可以使用Java语言轻松实现异步，可伸缩和并行应用程序。</p> 
 <p>Java SE 9引入了以下API来开发基于Java的应用程序中的Reactive Streams。</p> 
 <ul> 
  <li><code>java.util.concurrent.Flow</code></li>
  <li><code>java.util.concurrent.Flow.Publisher</code></li>
  <li><code>java.util.concurrent.Flow.Subscriber</code></li>
  <li><code>java.util.concurrent.Flow.Processor</code></li>
 </ul> 
 <h2 id="h2-9-"><a name="9. 菱形运算符匿名内部类" class="reference-link"></a><span class="header-link octicon octicon-link"></span>9. 菱形运算符匿名内部类</h2>
 <p>我们知道，Java SE 7引入了一项新功能:菱形运算符，以避免冗余代码和冗长，以提高可读性。 但是，在Java SE 8中，Oracle Corp(Java Library Developer)发现在使用带有匿名内部类的菱形(Diamond)操作符方面存在一些限制。 他们已经修复了这些问题并将作为Java 9的一部分发布。</p>   
 <pre><code class="lang-java"> public List getEmployee(String empid){
     // Code to get Employee details from Data Store
     return new List(emp){ };
  }
</code></pre> 
 <p>这里只使用<code>List</code>而不指定类型参数。</p> 
 <h2 id="h2-10-optional-"><a name="10 Optional类改进" class="reference-link"></a><span class="header-link octicon octicon-link"></span>10 Optional类改进</h2>
 <p>在Java SE 9中，Oracle公司为<code>java.util.Optional</code>类添加了一些有用的新方法。 在这里将通过一些简单的例子来讨论其中的一种方法:流方法</p> 
 <p>如果给定<code>Optional</code>对象中存在一个值，则此<code>stream()</code>方法将返回具有该值的顺序<code>Stream</code>。 否则，它将返回一个空流。<br>已经添加了<code>stream()</code>方法来延迟处理<code>Optional</code>对象，如下所示:</p> 
 <pre><code class="lang-java">Stream&lt;Optional&gt; emp = getEmployee(id)
Stream empStream = emp.flatMap(Optional::stream)
</code></pre> 
 <p>这里使用<code>Optional.stream()</code>方法将<code>Employee</code>对象的一个可选的<code>Stream</code>转换为一个<code>Employee</code>流，以便可以在结果代码中懒处理这个结果。</p> 
 <h2 id="h2-11-stream-api-"><a name="11. Stream API改进" class="reference-link"></a><span class="header-link octicon octicon-link"></span>11. Stream API改进</h2>
 <p>在Java SE 9中，Oracle Corp为<code>java.util.Stream</code>接口添加了四个有用的新方法。 由于Stream是一个接口，所有这些新实现的方法都是默认方法。 其中两个非常重要:<code>dropWhile</code>和<code>takeWhile</code>方法</p> 
 <p>如果您熟悉Scala语言或任何函数编程语言，您一定会了解这些方法。 在编写一些功能样式代码时，这些是非常有用的方法。 在这里我们讨论<code>takeWhile</code>实用方法。</p> 
 <p>这个<code>takeWhile()</code>将一个谓词作为参数，并返回给定<code>Stream</code>值的一个子集的<code>Stream</code>，直到<code>Predicate</code>返回<code>false</code>。 如果第一个值不满足该谓词，它只会返回一个空的流。</p> 
 <pre><code class="lang-shell">jshell&gt; Stream.of(1,2,3,4,5,6,7,8,9,10).takeWhile(i -&gt; i &lt; 5 )
                 .forEach(System.out::println);
1
2
3
4
</code></pre> 
 <h2 id="h2-12-deprecated-"><a name="12. 增强了@Deprecated注释" class="reference-link"></a><span class="header-link octicon octicon-link"></span>12. 增强了<a target="_blank" href="https://github.com/Deprecated" title="@Deprecated" class="at-link">@Deprecated</a>注释</h2>
 <p>在Java SE 8和更早版本中，<code><a target="_blank" href="https://github.com/Deprecated" title="@Deprecated" class="at-link">@Deprecated</a></code>注释只是一个没有任何方法的<code>Marker</code>接口。 它用于标记一个Java API，它是一个类，字段，方法，接口，构造函数，枚举等。</p> 
 <p>在Java SE 9中，Oracle Corp增强了<code><a target="_blank" href="https://github.com/Deprecated" title="@Deprecated" class="at-link">@Deprecated</a></code>注释以提供有关不推荐使用的API的更多信息，并提供了一个工具来分析应用程序对不推荐使用的API的静态使用情况。 他们添加了两个方法到这个<code>Deprecated</code>接口:<code>forRemoval</code>和自此来提供这些信息。</p> 
 <h2 id="h2-13-http2-"><a name="13. HTTP2客户端" class="reference-link"></a><span class="header-link octicon octicon-link"></span>13. HTTP2客户端</h2>
 <p>在Java SE 9中，Oracle Corp将发布新的HTTP 2客户端API以支持HTTP/2协议和WebSocket功能。 由于现有的或传统的HTTP客户端API有许多问题(例如支持HTTP/1.1协议，不支持HTTP/2协议和<code>WebSocket</code>，只能在阻塞模式和大量性能问题下工作)，他们用新的HTTP替换了这个HttpURLConnection API 客户。</p> 
 <p>他们将在<code>java.net.http</code>包下引入新的HTTP 2客户端API。 它支持<code>HTTP/1.1</code>和<code>HTTP/2</code>协议。 它支持同步(阻塞模式)和异步模式。 它支持使用WebSocket API的异步模式。</p> 
 <p><strong>HTTP2客户端示例</strong></p> 
 <pre><code class="lang-shell">jshell&gt; import java.net.http.*

jshell&gt; import static java.net.http.HttpRequest.*

jshell&gt; import static java.net.http.HttpResponse.*

jshell&gt; URI uri = new URI("http://rams4java.blogspot.co.uk/2016/05/java-news.html")
uri ==&gt; http://rams4java.blogspot.co.uk/2016/05/java-news.html

jshell&gt; HttpResponse response = HttpRequest.create(uri).body(noBody()).GET().response()
response ==&gt; java.net.http.HttpResponseImpl@79efed2d

jshell&gt; System.out.println("Response was " + response.body(asString()))
</code></pre> 
 <h2 id="h2-14-api"><a name="14. 多分辨率图像API" class="reference-link"></a><span class="header-link octicon octicon-link"></span>14. 多分辨率图像API</h2>
 <p>在Java SE 9中，甲骨文公司将推出一种新的多分辨率图像API。 此API中的重要接口是<code>MultiResolutionImage</code>，它在<code>java.awt.image</code>包中可用。</p> 
 <p><code>MultiResolutionImage</code>封装了一组具有不同高度和宽度(即不同分辨率)的图像，并允许我们按照自己的要求查询它们。</p>
 <br>      
</div></body></html>