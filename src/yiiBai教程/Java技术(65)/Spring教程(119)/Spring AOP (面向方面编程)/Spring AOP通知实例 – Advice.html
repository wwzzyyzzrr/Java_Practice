<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Spring AOP通知实例 – Advice</h1><div style="width:100%;float:left;" class="article-content">   
 <div> 
  <div>
    Spring&nbsp;AOP(面向方面编程)框架，用于在模块化方面的横切关注点。简单得说，它只是一个拦截器拦截一些过程，例如，当一个方法执行，Spring&nbsp;AOP 可以劫持一个执行的方法，在方法执行之前或之后添加额外的功能。 
  </div> 
 </div> 
 <div> 
  <div>
    在Spring&nbsp;AOP中，有 4 种类型通知(advices)的支持： 
  </div> 
  <ul> 
   <li> 
    <div>
      通知(Advice)之前&nbsp;-&nbsp;该方法执行前运行 
    </div> </li> 
   <li> 通知(Advice)返回之后&nbsp;–&nbsp;运行后，该方法返回一个结果 </li> 
   <li> 通知(Advice)抛出之后&nbsp;–&nbsp;运行方法抛出异常后， </li> 
   <li> 环绕通知&nbsp;–&nbsp;环绕方法执行运行，结合以上这三个通知。 </li> 
  </ul> 
  <div>
    下面的例子显示Spring&nbsp;AOP&nbsp;通知如何工作。 
  </div> 
  <h2> 
   <div>
     简单的 Spring 例子 
   </div> </h2> 
  <div>
    创建一个简单的客户服务类及一个print方法作为演示。 
  </div> 
  <pre>package com.yiibai.customer.services;

public class CustomerService {
	private String name;
	private String url;

	public void setName(String name) {
		this.name = name;
	}

	public void setUrl(String url) {
		this.url = url;
	}

	public void printName() {
		System.out.println("Customer name : " + this.name);
	}

	public void printURL() {
		System.out.println("Customer website : " + this.url);
	}

	public void printThrowException() {
		throw new IllegalArgumentException();
	}

}</pre> 
  <p> File : applicationContext.xml –&nbsp;一个bean配置文件 </p> 
  <pre>&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;

	&lt;bean id="customerService" class="com.yiibai.customer.services.CustomerService"&gt;
		&lt;property name="name" value="YiiBaii Mook Kim" /&gt;
		&lt;property name="url" value="http://www.yiibai.com" /&gt;
	&lt;/bean&gt;

&lt;/beans&gt;</pre> 
  <p> 执行它 </p> 
  <pre>package com.yiibai.common;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.yiibai.customer.services.CustomerService;

public class App {
	public static void main(String[] args) {
		ApplicationContext appContext = new ClassPathXmlApplicationContext(
				new String[] { "Spring-Customer.xml" });

		CustomerService cust = (CustomerService) appContext.getBean("customerService");

		System.out.println("*************************");
		cust.printName();
		System.out.println("*************************");
		cust.printURL();
		System.out.println("*************************");
		try {
			cust.printThrowException();
		} catch (Exception e) {

		}

	}
}</pre> 
  <p> 输出 </p> 
  <pre>*************************
Customer name : Yiibai Mook Kim
*************************
Customer website : http://www.yiibai.com
*************************</pre> 
  <div>
    一个简单的Spring项目用来注入(DI)bean和输出一些字符串。 
  </div> 
  <h2> Spring AOP 通知 </h2> 
  <div>
    现在，附加&nbsp;Spring&nbsp;AOP&nbsp;建议到上述的客户服务。 
  </div> 
  <h2> 1. 之前通知 </h2> 
  <div>
    它会在方法执行之前执行。创建一个实现 MethodBeforeAdvice 接口的类。 
  </div> 
  <pre>package com.yiibai.aop;

import java.lang.reflect.Method;
import org.springframework.aop.MethodBeforeAdvice;

public class HijackBeforeMethod implements MethodBeforeAdvice
{
	@Override
	public void before(Method method, Object[] args, Object target)
		throws Throwable {
	        System.out.println("HijackBeforeMethod : Before method hijacked!");
	}
}</pre> 
  <div>
    在&nbsp;bean&nbsp;配置文件(applicationContext.xml)，创建一个&nbsp;bean&nbsp;的&nbsp;HijackBeforeMethod&nbsp;类，并命名为“customerServiceProxy”&nbsp;作为一个新的代理对象。 
  </div> 
  <ul> 
   <li> ‘target’ –&nbsp;定义你想拦截的bean。 </li> 
   <li> ‘interceptorNames’ –&nbsp;定义要应用这个代理/目标对象的类(通知)。 </li> 
  </ul> 
  <pre>&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;

	&lt;bean id="customerService" class="com.yiibai.customer.services.CustomerService"&gt;
		&lt;property name="name" value="Yiibai Mook Kim" /&gt;
		&lt;property name="url" value="http://www.yiibai.com" /&gt;
	&lt;/bean&gt;

	&lt;bean id="hijackBeforeMethodBean" class="com.yiibai.aop.HijackBeforeMethod" /&gt;

	&lt;bean id="customerServiceProxy" 
                 class="org.springframework.aop.framework.ProxyFactoryBean"&gt;

		&lt;property name="target" ref="customerService" /&gt;

		&lt;property name="interceptorNames"&gt;
			&lt;list&gt;
				&lt;value&gt;hijackBeforeMethodBean&lt;/value&gt;
			&lt;/list&gt;
		&lt;/property&gt;
	&lt;/bean&gt;
&lt;/beans&gt;</pre> 
  <div>
    再次运行它，现在得到新的&nbsp;customerServiceProxy&nbsp;bean，而不是原来的CustomerService&nbsp;bean。 
  </div> 
  <pre>package com.yiibai.common;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import com.yiibai.customer.services.CustomerService;

public class App {
	public static void main(String[] args) {
		ApplicationContext appContext = new ClassPathXmlApplicationContext(
				new String[] { "Spring-Customer.xml" });

		CustomerService cust = 
                                (CustomerService) appContext.getBean("customerServiceProxy");

		System.out.println("*************************");
		cust.printName();
		System.out.println("*************************");
		cust.printURL();
		System.out.println("*************************");
		try {
			cust.printThrowException();
		} catch (Exception e) {

		}

	}
}</pre> 
  <p> 输出结果 </p> 
  <pre>*************************
HijackBeforeMethod : Before method hijacked!
Customer name : Yiibai Mook Kim
*************************
HijackBeforeMethod : Before method hijacked!
Customer website : http://www.yiibai.com
*************************
HijackBeforeMethod : Before method hijacked!</pre> 
  <div>
    它将运行&nbsp;HijackBeforeMethod&nbsp;的&nbsp;before()&nbsp;方法，在每个&nbsp;CustomerService&nbsp;的方法之前执行。 
  </div> 
  <h2> 
   <div>
     2.返回后通知 
   </div> </h2> 
  <div>
    该方法返回一个结果之后它将执行。创建一个实现AfterReturningAdvice接口的类。 
  </div> 
  <pre>package com.yiibai.aop;

import java.lang.reflect.Method;
import org.springframework.aop.AfterReturningAdvice;

public class HijackAfterMethod implements AfterReturningAdvice
{
	@Override
	public void afterReturning(Object returnValue, Method method,
		Object[] args, Object target) throws Throwable {
	        System.out.println("HijackAfterMethod : After method hijacked!");
	}
}</pre> 
  <div>
    bean配置文件 
  </div> 
  <pre>&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;

	&lt;bean id="customerService" class="com.yiibai.customer.services.CustomerService"&gt;
		&lt;property name="name" value="Yong Mook Kim" /&gt;
		&lt;property name="url" value="http://www.yiibai.com" /&gt;
	&lt;/bean&gt;

	&lt;bean id="hijackAfterMethodBean" class="com.yiibai.aop.HijackAfterMethod" /&gt;

	&lt;bean id="customerServiceProxy" 
                class="org.springframework.aop.framework.ProxyFactoryBean"&gt;

		&lt;property name="target" ref="customerService" /&gt;

		&lt;property name="interceptorNames"&gt;
			&lt;list&gt;
				&lt;value&gt;hijackAfterMethodBean&lt;/value&gt;
			&lt;/list&gt;
		&lt;/property&gt;
	&lt;/bean&gt;
&lt;/beans&gt;</pre> 
  <div>
    再次运行，输出 
  </div> 
  <pre>*************************
Customer name : Yiibai Mook Kim
HijackAfterMethod : After method hijacked!
*************************
Customer website : http://www.yiibai.com
HijackAfterMethod : After method hijacked!
*************************</pre> 
  <div>
    它将运行&nbsp;HijackAfterMethod&nbsp;的&nbsp;afterReturning()方法，在每次&nbsp;CustomerService&nbsp;方法返回结果之后。 
  </div> 
  <h2> 
   <div>
     3.抛出后通知 
   </div> </h2> 
  <div>
    它将在执行方法抛出一个异常后。创建一个实现ThrowsAdvice接口的类，并创建一个afterThrowing方法拦截抛出：IllegalArgumentException异常。 
  </div>   
  <pre>package com.yiibai.aop;

import org.springframework.aop.ThrowsAdvice;

public class HijackThrowException implements ThrowsAdvice {
	public void afterThrowing(IllegalArgumentException e) throws Throwable {
		System.out.println("HijackThrowException : Throw exception hijacked!");
	}
}</pre> 
  <div>
    bean配置文件 
  </div> 
  <pre>&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;

	&lt;bean id="customerService" class="com.yiibai.customer.services.CustomerService"&gt;
		&lt;property name="name" value="Yong Mook Kim" /&gt;
		&lt;property name="url" value="http://www.yiibai.com" /&gt;
	&lt;/bean&gt;

	&lt;bean id="hijackThrowExceptionBean" class="com.yiibai.aop.HijackThrowException" /&gt;

	&lt;bean id="customerServiceProxy" 
                 class="org.springframework.aop.framework.ProxyFactoryBean"&gt;

		&lt;property name="target" ref="customerService" /&gt;

		&lt;property name="interceptorNames"&gt;
			&lt;list&gt;
				&lt;value&gt;hijackThrowExceptionBean&lt;/value&gt;
			&lt;/list&gt;
		&lt;/property&gt;
	&lt;/bean&gt;
&lt;/beans&gt;</pre> 
  <div>
    再次运行，输出 
  </div> 
  <pre>*************************
Customer name : Yiibai Mook Kim
*************************
Customer website : http://www.yiibai.com
*************************
HijackThrowException : Throw exception hijacked!</pre> 
  <div>
    它将运行 HijackThrowException 的 afterThrowing()方法，如果 CustomerService 的方法抛出异常。 
  </div> 
  <h2> 
   <div>
     4.环绕通知 
   </div> </h2> 
  <p> 它结合了上面的三个通知，在方法执行过程中执行。创建一个实现了MethodInterceptor接口的类。必须调用“methodInvocation.proceed();”&nbsp;继续在原来的方法执行，否则原来的方法将不会执行。 </p> 
  <pre>package com.yiibai.aop;

import java.util.Arrays;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;

public class HijackAroundMethod implements MethodInterceptor {
	@Override
	public Object invoke(MethodInvocation methodInvocation) throws Throwable {

		System.out.println("Method name : "
				+ methodInvocation.getMethod().getName());
		System.out.println("Method arguments : "
				+ Arrays.toString(methodInvocation.getArguments()));

		// same with MethodBeforeAdvice
		System.out.println("HijackAroundMethod : Before method hijacked!");

		try {
			// proceed to original method call
			Object result = methodInvocation.proceed();

			// same with AfterReturningAdvice
			System.out.println("HijackAroundMethod : Before after hijacked!");

			return result;

		} catch (IllegalArgumentException e) {
			// same with ThrowsAdvice
			System.out.println("HijackAroundMethod : Throw exception hijacked!");
			throw e;
		}
	}
}</pre> 
  <div>
    bean配置文件 
  </div> 
  <pre>&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;

	&lt;bean id="customerService" class="com.yiibai.customer.services.CustomerService"&gt;
		&lt;property name="name" value="Yong Mook Kim" /&gt;
		&lt;property name="url" value="http://www.yiibai.com" /&gt;
	&lt;/bean&gt;

	&lt;bean id="hijackAroundMethodBean" class="com.yiibai.aop.HijackAroundMethod" /&gt;

	&lt;bean id="customerServiceProxy" 
                class="org.springframework.aop.framework.ProxyFactoryBean"&gt;

		&lt;property name="target" ref="customerService" /&gt;

		&lt;property name="interceptorNames"&gt;
			&lt;list&gt;
				&lt;value&gt;hijackAroundMethodBean&lt;/value&gt;
			&lt;/list&gt;
		&lt;/property&gt;
	&lt;/bean&gt;
&lt;/beans&gt;</pre> 
  <div>
    再次运行，输出
   <br> 
   <pre class="prettyprint lang-bsh">*************************
Method name : printName
Method arguments : []
HijackAroundMethod : Before method hijacked!
Customer name : YiiBai Mook Kim
HijackAroundMethod : Before after hijacked!
*************************
Method name : printURL
Method arguments : []
HijackAroundMethod : Before method hijacked!
Customer website : http://www.yiibai.com 
HijackAroundMethod : Before after hijacked!
*************************
Method name : printThrowException
Method arguments : []
HijackAroundMethod : Before method hijacked!
HijackAroundMethod : Throw exception hijacked!</pre> 
   <br> 
  </div> 
  <div>
    它将运行HijackAroundMethod&nbsp;的&nbsp;invoke()方法，在每一个&nbsp;CustomerService&nbsp;方法执行后。 
  </div> 
  <h2> 总结 </h2> 
  <div>
    大部分的 Spring 开发者都只是实现了“环绕通知”，因为它可以对所有通知类型，但更好的做法应该是选择最合适的通知类型来满足要求。 
  </div> 
  <div> 
   <div>
     切入点 
   </div> 
   <div>
     在这个例子中，在一客户服务类中的所有方法都自动拦截(通知)。但在大多数情况下，可能需要使用
    <a target="_blank" href="http://www.yiibai.com/spring/spring-aop-example-pointcut-advisor/">切入点和Advisor</a>通过它的方法名拦截它的方法。 
   </div> 
  </div> 
  <div> 
   <br> 
  </div> 
  <div>
    下载代码 –&nbsp; 
  </div> 
 </div>
 <br>      
</div></body></html>