<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Spring AOP+AspectJ注解实例</h1><div style="width:100%;float:left;" class="article-content">   
 <div> 
  <div>
    在本教程中，我们将向你展示如何将AspectJ注解集成到Spring&nbsp;AOP框架。在这个Spring&nbsp;AOP+&nbsp;AspectJ&nbsp;示例中，让您轻松实现拦截方法。 
  </div> 
 </div> 
 <div> 
  <div>
    常见AspectJ的注解： 
  </div> 
  <ol> 
   <li> @Before&nbsp;–&nbsp;方法执行前运行 </li> 
   <li> @After&nbsp;–&nbsp;运行在方法返回结果后 </li> 
   <li> @AfterReturning&nbsp;–&nbsp;运行在方法返回一个结果后，在拦截器返回结果。 </li> 
   <li> @AfterThrowing&nbsp;–&nbsp;运行方法在抛出异常后， </li> 
   <li> @Around&nbsp;–&nbsp;围绕方法执行运行，结合以上这三个通知。 </li> 
  </ol> 
  <div>
    注意
   <br> 
   <div>
     Spring&nbsp;AOP 中没有 AspectJ 支持，请阅读&nbsp;
    <a target="_blank" href="http://www.yiibai.com/spring/spring-aop-examples-advice.html">内置 Spring&nbsp;AOP 例子</a>。 
   </div> 
  </div> 
  <h2> 1. 目录结构 </h2> 
  <div>
    看到这个例子的目录结构。
   <br> 
   <img src="/uploads/tutorial/20151227/1-15122H0213Q04.png" alt="">
   <br> 
  </div> 
  <div style="text-align:center;"> 
  </div> 
  <h2> 2. Spring Beans </h2> 
  <div>
    普通 bean 中有几个方法，后来通过 AspectJ 注解拦截。 
  </div> 
  <pre>package com.yiibai.customer.bo;

public interface CustomerBo {

	void addCustomer();
	
	String addCustomerReturnValue();
	
	void addCustomerThrowException() throws Exception;
	
	void addCustomerAround(String name);
}</pre> 
  <pre>package com.yiibai.customer.bo.impl;

import com.yiibai.customer.bo.CustomerBo;

public class CustomerBoImpl implements CustomerBo {

	public void addCustomer(){
		System.out.println("addCustomer() is running ");
	}
	
	public String addCustomerReturnValue(){
		System.out.println("addCustomerReturnValue() is running ");
		return "abc";
	}
	
	public void addCustomerThrowException() throws Exception {
		System.out.println("addCustomerThrowException() is running ");
		throw new Exception("Generic Error");
	}
	
	public void addCustomerAround(String name){
		System.out.println("addCustomerAround() is running, args : " + name);
	}
}</pre> 
  <h2> 4. 启用AspectJ </h2> 
  <div>
    在&nbsp;Spring&nbsp;配置文件，把“&lt;aop:aspectj-autoproxy&nbsp;/&gt;”，并定义Aspect(拦截)和普通的bean。 
  </div> 
  <p style="color:#333333;font-family:'Helvetica Neue', Helvetica,  font-size:16px;"> <em>File : applicationContext.xml</em> </p> 
  <pre>&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	xmlns:aop="http://www.springframework.org/schema/aop"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
	http://www.springframework.org/schema/aop 
	http://www.springframework.org/schema/aop/spring-aop-3.0.xsd "&gt;

	&lt;aop:aspectj-autoproxy /&gt;

	&lt;bean id="customerBo" class="com.yiibai.customer.bo.impl.CustomerBoImpl" /&gt;

	&lt;!-- Aspect --&gt;
	&lt;bean id="logAspect" class="com.yiibai.aspect.LoggingAspect" /&gt;

&lt;/beans&gt;</pre> 
  <h2> 4. AspectJ @Before </h2> 
  <div> 
   <div>
     在下面例子中，logBefore()方法将在&nbsp;customerBo接口的&nbsp;addCustomer()方法的执行之前被执行。 
   </div> 
  </div> 
  <div>
    AspectJ的“切入点”是用来声明哪种方法将被拦截，应该参考
   <a target="_blank" href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/aop.html#aop-pointcuts">Spring&nbsp;AOP切入点指南</a>，支持切入点表达式的完整列表。 
  </div> 
  <p style="color:#333333;font-family:'Helvetica Neue', Helvetica,  font-size:16px;"> <em>File : LoggingAspect.java</em> </p> 
  <pre>package com.yiibai.aspect;

import org.aspectj.lang.JoinYiibai;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect
public class LoggingAspect {

	@Before("execution(* com.yiibai.customer.bo.CustomerBo.addCustomer(..))")
	public void logBefore(JoinYiibai joinYiibai) {

		System.out.println("logBefore() is running!");
		System.out.println("hijacked : " + joinYiibai.getSignature().getName());
		System.out.println("******");
	}

}</pre> 
  <p> 运行 </p> 
  <pre>CustomerBo customer = (CustomerBo) appContext.getBean("customerBo");
customer.addCustomer();</pre> 
  <p> 输出结果 </p> 
  <pre>logBefore() is running!
hijacked : addCustomer
******
addCustomer() is running</pre> 
  <h2> 5. AspectJ @After </h2> 
  <div>
    在下面例子中，logAfter()方法将在&nbsp;customerBo&nbsp;接口的 addCustomer()方法的执行之后执行。 
  </div> 
  <p style="color:#333333;font-family:'Helvetica Neue', Helvetica,  font-size:16px;"> <em>File : LoggingAspect.java</em> </p> 
  <pre>package com.yiibai.aspect;

import org.aspectj.lang.JoinYiibai;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.After;

@Aspect
public class LoggingAspect {

	@After("execution(* com.yiibai.customer.bo.CustomerBo.addCustomer(..))")
	public void logAfter(JoinYiibai joinYiibai) {

		System.out.println("logAfter() is running!");
		System.out.println("hijacked : " + joinYiibai.getSignature().getName());
		System.out.println("******");

	}

}</pre> 
  <p> 运行它 </p> 
  <pre>CustomerBo customer = (CustomerBo) appContext.getBean("customerBo");
customer.addCustomer();</pre> 
  <p> 输出结果 </p> 
  <pre>addCustomer() is running 
logAfter() is running!
hijacked : addCustomer
******</pre> 
  <h2> 6. AspectJ @AfterReturning </h2> 
  <p> 在下面例子中，logAfterReturning()方法将在&nbsp;customerBo&nbsp;接口的addCustomerReturnValue()方法执行之后执行。此外，还可以截取返回的值使用“returning”属性。 </p> 
  <div>
    要截取返回的值，对“returning”属性(结果)的值必须用相同的方法参数(结果)。 
  </div> 
  <p style="color:#333333;font-family:'Helvetica Neue', Helvetica,  font-size:16px;"> <em>File : LoggingAspect.java</em> </p> 
  <pre>package com.yiibai.aspect;

import org.aspectj.lang.JoinYiibai;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterReturning;

@Aspect
public class LoggingAspect {

   @AfterReturning(
      pointcut = "execution(* com.yiibai.customer.bo.CustomerBo.addCustomerReturnValue(..))",
      returning= "result")
   public void logAfterReturning(JoinYiibai joinYiibai, Object result) {

	System.out.println("logAfterReturning() is running!");
	System.out.println("hijacked : " + joinYiibai.getSignature().getName());
	System.out.println("Method returned value is : " + result);
	System.out.println("******");
   }
}</pre> 
  <p> 运行它 </p>   
  <pre>CustomerBo customer = (CustomerBo) appContext.getBean("customerBo");
	customer.addCustomerReturnValue();</pre> 
  <p style="color:#333333;font-family:'Helvetica Neue', Helvetica,  font-size:16px;"> 输出结果 </p> 
  <pre>addCustomerReturnValue() is running 
logAfterReturning() is running!
hijacked : addCustomerReturnValue
Method returned value is : abc
******</pre> 
  <h2> 7. AspectJ @AfterReturning </h2> 
  <div>
    在下面的例子中，如果&nbsp;customerBo&nbsp;接口的addCustomerThrowException()方法抛出异常logAfterThrowing()方法将被执行。 
  </div> 
  <p style="color:#333333;font-family:'Helvetica Neue', Helvetica,  font-size:16px;"> <em>File : LoggingAspect.java</em> </p> 
  <pre>package com.yiibai.aspect;

import org.aspectj.lang.JoinYiibai;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterThrowing;

@Aspect
public class LoggingAspect {

   @AfterThrowing(
      pointcut = "execution(* com.yiibai.customer.bo.CustomerBo.addCustomerThrowException(..))",
      throwing= "error")
    public void logAfterThrowing(JoinYiibai joinYiibai, Throwable error) {

	System.out.println("logAfterThrowing() is running!");
	System.out.println("hijacked : " + joinYiibai.getSignature().getName());
	System.out.println("Exception : " + error);
	System.out.println("******");

    }
}</pre> 
  <p> 运行它 </p> 
  <pre>CustomerBo customer = (CustomerBo) appContext.getBean("customerBo");
customer.addCustomerThrowException();</pre> 
  <p> 输出结果 </p> 
  <pre>addCustomerThrowException() is running 
logAfterThrowing() is running!
hijacked : addCustomerThrowException
Exception : java.lang.Exception: Generic Error
******
Exception in thread "main" java.lang.Exception: Generic Error
	//...</pre> 
  <h2> 8. AspectJ @Around </h2> 
  <p> 在下面例子中，logAround()方法将在customerBo接口的addCustomerAround()方法执行之前执行，&nbsp;必须定义“joinYiibai.proceed();”&nbsp;控制何时拦截器返回控制到原来的addCustomerAround()方法。 </p> 
  <p style="color:#333333;font-family:'Helvetica Neue', Helvetica,  font-size:16px;"> <em>File : LoggingAspect.java</em> </p> 
  <pre>package com.yiibai.aspect;

import org.aspectj.lang.ProceedingJoinYiibai;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Around;

@Aspect
public class LoggingAspect {

   @Around("execution(* com.yiibai.customer.bo.CustomerBo.addCustomerAround(..))")
   public void logAround(ProceedingJoinYiibai joinYiibai) throws Throwable {

	System.out.println("logAround() is running!");
	System.out.println("hijacked method : " + joinYiibai.getSignature().getName());
	System.out.println("hijacked arguments : " + Arrays.toString(joinYiibai.getArgs()));
		
	System.out.println("Around before is running!");
	joinYiibai.proceed(); //continue on the intercepted method
	System.out.println("Around after is running!");
		
	System.out.println("******");

   }
	
}</pre> 
  <p style="color:#333333;font-family:'Helvetica Neue', Helvetica,  font-size:16px;"> 运行它 </p> 
  <pre>CustomerBo customer = (CustomerBo) appContext.getBean("customerBo");
customer.addCustomerAround("yiibai");</pre> 
  <p style="color:#333333;font-family:'Helvetica Neue', Helvetica,  font-size:16px;"> 输出结果 </p> 
  <pre class="prettyprint lang-bsh">logAround() is running!
hijacked method : addCustomerAround
hijacked arguments : [yiibai]
Around before is running!
addCustomerAround() is running, args : yiibai
Around after is running!
******</pre> 
  <h2> <span style="line-height:1.5;">总结</span> </h2> 
  <div>
    它总是建议采用最少 AspectJ 注解。这是关于Spring AspectJ 的一篇相当长的文章。进一步的解释和例子，请访问下面的参考链接。 
  </div> 
  <div> 
   <br> 
  </div> 
  <div>
    下载源代码 –&nbsp;
   <a target="_blank" href="http://pan.baidu.com/s/1boo4f9P">http://pan.baidu.com/s/1boo4f9P</a> 
  </div> 
 </div>
 <br>      
</div></body></html>