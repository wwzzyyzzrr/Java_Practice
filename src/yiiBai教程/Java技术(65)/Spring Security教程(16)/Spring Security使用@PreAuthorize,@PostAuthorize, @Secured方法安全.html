<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Spring Security使用@PreAuthorize,@PostAuthorize, @Secured方法安全</h1><div style="width:100%;float:left;" class="article-content">   
 <div>
   这篇教程文章中我们来学习 Spring&nbsp;
  <a target="_blank" href="mailto:Security4@PreAuthorize">Security使用 @PreAuthorize</a>，@PostAuthorize，@Secured和Spring&nbsp;EL表达式的方法级安全。 
 </div> 
 <div> 
  <div>
    为了使使用Spring的方法级别安全，我们需要用注释一个 @EnableGlobalMethodSecurity类在@Configuration，如下图所示： 
  </div> 
  <pre>package com.yiibai.springsecurity.configuration;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

	
	@Autowired
	public void configureGlobalSecurity(AuthenticationManagerBuilder auth) throws Exception {
		auth.inMemoryAuthentication().withUser("yiibai").password("123456").roles("USER");
		auth.inMemoryAuthentication().withUser("admin").password("123456").roles("ADMIN");
		auth.inMemoryAuthentication().withUser("dba").password("123456").roles("ADMIN","DBA");
	}
	
	@Override
	protected void configure(HttpSecurity http) throws Exception {
	  
	  http.authorizeRequests()
	  	.antMatchers("/", "/home").access("hasRole('USER') or hasRole('ADMIN') or hasRole('DBA')")
	  	.and().formLogin().loginPage("/login")
	  	.usernameParameter("ssoId").passwordParameter("password")
	  	.and().exceptionHandling().accessDeniedPage("/Access_Denied");
	}
}</pre> 
  <p> @EnableGlobalMethodSecurity 启用&nbsp;Spring Security 全局方法可以使用如下XML配置： </p> 
  <pre>&lt;beans:beans xmlns="http://www.springframework.org/schema/security"
    xmlns:beans="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd
    http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-4.0.xsd"&gt;
     
    &lt;http auto-config="true" &gt;
        &lt;intercept-url pattern="/"     access="hasRole('USER') or hasRole('ADMIN') and hasRole('DBA')" /&gt;
        &lt;intercept-url pattern="/home" access="hasRole('USER') or hasRole('ADMIN') and hasRole('DBA')" /&gt;
        &lt;form-login  login-page="/login" 
                     username-parameter="ssoId" 
                     password-parameter="password" 
                     authentication-failure-url="/Access_Denied" /&gt;
    &lt;/http&gt;
    
    &lt;global-method-security pre-post-annotations="enabled"/&gt;

    &lt;authentication-manager &gt;
        &lt;authentication-provider&gt;
            &lt;user-service&gt;
                &lt;user name="bill"  password="abc123"  authorities="ROLE_USER" /&gt;
                &lt;user name="admin" password="root123" authorities="ROLE_ADMIN" /&gt;
                &lt;user name="dba"   password="root123" authorities="ROLE_ADMIN,ROLE_DBA" /&gt;
            &lt;/user-service&gt;
        &lt;/authentication-provider&gt;
    &lt;/authentication-manager&gt;
    
&lt;/beans:beans&gt;</pre> 
  <div>
    需要注意的是@EnableGlobalMethodSecurity需要几个参数，如下所示： 
  </div> 
  <ul> 
   <li> prePostEnabled&nbsp;:确定&nbsp;Spring Security&nbsp;前置注释&nbsp;[@PreAuthorize,@PostAuthorize,..]&nbsp;是否应该启用； </li> 
   <li> secureEnabled&nbsp;:&nbsp;确定&nbsp;Spring Security 安全注释 [@Secured]&nbsp;是否应该启用； </li> 
   <li> jsr250Enabled&nbsp;:&nbsp;确定&nbsp;<a target="_blank" href="https://en.wikipedia.org/wiki/JSR_250">JSR-250注释</a>&nbsp;[@RolesAllowed..]&nbsp;是否应该启用； </li> 
  </ul> 
  <div>
    可以在同一应用程序启动一个以上的类型的注释，但只有一种类型用于接口或类的行为(在类的行为没有明确定义时)。如果找到两个注解适用于特定的方法，那么只有其中的一个被应用。 
  </div> 
  <div>
    我们将探讨上面两个提到细节。 
  </div> 
  <h4> @Secured </h4> 
  <p> @Secured注释是用来定义业务方法的安全性配置属性列表。您可以使用@Secured在方法上指定安全性要求[角色/权限等]，只有对应角色/权限的用户才可以调用这些方法。如果有人试图调用一个方法，但是不拥有所需的角色/权限，那会将会拒绝访问将引发异常。 </p> 
  <div>
    @Secured是从之前Spring版本中引入进来的。它有一个缺点(限制)就是不支持Spring&nbsp;EL表达式。考虑下面的例子： 
  </div> 
  <pre>package com.yiibai.springsecurity.service;

import org.springframework.security.access.annotation.Secured;


public interface UserService {

	List&lt;User&gt; findAllUsers();

	@Secured("ROLE_ADMIN")
	void updateUser(User user);

	@Secured({ "ROLE_DBA", "ROLE_ADMIN" })
	void deleteUser();
	
}</pre> 
  <div>
    在上面的例子中，UpdateUser方法可以由具有 Admin 角色的人调用，而deleteUser可以由DBA或管理员角色的人被调用。如果不拥有所需的角色而试图调用一个方法，那么将一个访问拒绝并将引发异常。 
  </div> 
  <div>
    如果你想要指定“AND”条件。想调用deleteUser方法同时拥有ADMIN和DBA角色的用户。这是不可能绕过&nbsp;@Secured&nbsp;注释的。 
  </div> 
  <div>
    这可以使用&nbsp;Spring&nbsp;新的&nbsp;@PreAuthorize/@PostAuthorize&nbsp;注解来支持&nbsp;Spring&nbsp;EL&nbsp;。 
  </div> 
  <h4> @PreAuthorize / @PostAuthorize </h4> 
  <div>
    Spring&nbsp;的&nbsp;@PreAuthorize/@PostAuthorize&nbsp;注解是首选应用到方法级安全性的方式，并支持Spring表达式语言，也提供基于表达式的访问控制。 
  </div> 
  <div>
    @PreAuthorize适合进入方法之前验证授权。&nbsp;@PreAuthorize可以兼顾，角色/登录用户权限，参数传递给方法等等。 
  </div> 
  <div>
    @PostAuthorize&nbsp;虽然不经常使用，检查授权方法之后才被执行，所以它适合用在对返回的值作验证授权。Spring&nbsp;EL提供可在表达式语言来访问并从方法返回&nbsp;returnObject&nbsp;对象来反映实际的对象。 
  </div> 
  <div>
    请参见常见
   <a target="_blank" href="http://docs.spring.io/spring-security/site/docs/4.0.1.RELEASE/reference/htmlsingle/#el-common-built-in">内置表达式</a>了解支持表达式的完整列表。让我们回到之前的例子，这一次使用&nbsp;@PreAuthorize/@PostAuthorize&nbsp;。 
  </div> 
  <pre>package com.yiibai.springsecurity.service;

import org.springframework.security.access.prepost.PostAuthorize;
import org.springframework.security.access.prepost.PreAuthorize;

import com.yiibai.springsecurity.model.User;


public interface UserService {

	List&lt;User&gt; findAllUsers();

	@PostAuthorize ("returnObject.type == authentication.name")
	User findById(int id);

	@PreAuthorize("hasRole('ADMIN')")
	void updateUser(User user);
	
	@PreAuthorize("hasRole('ADMIN') AND hasRole('DBA')")
	void deleteUser(int id);

}</pre> 
  <div>
    由于@PreAuthorize可以使用Spring表达式语言，任何条件可以很容易地使用EL来表示。deleteUser&nbsp;方法现在配置以通过同时拥有ADMIN和DBA角色的用户调用。 
  </div> 
  <div>
    此外，我们还在&nbsp;findById()方法上添加了注解&nbsp;@PostAuthorize&nbsp;。使用@PostAuthorize，从方法(用户对象)返回的值将是使用&nbsp;returnObject&nbsp;对象访问在Spring表达式语言中，并且返回用户对象的个别属性可以应用到一些安全规则。在这个例子中，我们要确保登录的用户只能得到它自己的用户类型对象。 
  </div> 
  <div>
    这是所有关于@Secured，@PreAuthorize，@PostAuthorize和EL的基本用法。 
  </div> 
  <div>
    以下在这个例子中要使用的服务实现，用户模型类和控制器等。代码如下所示 -&nbsp; 
  </div> 
  <pre>package com.yiibai.springsecurity.service;


import java.util.ArrayList;
import java.util.List;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.yiibai.springsecurity.model.User;

@Service("userService")
@Transactional
public class UserServiceImpl implements UserService{

	static List&lt;User&gt; users = new ArrayList&lt;User&gt;();
	
	static{
		users = populateUser();
	}
	
	public List&lt;User&gt; findAllUsers(){
		return users;
	}
	
	public User findById(int id){
		for(User u : users){
			if(u.getId()==id){
				return u;
			}
		}
		return null;
	}
	
	public void updateUser(User user) {
		System.out.println("Only an Admin can Update a User");
		User u = findById(user.getId());
		users.remove(u);
		u.setFirstName(user.getFirstName());
		u.setLastName(user.getLastName());
		u.setType(user.getType());
		users.add(u);
	}
	
	public void deleteUser(int id){
		User u = findById(id);
		users.remove(u);
	}
	
	private static List&lt;User&gt; populateUser(){
		List&lt;User&gt; users = new ArrayList&lt;User&gt;();
		users.add(new User(1,"Sam","Disilva","admin"));
		users.add(new User(2,"Kevin","Brayn","admin"));
		users.add(new User(3,"Nina","Conor","dba"));
		users.add(new User(4,"Tito","Menz","dba"));
		return users;
	}

}</pre>   
  <pre>public class User {

	private int id;
	
	private String firstName;
	
	private String lastName;
	
	private String type;

//getters/setters
}</pre> 
  <pre>package com.yiibai.springsecurity.controller;

import java.util.List;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler;
import org.springframework.stereotype.Controller;
import org.springframework.ui.ModelMap;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

import com.yiibai.springsecurity.model.User;
import com.yiibai.springsecurity.service.UserService;

@Controller
public class HelloWorldController {

	@Autowired
	UserService service;
	
    @RequestMapping(value = { "/", "/list" }, method = RequestMethod.GET)
    public String listAllUsers(ModelMap model) {
 
        List&lt;User&gt; users = service.findAllUsers();
        model.addAttribute("users", users);
        return "allusers";
    }
	
    @RequestMapping(value = { "/edit-user-{id}" }, method = RequestMethod.GET)
    public String editUser(@PathVariable int id, ModelMap model) {
        User user  = service.findById(id);
        model.addAttribute("user", user);
        model.addAttribute("edit", true);
        return "registration";
    }
    
    @RequestMapping(value = { "/edit-user-{id}" }, method = RequestMethod.POST)
    public String updateUser(User user, ModelMap model, @PathVariable int id) {
        service.updateUser(user);
        model.addAttribute("success", "User " + user.getFirstName()  + " updated successfully");
        return "success";
    }
    
    @RequestMapping(value = { "/delete-user-{id}" }, method = RequestMethod.GET)
    public String deleteUser(@PathVariable int id) {
        service.deleteUser(id);
        return "redirect:/list";
    }
    
	@RequestMapping(value = "/Access_Denied", method = RequestMethod.GET)
	public String accessDeniedPage(ModelMap model) {
		model.addAttribute("user", getPrincipal());
		return "accessDenied";
	}

	@RequestMapping(value = "/login", method = RequestMethod.GET)
	public String loginPage() {
		return "login";
	}

	@RequestMapping(value="/logout", method = RequestMethod.GET)
	public String logoutPage (HttpServletRequest request, HttpServletResponse response) {
		Authentication auth = SecurityContextHolder.getContext().getAuthentication();
		if (auth != null){    
			new SecurityContextLogoutHandler().logout(request, response, auth);
		}
		return "redirect:/login?logout";
	}

	private String getPrincipal(){
		String userName = null;
		Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();

		if (principal instanceof UserDetails) {
			userName = ((UserDetails)principal).getUsername();
		} else {
			userName = principal.toString();
		}
		return userName;
	}

}</pre> 
  <div>
    这个例子完整的代码附加在这篇文章的末尾。有需要练习或参考可自行下载(不收费)。 
  </div> 
  <h4> 
   <div>
     部署和运行 
   </div> </h4> 
  <div>
    下载并安装在帖子的末尾完整的示例代码。部署它到Servlet3.0容器(例如：Tomcat&nbsp;8.0.21)。 
  </div> 
  <p> 打开浏览器，并打开网址：http://localhost:8080/SpringSecurityMethodLevelSecurityAnnotation/,&nbsp;系统将提示您登录。 </p> 
  <p> <img src="/uploads/tutorial/20160823/160r3225545_1_937.png" alt=""> </p> 
  <div>
    提交后，您会看到一个用户列表。 
  </div> 
  <p> <img src="/uploads/tutorial/20160823/160r3225601_1_s1.png" alt=""> </p> 
  <div>
    现在尝试编辑或删除用户，你应该看到拒绝访问页面，因为此用户角色无权访问这些功能。 
  </div> 
  <p> <img src="/uploads/tutorial/20160823/160r3225620_1_k8.png" alt=""> </p> 
  <div>
    现在注销登录。重新使用&nbsp;admin&nbsp;角色的用户(admin / 123456)登录。 
  </div> 
  <p> <img src="/uploads/tutorial/20160823/160r3225638_1_3y.png" alt=""> </p> 
  <div>
    提交后，你会看到用户列表，如下图中所示 -&nbsp; 
  </div> 
  <p> <img src="/uploads/tutorial/20160823/160r3225a3_1_2b.png" alt=""> </p> 
  <div>
    现在点击编辑第一行[type='admin']。编辑页面应该出现。 
  </div> 
  <p> <img src="/uploads/tutorial/20160823/160r3225g0_1_9e.png" alt=""> </p> 
  <div>
    现在回到记录列表中，点击第三行[type&nbsp;=&nbsp;'dba']，如下所示 -&nbsp; 
  </div> 
  <p> <img src="/uploads/tutorial/20160823/160r3225h4_1_544.png" alt=""> </p> 
  <div>
    在执行编辑时访问拒绝，findById()函数调用了使用EL限制的&nbsp;@PostAuthorize注释，返回的对象只能与类型为['dba']一样的登录用户名才能操作。 
  </div> 
  <div>
    现在点击任何删除行应该会显示拒绝访问，因为只允许角色为“DBA”的用户才能删除用户。 
  </div> 
  <p> <img src="/uploads/tutorial/20160823/160r3225i9_1_914.png" alt=""> </p> 
  <div>
    现在注销，登录一个具有DBA角色的用户[dba，123456]，然后点击第一行的删除链接，这一行记录应该会被成功删除。其它更多的操作您可以试着去摸索。 
  </div> 
  <p> <img src="/uploads/tutorial/20160823/160r3225k7_1_p2.png" alt=""> </p> 
  <p> 就这么多，包教不包会。 </p> 
  <h4> 下载源代码 </h4> 
  <a target="_blank" href="http://share.weiyun.com/7beba97946f8ed117a9e43fd5665db9e">12-SpringSecurityMethodLevelSecurityAnnotation.zip</a>
  <br> 
  <h4> 参考 </h4> 
  <ul> 
   <li> <a target="_blank" href="http://docs.spring.io/spring-security/site/docs/4.0.1.RELEASE/reference/htmlsingle/#el-common-built-in">Spring Security表达式</a> </li> 
   <li> <a target="_blank" href="http://projects.spring.io/spring-security/">Spring Security工程页面</a> </li> 
   <li> <a target="_blank" href="http://docs.spring.io/spring-security/site/docs/4.0.1.RELEASE/reference/htmlsingle/">Spring Security 4 参考手册</a> </li> 
  </ul> 
  <div> 
   <div> 
    <br> 
   </div> 
  </div> 
 </div>
 <br>      
</div></body></html>