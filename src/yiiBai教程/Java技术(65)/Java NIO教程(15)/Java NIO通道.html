<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Java NIO通道</h1><div style="width:100%;float:left;" class="article-content">   
 <p>在Java NIO中，通道是用于在实体和字节缓冲区之间有效传输数据的介质。它从一个实体读取数据，并将其放在缓冲区块中以供消费。</p> 
 <p>通道作为Java NIO提供的网关来访问I/O机制。 通常，通道与操作系统文件描述符具有一对一关系，用于提供平台独立操作功能。</p> 
 <p>让我们来看看<code>java.nio.channels</code>类的层次结构：</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201709/2809/827080947_43814.png" alt=""></p> 
 <p>上述通道可以用于阻塞或非阻塞模式，但是我们主要关注在非阻塞模式下使用通道。</p> 
 <h2 id="h2-nio-"><a name="NIO通道基础" class="reference-link"></a><span class="header-link octicon octicon-link"></span>NIO通道基础</h2>
 <p>通道实现是使用本地代码执行实际工作。通道接口允许我们以便携和受控的方式访问低级I/O服务。</p> 
 <p>在层次结构的顶部，通道接口如下所示：</p> 
 <pre><code class="lang-java">package java.nio.channels;  
 public interface Channel{  
    public boolean isclose();  
    public void Open() throws IOException;  
}
</code></pre> 
 <p>正如在上述通道接口中看到的，所有通道只有两个常用操作：</p> 
 <ul> 
  <li>检查通道是否关闭(<code>isclose()</code>)</li>
  <li>打开关闭通道(<code>close()</code>)</li>
 </ul> 
 <h2 id="h2-u901Au9053u5B9Eu73B0"><a name="通道实现" class="reference-link"></a><span class="header-link octicon octicon-link"></span>通道实现</h2>
 <p>在Java NIO中，主要使用的通道如下：</p> 
 <ul> 
  <li><em>FileChannel</em>：文件通道用于从文件读取数据。它只能通过调用<code>getChannel()</code>方法来创建对象。不能直接创建<code>FileChannel</code>对象。<br>下面是一个创建<code>FileChannel</code>对象的例子：<pre><code class="lang-java">FileInputStream fis = new FileInputStream("D:\\file-read.txt"); // Path of Input text file  
ReadableByteChannel rbc = fis.getChannel();
</code></pre> </li>
  <li><em>DatagramChannel</em>：数据报通道可以通过UDP(用户数据报协议)通过网络读取和写入数据。它使用工厂方法来创建新对象。<br>下面是打开<code>DatagramChannel</code>的语法：<pre><code class="lang-java">DatagramChannel ch = DatagramChannel.open();
</code></pre> 用于关闭<code>DatagramChannel</code>的语法：<pre><code class="lang-java">DatagramChannel ch = DatagramChannel.close();
</code></pre> </li>
  <li><em>SocketChannel</em>：数据报通道可以通过TCP(传输控制协议)通过网络读取和写入数据。 它还使用工厂方法来创建新对象。<br>用于打开<code>SocketChannel</code>的语法：<pre><code class="lang-java">SocketChannel ch = SocketChannel.open();  
ch.connect(new InetSocketAddress("somehost", someport));
</code></pre> 用于关闭<code>SocketChannel</code>的语法：<pre><code class="lang-java">SocketChannel ch = SocketChannel.close();  
ch.connect(new InetSocketAddress("somehost", someport));
</code></pre> </li>
  <li><em>ServerSocketChannel</em>：<code>ServerSocketChannel</code>允许用户监听传入的TCP连接，与Web服务器相同。对于每个传入连接，都会为连接创建一个<code>SocketChannel</code>。<br>下面是打开<code>ServerSocketChannel</code>的语法：<pre><code class="lang-java">ServerSocketChannel ch = ServerSocketChannel.open();  
ch.socket().bind (new InetSocketAddress (somelocalport));
</code></pre> 下面是关闭<code>ServerSocketChannel</code>的语法：  <pre><code class="lang-java">ServerSocketChannel ch = ServerSocketChannel.close();  
ch.socket().bind (new InetSocketAddress (somelocalport));
</code></pre> </li>
 </ul> 
 <h2 id="h2-u57FAu672Cu901Au9053u793Au4F8B"><a name="基本通道示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>基本通道示例</h2>
 <p>下面来看看如何将数据从一个通道复制到另一个通道或从一个文件复制到另一个文件的示例：</p> 
 <pre><code class="lang-java">package com.yiibai;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.ReadableByteChannel;
import java.nio.channels.WritableByteChannel;

public class ChannelDemo {
    public static void main(String args[]) throws IOException {
        String relativelyPath = System.getProperty("user.dir");
        FileInputStream input = new FileInputStream(relativelyPath + "/testin.txt");
        ReadableByteChannel source = input.getChannel();
        FileOutputStream output = new FileOutputStream(relativelyPath + "/testout.txt");
        WritableByteChannel destination = output.getChannel();
        copyData(source, destination);
        source.close();
        destination.close();
        System.out.println("Copy Data finished.");
    }

    private static void copyData(ReadableByteChannel src, WritableByteChannel dest) throws IOException {
        ByteBuffer buffer = ByteBuffer.allocateDirect(20 * 1024);
        while (src.read(buffer) != -1) {
            // The buffer is used to drained
            buffer.flip();
            // keep sure that buffer was fully drained
            while (buffer.hasRemaining()) {
                dest.write(buffer);
            }
            buffer.clear(); // Now the buffer is empty, ready for the filling
        }
    }
}
</code></pre> 
 <p>执行上面示例代码，得到以下结果：</p> 
 <pre><code class="lang-shell">Copy Data finished.
</code></pre> 
 <p>上述程序将文本文件<code>filein.txt</code>的内容复制到另一个文本文件<code>fileout.txt</code>。</p>
 <br>      
</div></body></html>