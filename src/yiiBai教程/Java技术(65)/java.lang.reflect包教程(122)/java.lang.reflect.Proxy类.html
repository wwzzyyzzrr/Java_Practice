<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">java.lang.reflect.Proxy类</h1><div style="width:100%;float:left;" class="article-content">   
 <p><code>java.lang.reflect.Proxy</code>类提供用于创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理类的超类。</p> 
 <h2 id="h2-u7C7Bu58F0u660E"><a name="类声明" class="reference-link"></a><span class="header-link octicon octicon-link"></span>类声明</h2>
 <p>以下是<code>java.lang.reflect.Proxy</code>类的声明 -</p> 
 <pre><code class="lang-java">public class Proxy
   extends Object
      implements Serializable
</code></pre> 
 <h2 id="h2-u5B57u6BB5"><a name="字段" class="reference-link"></a><span class="header-link octicon octicon-link"></span>字段</h2>
 <p>以下是<code>java.lang.reflect.Proxy</code>类的字段 -</p> 
 <ul> 
  <li><em>protected InvocationHandler h</em> - 该代理实例调用的处理程序。</li>
 </ul> 
 <h2 id="h2-u6784u9020u51FDu6570"><a name="构造函数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>构造函数</h2>
 <table> 
  <thead> 
   <tr> 
    <th>序号</th> 
    <th>方法</th> 
    <th>描述</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>1</td> 
    <td>protected Proxy(InvocationHandler h)</td> 
    <td>从一个子类(通常是一个动态代理类)构造一个新的<code>Proxy</code>实例，并为其调用处理程序指定一个值。</td> 
   </tr> 
   <tr> 
    <td></td> 
    <td></td> 
   </tr> 
  </tbody> 
 </table> 
 <h2 id="h2-u7C7Bu65B9u6CD5"><a name="类方法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>类方法</h2>
 <table> 
  <thead> 
   <tr> 
    <th>序号</th> 
    <th>方法</th> 
    <th>描述</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>1</td> 
    <td><a target="_blank" href="http://www.yiibai.com/javareflect/javareflect_proxy_getinvocationhandler.html" title="static InvocationHandler getInvocationHandler(Object proxy)">static InvocationHandler getInvocationHandler(Object proxy)</a></td> 
    <td>返回指定代理实例的调用处理程序。</td> 
   </tr> 
   <tr> 
    <td>2</td> 
    <td><a target="_blank" href="http://www.yiibai.com/javareflect/javareflect_proxy_getproxyclass.html" title="static Class<?> getProxyClass(ClassLoader loader, Class<?>... interfaces)">static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;… interfaces)</a></td> 
    <td>给定类加载器和接口数组的代理类的<code>java.lang.Class</code>对象。</td> 
   </tr> 
   <tr> 
    <td>3</td> 
    <td><a target="_blank" href="http://www.yiibai.com/javareflect/javareflect_proxy_isproxyclass.html" title="static boolean isProxyClass(Class<?> cl)">static boolean isProxyClass(Class&lt;?&gt; cl)</a></td> 
    <td>当且仅当使用<code>getProxyClass</code>方法或<code>newProxyInstance</code>方法将指定的类动态生成为代理类时，才返回<code>true</code>。</td> 
   </tr> 
   <tr> 
    <td>4</td> 
    <td><a target="_blank" href="http://www.yiibai.com/javareflect/javareflect_proxy_newproxyinstance.html" title="static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)">static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</a></td> 
    <td>返回指定接口的代理类的实例，该接口将方法调用分派给指定的调用处理程序。</td> 
   </tr> 
  </tbody> 
 </table> 
 <h2 id="h2-u65B9u6CD5u7EE7u627F"><a name="方法继承" class="reference-link"></a><span class="header-link octicon octicon-link"></span>方法继承</h2>  
 <p>此类继承以下类的方法 -</p> 
 <ul> 
  <li><em>java.lang.Object</em></li>
 </ul>
 <br>      
</div></body></html>