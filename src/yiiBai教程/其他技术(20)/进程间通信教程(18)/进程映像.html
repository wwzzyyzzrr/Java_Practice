<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">进程映像</h1><div style="width:100%;float:left;" class="article-content">   
 <p>前面我们已经看到了如何获得进程及其父进程的基本信息，现在来查看进程/程序信息的细节。</p> 
 <p><strong>进程映像究竟是什么？</strong> 进程映像是执行程序时所需的可执行文件。 该图片通常包含以下部分 -</p> 
 <ul> 
  <li>代码段或文本段</li>
  <li>数据段</li>
  <li>堆栈段</li>
  <li>堆段</li>
 </ul> 
 <p>以下是进程映像的图形表示。参考下图 -<br><img src="http://www.yiibai.com/uploads/images/201802/0702/608210258_31611.jpg" alt=""></p> 
 <p><strong>代码段</strong>是由可执行指令组成的目标文件或程序虚拟地址空间的一部分。 这通常是只读数据段，具有固定的大小。</p> 
 <p>数据段有两种类型。分别如下所示 - </p> 
 <ul> 
  <li>初始化</li>
  <li>未初始化</li>
 </ul> 
 <p><strong>初始化</strong>的数据段是由初始化的静态变量和全局变量组成的目标文件或程序的虚拟地址空间的一部分。</p> 
 <p><strong>未初始化</strong>的数据段是由未初始化的静态变量和全局变量组成的目标文件或程序的虚拟地址空间的一部分。 未初始化的数据段也称为BSS(符号启动的块)段。</p> 
 <p><strong>数据段</strong>是可读写的，因为变量的值可以在运行期间更改。 这部分也有一个固定的大小。</p> 
 <p><strong>堆栈段</strong>是分配给自动变量和功能参数的内存区域。 它还在执行函数调用时存储返回地址。 堆栈使用LIFO(后进先出)机制存储本地或自动变量，函数参数和存储下一个地址或返回地址。 返回地址是指函数执行完成后返回的地址。 该段大小根据局部变量，函数参数和函数调用而变化。 该分部从较高的地址增长到较低的地址。</p> 
 <p><strong>堆段</strong>是分配给动态内存存储器的区域，例如<code>malloc()</code>和<code>calloc()</code>函数调用。 这个段的大小也是根据用户分配而变化的。 该分部从较低的地址增长到较高的地址。</p> 
 <p>现在来看几个示例程序段(数据段和bss段)的大小。 通过执行命令<code>size</code>已知分段大小。</p> 
 <h2 id="h2-u521Du59CBu7A0Bu5E8F"><a name="初始程序" class="reference-link"></a><span class="header-link octicon octicon-link"></span>初始程序</h2>
 <p>文件:<em>segment_size1.c</em> 代码如下所示 - </p> 
 <pre><code class="lang-cpp">#include&lt;stdio.h&gt;

int main() {
   printf("Hello World\n");
   return 0;
}
</code></pre> 
 <p>在下面的程序中，添加了一个未初始化的静态变量。未初始化的段(BSS)大小将增加<code>4</code>个字节。 <strong>注</strong> - 在Linux操作系统中，<code>int</code>的大小是<code>4</code>个字节。 整型数据类型的大小取决于编译器和操作系统的支持。</p> 
 <p><strong>文件:*</strong>segment_size2.c* - </p> 
 <pre><code class="lang-cpp">#include&lt;stdio.h&gt;

int main() {
   static int mystaticint1;
   printf("Hello World\n");
   return 0;
}
</code></pre> 
 <p>在下面的程序中，添加了一个初始化的静态变量。 这意味着初始化段(DATA)的大小会增加<code>4</code>个字节。</p> 
 <p><strong>文件:*</strong>segment_size3.c* - </p>   
 <pre><code class="lang-cpp">#include&lt;stdio.h&gt;

int main() {
   static int mystaticint1;
   static int mystaticint2 = 100;
   printf("Hello World\n");
   return 0;
}
</code></pre> 
 <p>在下面的程序中，添加了一个初始化的全局变量。 这意味着初始化段(DATA)的大小会增加4个字节。</p> 
 <p><strong>文件:*</strong>segment_size4.c* - </p> 
 <pre><code class="lang-cpp">#include&lt;stdio.h&gt;

int myglobalint1 = 500;
int main() {
   static int mystaticint1;
   static int mystaticint2 = 100;
   printf("Hello World\n");
   return 0;
}
</code></pre> 
 <p>在下面的程序中，添加了未初始化的全局变量。 这意味着未初始化的段(BSS)大小将增加4个字节。<br><strong>文件:*</strong>segment_size5.c* - </p> 
 <pre><code class="lang-cpp">#include&lt;stdio.h&gt;

int myglobalint1 = 500;
int myglobalint2;
int main() {
   static int mystaticint1;
   static int mystaticint2 = 100;
   printf("Hello World\n");
   return 0;
}
</code></pre> 
 <h2 id="h2-u6267u884Cu6B65u9AA4"><a name="执行步骤" class="reference-link"></a><span class="header-link octicon octicon-link"></span>执行步骤</h2>
 <p>编译 - </p> 
 <pre><code class="lang-shell">yiibai$ gcc segment_size1.c -o segment_size1
yiibai$ gcc segment_size2.c -o segment_size2
yiibai$ gcc segment_size3.c -o segment_size3
yiibai$ gcc segment_size4.c -o segment_size4
yiibai$ gcc segment_size5.c -o segment_size5
</code></pre> 
 <p>执行上面编译后的程序，得到以下结果 - </p> 
 <pre><code class="lang-shell">yiibai$ size segment_size1 segment_size2 segment_size3 segment_size4 segment_size5
   text  data  bss  dec  hex  filename
   878   252    8   1138 472  segment_size1 
   878   252   12   1142 476  segment_size2 
   878   256   12   1146 47a  segment_size3 
   878   260   12   1150 47e  segment_size4 
   878   260   16   1154 482  segment_size5
yiibai$
</code></pre>
 <br>      
</div></body></html>