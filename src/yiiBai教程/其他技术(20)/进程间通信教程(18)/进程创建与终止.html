<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">进程创建与终止</h1><div style="width:100%;float:left;" class="article-content">   
 <p>到目前为止，我们知道每当执行一个程序时，就会创建一个进程，并在执行完成后终止。 如果我们需要在程序中创建一个进程，并且可能希望为其安排不同的任务。 这可以实现吗？ 是的，显然是通过进程创建来实现。 当然，工作完成后进程会自动终止，或者根据需要终止。</p> 
 <p>过程创建是通过<code>fork()</code>系统调用实现的。 新创建的进程称为子进程，启动该进程的进程(或执行开始时的进程)称为父进程。 在<code>fork()</code>系统调用之后，现在有两个进程 - 父进程和子进程。 如何区分它们？ 非常简单，可通过它们的返回值来区分它们。<br><img src="http://www.yiibai.com/uploads/images/201802/0702/807090230_31045.jpg" alt=""></p> 
 <p>在创建子进程之后，让我们看看<code>fork()</code>系统调用细节。参考以下代码 - </p> 
 <pre><code class="lang-cpp">#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

pid_t fork(void);
</code></pre> 
 <p>创建子进程。 这个调用之后，有两个进程，现有的进程称为父进程，新创建的进程称为子进程。</p> 
 <p><code>fork()</code>系统调用返回三个值之一 -</p> 
 <ul> 
  <li>表示错误的负值，即创建子进程失败。</li>
  <li>子进程则返回一个零。</li>
  <li>父进程则返回正值。 该值是新创建的子进程的进程ID。</li>
 </ul> 
 <p>让我们来看看一个简单的程序。</p> 
 <pre><code class="lang-cpp">// File name: basicfork.c
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int main() {
   fork();
   printf("Called fork() system call\n");
   return 0;
}
</code></pre> 
 <h2 id="h2-u6267u884Cu6B65u9AA4"><a name="执行步骤" class="reference-link"></a><span class="header-link octicon octicon-link"></span>执行步骤</h2>
 <p><strong>编译</strong> - </p> 
 <pre><code class="lang-cpp">yiibai$ gcc basicfork.c -o basicfork
</code></pre> 
 <p>执行后输出结果如下 - </p> 
 <pre><code class="lang-shell">Called fork() system call
Called fork() system call
</code></pre> 
 <blockquote> 
  <p>注 - 通常在调用<code>fork()</code>之后，子进程和父进程将执行不同的任务。 如果需要运行相同的任务，那么对于每个<code>fork()</code>调用，它将运行<code>n</code>次，其中<code>n</code>是调用<code>fork()</code>的次数。</p> 
 </blockquote> 
 <p>在上面的情况下，<code>fork()</code>被调用一次，因此输出打印两次(2次幂)。 如果<code>fork()</code>被调用3次，那么输出将被打印8次(2的3次方)。 如果被称为5次，则打印32次，依此类推。</p> 
 <p>看到<code>fork()</code>创建子进程，就可以看到父进程和子进程的详细信息了。</p> 
 <p><strong>文件:</strong> <em>pids_after_fork.c</em> - </p> 
 <pre><code class="lang-cpp">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int main() {
   pid_t pid, mypid, myppid;
   pid = getpid();
   printf("Before fork: Process id is %d\n", pid);
   pid = fork();

   if (pid &lt; 0) {
      perror("fork() failure\n");
      return 1;
   }

   // Child process
   if (pid == 0) {
      printf("This is child process\n");
      mypid = getpid();
      myppid = getppid();
      printf("Process id is %d and PPID is %d\n", mypid, myppid);
   } else { // Parent process 
      sleep(2);
      printf("This is parent process\n");
      mypid = getpid();
      myppid = getppid();
      printf("Process id is %d and PPID is %d\n", mypid, myppid);
      printf("Newly created process id or child pid is %d\n", pid);
   }
   return 0;
}
</code></pre> 
 <p>编译和执行步骤 - </p>   
 <pre><code class="lang-shell">Before fork: Process id is 166629
This is child process
Process id is 166630 and PPID is 166629
Before fork: Process id is 166629
This is parent process
Process id is 166629 and PPID is 166628
Newly created process id or child pid is 166630
</code></pre> 
 <p>一个进程可以以两种方式之一终止 -</p> 
 <ul> 
  <li>异常情况下，发送某些信号时发生终止信号。</li>
  <li>通常，使用<code>_exit()</code>系统调用(或<code>_Exit()</code>系统调用)或<code>exit()</code>库函数。</li>
 </ul> 
 <p><code>_exit()</code>和<code>exit()</code>之间的区别主要是清理活动。 <code>exit()</code>在将控制权返回给内核之前做了一些清理，而<code>_exit()</code>(或<code>_Exit()</code>)会立即将控制权返回给内核。</p> 
 <p>考虑下面的<code>exit()</code>例子程序。</p> 
 <p><strong>文件:</strong> <em>atexit_sample.c</em> - </p> 
 <pre><code class="lang-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void exitfunc() {
   printf("Called cleanup function - exitfunc()\n");
   return;
}

int main() {
   atexit(exitfunc);
   printf("Hello, World!\n");
   exit (0);
}
</code></pre> 
 <p>编译和执行结果 - </p> 
 <pre><code class="lang-shell">Hello, World!
Called cleanup function - exitfunc()
</code></pre> 
 <p>考虑使用<code>_exit()</code>的以下示例程序。</p> 
 <p>文件名称:<em>at_exit_sample.c</em> - </p> 
 <pre><code class="lang-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

void exitfunc() {
   printf("Called cleanup function - exitfunc()\n");
   return;
}

int main() {
   atexit(exitfunc);
   printf("Hello, World!\n");
   _exit (0);
}
</code></pre> 
 <p>编译和执行结果 - </p> 
 <pre><code class="lang-shell">Hello, World!
</code></pre>
 <br>      
</div></body></html>