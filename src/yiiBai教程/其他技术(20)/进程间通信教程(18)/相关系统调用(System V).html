<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">相关系统调用(System V)</h1><div style="width:100%;float:left;" class="article-content">   
 <p>下表列出了各种系统调用及其描述。</p> 
 <table> 
  <thead> 
   <tr> 
    <th>分类</th> 
    <th>系统调用</th> 
    <th>描述</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>普通</td> 
    <td><code>open()</code></td> 
    <td>这个系统调用要么打开一个已经存在的文件，要么创建并打开一个新文件。</td> 
   </tr> 
   <tr> 
    <td>普通</td> 
    <td><code>creat()</code></td> 
    <td>创建并打开一个新文件。</td> 
   </tr> 
   <tr> 
    <td>普通</td> 
    <td><code>read()</code></td> 
    <td>将文件的内容读入所需的缓冲区。</td> 
   </tr> 
   <tr> 
    <td>普通</td> 
    <td><code>write()</code></td> 
    <td>将缓冲区的内容写入文件。</td> 
   </tr> 
   <tr> 
    <td>普通</td> 
    <td><code>close()</code></td> 
    <td>关闭文件描述符。</td> 
   </tr> 
   <tr> 
    <td>普通</td> 
    <td><code>stat()</code></td> 
    <td>提供有关文件的信息。</td> 
   </tr> 
   <tr> 
    <td>管道</td> 
    <td><code>pipe()</code></td> 
    <td>创建管道进行通信，返回两个文件描述符进行读取和写入。</td> 
   </tr> 
   <tr> 
    <td>命名管道或Fifo</td> 
    <td><code>mknod()</code></td> 
    <td>创建一个存储设备文件或特殊文件来创建FIFO</td> 
   </tr> 
   <tr> 
    <td>命名管道或Fifo</td> 
    <td><code>mkfifo()</code></td> 
    <td>创建一个新的FIFO</td> 
   </tr> 
   <tr> 
    <td>共享内存</td> 
    <td><code>shmget()</code></td> 
    <td>创建一个新的共享内存段或获取现有段的标识符。</td> 
   </tr> 
   <tr> 
    <td>共享内存</td> 
    <td><code>shmat()</code></td> 
    <td>附加共享内存段，并使该段成为调用进程的虚拟内存的一部分。</td> 
   </tr> 
   <tr> 
    <td>共享内存</td> 
    <td><code>shmdt()</code></td> 
    <td>分离共享内存段。</td> 
   </tr> 
   <tr> 
    <td>共享内存</td> 
    <td><code>shmctl()</code></td> 
    <td>对共享内存执行控制操作。 很少有对共享内存的通用控制操作是删除共享内存段(IPC_RMID)，接收共享内存信息(IPC_STAT)和更新现有共享内存(IPC_SET)的新值。</td> 
   </tr> 
   <tr> 
    <td>消息队列</td> 
    <td><code>msgget()</code></td> 
    <td>创建新的消息队列或访问已存在的消息队列，并获取句柄或标识符来执行有关消息队列的操作，如发送消息到队列以及从队列接收消息。</td> 
   </tr> 
   <tr> 
    <td>消息队列</td> 
    <td><code>msgsnd()</code></td> 
    <td>使用所需的识别编号将消息发送到所需的消息队列。</td> 
   </tr> 
   <tr> 
    <td>消息队列</td> 
    <td><code>msgrcv()</code></td> 
    <td>从消息队列接收消息。 默认情况下，这是无限等待操作，意味着调用将被阻塞，直到它收到一条消息。</td> 
   </tr> 
   <tr> 
    <td>消息队列</td> 
    <td><code>msgctl()</code></td> 
    <td>消息队列执行控制操作。 消息队列的通用控制操作很少是删除消息队列(IPC_RMID)，接收消息队列(IPC_STAT)的信息并更新现有消息队列(IPC_SET)的新值。</td> 
   </tr> 
   <tr> 
    <td>信号灯</td> 
    <td><code>semget()</code></td> 
    <td>创建新的信号量或获取现有信号量的标识符。 信号量用于执行同一对象上工作的各种IPC之间的同步。</td> 
   </tr> 
   <tr> 
    <td>信号灯</td> 
    <td><code>semop()</code></td> 
    <td>对信号量值执行信号量操作。 基本的信号量操作是获取或释放信号量的锁。</td> 
   </tr> 
   <tr> 
    <td>信号灯</td> 
    <td><code>semctl()</code></td> 
    <td>对信号量执行控制操作。 信号量的通用控制操作很少会去除信号量(IPC_RMID)，接收信号量信息(IPC_STAT)和更新现有信号量(IPC_SET)的新值。</td> 
   </tr> 
   <tr> 
    <td>信号灯</td> 
    <td><code>signal()</code></td> 
    <td>设置信号(信号编号)和信号处理程序的配置。 换句话说，注册该例程，该例程在引发该信号时执行。</td> 
   </tr> 
   <tr> 
    <td>信号灯</td> 
    <td><code>sigaction()</code></td> 
    <td>与<code>signal()</code>相同，设置信号的配置，即，在接收登记的信号之后按照登记的信号处理器执行特定的动作。 这个系统调用支持更好地控制<code>signal()</code>，例如阻塞某些信号，在调用信号处理程序后将信号动作恢复到默认状态，提供用户和系统消耗的时间，发送进程的进程ID等信息。</td> 
   </tr> 
   <tr> 
    <td>内存映射</td> 
    <td><code>mmap()</code></td> 
    <td>将文件映射到内存中。 一旦映射到内存中，访问文件就像使用地址访问数据一样简单，并且这样，调用也不像系统调用那样昂贵。</td> 
   </tr> 
   <tr> 
    <td>内存映射</td> 
    <td><code>munmap()</code></td> 
    <td>从内存中取消映射映射的文件。</td> 
   </tr> 
  </tbody> 
 </table>
 <br>      
</div></body></html>