<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">共享内存</h1><div style="width:100%;float:left;" class="article-content">   
 <p>共享内存是两个或多个进程共享的内存。 但是，为什么我们需要共享内存或其他通信方式呢？</p> 
 <p>重申一下，每个进程都有自己的地址空间，如果任何进程想要将自己的地址空间的某些信息与其他进程进行通信，那么只能通过IPC(进程间通信)技术进行。 我们已经知道，通信可以在相关或不相关的进程之间进行。</p> 
 <p>通常，使用管道或命名管道来执行相互关联的进程通信。 可以使用命名管道或通过共享内存和消息队列的常用IPC技术执行无关的进程(例如在一个终端中运行一个进程而在另一个终端中运行另一个进程)通信。</p> 
 <p>我们已经看到了管道和命名管道的IPC技术，现在来了解其他的IPC技术，即共享内存，消息队列，信号量，信号和内存映射。</p> 
 <p>在本章中，我们将会了解所有关于共享内存的知识。<br><img src="http://www.yiibai.com/uploads/images/201802/0802/127180222_68526.jpg" alt=""></p> 
 <p>我们知道，为了在两个或多个进程之间进行通信，使用共享内存。但是在使用共享内存之前，系统调用需要完成，让我们看看 -</p> 
 <ul> 
  <li>创建共享内存段或使用已经创建的共享内存段(<code>shmget()</code>)</li>
  <li>将进程附加到已经创建的共享内存段(<code>shmat()</code>)</li>
  <li>从已连接的共享内存段(<code>shmdt()</code>)中分离进程</li>
  <li>共享内存段上的控制操作(<code>shmctl()</code>)</li>
 </ul> 
 <p>让我们看看与共享内存有关的系统调用的一些细节。</p> 
 <pre><code class="lang-cpp">#include &lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;

int shmget(key_t key, size_t size, int shmflg)
</code></pre> 
 <p>上述系统调用将创建或分配一个System V共享内存段。 需要传递的参数如下 - </p> 
 <ul> 
  <li>第一个参数<code>key</code>用于识别共享内存段。<code>key</code>可以是任意值，也可以是来自库函数<code>ftok()</code>的值。 <code>key</code>也可以是<code>IPC_PRIVATE</code>，意思是运行进程作为服务器和客户机(父子关系)，即相互关联的进程通信。 如果客户端想用这个<code>key</code>来使用共享内存，那么它必须是服务器的子进程。 另外，子进程需要在父进程获得共享内存之后创建。</li>
  <li>第二个参数<code>size</code>是四舍五入<code>PAGE_SIZE</code>的倍数的共享内存段的大小。</li>
  <li>第三个参数<code>shmflg</code>指定所需的共享内存标志，例如<code>IPC_CREAT</code>(创建新段)或IPC_EXCL(与IPC_CREAT一起用于创建新段，如果段已经存在，则调用失败)。 还需要传递权限。</li>
 </ul> 
 <p><strong>注</strong> - 有关权限的详细信息，请参阅前面几节。</p> 
 <p>这个调用会在成功时返回一个有效的共享内存标识符(用于进一步调用共享内存)，在失败时返回<code>-1</code>。 要知道失败的原因，请查看<code>errno</code>变量或<code>perror(</code>)函数的值。</p> 
 <pre><code class="lang-cpp">#include &lt;sys/types.h&gt;
#include &lt;sys/shm.h&gt;

void * shmat(int shmid, const void *shmaddr, int shmflg)
</code></pre> 
 <p>上述系统调用为系统V共享内存段执行共享内存操作，即将共享内存段附加到调用进程的地址空间。 需要传递的参数如下 -</p> 
 <ul> 
  <li><p>第一个参数<code>shmid</code>是共享内存段的标识符。 这个<code>id</code>是共享内存标识符，它是<code>shmget()</code>系统调用的返回值。</p> </li>
  <li><p>第二个参数<code>shmaddr</code>是指定附加地址。 如果<code>shmaddr</code>为<code>NULL</code>，则系统默认选择合适的地址来附加分段。 如果<code>shmaddr</code>不是<code>NULL</code>并且在<code>shmflg</code>中指定了<code>SHM_RND</code>，那么<code>attach</code>等于SHMLBA(下边界地址)的最接近倍数的地址。 否则，<code>shmaddr</code>必须是共享内存附件发生/启动的页面对齐地址。</p> </li>
  <li>第三个参数<code>shmflg</code>指定所需的共享内存标志，例如<code>SHM_RND</code>(舍入到SHMLBA的地址)或SHM_EXEC(允许执行段的内容)或<code>SHM_RDONLY</code>(默认为只读目的附加段 它是可读写的)或SHM_REMAP(替换<code>shmaddr</code>指定范围内的现有映射并继续到段的结尾)。<br>这个调用会在成功时返回附加共享内存段的地址，在失败的情况下返回<code>-1</code>。 要知道失败的原因，请检查<code>errno</code>变量或<code>perror()</code>函数。</li>
 </ul> 
 <pre><code class="lang-cpp">#include &lt;sys/types.h&gt;
#include &lt;sys/shm.h&gt;

int shmdt(const void *shmaddr)
</code></pre> 
 <p>上述系统调用对共享内存段从调用进程地址空间中分离出来的System V共享内存段执行共享内存操作。需要传递的参数如下 -</p> 
 <ul> 
  <li>参数<code>shmaddr</code>是要分离的共享内存段的地址。待分离的段必须是由<code>shmat()</code>系统调用返回的地址。</li>
 </ul> 
 <p>这个调用在成功时将返回<code>0</code>，在失败的情况下为<code>-1</code>。 要知道失败的原因，请检查<code>errno</code>变量或<code>perror()</code>函数。</p> 
 <pre><code class="lang-cpp">#include &lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;

int shmctl(int shmid, int cmd, struct shmid_ds *buf)
</code></pre> 
 <p>上述系统调用对System V共享内存段进行控制操作。需要传递的参数如下 -</p> 
 <ul> 
  <li>第一个参数<code>shmid</code>是共享内存段的标识符。 这个<code>id</code>是共享内存标识符，它是<code>shmget()</code>系统调用的返回值。</li>
  <li>第二个参数<code>cmd</code>是对共享内存段执行所需控制操作的命令。<code>cmd</code>的有效值有 -
   <ul> 
    <li><code>IPC_STAT</code> - 将<code>struct shmid_ds</code>的每个成员的当前值的信息复制到由<code>buf</code>指向的传递的结构。 该命令需要对共享内存段的读取权限。</li>
    <li><code>IPC_SET</code> - 设置结构<code>buf</code>指向的用户ID，所有者的组ID，权限等。</li>
    <li><code>IPC_RMID</code> - 标记要销毁的段。 该段只有在最后一个进程分离后才被销毁。</li>
    <li><code>IPC_INFO</code> - 返回有关<code>buf</code>指向的结构中共享内存限制和参数的信息。</li>
    <li><code>SHM_INFO</code> - 返回一个<code>shm_info</code>结构，其中包含有关共享内存所消耗的系统资源的信息。</li>
   </ul> </li>
  <li>第三个参数<code>buf</code>是一个指向名为<code>struct shmid_ds</code>的共享内存结构的指针。 这个结构的值将被用于任一集或者按照<code>cmd</code>得到。</li>
 </ul> 
 <p>此调用根据传递的命令返回值。 在<code>IPC_INFO</code>和<code>SHM_INFO</code>或<code>SHM_STAT</code>成功之后，返回共享内存段的索引或标识符，或者返回其他操作的<code>0</code>，否则返回<code>-1</code>。 要知道失败的原因，请检查<code>errno</code>变量或<code>perror()</code>函数。</p> 
 <p>让我们考虑下面的示例程序。</p> 
 <ul> 
  <li>创建两个进程，一个用于写入共享内存(shm_write.c)，另一个用于从共享内存(shm_read.c)读取。</li>
  <li>程序通过写入过程(shm_write.c)执行写入共享内存，并通过读取过程(shm_read.c)从共享内存读取。</li>
  <li>在共享内存中，写入过程创建一个大小为1K(和标志)的共享内存并附加共享内存</li>
  <li>写入过程将每个1023个字节从’A’到’E’的字母写入共享存储器5次。 最后一个字节表示缓冲区的结束。</li>
  <li>读取过程将从共享内存读取并写入标准输出。</li>
  <li>读取和写入过程操作是同时执行的。</li>
  <li>写入完成后，写入过程将更新以指示写入共享内存的完成(在<code>struct shmseg</code>中具有完整变量)</li>
  <li>读取过程执行从共享内存中读取并显示在输出上，直到它得到写入过程完成的指示(<code>struct shmseg</code>中的完整变量)</li>
  <li>执行几次简单的读写过程，以避免无限循环和复杂的程序。</li>
 </ul> 
 <p>以下是写入过程的代码(写入共享内存 - 文件:<em>shm_write.c</em>)</p> 
 <pre><code class="lang-cpp">/* Filename: shm_write.c */
#include&lt;stdio.h&gt;
#include&lt;sys/ipc.h&gt;
#include&lt;sys/shm.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;string.h&gt;
#include&lt;errno.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;unistd.h&gt;
#include&lt;string.h&gt;

#define BUF_SIZE 1024
#define SHM_KEY 0x1234

struct shmseg {
   int cnt;
   int complete;
   char buf[BUF_SIZE];
};
int fill_buffer(char * bufptr, int size);

int main(int argc, char *argv[]) {
   int shmid, numtimes;
   struct shmseg *shmp;
   char *bufptr;
   int spaceavailable;
   shmid = shmget(SHM_KEY, sizeof(struct shmseg), 0644|IPC_CREAT);
   if (shmid == -1) {
      perror("Shared memory");
      return 1;
   }

   // Attach to the segment to get a pointer to it.
   shmp = shmat(shmid, NULL, 0);
   if (shmp == (void *) -1) {
      perror("Shared memory attach");
      return 1;
   }

   /* Transfer blocks of data from buffer to shared memory */
   bufptr = shmp-&gt;buf;
   spaceavailable = BUF_SIZE;
   for (numtimes = 0; numtimes &lt; 5; numtimes++) {
      shmp-&gt;cnt = fill_buffer(bufptr, spaceavailable);
      shmp-&gt;complete = 0;
      printf("Writing Process: Shared Memory Write: Wrote %d bytes\n", shmp-&gt;cnt);
      bufptr = shmp-&gt;buf;
      spaceavailable = BUF_SIZE;
      sleep(3);
   }
   printf("Writing Process: Wrote %d times\n", numtimes);
   shmp-&gt;complete = 1;

   if (shmdt(shmp) == -1) {
      perror("shmdt");
      return 1;
   }

   if (shmctl(shmid, IPC_RMID, 0) == -1) {
      perror("shmctl");
      return 1;
   }
   printf("Writing Process: Complete\n");
   return 0;
}

int fill_buffer(char * bufptr, int size) {
   static char ch = 'A';
   int filled_count;

   //printf("size is %d\n", size);
   memset(bufptr, ch, size - 1);
   bufptr[size-1] = '\0';
   if (ch &gt; 122)
   ch = 65;
   if ( (ch &gt;= 65) &amp;&amp; (ch &lt;= 122) ) {
      if ( (ch &gt;= 91) &amp;&amp; (ch &lt;= 96) ) {
         ch = 65;
      }
   }
   filled_count = strlen(bufptr);

   //printf("buffer count is: %d\n", filled_count);
   //printf("buffer filled is:%s\n", bufptr);
   ch++;
   return filled_count;
}
</code></pre> 
 <p>编译并执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">Writing Process: Shared Memory Write: Wrote 1023 bytes
Writing Process: Shared Memory Write: Wrote 1023 bytes
Writing Process: Shared Memory Write: Wrote 1023 bytes
Writing Process: Shared Memory Write: Wrote 1023 bytes
Writing Process: Shared Memory Write: Wrote 1023 bytes
Writing Process: Wrote 5 times
Writing Process: Complete
</code></pre> 
 <p>以下是读取过程的代码(从共享内存读取并写入标准输出 - 文件:<em>shm_read.c</em>)</p>   
 <pre><code class="lang-cpp">/* Filename: shm_read.c */
#include&lt;stdio.h&gt;
#include&lt;sys/ipc.h&gt;
#include&lt;sys/shm.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;string.h&gt;
#include&lt;errno.h&gt;
#include&lt;stdlib.h&gt;

#define BUF_SIZE 1024
#define SHM_KEY 0x1234

struct shmseg {
   int cnt;
   int complete;
   char buf[BUF_SIZE];
};

int main(int argc, char *argv[]) {
   int shmid;
   struct shmseg *shmp;
   shmid = shmget(SHM_KEY, sizeof(struct shmseg), 0644|IPC_CREAT);
   if (shmid == -1) {
      perror("Shared memory");
      return 1;
   }

   // Attach to the segment to get a pointer to it.
   shmp = shmat(shmid, NULL, 0);
   if (shmp == (void *) -1) {
      perror("Shared memory attach");
      return 1;
   }

   /* Transfer blocks of data from shared memory to stdout*/
   while (shmp-&gt;complete != 1) {
      printf("segment contains : \n\"%s\"\n", shmp-&gt;buf);
      if (shmp-&gt;cnt == -1) {
         perror("read");
         return 1;
      }
      printf("Reading Process: Shared Memory: Read %d bytes\n", shmp-&gt;cnt);
      sleep(3);
   }
   printf("Reading Process: Reading Done, Detaching Shared Memory\n");
   if (shmdt(shmp) == -1) {
      perror("shmdt");
      return 1;
   }
   printf("Reading Process: Complete\n");
   return 0;
}
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">segment contains :
"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
Reading Process: Shared Memory: Read 1023 bytes
segment contains :
"BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"
Reading Process: Shared Memory: Read 1023 bytes
segment contains :
"CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC"
Reading Process: Shared Memory: Read 1023 bytes
segment contains :
"DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD"
Reading Process: Shared Memory: Read 1023 bytes
segment contains :
"EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE"
Reading Process: Shared Memory: Read 1023 bytes
Reading Process: Reading Done, Detaching Shared Memory
Reading Process: Complete
</code></pre>
 <br>      
</div></body></html>