<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">信号</h1><div style="width:100%;float:left;" class="article-content">   
 <p>信号是指示事件发生的进程的通知。 信号也被称为软件中断，不可预测知道它的发生，因此它也被称为异步事件。</p> 
 <p>信号可以用数字或名称来指定，通常信号名称以SIG开头。 可用的信号可以用命令<code>kill -l</code>(l列出信号名称)来检查，如下所示 -<br><img src="http://www.yiibai.com/uploads/images/201802/0802/749090216_41485.jpg" alt="信号"></p> 
 <p>无论何时发出信号(以编程方式或系统产生的信号)，都会执行默认操作。 如果您不想执行默认操作但希望在接收信号时执行自己的操作。 可以处理信号，但不能处理所有的信号。 如果你想忽略信号，这是可能的吗？ 这是可以忽略信号。 忽略信号意味着既不执行默认操作也不处理信号。 可以忽略或处理几乎所有的信号。 <code>SIGSTOP</code>和<code>SIGKILL</code>不能被忽略或处理/捕获的信号。</p> 
 <p>总之，对信号执行的操作如下 -</p> 
 <ul> 
  <li>默认操作</li>
  <li>处理信号</li>
  <li>忽略信号</li>
 </ul> 
 <p>正如所讨论的，信号可以被处理，改变默认行为的执行。 信号处理可以通过系统调用，<code>signal()</code>和<code>sigaction()</code>两种方式完成。</p> 
 <pre><code class="lang-cpp">#include &lt;signal.h&gt;

typedef void (*sighandler_t) (int);
sighandler_t signal(int signum, sighandler_t handler);
</code></pre> 
 <p>系统调用<code>signal()</code>将在符号中提到的信号产生时调用注册的处理程序。 处理程序可以是SIG_IGN(忽略信号)，SIG_DFL(将信号设置回默认机制)或用户定义的信号处理程序或函数地址之一。</p> 
 <p>这个系统调用成功返回一个函数的地址，该函数接受一个整数参数并且没有返回值。 这个调用在出错的时候返回<code>SIG_ERR</code>。</p> 
 <p>虽然<code>signal()</code>可以调用用户注册的各自的信号处理程序，但是不可能进行微调，例如掩蔽应该被阻塞的信号，修改信号的行为以及其他功能。 这可以使用<code>sigaction()</code>系统调用。</p> 
 <pre><code class="lang-cpp">#include &lt;signal.h&gt;

int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact)
</code></pre> 
 <p>这个系统调用用于检查或改变信号动作。 如果行为不为空，则从行为安装信号的新行为。 如果<code>oldact</code>不为<code>null</code>，则以前的操作将保存在<code>oldact</code>中。</p> 
 <p><code>sigaction</code>结构包含以下字段 -</p> 
 <p><strong>字段1</strong> - 处理程序在<code>sa_handler</code>或<code>sa_sigaction</code>中提到。</p> 
 <pre><code class="lang-cpp">void (*sa_handler)(int);
void (*sa_sigaction)(int, siginfo_t *, void *);
</code></pre> 
 <p><code>sa_handler</code>的处理程序指定要根据<code>signum</code>和<code>SIG_DFL</code>指示默认操作执行的操作，或者<code>SIG_IGN</code>忽略指向信号处理函数的信号或指针。<br><code>sa_sigaction</code>的处理程序将信号编号指定为第一个参数，将指向<code>siginfo_t</code>结构体的指针指定为第二个参数，并指定用户上下文(有关详细信息，请参阅<code>getcontext()</code>或<code>setcontext()</code>)作为第三个参数。</p> 
 <p><code>siginfo_t</code>结构包含信号信息，例如要传递的信号数量，信号值，进程ID，发送进程的真实用户ID等。</p> 
 <p><strong>字段2</strong> - 要阻止的信号集。</p> 
 <pre><code class="lang-cpp">int sa_mask;
</code></pre> 
 <p>这个变量指定了信号处理程序执行期间应该被阻塞的信号掩码。</p> 
 <p><strong>字段3</strong> - 特殊标志。</p> 
 <pre><code class="lang-cpp">int sa_flags;
</code></pre> 
 <p>该字段指定一组修改信号行为的标志。</p> 
 <p><strong>字段4</strong> - 恢复处理程序。</p> 
 <pre><code class="lang-cpp">void (*sa_restorer) (void);
</code></pre> 
 <p>这个系统调用在成功时返回<code>0</code>，在失败的情况下为<code>-1</code>。</p> 
 <p>让我们考虑一些示例程序。</p> 
 <p>首先，从一个生成异常的示例程序开始。 在这个程序中，试图执行除零运算，这会使系统产生一个异常。</p> 
 <pre><code class="lang-cpp">/* signal_fpe.c */
#include&lt;stdio.h&gt;

int main() {
   int result;
   int v1, v2;
   v1 = 121;
   v2 = 0;
   result = v1/v2;
   printf("Result of Divide by Zero is %d\n", result);
   return 0;
}
</code></pre> 
 <p>编译和运行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-cpp">Floating point exception (core dumped)
</code></pre> 
 <p>因此，当试图执行一个算术运算时，系统已经产生了一个浮点异常，核心转储是信号的默认操作。</p> 
 <p>现在，修改代码以使用<code>signal()</code>系统调用来处理这个特定的信号。</p> 
 <pre><code class="lang-cpp">/* signal_fpe_handler.c */
#include&lt;stdio.h&gt;
#include&lt;signal.h&gt;
#include&lt;stdlib.h&gt;

void handler_dividebyzero(int signum);

int main() {
   int result;
   int v1, v2;
   void (*sigHandlerReturn)(int);
   sigHandlerReturn = signal(SIGFPE, handler_dividebyzero);
   if (sigHandlerReturn == SIG_ERR) {
      perror("Signal Error: ");
      return 1;
   }
   v1 = 121;
   v2 = 0;
   result = v1/v2;
   printf("Result of Divide by Zero is %d\n", result);
   return 0;
}

void handler_dividebyzero(int signum) {
   if (signum == SIGFPE) {
      printf("Received SIGFPE, Divide by Zero Exception\n");
      exit (0);
   } 
   else
      printf("Received %d Signal\n", signum);
      return;
}
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">Received SIGFPE, Divide by Zero Exception
</code></pre> 
 <p>正如所讨论的那样，信号是由系统产生的(在执行某些操作(例如除以零等)时)，或者用户也可以以编程方式产生信号。 如果要以编程方式生成信号，请使用库函数<code>raise()</code>。</p> 
 <p>现在，另外一个程序来演示处理和忽略信号。</p> 
 <p>假设用<code>raise()</code>发出了一个信号，那么会发生什么？ 发出信号后，当前进程的执行停止。 那么停止的过程会发生什么？ 可以有两种情况 - 首先，在需要时继续执行。 其次，终止(用kill命令)这个进程。</p> 
 <p>要继续执行已停止的进程，请将SIGCONT发送到该特定进程。 也可以发出fg(前景)或bg(后台)命令来继续执行。 在这里，这些命令只会重新开始执行最后一个进程。 如果多个进程停止，则只有最后一个进程被恢复。 如果想恢复先前停止的过程，请使用<code>fg/bg</code>和作业编号恢复作业。</p> 
 <p>下面的程序用于使用<code>raise()</code>函数来提升信号SIGSTOP。 信号SIGSTOP也可以由用户按下CTRL + Z(Ctrl + Z)键生成。 发出此信号后，程序将停止执行。 发送信号(SIGCONT)继续执行。</p> 
 <p>在下面的例子中，使用命令<code>fg</code>重新开始停止的进程。</p> 
 <pre><code class="lang-cpp">/* signal_raising.c */
#include&lt;stdio.h&gt;
#include&lt;signal.h&gt;
#include&lt;stdlib.h&gt;

int main() {
   printf("Testing SIGSTOP\n");
   raise(SIGSTOP);
   return 0;
}
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">Testing SIGSTOP
[1]+ Stopped ./a.out
./a.out
</code></pre> 
 <p>现在，增强以前的程序，通过从另一个终端发出SIGCONT来继续执行停止的进程。</p> 
 <pre><code class="lang-cpp">/* signal_stop_continue.c */
#include&lt;stdio.h&gt;
#include&lt;signal.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

void handler_sigtstp(int signum);

int main() {
   pid_t pid;
   printf("Testing SIGSTOP\n");
   pid = getpid();
   printf("Open Another Terminal and issue following command\n");
   printf("kill -SIGCONT %d or kill -CONT %d or kill -18 %d\n", pid, pid, pid);
   raise(SIGSTOP);
   printf("Received signal SIGCONT\n");
   return 0;
}
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">Testing SIGSTOP
Open Another Terminal and issue following command
kill -SIGCONT 30379 or kill -CONT 30379 or kill -18 30379
[1]+ Stopped ./a.out

Received signal SIGCONT
[1]+ Done ./a.out
</code></pre> 
 <p>在另一个终端执行 - </p> 
 <pre><code class="lang-shell">kill -SIGCONT 30379
</code></pre> 
 <p>到目前为止，我们已经看到了处理系统产生的信号的程序。 现在让我们看看通过程序产生的信号(使用<code>raise()</code>函数或者通过kill命令)。 该程序产生信号SIGTSTP(终端停止)，其默认动作是停止执行。 但是，由于现在正在处理信号，而不是默认的动作，它会来到定义的处理程序。 在这种情况下，只是打印消息并退出。</p> 
 <pre><code class="lang-cpp">/* signal_raising_handling.c */
#include&lt;stdio.h&gt;
#include&lt;signal.h&gt;
#include&lt;stdlib.h&gt;

void handler_sigtstp(int signum);

int main() {
   void (*sigHandlerReturn)(int);
   sigHandlerReturn = signal(SIGTSTP, handler_sigtstp);
   if (sigHandlerReturn == SIG_ERR) {
      perror("Signal Error: ");
      return 1;
   }
   printf("Testing SIGTSTP\n");
   raise(SIGTSTP);
   return 0;
}

void handler_sigtstp(int signum) {
   if (signum == SIGTSTP) {
      printf("Received SIGTSTP\n");
      exit(0);
   }
   else
      printf("Received %d Signal\n", signum);
      return;
}
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">Testing SIGTSTP
Received SIGTSTP
</code></pre> 
 <p>已经看到了执行默认操作或处理信号的情况。 现在是时候忽略这个信号了。 在这个示例程序中，通过SIG_IGN注册信号SIGTSTP忽略，然后发送信号SIGTSTP(终端停止)。 当信号SIGTSTP正在被生成，将被忽略。参考以下代码 - </p> 
 <pre><code class="lang-cpp">/* signal_raising_ignoring.c */
#include&lt;stdio.h&gt;
#include&lt;signal.h&gt;
#include&lt;stdlib.h&gt;

void handler_sigtstp(int signum);

int main() {
   void (*sigHandlerReturn)(int);
   sigHandlerReturn = signal(SIGTSTP, SIG_IGN);
   if (sigHandlerReturn == SIG_ERR) {
      perror("Signal Error: ");
      return 1;
   }
   printf("Testing SIGTSTP\n");
   raise(SIGTSTP);
   printf("Signal SIGTSTP is ignored\n");
   return 0;
}
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p>   
 <pre><code class="lang-shell">Testing SIGTSTP
Signal SIGTSTP is ignored
</code></pre> 
 <p>到目前为止，我们已经观察到，一个信号处理程序用来处理一个信号。 那么一个信号可以处理多个信号吗？ 答案是肯定的 让我们通过一个程序来实现。</p> 
 <p>以下程序执行以下操作 -</p> 
 <p><strong>第1步</strong> - 注册一个处理程序(handleSignals)来捕获或处理信号SIGINT(CTRL + C)或SIGQUIT(CTRL + )</p> 
 <p><strong>第2步</strong> - 如果用户产生信号SIGQUIT(或者通过kill命令或者用CTRL + \键盘控制)，处理程序简单地将消息打印为返回。</p> 
 <p><strong>第3步</strong> - 如果用户第一次生成信号SIGINT(通过kill命令或者使用CTRL + C的键盘控制)，则修改信号从下次开始执行默认操作(使用SIG_DFL)。</p> 
 <p><strong>第4步</strong> - 如果用户第二次生成信号SIGINT，则执行默认操作，即程序终止。</p> 
 <pre><code class="lang-cpp">/* Filename: sigHandler.c */
#include&lt;stdio.h&gt;
#include&lt;unistd.h&gt;
#include&lt;signal.h&gt;

void handleSignals(int signum);

int main(void) {
   void (*sigHandlerInterrupt)(int);
   void (*sigHandlerQuit)(int);
   void (*sigHandlerReturn)(int);
   sigHandlerInterrupt = sigHandlerQuit = handleSignals;
   sigHandlerReturn = signal(SIGINT, sigHandlerInterrupt);
   if (sigHandlerReturn == SIG_ERR) {
      perror("signal error: ");
      return 1;
   }
   sigHandlerReturn = signal(SIGQUIT, sigHandlerQuit);

   if (sigHandlerReturn == SIG_ERR) {
      perror("signal error: ");
      return 1;
   }
   while (1) {
      printf("\nTo terminate this program, perform the following: \n");
      printf("1. Open another terminal\n");
      printf("2. Issue command: kill %d or issue CTRL+C 2 times (second time it terminates)\n", getpid());
      sleep(10);
   }
   return 0;
}

void handleSignals(int signum) {
   switch(signum) {
      case SIGINT:
      printf("\nYou pressed CTRL+C \n");
      printf("Now reverting SIGINT signal to default action\n");
      signal(SIGINT, SIG_DFL);
      break;
      case SIGQUIT:
      printf("\nYou pressed CTRL+\\ \n");
      break;
      default:
      printf("\nReceived signal number %d\n", signum);
      break;
   }
   return;
}
</code></pre> 
 <p>编译和执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">To terminate this program, perform the following:
1. Open another terminal
2. Issue command: kill 74 or issue CTRL+C 2 times (second time it terminates)
^C
You pressed CTRL+C
Now reverting SIGINT signal to default action

To terminate this program, perform the following:
1. Open another terminal
2. Issue command: kill 74 or issue CTRL+C 2 times (second time it terminates)
^\You pressed CTRL+\
To terminate this program, perform the following:
1. Open another terminal
2. Issue command: kill 120
Terminated
</code></pre> 
 <p>在另一个终端中执行 - </p> 
 <pre><code class="lang-shell">kill 71
</code></pre> 
 <p>第二种方法 - </p> 
 <pre><code class="lang-shell">To terminate this program, perform the following:
1. Open another terminal
2. Issue command: kill 71 or issue CTRL+C 2 times (second time it terminates)
^C
You pressed CTRL+C
Now reverting SIGINT signal to default action

To terminate this program, perform the following:
1. Open another terminal
2. Issue command: kill 71 or issue CTRL+C 2 times (second time it terminates)
^C
</code></pre> 
 <p>我们知道要处理一个信号，有两个系统调用，即<code>signal()</code>或<code>sigaction()</code>。 直到现在我们已经看到了<code>signal()</code>系统调用，现在是时候进行<code>sigaction()</code>系统调用了。 让我们修改上面的程序来执行使用<code>sigaction()</code>，如下所示 -</p> 
 <pre><code class="lang-cpp">/* Filename: sigHandlerSigAction.c */
#include&lt;stdio.h&gt;
#include&lt;unistd.h&gt;
#include&lt;signal.h&gt;

void handleSignals(int signum);

int main(void) {
   void (*sigHandlerReturn)(int);
   struct sigaction mysigaction;
   mysigaction.sa_handler = handleSignals;
   sigemptyset(&amp;mysigaction.sa_mask);
   mysigaction.sa_flags = 0;
   sigaction(SIGINT, &amp;mysigaction, NULL);

   if (mysigaction.sa_handler == SIG_ERR) {
      perror("signal error: ");
      return 1;
   }
   mysigaction.sa_handler = handleSignals;
   sigemptyset(&amp;mysigaction.sa_mask);
   mysigaction.sa_flags = 0;
   sigaction(SIGQUIT, &amp;mysigaction, NULL);

   if (mysigaction.sa_handler == SIG_ERR) {
      perror("signal error: ");
      return 1;
   }
   while (-1) {
      printf("\nTo terminate this program, perform either of the following: \n");
      printf("1. Open another terminal and issue command: kill %d\n", getpid());
      printf("2. Issue CTRL+C 2 times (second time it terminates)\n");
      sleep(10);
   }
   return 0;
}

void handleSignals(int signum) {
   switch(signum) {
      case SIGINT:
      printf("\nYou have entered CTRL+C \n");
      printf("Now reverting SIGINT signal to perform default action\n");
      signal(SIGINT, SIG_DFL);
      break;
      case SIGQUIT:
      printf("\nYou have entered CTRL+\\ \n");
      break;
      default:
      printf("\nReceived signal number %d\n", signum);
      break;
   }
   return;
}
</code></pre> 
 <p>让我们编译和执行上面的代码。 在执行过程中，按<strong>CTRL + C</strong>两次，其余的检查/方式(如上)来尝试执行这个程序。</p> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">To terminate this program, perform either of the following:
1. Open another terminal and issue command: kill 3199
2. Issue CTRL+C 2 times (second time it terminates)
^C
You have entered CTRL+C
Now reverting SIGINT signal to perform default action
To terminate this program, perform either of the following:
1. Open another terminal and issue command: kill 3199
2. Issue CTRL+C 2 times (second time it terminates)
^C
</code></pre>
 <br>      
</div></body></html>