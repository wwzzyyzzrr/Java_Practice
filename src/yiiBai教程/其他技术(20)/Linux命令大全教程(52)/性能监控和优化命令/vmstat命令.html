<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">vmstat命令</h1><div style="width:100%;float:left;" class="article-content">   
 <p><strong>vmstat</strong>是Virtual Meomory Statistics(虚拟内存统计)的缩写，可对操作系统的虚拟内存、进程、CPU活动进行监控。他是对系统的整体情况进行统计，不足之处是无法对某个进程进行深入分析。<strong>vmstat</strong> 工具提供了一种低开销的系统性能观察方式。因为 <strong>vmstat</strong> 本身就是低开销工具，在非常高负荷的服务器上，需要查看并监控系统的健康情况,在控制窗口还是能够使用<strong>vmstat</strong> 输出结果。在学习<strong>vmstat</strong>命令前，我们先了解一下Linux系统中关于物理内存和虚拟内存相关信息。</p> 
 <p><strong>物理内存和虚拟内存区别：</strong><br>我们知道，直接从物理内存读写数据要比从硬盘读写数据要快的多，因此，我们希望所有数据的读取和写入都在内存完成，而内存是有限的，这样就引出了物理内存与虚拟内存的概念。<br>物理内存就是系统硬件提供的内存大小，是真正的内存，相对于物理内存，在linux下还有一个虚拟内存的概念，虚拟内存就是为了满足物理内存的不足而提出的策略，它是利用磁盘空间虚拟出的一块逻辑内存，用作虚拟内存的磁盘空间被称为交换空间(Swap Space)。<br>作为物理内存的扩展，linux会在物理内存不足时，使用交换分区的虚拟内存，更详细的说，就是内核会将暂时不用的内存块信息写到交换空间，这样以来，物理内存得到了释放，这块内存就可以用于其它目的，当需要用到原始的内容时，这些信息会被重新从交换空间读入物理内存。<br>linux的内存管理采取的是分页存取机制，为了保证物理内存能得到充分的利用，内核会在适当的时候将物理内存中不经常使用的数据块自动交换到虚拟内存中，而将经常使用的信息保留到物理内存。</p> 
 <p>要深入了解linux内存运行机制，需要知道下面提到的几个方面：<br><strong>首先</strong>，Linux系统会不时的进行页面交换操作，以保持尽可能多的空闲物理内存，即使并没有什么事情需要内存，Linux也会交换出暂时不用的内存页面。这可以避免等待交换所需的时间。<br><strong>其次</strong>，linux进行页面交换是有条件的，不是所有页面在不用时都交换到虚拟内存，linux内核根据”最近最经常使用“算法，仅仅将一些不经常使用的页面文件交换到虚拟内存，有时我们会看到这么一个现象：linux物理内存还有很多，但是交换空间也使用了很多。其实，这并不奇怪，例如，一个占用很大内存的进程运行时，需要耗费很多内存资源，此时就会有一些不常用页面文件被交换到虚拟内存中，但后来这个占用很多内存资源的进程结束并释放了很多内存时，刚才被交换出去的页面文件并不会自动的交换进物理内存，除非有这个必要，那么此刻系统物理内存就会空闲很多，同时交换空间也在被使用，就出现了刚才所说的现象了。关于这点，不用担心什么，只要知道是怎么一回事就可以了。</p> 
 <p><strong>最后</strong>，交换空间的页面在使用时会首先被交换到物理内存，如果此时没有足够的物理内存来容纳这些页面，它们又会被马上交换出去，如此以来，虚拟内存中可能没有足够空间来存储这些交换页面，最终会导致linux出现假死机、服务异常等问题，linux虽然可以在一段时间内自行恢复，但是恢复后的系统已经基本不可用了。<br>因此，合理规划和设计linux内存的使用，是非常重要的。</p> 
 <p><strong>虚拟内存原理：</strong></p> 
 <p>在系统中运行的每个进程都需要使用到内存，但不是每个进程都需要每时每刻使用系统分配的内存空间。当系统运行所需内存超过实际的物理内存，内核会释放某些进程所占用但未使用的部分或所有物理内存，将这部分资料存储在磁盘上直到进程下一次调用，并将释放出的内存提供给有需要的进程使用。</p> 
 <p>在Linux内存管理中，主要是通过“调页Paging”和“交换Swapping”来完成上述的内存调度。调页算法是将内存中最近不常使用的页面换到磁盘上，把活动页面保留在内存中供进程使用。交换技术是将整个进程，而不是部分页面，全部交换到磁盘上。</p> 
 <p>分页(Page)写入磁盘的过程被称作Page-Out，分页(Page)从磁盘重新回到内存的过程被称作Page-In。当内核需要一个分页时，但发现此分页不在物理内存中(因为已经被Page-Out了)，此时就发生了分页错误(Page Fault)。</p> 
 <p>当系统内核发现可运行内存变少时，就会通过Page-Out来释放一部分物理内存。经管Page-Out不是经常发生，但是如果Page-out频繁不断的发生，直到当内核管理分页的时间超过运行程式的时间时，系统效能会急剧下降。这时的系统已经运行非常慢或进入暂停状态，这种状态亦被称作thrashing。</p> 
 <h2 id="h2-1-"><a name="1．命令格式" class="reference-link"></a><span class="header-link octicon octicon-link"></span>1．命令格式</h2>
 <pre><code class="lang-shell">vmstat [-a] [-n] [-S unit] [delay [ count]]
vmstat [-s] [-n] [-S unit]
vmstat [-m] [-n] [delay [ count]]
vmstat [-d] [-n] [delay [ count]]
vmstat [-p disk partition] [-n] [delay [ count]]
vmstat [-f]
vmstat [-V]
</code></pre> 
 <h2 id="h2-2-"><a name="2．命令功能" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2．命令功能</h2>
 <p>用来显示虚拟内存的信息</p> 
 <h2 id="h2-3-"><a name="3．命令参数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>3．命令参数</h2>
 <ul> 
  <li><code>-a</code>：显示活跃和非活跃内存</li>
  <li><code>-f</code>：显示从系统启动至今的fork数量 。</li>
  <li><code>-m</code>：显示slabinfo</li>
  <li><code>-n</code>：只在开始时显示一次各字段名称。</li>
  <li><code>-s</code>：显示内存相关统计信息及多种系统活动数量。</li>
  <li><code>delay</code>：刷新时间间隔。如果不指定，只显示一条结果。</li>
  <li><code>count</code>：刷新次数。如果不指定刷新次数，但指定了刷新时间间隔，这时刷新次数为无穷。</li>
  <li><code>-d</code>：显示磁盘相关统计信息。</li>
  <li><code>-p</code>：显示指定磁盘分区统计信息</li>
  <li><code>-S</code>：使用指定单位显示。参数有 k 、K 、m 、M ，分别代表1000、1024、1000000、1048576字节(byte)。默认单位为K(1024 bytes)</li>
  <li><code>-V</code>：显示vmstat版本信息。</li>
 </ul> 
 <h2 id="h2-4-"><a name="4．使用实例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>4．使用实例</h2>
 <h3 id="h3--1-"><a name="实例1：显示虚拟内存使用情况" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例1：显示虚拟内存使用情况</h3>
 <p>命令：</p> 
 <pre><code class="lang-shell">vmstat
</code></pre> 
 <p>输出：</p> 
 <pre><code class="lang-shell">[yiibai@localhost ~]$ vmstat
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 3  0      0 703572    948 162328    0    0   608    65  379  564 14 10 72  3  0
[yiibai@localhost ~]$
</code></pre> 
 <p><strong>字段说明：</strong></p> 
 <ul> 
  <li><p>Procs(进程)：</p> 
   <ul> 
    <li><code>r</code>: 运行队列中进程数量</li>
    <li><code>b</code>: 等待IO的进程数量</li>
   </ul> </li>
  <li><p>Memory(内存)：</p> 
   <ul> 
    <li><code>swpd</code>: 使用虚拟内存大小</li>
    <li><code>free</code>: 可用内存大小</li>
    <li><code>buff</code>: 用作缓冲的内存大小</li>
    <li><code>cache</code>: 用作缓存的内存大小</li>
   </ul> </li>
  <li><p>Swap：</p> 
   <ul> 
    <li><code>si</code>: 每秒从交换区写到内存的大小</li>
    <li><code>so</code>: 每秒写入交换区的内存大小</li>
    <li><code>IO</code>：(现在的Linux版本块的大小为1024bytes)</li>
    <li><code>bi</code>: 每秒读取的块数</li>
    <li><code>bo</code>: 每秒写入的块数</li>
   </ul> </li>
  <li><p>system：</p> 
   <ul> 
    <li><code>in</code>: 每秒中断数，包括时钟中断。</li>
    <li><code>cs</code>: 每秒上下文切换数。</li>
    <li><code>CPU</code>(以百分比表示)：</li>
    <li><code>us</code>: 用户进程执行时间(user time)</li>
    <li><code>sy</code>: 系统进程执行时间(system time)</li>
    <li><code>id</code>: 空闲时间(包括IO等待时间),中央处理器的空闲时间 。以百分比表示。</li>
    <li><code>wa</code>: 等待IO时间</li>
   </ul> </li>
 </ul> 
 <p>备注： 如果 <code>r</code>经常大于 <code>4</code>，且<code>id</code>经常少于<code>40</code>，表示cpu的负荷很重。如果pi，po 长期不等于<code>0</code>，表示内存不足。如果<code>disk</code> 经常不等于<code>0</code>， 且在 <code>b</code>中的队列 大于<code>3</code>， 表示 <code>io</code>性能不好。Linux在具有高稳定性、可靠性的同时，具有很好的可伸缩性和扩展性，能够针对不同的应用和硬件环境调整，优化出满足当前应用需要的最佳性能。因此企业在维护Linux系统、进行系统调优时，了解系统性能分析工具是至关重要的。</p> 
 <p>命令：</p> 
 <pre><code class="lang-shell">vmstat 5 5
</code></pre> 
 <p>表示在<code>5</code>秒时间内进行<code>5</code>次采样。将得到一个数据汇总他能够反映真正的系统情况。</p> 
 <h3 id="h3--2-"><a name="实例2：显示活跃和非活跃内存" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例2：显示活跃和非活跃内存</h3>
 <p>命令：</p> 
 <pre><code class="lang-shell">vmstat -a 2 5
</code></pre> 
 <p>输出：</p> 
 <pre><code class="lang-shell">[yiibai@localhost ~]$ vmstat -a 2 5
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free  inact active   si   so    bi    bo   in   cs us sy id wa st
 3  0      0 703524  67680 121392    0    0   496    54  506  484 30  8 59  3  0
 1  0      0 703528  67680 121396    0    0     0     0 1059   87 100  0  0  0  0
 1  0      0 703528  67680 121396    0    0     0     1 1058   94 100  0  0  0  0
 1  0      0 703528  67680 121408    0    0     0     0 1069   93 100  0  0  0  0
 1  0      0 703528  67680 121408    0    0     0     0 1064   90 100  1  0  0  0
[yiibai@localhost ~]$
</code></pre> 
 <p>说明：<br>使用<code>-a</code>选项显示活跃和非活跃内存时，所显示的内容除增加<code>inact</code>和<code>active</code>外，其他显示内容与例子1相同。<br><strong>字段说明：</strong></p> 
 <ul> 
  <li><code>Memory</code>(内存)：
   <ul> 
    <li><code>inact</code>: 非活跃内存大小(当使用-a选项时显示)</li>
    <li><code>active</code>: 活跃的内存大小(当使用-a选项时显示)</li>
   </ul> </li>
 </ul> 
 <h3 id="h3--3-fork-"><a name="实例3：查看系统已经fork了多少次" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例3：查看系统已经fork了多少次</h3>
 <p>命令：</p>   
 <pre><code class="lang-shell">vmstat -f
</code></pre> 
 <p>输出：</p> 
 <pre><code class="lang-shell">[yiibai@localhost ~]$ vmstat -f
         2436 forks
[yiibai@localhost ~]$ vmstat -f
         2437 forks
</code></pre> 
 <p>说明：这个数据是从<code>/proc/stat</code>中的<code>processes</code>字段里取得。</p> 
 <h3 id="h3--4-"><a name="实例4：查看内存使用的详细信息" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例4：查看内存使用的详细信息</h3>
 <p>命令：</p> 
 <pre><code class="lang-shell">vmstat -s
</code></pre> 
 <p>输出：</p> 
 <pre><code class="lang-shell">[yiibai@localhost ~]$ vmstat -s
       999936 K total memory
       133040 K used memory
       121372 K active memory
        67680 K inactive memory
       703620 K free memory
          948 K buffer memory
       162328 K swap cache
      2097148 K total swap
            0 K used swap
      2097148 K free swap
        18184 non-nice user cpu ticks
            0 nice user cpu ticks
         1962 system cpu ticks
        14474 idle cpu ticks
          700 IO-wait cpu ticks
            0 IRQ cpu ticks
          146 softirq cpu ticks
            0 stolen cpu ticks
       121878 pages paged in
        13296 pages paged out
            0 pages swapped in
            0 pages swapped out
       240318 interrupts
       129447 CPU context switches
   1487555462 boot time
         2441 forks
[yiibai@localhost ~]$
</code></pre> 
 <p>说明：这些信息的分别来自于<code>/proc/meminfo</code>,<code>/proc/stat</code>和<code>/proc/vmstat</code>。</p> 
 <h3 id="h3--5-"><a name="实例5：查看磁盘的读/写" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例5：查看磁盘的读/写</h3>
 <p>命令：</p> 
 <pre><code class="lang-shell">vmstat -d
</code></pre> 
 <p>输出：</p> 
 <pre><code class="lang-shell">[yiibai@localhost ~]$ vmstat -d
disk- ------------reads------------ ------------writes----------- -----IO------
       total merged sectors      ms  total merged sectors      ms    cur    sec
sda     5993      1  243668   34060    915    119   26595   71815      0     22
sr0       11      0      88      89      0      0       0       0      0      0
dm-0    3025      0  188242   29896   1008      0   18235   97048      0     20
dm-1     128      0    2136     272      0      0       0       0      0      0
dm-2     655      0    5470     722     16      0    4224     177      0      0
[yiibai@localhost ~]$
</code></pre> 
 <p>说明：这些信息主要来自于<code>/proc/diskstats</code>.<br><code>merged</code>:表示一次来自于合并的写/读请求,一般系统会把多个连接/邻近的读/写请求合并到一起来操作.</p> 
 <h3 id="h3--6-dev-sda1-"><a name="实例6：查看/dev/sda1磁盘的读/写" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例6：查看/dev/sda1磁盘的读/写</h3>
 <p>命令执行及输出：</p> 
 <pre><code class="lang-shell">[yiibai@localhost ~]$ df
Filesystem          1K-blocks    Used Available Use% Mounted on
/dev/mapper/cl-root  40137576 1652712  38484864   5% /
devtmpfs               488988       0    488988   0% /dev
tmpfs                  499968       0    499968   0% /dev/shm
tmpfs                  499968    6856    493112   2% /run
tmpfs                  499968       0    499968   0% /sys/fs/cgroup
/dev/sda1             1038336  141652    896684  14% /boot
/dev/mapper/cl-home  19593216   34612  19558604   1% /home
tmpfs                   99996       0     99996   0% /run/user/0
[yiibai@localhost ~]$ vmstat -p /dev/sda1
sda1          reads   read sectors  writes    requested writes
                1981      45316         10       4136
[yiibai@localhost ~]
</code></pre> 
 <p>说明：这些信息主要来自于<code>/proc/diskstats</code>。</p> 
 <ul> 
  <li><code>reads</code>:来自于这个分区的读的次数。</li>
  <li><code>read sectors</code>:来自于这个分区的读扇区的次数。</li>
  <li><code>writes</code>:来自于这个分区的写的次数。</li>
  <li><code>requested writes</code>:来自于这个分区的写请求次数。</li>
 </ul> 
 <h3 id="h3--7-slab-"><a name="实例7：查看系统的slab信息" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例7：查看系统的slab信息</h3>
 <p>命令：</p> 
 <pre><code class="lang-shell">vmstat -m
</code></pre> 
 <p>输出：</p> 
 <pre><code class="lang-shell">[yiibai@localhost ~]$ vmstat -m
vmstat: your kernel does not support slabinfo or your permissions are insufficie                            nt
[yiibai@localhost ~]$
</code></pre> 
 <p>这组信息来自于<code>/proc/slabinfo</code>。<br><code>slab</code>:由于内核会有许多小对象，这些对象构造销毁十分频繁，比如<code>i-node</code>，<code>dentry</code>，这些对象如果每次构建的时候就向内存要一个页(4kb)，而其实只有几个字节，这样就会非常浪费，为了解决这个问题，就引入了一种新的机制来处理在同一个页框中如何分配小存储区，而slab可以对小对象进行分配,这样就不用为每一个对象分配页框，从而节省了空间，内核对一些小对象创建析构很频繁，slab对这些小对象进行缓冲,可以重复利用,减少内存分配次数。</p>
 <br>      
</div></body></html>