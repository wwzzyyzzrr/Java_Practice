<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">find命令常用参数示例</h1><div style="width:100%;float:left;" class="article-content">   
 <p><strong>find</strong>一些常用参数的一些常用实例和一些具体用法和注意事项。</p> 
 <h2 id="h2-1-name-"><a name="1．使用-name选项" class="reference-link"></a><span class="header-link octicon octicon-link"></span>1．使用-name选项</h2>
 <p>文件名选项是<code>find</code>命令最常用的选项，要么单独使用该选项，要么和其他选项一起使用。 可以使用某种文件名模式来匹配文件，记住要用引号将文件名模式引起来。不管当前路径是什么，如果想要在自己的根目录<code>$HOME</code>中查找文件名符合<code>*.log</code>的文件，使用<code>~</code>作为 ‘<code>pathname</code>‘参数，波浪号<code>~</code>代表了当前用户的<code>$HOME</code>目录。</p> 
 <pre><code class="lang-shell">find ~ -name "*.log" -print
</code></pre> 
 <p>想要在当前目录及子目录中查找所有的‘ <code>*.log</code>‘文件，可以用：</p> 
 <pre><code class="lang-shell">find . -name "*.log" -print
</code></pre> 
 <p>想要的当前目录及子目录中查找文件名以一个大写字母开头的文件，可以用：</p> 
 <pre><code class="lang-shell">find . -name "[A-Z]*" -print
</code></pre> 
 <p>想要在<code>/etc</code>目录中查找文件名以<code>host</code>开头的文件，可以用：</p> 
 <pre><code class="lang-shell">find /etc -name "host*" -print
</code></pre> 
 <p>想要查找<code>$HOME</code>目录中的文件，可以用：</p> 
 <pre><code class="lang-shell">find ~ -name "*" -print 或find . -print
</code></pre> 
 <p>要想让系统高负荷运行，就从根目录开始查找所有的文件。</p> 
 <pre><code class="lang-shell">find / -name "*" -print
</code></pre> 
 <p>如果想在当前目录查找文件名以一个个小写字母开头，最后是4到9加上.log结束的文件：<br>命令：</p> 
 <pre><code class="lang-shell">find . -name "[a-z]*[4-9].log" -print
</code></pre> 
 <p>演示执行及输出：</p> 
 <pre><code class="lang-shell">[yiibai@localhost ~]$ ll
total 20
-rw-rw-r--. 1 yiibai yiibai  464 Feb 15 20:58 log1.log
-rw-rw-r--. 1 yiibai yiibai    0 Feb 15 20:43 log2018.log
-rw-rw-r--. 1 yiibai yiibai    0 Feb 15 20:43 log2019.log
-rw-rw-r--. 1 yiibai yiibai    0 Feb 15 20:43 log2020.log
-rwxrwxr-x. 1 yiibai yiibai    0 Feb 15 20:43 log2.log
-rw-rw-r--. 1 yiibai yiibai  384 Feb 15 20:59 log3.log
-rwxrwxr-x. 1 yiibai yiibai 1197 Feb 15 20:58 log.log
drwxrwxr-x. 7 yiibai yiibai   66 Feb 15 20:48 project
drwxrwxr-x. 2 yiibai yiibai    6 Feb 15 21:12 test3
-rw-rw-r--. 1 yiibai yiibai    0 Feb 15 21:10 test3.log
drwxrwxr-x. 2 yiibai yiibai   22 Feb 15 21:04 test4
-rw-rw-r--. 1 yiibai yiibai   19 Feb 15 21:08 text.txt
-rw-rw-r--. 1 yiibai yiibai    1 Feb 15 20:46 tmpcore.log
[yiibai@localhost ~]$ find . -name "[a-z]*[4-9].log" -print
./log2018.log
./log2019.log
</code></pre> 
 <h2 id="h2-2-perm-"><a name="2．使用-perm选项" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2．使用-perm选项</h2>
 <p>按照文件权限模式用<code>-perm</code>选项,按文件权限模式来查找文件的话。最好使用八进制的权限表示法。<br>如在当前目录下查找文件权限位为<code>755</code>的文件，即文件属主可以读、写、执行，其他用户可以读、执行的文件，可以用：</p> 
 <pre><code class="lang-shell">[yiibai@localhost ~]$ ll
total 20
-rwxr-xr-x. 1 yiibai yiibai  464 Feb 15 20:58 log1.log
-rw-rw-r--. 1 yiibai yiibai    0 Feb 15 20:43 log2018.log
-rw-rw-r--. 1 yiibai yiibai    0 Feb 15 20:43 log2019.log
-rw-rw-r--. 1 yiibai yiibai    0 Feb 15 20:43 log2020.log
-rwxrwxr-x. 1 yiibai yiibai    0 Feb 15 20:43 log2.log
-rw-rw-r--. 1 yiibai yiibai  384 Feb 15 20:59 log3.log
-rwxr-xr-x. 1 yiibai yiibai 1197 Feb 15 20:58 log.log
drwxrwxr-x. 7 yiibai yiibai   66 Feb 15 20:48 project
drwxrwxr-x. 2 yiibai yiibai    6 Feb 15 21:12 test3
-rw-rw-r--. 1 yiibai yiibai    0 Feb 15 21:10 test3.log
drwxrwxr-x. 2 yiibai yiibai   22 Feb 15 21:04 test4
-rw-rw-r--. 1 yiibai yiibai   19 Feb 15 21:08 text.txt
-rw-rw-r--. 1 yiibai yiibai    1 Feb 15 20:46 tmpcore.log
[yiibai@localhost ~]$ find . -perm 755 -print
./log.log
./log1.log
[yiibai@localhost ~]$
</code></pre> 
 <p><strong>还有一种表达方法</strong>：在八进制数字前面要加一个横杠<code>-</code>，表示都匹配，如<code>-007</code>就相当于<code>777</code>，<code>-005</code>相当于<code>555</code>,<br>命令：</p> 
 <pre><code class="lang-shell">find . -perm -005
</code></pre> 
 <p>演示执行及输出：</p> 
 <pre><code class="lang-shell">[yiibai@localhost ~]$ ll
total 20
-rw-rw-r--. 1 yiibai yiibai    0 Feb 15 21:19 ?
-rwxr-xr-x. 1 yiibai yiibai  464 Feb 15 20:58 log1.log
-rw-rw-r--. 1 yiibai yiibai    0 Feb 15 20:43 log2018.log
-rw-rw-r--. 1 yiibai yiibai    0 Feb 15 20:43 log2019.log
-rw-rw-r--. 1 yiibai yiibai    0 Feb 15 20:43 log2020.log
-rwxrwxr-x. 1 yiibai yiibai    0 Feb 15 20:43 log2.log
-rw-rw-r--. 1 yiibai yiibai  384 Feb 15 20:59 log3.log
-rwxr-xr-x. 1 yiibai yiibai 1197 Feb 15 20:58 log.log
drwxrwxr-x. 7 yiibai yiibai   66 Feb 15 20:48 project
drwxrwxr-x. 2 yiibai yiibai    6 Feb 15 21:12 test3
-rw-rw-r--. 1 yiibai yiibai    0 Feb 15 21:10 test3.log
drwxrwxr-x. 2 yiibai yiibai   22 Feb 15 21:04 test4
-rw-rw-r--. 1 yiibai yiibai   19 Feb 15 21:08 text.txt
-rw-rw-r--. 1 yiibai yiibai    1 Feb 15 20:46 tmpcore.log
[yiibai@localhost ~]$ find . -perm -005
./log.log
./log1.log
./log2.log
./test3
./test4
./project
./project/lib
./project/bin
./project/doc
./project/doc/info
./project/doc/product
./project/logs
./project/logs/info
./project/logs/product
./project/service
./project/service/deploy
./project/service/deploy/info
./project/service/deploy/product
[yiibai@localhost ~]$
</code></pre> 
 <h2 id="h2-3-"><a name="3．忽略某个目录" class="reference-link"></a><span class="header-link octicon octicon-link"></span>3．忽略某个目录</h2>
 <p>如果在查找文件时希望忽略某个目录，因为你知道那个目录中没有你所要查找的文件，那么可以使用<code>-prune</code>选项来指出需要忽略的目录。在使用<code>-prune</code>选项时要当心，因为如果你同时使用了<code>-depth</code>选项，那么<code>-prune</code>选项就会被<code>find</code>命令忽略。如果希望在<code>test</code>目录下查找文件，但不希望在<code>project/logs</code>目录下查找，可以用：<br>命令：</p> 
 <pre><code class="lang-shell">find test -path "project/logs" -prune -o -print
</code></pre> 
 <p>演示执行及输出：</p> 
 <pre><code class="lang-shell">[yiibai@localhost ~]$ ll
total 20
-rw-rw-r--. 1 yiibai yiibai    0 Feb 15 21:20 ?
-rwxr-xr-x. 1 yiibai yiibai  464 Feb 15 20:58 log1.log
-rw-rw-r--. 1 yiibai yiibai    0 Feb 15 20:43 log2018.log
-rw-rw-r--. 1 yiibai yiibai    0 Feb 15 20:43 log2019.log
-rw-rw-r--. 1 yiibai yiibai    0 Feb 15 20:43 log2020.log
-rwxrwxr-x. 1 yiibai yiibai    0 Feb 15 20:43 log2.log
-rw-rw-r--. 1 yiibai yiibai  384 Feb 15 20:59 log3.log
-rwxr-xr-x. 1 yiibai yiibai 1197 Feb 15 20:58 log.log
drwxrwxr-x. 7 yiibai yiibai   66 Feb 15 20:48 project
drwxrwxr-x. 2 yiibai yiibai    6 Feb 15 21:12 test3
-rw-rw-r--. 1 yiibai yiibai    0 Feb 15 21:10 test3.log
drwxrwxr-x. 2 yiibai yiibai   22 Feb 15 21:04 test4
-rw-rw-r--. 1 yiibai yiibai   19 Feb 15 21:08 text.txt
-rw-rw-r--. 1 yiibai yiibai    1 Feb 15 20:46 tmpcore.log
[yiibai@localhost ~]$ find log -path "project/logs" -prune -o -print
find: ‘log’: No such file or directory
[yiibai@localhost ~]$ find *.log -path "project/logs" -prune -o -print
log1.log
log2018.log
log2019.log
log2020.log
log2.log
log3.log
log.log
test3.log
tmpcore.log
[yiibai@localhost ~]$ ll project/logs
total 0
drwxrwxr-x. 2 yiibai yiibai 6 Feb 15 20:48 info
-rw-rw-r--. 1 yiibai yiibai 0 Feb 15 21:24 log201710.log
drwxrwxr-x. 2 yiibai yiibai 6 Feb 15 20:48 product
-rw-rw-r--. 1 yiibai yiibai 0 Feb 15 21:23 readme.txt
[yiibai@localhost ~]$
</code></pre> 
 <h2 id="h2-4-find-"><a name="4．使用find查找文件的时候怎么避开某个文件目录" class="reference-link"></a><span class="header-link octicon octicon-link"></span>4．使用find查找文件的时候怎么避开某个文件目录</h2>
 <h3 id="h3--1-test4-log-"><a name="实例1：查找不在test4子目录之内的所有*.log文件" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例1：查找不在test4子目录之内的所有*.log文件</h3>
 <p>命令：</p> 
 <pre><code class="lang-shell">find *.log -path "test4" -prune -o -print
</code></pre> 
 <p>演示执行及输出：</p> 
 <pre><code class="lang-shell">[yiibai@localhost ~]$ ll test4/
total 4
-rw-rw-r--. 1 yiibai yiibai  0 Feb 15 21:31 test4.log
-rw-rw-r--. 1 yiibai yiibai 19 Feb 15 21:04 text.txt
[yiibai@localhost ~]$ find *.log -path "test4" -prune -o -print
log1.log
log2018.log
log2019.log
log2020.log
log2.log
log3.log
log.log
test3.log
tmpcore.log
[yiibai@localhost ~]$
</code></pre> 
 <p>说明：</p> 
 <pre><code class="lang-shell">find [-path ..] [expression]
</code></pre> 
 <p>在路径列表的后面的是表达式<br><code>-path "test" -prune -o -print</code> 是<code>-path "test" -a -prune -o -print</code> 的简写表达式按顺序求值, <code>-a</code> 和 <code>-o</code> 都是短路求值，与 <code>shell 的 &amp;&amp; 和 ||</code>类似。如果<br><code>-path "test"</code> 为真，则求值 <code>-prune , -prune</code> 返回真，与逻辑表达式为真；否则不求值 -prune，与逻辑表达式为假。如果 <code>-path "test" -a -prune</code> 为假，则求值 <code>-print</code> ，<code>-print</code>返回真，或逻辑表达式为真；否则不求值 <code>-print</code>，或逻辑表达式为真。<br>这个表达式组合特例可以用伪码写为:</p> 
 <pre><code class="lang-shell">if -path "test" then  
-prune  
else  
-print
</code></pre> 
 <h3 id="h3--2-"><a name="实例2：避开多个文件夹:" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例2：避开多个文件夹:</h3>
 <p>命令：</p> 
 <pre><code class="lang-shell">find project \( -path project/logs -o -path project/doc \) -prune -o -print
</code></pre> 
 <p>输出：</p> 
 <pre><code class="lang-shell">[yiibai@localhost ~]$ ll project/
total 0
drwxrwxr-x. 2 yiibai yiibai  6 Feb 15 20:48 bin
drwxrwxr-x. 4 yiibai yiibai 33 Feb 15 20:48 doc
drwxrwxr-x. 2 yiibai yiibai  6 Feb 15 20:48 lib
drwxrwxr-x. 4 yiibai yiibai 72 Feb 15 21:24 logs
drwxrwxr-x. 3 yiibai yiibai 20 Feb 15 20:48 service
[yiibai@localhost ~]$ find project \( -path project/logs -o -path project/doc \) -prune -o -print
project
project/lib
project/bin
project/service
project/service/deploy
project/service/deploy/info
project/service/deploy/product
[yiibai@localhost ~]$
</code></pre> 
 <blockquote> 
  <p>说明：圆括号表示表达式的结合。 <code>\</code> 表示引用，即指示 shell 不对后面的字符作特殊解释，而留给 <code>find</code> 命令去解释其意义。 </p> 
 </blockquote> 
 <h3 id="h3--3-name-o-"><a name="实例3：查找某一确定文件，-name等选项加在-o 之后" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例3：查找某一确定文件，-name等选项加在-o 之后</h3>
 <p>命令：</p> 
 <pre><code class="lang-shell">find project \( -path project/bin -o -path project/doc \) -prune -o -name "*.log" -print
</code></pre> 
 <p>输出：</p> 
 <pre><code class="lang-shell">[yiibai@localhost ~]$ ll project/
total 0
drwxrwxr-x. 2 yiibai yiibai  6 Feb 15 20:48 bin
drwxrwxr-x. 4 yiibai yiibai 33 Feb 15 20:48 doc
drwxrwxr-x. 2 yiibai yiibai  6 Feb 15 20:48 lib
drwxrwxr-x. 4 yiibai yiibai 72 Feb 15 21:24 logs
drwxrwxr-x. 3 yiibai yiibai 20 Feb 15 20:48 service
[yiibai@localhost ~]$ find project \( -path project/bin -o -path project/doc \) -prune -o -name "*.log" -print
project/logs/log201710.log
[yiibai@localhost ~]$
</code></pre> 
 <h2 id="h2-5-user-nouser-"><a name="5．使用user和nouser选项" class="reference-link"></a><span class="header-link octicon octicon-link"></span>5．使用user和nouser选项</h2>
 <p>按文件属主查找文件：</p> 
 <h3 id="h3--1-home-peida-"><a name="实例1：在$HOME目录中查找文件属主为peida的文件" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例1：在$HOME目录中查找文件属主为peida的文件</h3>
 <p>命令：</p> 
 <pre><code class="lang-shell">find ~ -user peida -print
</code></pre> 
 <h3 id="h3--2-etc-peida-"><a name="实例2：在/etc目录下查找文件属主为peida的文件:" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例2：在/etc目录下查找文件属主为peida的文件:</h3>
 <p>命令：</p> 
 <pre><code class="lang-shell">find /etc -user peida -print
</code></pre> 
 <p>说明：</p> 
 <h3 id="h3--3-code-nouser-code-code-home-code-"><a name="实例3：为了查找属主帐户已经被删除的文件，可以使用<code>-nouser</code>选项。在<code>/home</code>目录下查找所有的这类文件" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例3：为了查找属主帐户已经被删除的文件，可以使用<code>-nouser</code>选项。在<code>/home</code>目录下查找所有的这类文件</h3>
 <p>命令：</p>   
 <pre><code class="lang-shell">find /home -nouser -print
</code></pre> 
 <p>说明：<br>这样就能够找到那些属主在<code>/etc/passwd</code>文件中没有有效帐户的文件。在使用<code>-nouser</code>选项时，不必给出用户名； <code>find</code>命令能够完成相应的工作。</p> 
 <h2 id="h2-6-group-nogroup-"><a name="6．使用group和nogroup选项" class="reference-link"></a><span class="header-link octicon octicon-link"></span>6．使用group和nogroup选项</h2>
 <p>就像<code>user</code>和<code>nouser</code>选项一样，针对文件所属于的用户组， <code>find</code>命令也具有同样的选项，为了在<code>/apps</code>目录下查找属于gem用户组的文件，可以用：</p> 
 <pre><code class="lang-shell">find /apps -group gem -print
</code></pre> 
 <p>要查找没有有效所属用户组的所有文件，可以使用<code>nogroup</code>选项。下面的<code>find</code>命令从文件系统的根目录处查找这样的文件:</p> 
 <pre><code class="lang-shell">find / -nogroup-print
</code></pre> 
 <h2 id="h2-7-"><a name="7．按照更改时间或访问时间等查找文件" class="reference-link"></a><span class="header-link octicon octicon-link"></span>7．按照更改时间或访问时间等查找文件</h2>
 <p>如果希望按照更改时间来查找文件，可以使用<code>mtime</code>,<code>atime</code>或<code>ctime</code>选项。如果系统突然没有可用空间了，很有可能某一个文件的长度在此期间增长迅速，这时就可以用mtime选项来查找这样的文件。<br>用减号<code>-</code>来限定更改时间在距今<code>n</code>日以内的文件，而用加号<code>+</code>来限定更改时间在距今<code>n</code>日以前的文件。<br>希望在系统根目录下查找更改时间在5日以内的文件，可以用：</p> 
 <pre><code class="lang-shell">find / -mtime -5 -print
</code></pre> 
 <p>为了在<code>/var/logs</code>目录下查找更改时间在<code>3</code>日以前的文件，可以用:</p> 
 <pre><code class="lang-shell">find /var/logs -mtime +3 -print
</code></pre> 
 <h2 id="h2-8-"><a name="8．查找比某个文件新或旧的文件" class="reference-link"></a><span class="header-link octicon octicon-link"></span>8．查找比某个文件新或旧的文件</h2>
 <p>如果希望查找更改时间比某个文件新但比另一个文件旧的所有文件，可以使用<code>-newer</code>选项。<br>它的一般形式为： </p> 
 <pre><code class="lang-shell">newest_file_name ! oldest_file_name
</code></pre> 
 <p>其中，<code>！</code>是逻辑非符号。 </p> 
 <h3 id="h3--1-code-log2000-log-code-code-log2019-log-code-"><a name="实例1：查找更改时间比文件<code>log2000.log</code>新但比文件<code>log2019.log</code>旧的文件" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例1：查找更改时间比文件<code>log2000.log</code>新但比文件<code>log2019.log</code>旧的文件</h3>
 <p>命令：</p> 
 <pre><code class="lang-shell">find -newer log2000.log ! -newer log2019.log
</code></pre> 
 <h3 id="h3--2-log-log-"><a name="实例2：查找更改时间在比log.log文件新的文件" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例2：查找更改时间在比log.log文件新的文件</h3>
 <p>命令：</p> 
 <pre><code class="lang-shell">find . -newer log.log -print
</code></pre> 
 <p>输出：</p> 
 <pre><code class="lang-shell">[yiibai@localhost ~]$ find . -newer log.log -print
.
./log3.log
./test3
./test4
./test4/text.txt
./test4/test4.log
./project/logs
./project/logs/readme.txt
./project/logs/log201710.log
./text.txt
./test3.log
./?
[yiibai@localhost ~]$
</code></pre> 
 <h2 id="h2-9-type-"><a name="9．使用type选项" class="reference-link"></a><span class="header-link octicon octicon-link"></span>9．使用type选项</h2>
 <h3 id="h3--1-etc-"><a name="实例1：在/etc目录下查找所有的目录" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例1：在/etc目录下查找所有的目录</h3>
 <p>命令：</p> 
 <pre><code class="lang-shell">find /etc -type d -print
</code></pre> 
 <h3 id="h3--2-"><a name="实例2：在当前目录下查找除目录以外的所有类型的文件" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例2：在当前目录下查找除目录以外的所有类型的文件</h3>
 <p>命令：</p> 
 <pre><code class="lang-shell">find . ! -type d -print
</code></pre> 
 <h3 id="h3--3-etc-"><a name="实例3：在/etc目录下查找所有的符号链接文件" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例3：在/etc目录下查找所有的符号链接文件</h3>
 <p>命令：</p> 
 <pre><code class="lang-shell">find /etc -type l -print
</code></pre> 
 <h2 id="h2-10-size-"><a name="10．使用size选项" class="reference-link"></a><span class="header-link octicon octicon-link"></span>10．使用size选项</h2>
 <p>可以按照文件长度来查找文件，这里所指的文件长度既可以用块(<code>block</code>)来计量，也可以用字节来计量。以字节计量文件长度的表达形式为<code>N c</code>；以块计量文件长度只用数字表示即可。<br>在按照文件长度查找文件时，一般使用这种以字节表示的文件长度，在查看文件系统的大小，因为这时使用块来计量更容易转换。 </p> 
 <h3 id="h3--1-1-m-"><a name="实例1：在当前目录下查找文件长度大于1 M字节的文件" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例1：在当前目录下查找文件长度大于1 M字节的文件</h3>
 <p>命令：</p> 
 <pre><code class="lang-shell">find . -size +1000000c -print
</code></pre> 
 <h3 id="h3--2-home-apache-100-"><a name="实例2：在/home/apache目录下查找文件长度恰好为100字节的文件:" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例2：在/home/apache目录下查找文件长度恰好为100字节的文件:</h3>
 <p>命令：</p> 
 <pre><code class="lang-shell">find /home/apache -size 100c -print
</code></pre> 
 <h3 id="h3--3-10-512-"><a name="实例3：在当前目录下查找长度超过10块的文件(一块等于512字节)" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例3：在当前目录下查找长度超过10块的文件(一块等于512字节)</h3>
 <p>命令：</p> 
 <pre><code class="lang-shell">find . -size +10 -print
</code></pre> 
 <h2 id="h2-11-depth-"><a name="11．使用depth选项" class="reference-link"></a><span class="header-link octicon octicon-link"></span>11．使用depth选项</h2>
 <p>在使用<code>find</code>命令时，可能希望先匹配所有的文件，再在子目录中查找。使用<code>depth</code>选项就可以使<code>find</code>命令这样做。这样做的一个原因就是，当在使用<code>find</code>命令向磁带上备份文件系统时，希望首先备份所有的文件，其次再备份子目录中的文件。 </p> 
 <h3 id="h3--1-find-con-file-"><a name="实例1：find命令从文件系统的根目录开始，查找一个名为CON.FILE的文件。" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例1：find命令从文件系统的根目录开始，查找一个名为CON.FILE的文件。</h3>
 <p>命令：</p> 
 <pre><code class="lang-shell">find / -name "CON.FILE" -depth -print
</code></pre> 
 <p>说明：<br>它将首先匹配所有的文件然后再进入子目录中查找</p> 
 <h2 id="h2-12-mount-"><a name="12．使用mount选项" class="reference-link"></a><span class="header-link octicon octicon-link"></span>12．使用mount选项</h2>
 <p>在当前的文件系统中查找文件(不进入其他文件系统)，可以使用<code>find</code>命令的<code>mount</code>选项。</p> 
 <h3 id="h3--1-xc-"><a name="实例1：从当前目录开始查找位于本文件系统中文件名以XC结尾的文件" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例1：从当前目录开始查找位于本文件系统中文件名以XC结尾的文件</h3>
 <p>命令：</p> 
 <pre><code class="lang-shell">find . -name "*.XC" -mount -print
</code></pre>
 <br>      
</div></body></html>