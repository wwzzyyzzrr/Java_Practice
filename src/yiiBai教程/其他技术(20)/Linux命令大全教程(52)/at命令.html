<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">at命令</h1><div style="width:100%;float:left;" class="article-content">   
 <p>在windows系统中，windows提供了计划任务这一功能，在控制面板 -&gt; 性能与维护 -&gt; 任务计划， 它的功能就是安排自动运行的任务。 通过’添加任务计划’的一步步引导，则可建立一个定时执行的任务。</p> 
 <p>在linux系统中你可能已经发现了为什么系统常常会自动的进行一些任务？这些任务到底是谁在支配他们工作的？在linux系统如果你想要让自己设计的备份程序可以自动在某个时间点开始在系统底下运行，而不需要手动来启动它，又该如何处置呢？ 这些例行的工作可能又分为一次性定时工作与循环定时工作，在系统内又是哪些服务在负责？ 还有，如果你想要每年在老婆的生日前一天就发出一封信件提醒自己不要忘记，linux系统下该怎么做呢？<br>接下来来学习一下一次性定时计划任务的<code>at</code>命令的用法。</p> 
 <h2 id="h2-1-"><a name="1．命令格式" class="reference-link"></a><span class="header-link octicon octicon-link"></span>1．命令格式</h2>
 <p>at[参数][时间]</p> 
 <h2 id="h2-2-"><a name="2．命令功能" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2．命令功能</h2>
 <p>在一个指定的时间执行一个指定任务，只能执行一次，且需要开启<code>atd</code>进程(<br><code>ps -ef | grep atd</code>查看， 开启用<code>/etc/init.d/atd start or restart</code>； 开机即启动则需要运行 <code>chkconfig --level 2345 atd on</code>)。</p> 
 <h2 id="h2-3-"><a name="3．命令参数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>3．命令参数</h2>
 <ul> 
  <li><code>-m</code> 当指定的任务被完成之后，将给用户发送邮件，即使没有标准输出</li>
  <li><code>-I</code> atq的别名</li>
  <li><code>-d</code> atrm的别名</li>
  <li><code>-v</code> 显示任务将被执行的时间</li>
  <li><code>-c</code> 打印任务的内容到标准输出</li>
  <li><code>-V</code> 显示版本信息</li>
  <li><code>-q</code>&lt;列队&gt; 使用指定的列队</li>
  <li><code>-f</code>&lt;文件&gt; 从指定文件读入任务而不是从标准输入读入</li>
  <li><code>-t</code>&lt;时间参数&gt; 以时间参数的形式提交要运行的任务<br><code>at</code>允许使用一套相当复杂的指定时间的方法。他能够接受在当天的hh:mm(小时:分钟)式的时间指定。假如该时间已过去，那么就放在第二天执行。当然也能够使用midnight(深夜)，noon(中午)，teatime(饮茶时间，一般是下午4点)等比较模糊的 词语来指定时间。用户还能够采用12小时计时制，即在时间后面加上AM(上午)或PM(下午)来说明是上午还是下午。 也能够指定命令执行的具体日期，指定格式为month day(月 日)或mm/dd/yy(月/日/年)或dd.mm.yy(日.月.年)。指定的日期必须跟在指定时间的后面。 上面介绍的都是绝对计时法，其实还能够使用相对计时法，这对于安排不久就要执行的命令是很有好处的。指定格式为：now + count time-units ，now就是当前时间，time-units是时间单位，这里能够是minutes(分钟)、hours(小时)、days(天)、weeks(星期)。count是时间的数量，究竟是几天，还是几小时，等等。 更有一种计时方法就是直接使用today(今天)、tomorrow(明天)来指定完成命令的时间。<br><code>TIME：</code>时间格式，这里可以定义出什么时候要进行 at 这项任务的时间，格式有：<pre><code class="lang-shell">HH:MM    
ex&gt; 04:00
</code></pre> 在今日的 HH:MM 时刻进行，若该时刻已超过，则明天的 HH:MM 进行此任务。<pre><code class="lang-shell">HH:MM YYYY-MM-DD
ex&gt; 04:00 2017-03-17
</code></pre> 强制规定在某年某月的某一天的特殊时刻进行该项任务<pre><code class="lang-shell">HH:MM[am|pm] [Month] [Date]
ex&gt; 04pm March 17
</code></pre> 也是一样，强制在某年某月某日的某时刻进行该项任务<pre><code class="lang-shell">HH:MM[am|pm] + number [minutes|hours|days|weeks]
ex&gt; now + 5 minutes
ex&gt; 04pm + 3 days
</code></pre> 就是说，在某个时间点再加几个时间后才进行该项任务。</li>
 </ul> 
 <h2 id="h2-4-"><a name="4．使用实例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>4．使用实例</h2>
 <h3 id="h3--1-5-bin-ls"><a name="实例1：三天后的下午 5 点执行 /bin/ls" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例1：三天后的下午 5 点执行 /bin/ls</h3>
 <p>命令：</p> 
 <pre><code class="lang-shell">at 5pm+3 days
</code></pre> 
 <p>输出：</p> 
 <pre><code class="lang-shell">[root@localhost yiibai]# at 5pm+3 days
at&gt; /bin/ls
at&gt; &lt;EOT&gt; ## Ctr+D
job 4 at Thu Mar  2 17:00:00 2017
[root@localhost yiibai]#
</code></pre> 
 <h3 id="h3--2-17-"><a name="实例2：明天17点钟，输出时间到指定文件内" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例2：明天17点钟，输出时间到指定文件内</h3>
 <p>命令：</p> 
 <pre><code class="lang-shell">at 17:20 tomorrow
</code></pre> 
 <p>输出：</p> 
 <pre><code class="lang-shell">[root@localhost yiibai]# at 17:20 tomorrow
at&gt; date &gt;/home/yiibai/date.log
at&gt; &lt;EOT&gt;
job 5 at Tue Feb 28 17:20:00 2017
[root@localhost yiibai]#
</code></pre> 
 <h3 id="h3--3-atq-"><a name="实例3：计划任务设定后，在没有执行之前我们可以用atq命令来查看系统没有执行工作任务" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例3：计划任务设定后，在没有执行之前我们可以用atq命令来查看系统没有执行工作任务</h3>
 <p>命令：</p> 
 <pre><code class="lang-shell">atq
</code></pre> 
 <p>输出：</p> 
 <pre><code class="lang-shell">[root@localhost yiibai]# atq
4       Thu Mar  2 17:00:00 2017 a root
5       Tue Feb 28 17:20:00 2017 a root
[root@localhost yiibai]#
</code></pre> 
 <h3 id="h3--4-"><a name="实例4：删除已经设置的任务" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例4：删除已经设置的任务</h3>
 <p>命令：</p> 
 <pre><code class="lang-shell">atrm 7
</code></pre> 
 <p>输出：</p> 
 <pre><code class="lang-shell">[root@localhost yiibai]# atrm 4
[root@localhost yiibai]# atq
5       Tue Feb 28 17:20:00 2017 a root
[root@localhost yiibai]#
</code></pre> 
 <h3 id="h3--5-"><a name="实例5：显示已经设置的任务内容" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例5：显示已经设置的任务内容</h3>
 <p>命令：</p> 
 <pre><code class="lang-shell">at -c 5
</code></pre> 
 <p>输出：</p> 
 <pre><code class="lang-shell">[root@localhost yiibai]# at -c 5
#!/bin/sh
# atrun uid=0 gid=0
# mail yiibai 0
umask 22
XDG_SESSION_ID=3; export XDG_SESSION_ID
HOSTNAME=localhost.localdomain; export HOSTNAME
SHELL=/bin/bash; export SHELL
HISTSIZE=1000; export HISTSIZE
SSH_CLIENT=192.168.0.5\ 51577\ 22; export SSH_CLIENT
SSH_TTY=/dev/pts/0; export SSH_TTY
USER=yiibai; export USER
LS_COLORS=rs=0:di=01\;34:ln=01\;36:mh=00:pi=40\;33:so=01\;35:do=01\;35:bd=40\;33\;01:cd=40\;33\;01:or=40\;31\;01:mi=01\;05\;37\;41:su=37\;41:sg=30\;43:ca=30\;41:tw=30\;42:ow=34\;42:st=37\;44:ex=01\;32:\*.tar=01\;31:\*.tgz=01\;31:\*.arc=01\;31:\*.arj=01\;31:\*.taz=01\;31:\*.lha=01\;31:\*.lz4=01\;31:\*.lzh=01\;31:\*.lzma=01\;31:\*.tlz=01\;31:\*.txz=01\;31:\*.tzo=01\;31:\*.t7z=01\;31:\*.zip=01\;31:\*.z=01\;31:\*.Z=01\;31:\*.dz=01\;31:\*.gz=01\;31:\*.lrz=01\;31:\*.lz=01\;31:\*.lzo=01\;31:\*.xz=01\;31:\*.bz2=01\;31:\*.bz=01\;31:\*.tbz=01\;31:\*.tbz2=01\;31:\*.tz=01\;31:\*.deb=01\;31:\*.rpm=01\;31:\*.jar=01\;31:\*.war=01\;31:\*.ear=01\;31:\*.sar=01\;31:\*.rar=01\;31:\*.alz=01\;31:\*.ace=01\;31:\*.zoo=01\;31:\*.cpio=01\;31:\*.7z=01\;31:\*.rz=01\;31:\*.cab=01\;31:\*.jpg=01\;35:\*.jpeg=01\;35:\*.gif=01\;35:\*.bmp=01\;35:\*.pbm=01\;35:\*.pgm=01\;35:\*.ppm=01\;35:\*.tga=01\;35:\*.xbm=01\;35:\*.xpm=01\;35:\*.tif=01\;35:\*.tiff=01\;35:\*.png=01\;35:\*.svg=01\;35:\*.svgz=01\;35:\*.mng=01\;35:\*.pcx=01\;35:\*.mov=01\;35:\*.mpg=01\;35:\*.mpeg=01\;35:\*.m2v=01\;35:\*.mkv=01\;35:\*.webm=01\;35:\*.ogm=01\;35:\*.mp4=01\;35:\*.m4v=01\;35:\*.mp4v=01\;35:\*.vob=01\;35:\*.qt=01\;35:\*.nuv=01\;35:\*.wmv=01\;35:\*.asf=01\;35:\*.rm=01\;35:\*.rmvb=01\;35:\*.flc=01\;35:\*.avi=01\;35:\*.fli=01\;35:\*.flv=01\;35:\*.gl=01\;35:\*.dl=01\;35:\*.xcf=01\;35:\*.xwd=01\;35:\*.yuv=01\;35:\*.cgm=01\;35:\*.emf=01\;35:\*.axv=01\;35:\*.anx=01\;35:\*.ogv=01\;35:\*.ogx=01\;35:\*.aac=01\;36:\*.au=01\;36:\*.flac=01\;36:\*.mid=01\;36:\*.midi=01\;36:\*.mka=01\;36:\*.mp3=01\;36:\*.mpc=01\;36:\*.ogg=01\;36:\*.ra=01\;36:\*.wav=01\;36:\*.axa=01\;36:\*.oga=01\;36:\*.spx=01\;36:\*.xspf=01\;36:; export LS_COLORS
PATH=/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/yiibai/bin:/sbin:/usr/bin:/usr/sbin; export PATH
MAIL=/var/spool/mail/yiibai; export MAIL
PWD=/home/yiibai; export PWD
LANG=en_US.UTF-8; export LANG
HISTCONTROL=ignoredups; export HISTCONTROL
HOME=/root; export HOME
SHLVL=2; export SHLVL
LOGNAME=yiibai; export LOGNAME
SSH_CONNECTION=192.168.0.5\ 51577\ 192.168.0.210\ 22; export SSH_CONNECTION
LESSOPEN=\|\|/usr/bin/lesspipe.sh\ %s; export LESSOPEN
XDG_RUNTIME_DIR=/run/user/1000; export XDG_RUNTIME_DIR
cd /home/yiibai || {
         echo 'Execution directory inaccessible' &gt;&amp;2
         exit 1
}
${SHELL:-/bin/sh} &lt;&lt; 'marcinDELIMITER40a1c04f'
date &gt;/home/yiibai/date.log

marcinDELIMITER40a1c04f
[root@localhost yiibai]#
</code></pre> 
 <h3 id="h3--6-"><a name="实例6：" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例6：</h3>
 <p>命令及输出：</p> 
 <p><strong>说明：</strong></p> 
 <ul> 
  <li>5． <code>atd</code> 的启动与 <code>at</code> 运行的方式：
   <ul> 
    <li>5.1. <code>atd</code> 的启动<br>要使用一次性计划任务时，Linux 系统上面必须要有负责这个计划任务的服务，那就是 <code>atd</code> 服务。 不过并非所有的 Linux distributions 都默认会把他打开的，所以，某些时刻我们需要手动将 <code>atd</code> 服务激活才行。 激活的方法很简单，就是这样：<br>命令：  <pre><code class="lang-shell">/etc/init.d/atd start 
/etc/init.d/atd restart
</code></pre> 输出：</li>
   </ul> </li>
 </ul> 
 <p><strong>说明：</strong><br><code>/etc/init.d/atd start</code> 没有启动的时候，直接启动 <code>atd</code> 服务<br><code>/etc/init.d/atd restart</code> 服务已经启动后，重启 <code>atd</code> 服务<br>备注：配置一下启动时就启动这个服务，免得每次重新启动都得再来一次<br>命令：</p> 
 <pre><code class="lang-shell">chkconfig atd on
</code></pre> 
 <p>输出：</p> 
 <ul> 
  <li>5.2 at 的运行方式<br>既然是计划任务，那么应该会有任务执行的方式，并且将这些任务排进行程表中。那么产生计划任务的方式是怎么进行的? 事实上，我们使用 at 这个命令来产生所要运行的计划任务，并将这个计划任务以文字档的方式写入 <code>/var/spool/at/</code> 目录内，该工作便能等待 <code>atd</code> 这个服务的取用与运行了。就这么简单。<br>不过，并不是所有的人都可以进行 <code>at</code> 计划任务。为什么? 因为系统安全的原因。很多主机被所谓的攻击破解后，最常发现的就是他们的系统当中多了很多的黑客程序， 这些程序非常可能运用一些计划任务来运行或搜集你的系统运行信息,并定时的发送给黑客。 所以，除非是你认可的帐号，否则先不要让他们使用 at 命令。那怎么达到使用 at 的可控呢?<br>我们可以利用 <code>/etc/at.allow</code> 与 <code>/etc/at.deny</code> 这两个文件来进行 at 的使用限制。加上这两个文件后， <code>at</code> 的工作情况是这样的：<br>先找寻 <code>/etc/at.allow</code> 这个文件，写在这个文件中的使用者才能使用 at ，没有在这个文件中的使用者则不能使用 at (即使没有写在 <code>at.deny</code> 当中);<br>如果 <code>/etc/at.allow</code> 不存在，就寻找 <code>/etc/at.deny</code> 这个文件，若写在这个 <code>at.deny</code> 的使用者则不能使用 at ，而没有在这个 <code>at.deny</code> 文件中的使用者，就可以使用 at 命令了。<br>如果两个文件都不存在，那么只有 root 可以使用 <code>at</code> 这个命令。<br>透过这个说明，我们知道 <code>/etc/at.allow</code> 是管理较为严格的方式，而 <code>/etc/at.deny</code> 则较为松散 (因为帐号没有在该文件中，就能够运行 at 了)。在一般的 distributions 当中，由于假设系统上的所有用户都是可信任的， 因此系统通常会保留一个空的 <code>/etc/at.deny</code> 文件，意思是允许所有人使用 at 命令的意思 (您可以自行检查一下该文件)。 不过，万一你不希望有某些使用者使用 at 的话，将那个使用者的帐号写入 <code>/etc/at.deny</code> 即可！ 一个帐号写一行。</li>
 </ul>
 <br>      
</div></body></html>