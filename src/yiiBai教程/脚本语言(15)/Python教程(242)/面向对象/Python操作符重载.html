<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Python操作符重载</h1><div style="width:100%;float:left;" class="article-content">   
 <p>可以根据所使用的操作数更改Python中运算符的含义。这种做法被称为运算符重载。</p> 
 <p>Python操作系统适用于内置类。 但同一运算符的行为在不同的类型有所不同。 例如，<code>+</code>运算符将对两个数字执行算术加法，合并两个列表并连接两个字符串。</p> 
 <p>Python中的这个功能，允许相同的操作符根据上下文的不同，其含义称为运算符重载。</p> 
 <p>那么当将它们与用户定义的类的对象一起使用时会发生什么？ 考虑下面的类，它试图模拟二维坐标系中的一个点。</p> 
 <pre><code class="lang-python">class Point:
    def __init__(self, x = 0, y = 0):
        self.x = x
        self.y = y
</code></pre> 
 <p>现在，运行代码，尝试在Python shell中添加两点。</p> 
 <pre><code class="lang-python">&gt;&gt;&gt; p1 = Point(2,3)
&gt;&gt;&gt; p2 = Point(-1,2)
&gt;&gt;&gt; p1 + p2
Traceback (most recent call last):
...
TypeError: unsupported operand type(s) for +: 'Point' and 'Point'
</code></pre> 
 <h2 id="h2-python-"><a name="Python中的特殊功能" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Python中的特殊功能</h2>
 <p>以双下划线<code>__</code>开头的类函数在Python中称为特殊函数。 这是因为，它们是有特殊含义。 上面定义的<code>__init__()</code>函数是其中之一。 每次创建该类的新对象时都会调用它。 Python中有很多特殊功能。</p> 
 <p>使用特殊功能，可以使类与内置函数兼容。</p> 
 <pre><code class="lang-python">&gt;&gt;&gt; p1 = Point(2,3)
&gt;&gt;&gt; print(p1)
&lt;__main__.Point object at 0x00000000031F8CC0&gt;
</code></pre> 
 <p>但是如果打印不好或不够美观。可以在类中定义<code>__str__()</code>方法，可以控制它如何打印。 所以，把它添加到类中，如下代码 - </p> 
 <pre><code class="lang-python">class Point:
    def __init__(self, x = 0, y = 0):
        self.x = x
        self.y = y

    def __str__(self):
        return "({0},{1})".format(self.x,self.y)
</code></pre> 
 <p>现在再试一次调用<code>print()</code>函数。</p> 
 <pre><code class="lang-shell">&gt;&gt;&gt; p1 = Point(2,3)
&gt;&gt;&gt; print(p1)
(2,3)
</code></pre> 
 <p>当使用内置函数<code>str()</code>或<code>format()</code>时，调用同样的方法。</p> 
 <pre><code class="lang-python">&gt;&gt;&gt; str(p1)
'(2,3)'

&gt;&gt;&gt; format(p1)
'(2,3)'
</code></pre> 
 <p>所以，当执行<code>str(p1)</code>或<code>format(p1)</code>，Python在内部执行<code>p1.__str__()</code>。</p> 
 <h2 id="h2--python-"><a name="在Python中重载+运算符" class="reference-link"></a><span class="header-link octicon octicon-link"></span>在Python中重载+运算符</h2>
 <p>要重载<code>+</code>号，需要在类中实现<code>__add__()</code>函数。可以在这个函数里面做任何喜欢的事情。 但是返回<code>Point</code>对象的坐标之和是最合理的。</p> 
 <pre><code class="lang-python">class Point:
    def __init__(self, x = 0, y = 0):
        self.x = x
        self.y = y

    def __str__(self):
        return "({0},{1})".format(self.x,self.y)

    def __add__(self,other):
        x = self.x + other.x
        y = self.y + other.y
        return Point(x,y)
</code></pre> 
 <p>现在让我们再试一次运行上面的代码 - </p> 
 <pre><code class="lang-shell">&gt;&gt;&gt; p1 = Point(2,3)
&gt;&gt;&gt; p2 = Point(-1,2)
&gt;&gt;&gt; print(p1 + p2)
(1,5)
</code></pre> 
 <p>实际发生的是，当执行<code>p1 + p2</code>语句时，Python将调用<code>p1.__add__(p2)</code>，之后是<code>Point.__add__(p1，p2)</code>。 同样，也可以重载其他运算符。需要实现的特殊功能列在下面。</p> 
 <p>Python中的运算符重载特殊函数 - </p> 
 <table> 
  <thead> 
   <tr> 
    <th>运算符</th> 
    <th>表达式</th> 
    <th>内置函数</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>加法</td> 
    <td><code>p1 + p2</code></td> 
    <td><code>p1.__add__(p2)</code></td> 
   </tr> 
   <tr> 
    <td>减法</td> 
    <td><code>p1 - p2</code></td> 
    <td><code>p1.__sub__(p2)</code></td> 
   </tr> 
   <tr> 
    <td>乘法</td> 
    <td>p1 * p2</td> 
    <td>p1.<strong>mul</strong>(p2)</td> 
   </tr> 
   <tr> 
    <td>次幂</td> 
    <td><code>p1 ** p2</code></td> 
    <td><code>p1.__pow__(p2)</code></td> 
   </tr> 
   <tr> 
    <td>除法</td> 
    <td><code>p1 / p2</code></td> 
    <td><code>p1.__truediv__(p2)</code></td> 
   </tr> 
   <tr> 
    <td>地板除法</td> 
    <td><code>p1 // p2</code></td> 
    <td><code>p1.__floordiv__(p2)</code></td> 
   </tr> 
   <tr> 
    <td>模 (modulo)</td> 
    <td><code>p1 % p2</code></td> 
    <td><code>p1.__mod__(p2)</code></td> 
   </tr> 
   <tr> 
    <td>按位左移</td> 
    <td><code>p1 &lt;&lt; p2</code></td> 
    <td><code>p1.__lshift__(p2)</code></td> 
   </tr> 
   <tr> 
    <td>按位右移</td> 
    <td><code>p1 &gt;&gt; p2</code></td> 
    <td><code>p1.__rshift__(p2)</code></td> 
   </tr> 
   <tr> 
    <td>按位AND</td> 
    <td><code>p1 &amp; p</code></td> 
    <td><code>p1.__and__(p2)</code></td> 
   </tr> 
   <tr> 
    <td>按位OR</td> 
    <td><code>p1 or p2</code></td> 
    <td><code>p1.__or__(p2)</code></td> 
   </tr> 
   <tr> 
    <td>按位XOR</td> 
    <td><code>p1 ^ p2</code></td> 
    <td><code>p1.__xor__(p2)</code></td> 
   </tr> 
   <tr> 
    <td>按位NOT</td> 
    <td>`~p1</td> 
    <td>p1.<strong>invert</strong>() `</td> 
   </tr> 
  </tbody> 
 </table> 
 <h2 id="h2--python-"><a name="在Python中重载比较运算符" class="reference-link"></a><span class="header-link octicon octicon-link"></span>在Python中重载比较运算符</h2>
 <p>Python不会限制操作符重载算术运算符。也可以重载比较运算符。</p> 
 <p>假设想在<code>Point</code>类中实现小于符号<code>&lt;</code>比较运算。</p> 
 <p>比较这些来自原点的数值，并为此返回结果。 可以实现如下。</p>   
 <pre><code class="lang-pythton">class Point:
    def __init__(self, x = 0, y = 0):
        self.x = x
        self.y = y

    def __str__(self):
        return "({0},{1})".format(self.x,self.y)

    def __lt__(self,other):
        self_mag = (self.x ** 2) + (self.y ** 2)
        other_mag = (other.x ** 2) + (other.y ** 2)
        return self_mag &lt; other_mag
</code></pre> 
 <p>在Python shell中尝试这些示例运行。</p> 
 <pre><code class="lang-pythton">&gt;&gt;&gt; Point(1,1) &lt; Point(-2,-3)
True

&gt;&gt;&gt; Point(1,1) &lt; Point(0.5,-0.2)
False

&gt;&gt;&gt; Point(1,1) &lt; Point(1,1)
False
</code></pre> 
 <p>类似地，可以实现的特殊功能，以重载其他比较运算符，如下表所示。</p> 
 <table> 
  <thead> 
   <tr> 
    <th>运算符</th> 
    <th>表达式</th> 
    <th>内置函数</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>小于</td> 
    <td><code>p1 &lt; p2</code></td> 
    <td><code>p1.__lt__(p2)</code></td> 
   </tr> 
   <tr> 
    <td>小于或等于</td> 
    <td><code>p1 &lt;= p2</code></td> 
    <td><code>p1.__le__(p2)</code></td> 
   </tr> 
   <tr> 
    <td>等于</td> 
    <td><code>p1 == p2</code></td> 
    <td><code>p1.__eq__(p2)</code></td> 
   </tr> 
   <tr> 
    <td>不等于</td> 
    <td><code>p1 != p2</code></td> 
    <td><code>p1.__ne__(p2)</code></td> 
   </tr> 
   <tr> 
    <td>大于</td> 
    <td><code>p1 &gt; p2</code></td> 
    <td><code>p1.__gt__(p2)</code></td> 
   </tr> 
   <tr> 
    <td>大于或等于</td> 
    <td><code>p1 &gt;= p2</code></td> 
    <td><code>p1.__ge__(p2)</code></td> 
   </tr> 
  </tbody> 
 </table>
 <br>      
</div></body></html>