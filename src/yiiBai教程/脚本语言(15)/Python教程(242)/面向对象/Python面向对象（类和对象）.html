<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Python面向对象（类和对象）</h1><div style="width:100%;float:left;" class="article-content">   
 <p>自从存在以来，Python一直是面向对象的语言。 因此，创建和使用类和对象是非常容易的。 本章将学习如何使用Python面向对象编程。</p> 
 <p>如果您以前没有面向对象(OO)编程的经验，可能需要查阅介绍面向对象(OO)编程课程或至少学习一些有关教程，以便掌握基本概念。</p> 
 <p>下面是面向对象编程(OOP)的一个小介绍，以帮助您快速入门学习 -</p> 
 <p><strong>OOP术语概述</strong> </p> 
 <ul> 
  <li><strong>类</strong> - 用于定义表示用户定义对象的一组属性的原型。属性是通过点符号访问的数据成员(类变量和实例变量)和方法。</li>
  <li><strong>类变量</strong> - 由类的所有实例共享的变量。 类变量在类中定义，但在类的任何方法之外。 类变量不像实例变量那样频繁使用。</li>
  <li><strong>数据成员</strong> - 保存与类及其对象相关联的数据的类变量或实例变量。</li>
  <li><strong>函数重载</strong> - 将多个行为分配给特定函数。 执行的操作因涉及的对象或参数的类型而异。</li>
  <li><strong>实例变量</strong> - 在方法中定义并仅属于类的当前实例的变量。</li>
  <li><strong>继承</strong> - 将类的特征传递给从其派生的其他类。</li>
  <li><strong>实例</strong> - 某个类的单个对象。 例如，对象<code>obj</code>属于<code>Circle</code>类，它是<code>Circle</code>类的实例。</li>
  <li><strong>实例化</strong> - 创建类的实例。</li>
  <li><strong>方法</strong> - 在类定义中定义的一种特殊类型的函数。</li>
  <li><strong>对象</strong> - 由其类定义的数据结构的唯一实例。对象包括数据成员(类变量和实例变量)和方法。</li>
  <li><strong>运算符重载</strong> - 将多个函数分配给特定的运算符。</li>
 </ul> 
 <h2 id="h2-1-"><a name="1.创建类" class="reference-link"></a><span class="header-link octicon octicon-link"></span>1.创建类</h2>
 <p><code>class</code>语句创建一个新的类定义。 类的名称紧跟在<code>class</code>关键字之后，在类的名称之后紧跟冒号，如下 -</p> 
 <pre><code class="lang-python">class ClassName:
   'Optional class documentation string'
   class_suite
</code></pre> 
 <ul> 
  <li>该类有一个文档字符串，可以通过<code>ClassName.__doc__</code>访问。</li>
  <li><code>class_suite</code>由定义类成员，数据属性和函数的所有组件语句组成。</li>
 </ul> 
 <p><strong>示例</strong></p> 
 <p>以下是一个简单的Python类的例子 -</p> 
 <pre><code class="lang-python">class Employee:
   'Common base class for all employees'
   empCount = 0

   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1

   def displayCount(self):
     print "Total Employee %d" % Employee.empCount

   def displayEmployee(self):
      print "Name : ", self.name,  ", Salary: ", self.salary
</code></pre> 
 <ul> 
  <li><p>变量<code>empCount</code>是一个类变量，其值在此类中的所有实例之间共享。 这可以从类或类之外的<code>Employee.empCount</code>访问。</p> </li>
  <li><p>第一个方法<code>__init __()</code>是一种特殊的方法，当创建此类的新实例时，该方法称为Python构造函数或初始化方法。</p> </li>
  <li><p>声明其他类方法，如正常函数，但每个方法的第一个参数是<code>self</code>。 Python将<code>self</code>参数添加到列表中; 调用方法时不需要包含它。</p> </li>
 </ul> 
 <h2 id="h2-2-"><a name="2.创建实例对象" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2.创建实例对象</h2>
 <p>要创建类的实例，可以使用类名调用该类，并传递其<code>__init__</code>方法接受的任何参数。</p> 
 <pre><code class="lang-python">## This would create first object of Employee class
emp1 = Employee("Maxsu", 2000)
## This would create second object of Employee class
emp2 = Employee("Kobe", 5000)
</code></pre> 
 <h2 id="h2-3-"><a name="3.访问属性" class="reference-link"></a><span class="header-link octicon octicon-link"></span>3.访问属性</h2>
 <p>可以使用带有对象的点(<code>.</code>)运算符来访问对象的属性。 类变量将使用类名访问如下 -</p> 
 <pre><code class="lang-python">emp1.displayEmployee()
emp2.displayEmployee()
print ("Total Employee %d" % Employee.empCount)
</code></pre> 
 <p>现在把所有的概念放在一起 -</p> 
 <pre><code class="lang-python">#!/usr/bin/python3

class Employee:
   'Common base class for all employees'
   empCount = 0

   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1

   def displayCount(self):
     print ("Total Employee %d" % Employee.empCount)

   def displayEmployee(self):
      print ("Name : ", self.name,  ", Salary: ", self.salary)


#This would create first object of Employee class"
emp1 = Employee("Maxsu", 2000)
#This would create second object of Employee class"
emp2 = Employee("Kobe", 5000)
emp1.displayEmployee()
emp2.displayEmployee()
print ("Total Employee %d" % Employee.empCount)
</code></pre> 
 <p>当执行上述代码时，会产生以下结果 -</p> 
 <pre><code class="lang-python">Name :  Maxsu ,Salary:  2000
Name :  Kobe ,Salary:  5000
Total Employee 2
</code></pre> 
 <p>可以随时添加，删除或修改类和对象的属性 -</p> 
 <pre><code class="lang-python">emp1.salary = 7000  # Add an 'salary' attribute.
emp1.name = 'xyz'  # Modify 'age' attribute.
del emp1.salary  # Delete 'age' attribute.
</code></pre> 
 <p>如果不是使用普通语句访问属性，可以使用以下函数 -</p> 
 <ul> 
  <li><code>getattr(obj，name [，default])</code> - 访问对象的属性。</li>
  <li><code>hasattr(obj，name)</code> - 检查属性是否存在。</li>
  <li><code>setattr(obj，name，value)</code> - 设置一个属性。如果属性不存在，那么它将被创建。</li>
  <li><code>delattr(obj，name)</code> - 删除一个属性。</li>
 </ul> 
 <p>下面是一此使用示例 - </p> 
 <pre><code class="lang-python">hasattr(emp1, 'salary')    # Returns true if 'salary' attribute exists
getattr(emp1, 'salary')    # Returns value of 'salary' attribute
setattr(emp1, 'salary', 7000) # Set attribute 'salary' at 7000
delattr(emp1, 'salary')    # Delete attribute 'salary'
</code></pre> 
 <h2 id="h2-3-"><a name="3.内置类属性" class="reference-link"></a><span class="header-link octicon octicon-link"></span>3.内置类属性</h2>
 <p>每个Python类保持以下内置属性，并且可以像任何其他属性一样使用点运算符访问它们 -</p> 
 <ul> 
  <li><code>__dict__</code> - 包含该类的命名空间的字典。</li>
  <li><code>__doc__</code> - 类文档字符串或无，如果未定义。</li>
  <li><code>__name__</code> - 类名。</li>
  <li><code>__module__</code> - 定义类的模块名称。此属性在交互模式下的值为“<strong>main</strong>”。</li>
  <li><code>__bases__</code> - 一个包含基类的空元组，按照它们在基类列表中出现的顺序。</li>
 </ul> 
 <p>对于上述类，尝试访问所有这些属性 -</p> 
 <pre><code class="lang-python">#!/usr/bin/python3

class Employee:
   'Common base class for all employees'
   empCount = 0

   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1

   def displayCount(self):
     print ("Total Employee %d" % Employee.empCount)

   def displayEmployee(self):
      print ("Name : ", self.name,  ", Salary: ", self.salary)

emp1 = Employee("Maxsu", 2000)
emp2 = Employee("Bryant", 5000)
print ("Employee.__doc__:", Employee.__doc__)
print ("Employee.__name__:", Employee.__name__)
print ("Employee.__module__:", Employee.__module__)
print ("Employee.__bases__:", Employee.__bases__)
print ("Employee.__dict__:", Employee.__dict__ )
</code></pre> 
 <p>当执行上述代码时，会产生以下结果 -</p> 
 <pre><code class="lang-python">Employee.__doc__: Common base class for all employees
Employee.__name__: Employee
Employee.__module__: __main__
Employee.__bases__: (&lt;class 'object'&gt;,)
Employee.__dict__: {
   'displayCount': &lt;function Employee.displayCount at 0x0160D2B8&gt;, 
   '__module__': '__main__', '__doc__': 'Common base class for all employees', 
   'empCount': 2, '__init__': 
   &lt;function Employee.__init__ at 0x0124F810&gt;, 'displayEmployee': 
   &lt;function Employee.displayEmployee at 0x0160D300&gt;,
   '__weakref__': 
   &lt;attribute '__weakref__' of 'Employee' objects&gt;, '__dict__': 
   &lt;attribute '__dict__' of 'Employee' objects&gt;
}
</code></pre> 
 <h2 id="h2-4-"><a name="4.销毁对象(垃圾收集)" class="reference-link"></a><span class="header-link octicon octicon-link"></span>4.销毁对象(垃圾收集)</h2>
 <p>Python自动删除不需要的对象(内置类型或类实例)以释放内存空间。 Python定期回收不再使用的内存块的过程称为垃圾收集。</p> 
 <p>Python的垃圾收集器在程序执行期间运行，当对象的引用计数达到零时触发。 对象的引用计数随着指向它的别名数量而变化。</p> 
 <p>当对象的引用计数被分配一个新名称或放置在容器(列表，元组或字典)中时，它的引用计数会增加。 当用<code>del</code>删除对象的引用计数时，引用计数减少，其引用被重新分配，或者其引用超出范围。 当对象的引用计数达到零时，Python会自动收集它。</p> 
 <pre><code class="lang-python">a = 40      # Create object &lt;40&gt;
b = a       # Increase ref. count  of &lt;40&gt; 
c = [b]     # Increase ref. count  of &lt;40&gt; 

del a       # Decrease ref. count  of &lt;40&gt;
b = 100     # Decrease ref. count  of &lt;40&gt; 
c[0] = -1   # Decrease ref. count  of &lt;40&gt;
</code></pre> 
 <p>通常情况下，垃圾回收器会销毁孤立的实例并回收其空间。 但是，类可以实现调用析构函数的特殊方法<code>__del__()</code>，该方法在实例即将被销毁时被调用。 此方法可能用于清理实例使用的任何非内存资源。</p> 
 <p><strong>示例</strong></p> 
 <p>这个<code>__del__()</code>析构函数打印要被销毁的实例的类名 -</p> 
 <pre><code class="lang-python">#!/usr/bin/python3

class Point:
   def __init__( self, x=0, y=0):
      self.x = x
      self.y = y
   def __del__(self):
      class_name = self.__class__.__name__
      print (class_name, "destroyed")

pt1 = Point()
pt2 = pt1
pt3 = pt1
print (id(pt1), id(pt2), id(pt3));   # prints the ids of the obejcts
del pt1
del pt2
del pt3
</code></pre> 
 <p>当执行上述代码时，会产生以下结果 -</p>   
 <pre><code class="lang-python">3083401324 3083401324 3083401324
Point destroyed
</code></pre> 
 <blockquote> 
  <p>注意 - 理想情况下，应该在单独的文件中定义类，然后使用<code>import</code>语句将其导入主程序文件。</p> 
 </blockquote> 
 <p>在上面的例子中，假定<code>Point</code>类的定义包含在<code>point.py</code>中，并且其中没有其他可执行代码。</p> 
 <pre><code class="lang-python">#!/usr/bin/python3
import point
p1 = point.Point()
</code></pre> 
 <h2 id="h2-5-"><a name="5.类继承" class="reference-link"></a><span class="header-link octicon octicon-link"></span>5.类继承</h2>
 <p>使用类继承不用从头开始构建代码，可以通过在新类名后面的括号中列出父类来从一个预先存在的类派生它来创建一个类。</p> 
 <p>子类继承其父类的属性，可以像子类中一样定义和使用它们。子类也可以从父类代替代数据成员和方法。</p> 
 <p><strong>语法</strong></p> 
 <p>派生类被声明为很像它们的父类; 然而，继承的基类的列表在类名之后给出 -</p> 
 <pre><code class="lang-python">class SubClassName (ParentClass1[, ParentClass2, ...]):
   'Optional class documentation string'
   class_suite
</code></pre> 
 <p><strong>示例</strong></p> 
 <pre><code class="lang-python">#!/usr/bin/python3

class Parent:        # define parent class
   parentAttr = 100
   def __init__(self):
      print ("Calling parent constructor")

   def parentMethod(self):
      print ('Calling parent method')

   def setAttr(self, attr):
      Parent.parentAttr = attr

   def getAttr(self):
      print ("Parent attribute :", Parent.parentAttr)

class Child(Parent): # define child class
   def __init__(self):
      print ("Calling child constructor")

   def childMethod(self):
      print ('Calling child method')

c = Child()          # instance of child
c.childMethod()      # child calls its method
c.parentMethod()     # calls parent's method
c.setAttr(200)       # again call parent's method
c.getAttr()          # again call parent's method
</code></pre> 
 <p>当执行上述代码时，会产生以下结果 -</p> 
 <pre><code class="lang-python">Calling child constructor
Calling child method
Calling parent method
Parent attribute : 200
</code></pre> 
 <p>以类似的方式，可以从多个父类来构建一个新的类，如下所示：</p> 
 <pre><code class="lang-python">class A:        # define your class A
.....

class B:         # define your calss B
.....

class C(A, B):   # subclass of A and B
.....
</code></pre> 
 <p>可以使用<code>issubclass()</code>或<code>isinstance()</code>函数来检查两个类和实例之间的关系。</p> 
 <ul> 
  <li><code>issubclass(sub，sup)</code>布尔函数如果给定的子类<code>sub</code>确实是超类<code>sup</code>的子类返回<code>True</code>。</li>
  <li><code>isinstance(obj，Class)</code>布尔函数如果<code>obj</code>是类<code>Class</code>的一个实例，或者是类的一个子类的实例则返回<code>True</code>。</li>
 </ul> 
 <h3 id="h3-u91CDu8F7Du65B9u6CD5"><a name="重载方法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>重载方法</h3>
 <p>可以随时重载父类的方法。 重载父方法的一个原因是：您可能希望在子类中使用特殊或不同的方法功能。</p> 
 <p><strong>示例</strong></p> 
 <pre><code class="lang-python">#!/usr/bin/python3

class Parent:        # define parent class
   def myMethod(self):
      print ('Calling parent method')

class Child(Parent): # define child class
   def myMethod(self):
      print ('Calling child method')

c = Child()          # instance of child
c.myMethod()         # child calls overridden method
</code></pre> 
 <p>当执行上述代码时，会产生以下结果 -</p> 
 <pre><code class="lang-python">Calling child method
</code></pre> 
 <h3 id="h3-u57FAu672Cu91CDu8F7Du65B9u6CD5"><a name="基本重载方法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>基本重载方法</h3>
 <p>下表列出了可以在自己的类中覆盖的一些通用方法 -</p> 
 <table> 
  <thead> 
   <tr> 
    <th>编号</th> 
    <th>方法</th> 
    <th>描述</th> 
    <th>调用示例</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>1</td> 
    <td><code>__init__ ( self [,args...] )</code></td> 
    <td>构造函数(带任意可选参数)</td> 
    <td><code>obj = className(args)</code></td> 
   </tr> 
   <tr> 
    <td>2</td> 
    <td><code>__del__( self )</code></td> 
    <td>析构函数，删除一个对象</td> 
    <td><code>del obj</code></td> 
   </tr> 
   <tr> 
    <td>3</td> 
    <td><code>__repr__( self )</code></td> 
    <td>可评估求值的字符串表示</td> 
    <td><code>repr(obj)</code></td> 
   </tr> 
   <tr> 
    <td>4</td> 
    <td><code>__str__( self )</code></td> 
    <td>可打印的字符串表示</td> 
    <td><code>str(obj)</code></td> 
   </tr> 
   <tr> 
    <td>5</td> 
    <td><code>__cmp__ ( self, x )</code></td> 
    <td>对象比较</td> 
    <td><code>cmp(obj, x)</code></td> 
   </tr> 
  </tbody> 
 </table> 
 <h2 id="h2-6-"><a name="6.重载运算符" class="reference-link"></a><span class="header-link octicon octicon-link"></span>6.重载运算符</h2>
 <p>假设已经创建了一个<code>Vector</code>类来表示二维向量。当使用加号(<code>+</code>)运算符执行运算时，它们会发生什么？ 很可能Python理解不了你想要做什么。</p> 
 <p>但是，可以在类中定义<code>__add__</code>方法来执行向量加法，然后将按照期望行为那样执行加法运算 -</p> 
 <p><strong>示例</strong></p> 
 <pre><code class="lang-python">#!/usr/bin/python3

class Vector:
   def __init__(self, a, b):
      self.a = a
      self.b = b

   def __str__(self):
      return 'Vector (%d, %d)' % (self.a, self.b)

   def __add__(self,other):
      return Vector(self.a + other.a, self.b + other.b)

v1 = Vector(2,10)
v2 = Vector(5,-2)
print (v1 + v2)
</code></pre> 
 <p>当执行上述代码时，会产生以下结果 -</p> 
 <pre><code class="lang-python">Vector(7,8)
</code></pre> 
 <h2 id="h2-7-"><a name="7.数据隐藏" class="reference-link"></a><span class="header-link octicon octicon-link"></span>7.数据隐藏</h2>
 <p>对象的属性在类定义之外可能或不可见。需要使用双下划线前缀命名属性，然后这些属性将不会直接对外部可见。</p> 
 <p><strong>示例</strong></p> 
 <pre><code class="lang-python">#!/usr/bin/python3

class JustCounter:
   __secretCount = 0

   def count(self):
      self.__secretCount += 1
      print (self.__secretCount)

counter = JustCounter()
counter.count()
counter.count()
print (counter.__secretCount)
</code></pre> 
 <p>当执行上述代码时，会产生以下结果 -</p> 
 <pre><code class="lang-shell">1
2
Traceback (most recent call last):
   File "test.py", line 12, in &lt;module&gt;
      print counter.__secretCount
AttributeError: JustCounter instance has no attribute '__secretCount'
</code></pre> 
 <p>Python通过内部更改名称来包含类名称来保护这些成员。 可以访问<code>object._className__attrName</code>等属性。如果将最后一行替换为以下，那么它适用于 -</p> 
 <pre><code class="lang-python">.........................
print (counter._JustCounter__secretCount)
</code></pre> 
 <p>当执行上述代码时，会产生以下结果 -</p> 
 <pre><code class="lang-shell">1
2
2
</code></pre>
 <br>      
</div></body></html>