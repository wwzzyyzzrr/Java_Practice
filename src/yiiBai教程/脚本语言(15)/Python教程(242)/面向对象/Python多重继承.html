<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Python多重继承</h1><div style="width:100%;float:left;" class="article-content">   
 <p>在本文中，您将了解Python中的多重继承以及如何在程序中使用它。还将了解多级继承和方法解析顺序。</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201706/2706/451080631_51525.jpg" alt=""></p> 
 <p>与C++一样，一个类可以从Python中的多个基类派生出来。这被称为多重继承。</p> 
 <p>在多重继承中，所有基类的特征都被继承到派生类中。多重继承的语法类似于单继承。</p> 
 <p><strong>Python多重继承示例</strong></p> 
 <pre><code class="lang-python">class Base1:
    pass

class Base2:
    pass

class MultiDerived(Base1, Base2):
    pass
</code></pre> 
 <p>这里，<code>MultiDerived</code>派生自<code>Base1</code>和<code>Base2</code>类。</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201706/2706/697080634_93411.jpg" alt=""></p> 
 <p><code>MultiDerived</code>类从<code>Base1</code>和<code>Base2</code>继承。</p> 
 <h2 id="h2-python-"><a name="Python中的多层继承" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Python中的多层继承</h2>
 <p>另一方面，我们也可以继承一个派生类的形式。这被称为多级继承。 它可以在Python中有任何的深度(层级)。在多级继承中，基类和派生类的特性被继承到新的派生类中。<br>下面给出了具有相应可视化的示例。</p> 
 <pre><code class="lang-python">class Base:
    pass

class Derived1(Base):
    pass

class Derived2(Derived1):
    pass
</code></pre> 
 <p>这里，<code>Derived1</code>派生自<code>Base</code>，<code>Derived2</code>派生自<code>Derived1</code>。</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201706/2706/238080640_87576.jpg" alt=""></p> 
 <h2 id="h2-python-"><a name="Python中的方法解析顺序" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Python中的方法解析顺序</h2>
 <p>Python中的每个类都派生自类:<code>object</code>。它是Python中最基础的类型。</p> 
 <p>所以在技术上，所有其他类，无论是内置还是用户定义，都是派生类，所有对象都是对象类的实例。</p> 
 <pre><code class="lang-python"># Output: True
print(issubclass(list,object))

# Output: True
print(isinstance(5.5,object))

# Output: True
print(isinstance("Hello",object))
</code></pre> 
 <p>在多继承方案中，在当前类中首先搜索任何指定的属性。如果没有找到，搜索继续进入父类，深度优先，再到左右的方式，而不需要搜索相同的类两次。</p> 
 <p>所以在<code>MultiDerived</code>类的上面的例子中，搜索顺序是<code>[MultiDerived，Base1，Base2，object]</code>。 此顺序也称为<code>MultiDerived</code>类的线性化，用于查找此顺序的一组规则称为方法解析顺序(MRO)。</p> 
 <p>MRO必须防止本地优先排序，并提供单调性。它确保一个类总是出现在其父类之前，并且在多个父类的情况下，该顺序与基类的元组相同。</p> 
 <p>一个类的MRO可以被看作是<code>__mro__</code>属性或者<code>mro()</code>方法。前者返回一个元组，而后者返回一个列表。</p>   
 <pre><code class="lang-python">&gt;&gt;&gt; MultiDerived.__mro__
(&lt;class '__main__.MultiDerived'&gt;,
 &lt;class '__main__.Base1'&gt;,
 &lt;class '__main__.Base2'&gt;,
 &lt;class 'object'&gt;)

&gt;&gt;&gt; MultiDerived.mro()
[&lt;class '__main__.MultiDerived'&gt;,
 &lt;class '__main__.Base1'&gt;,
 &lt;class '__main__.Base2'&gt;,
 &lt;class 'object'&gt;]
</code></pre> 
 <p>这里有一个更复杂的多重继承示例及其可视化图型。</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201706/2706/470080646_77018.jpg" alt=""></p> 
 <pre><code class="lang-python">class X: pass
class Y: pass
class Z: pass

class A(X,Y): pass
class B(Y,Z): pass

class M(B,A,Z): pass

# Output:
# [&lt;class '__main__.M'&gt;, &lt;class '__main__.B'&gt;,
# &lt;class '__main__.A'&gt;, &lt;class '__main__.X'&gt;,
# &lt;class '__main__.Y'&gt;, &lt;class '__main__.Z'&gt;,
# &lt;class 'object'&gt;]

print(M.mro())
</code></pre> 
 <p>参考这一点，进一步讨论MRO并了解实际算法如何计算。</p>
 <br>      
</div></body></html>