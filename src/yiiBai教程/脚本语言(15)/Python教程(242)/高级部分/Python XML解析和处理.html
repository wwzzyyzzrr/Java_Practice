<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Python XML解析和处理</h1><div style="width:100%;float:left;" class="article-content">   
 <p>XML是一种便携式的开源语言，允许程序员开发可由其他应用程序读取的应用程序，而不管操作系统和/或开发语言是什么。</p> 
 <h2 id="h2-1-xml-"><a name="1.什么是XML？" class="reference-link"></a><span class="header-link octicon octicon-link"></span>1.什么是XML？</h2>
 <p>可扩展标记语言(<a target="_blank" href="http://www.yiibai.com/xml/" title="XML">XML</a>)是一种非常像HTML或SGML的标记语言。 这是由万维网联盟推荐的，可以作为开放标准。</p> 
 <p>XML对于存储小到中等数量的数据非常有用，而不需要使用SQL。</p> 
 <h2 id="h2-2-xml-api"><a name="2.XML解析器体系结构和API" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2.XML解析器体系结构和API</h2>
 <p>Python标准库提供了一组极少使用但有用的接口来处理XML。两个最基本和最广泛使用在XML数据的API是SAX和DOM接口。</p> 
 <ul> 
  <li><p>简单XML API(SAX) - 在这里，注册感兴趣的事件回调，然后让解析器继续执行文档。 当文档较大或存在内存限制时，此功能非常有用，它会从文件读取文件时解析文件，并且整个文件不会存储在内存中。</p> </li>
  <li><p>文档对象模型(DOM)API - 这是一个万维网联盟的推荐，它将整个文件读入存储器并以分层(基于树)的形式存储，以表示XML文档的所有功能。</p> </li>
 </ul> 
 <p>当处理大文件时，SAX显然无法与DOM一样快地处理信息。 另一方面，使用DOM专门可以真正地占用资源，特别是如果要加许多文件使用的时候。</p> 
 <p>SAX是只读的，而DOM允许更改XML文件。由于这两种不同的API相辅相成，在大型项目中一般根据需要使用它们。</p> 
 <p>对于我们所有的XML代码示例，使用一个简单的XML文件：<code>movies.xml</code>作为输入 -</p> 
 <pre><code class="lang-xml">&lt;collection shelf = "New Arrivals"&gt;
&lt;movie title = "Enemy Behind"&gt;
   &lt;type&gt;War, Thriller&lt;/type&gt;
   &lt;format&gt;DVD&lt;/format&gt;
   &lt;year&gt;2013&lt;/year&gt;
   &lt;rating&gt;PG&lt;/rating&gt;
   &lt;stars&gt;10&lt;/stars&gt;
   &lt;description&gt;Talk about a US-Japan war&lt;/description&gt;
&lt;/movie&gt;
&lt;movie title = "Transformers"&gt;
   &lt;type&gt;Anime, Science Fiction&lt;/type&gt;
   &lt;format&gt;DVD&lt;/format&gt;
   &lt;year&gt;1989&lt;/year&gt;
   &lt;rating&gt;R&lt;/rating&gt;
   &lt;stars&gt;8&lt;/stars&gt;
   &lt;description&gt;A schientific fiction&lt;/description&gt;
&lt;/movie&gt;
   &lt;movie title = "Trigun"&gt;
   &lt;type&gt;Anime, Action&lt;/type&gt;
   &lt;format&gt;DVD&lt;/format&gt;
   &lt;episodes&gt;4&lt;/episodes&gt;
   &lt;rating&gt;PG&lt;/rating&gt;
   &lt;stars&gt;10&lt;/stars&gt;
   &lt;description&gt;Vash the Stampede!&lt;/description&gt;
&lt;/movie&gt;
&lt;movie title = "Ishtar"&gt;
   &lt;type&gt;Comedy&lt;/type&gt;
   &lt;format&gt;VHS&lt;/format&gt;
   &lt;rating&gt;PG&lt;/rating&gt;
   &lt;stars&gt;2&lt;/stars&gt;
   &lt;description&gt;Viewable boredom&lt;/description&gt;
&lt;/movie&gt;
&lt;/collection&gt;
</code></pre> 
 <h2 id="h2-3-sax-api-xml"><a name="3.使用SAX API解析XML" class="reference-link"></a><span class="header-link octicon octicon-link"></span>3.使用SAX API解析XML</h2>
 <p>SAX是事件驱动的XML解析的标准接口。 使用SAX解析XML通常需要通过子类化<code>xml.sax.ContentHandler</code>来创建自己的<code>ContentHandler</code>。<br><code>ContentHandler</code>处理XML样式/风格的特定标签和属性。 <code>ContentHandler</code>对象提供了处理各种解析事件的方法。它拥有的解析器在解析XML文件时调用<code>ContentHandler</code>方法。<br>在XML文件的开头和结尾分别调用：<code>startDocument</code>和<code>endDocument</code>方法。 <code>characters(text)</code>方法通过参数<code>text</code>传递XML文件的字符数据。</p> 
 <p><code>ContentHandler</code>在每个元素的开头和结尾被调用。如果解析器不在命名空间模式下，则调用<code>startElement(tag，attributes)</code>和<code>endElement(tag)</code>方法; 否则，调用相应的方法<code>startElementNS</code>和<code>endElementNS</code>方法。 这里，<code>tag</code>是元素标签，属性是<code>Attributes</code>对象。</p> 
 <p>以下是继续前面了解的其他重要方法 -</p> 
 <p><strong>make_parser()方法</strong></p> 
 <p>以下方法创建一个新的解析器对象并返回它。创建的解析器对象将是系统查找的第一个解析器类型。</p> 
 <pre><code class="lang-python">xml.sax.make_parser( [parser_list] )
</code></pre> 
 <p>以下是参数的详细信息 - </p> 
 <ul> 
  <li><em>parser_list</em> - 可选参数，由使用哪个解析器的列表组成，必须全部实现<code>make_parser</code>方法。</li>
 </ul> 
 <p><strong>parse()方法</strong></p> 
 <p>以下方法创建一个SAX解析器并使用它来解析文档。</p> 
 <pre><code class="lang-python">xml.sax.parse( xmlfile, contenthandler[, errorhandler])
</code></pre> 
 <p>以下是参数的详细信息 -</p> 
 <ul> 
  <li><em>xmlfile</em> - 这是要读取的XML文件的名称。</li>
  <li><em>contenthandler</em> - 这必须是<code>ContentHandler</code>对象。</li>
  <li><em>errorhandler</em> - 如果指定，<code>errorhandler</code>必须是SAX ErrorHandler</li>
 </ul> 
 <p><strong>parseString方法</strong></p> 
 <p>还有一种方法来创建SAX解析器并解析指定的XML字符串。</p> 
 <pre><code class="lang-python">xml.sax.parseString(xmlstring, contenthandler[, errorhandler])
</code></pre> 
 <p>以下是参数的详细信息 -</p> 
 <ul> 
  <li><em>xmlstring</em> - 这是要读取的XML字符串的名称。</li>
  <li><em>contenthandler</em> - 这必须是<code>ContentHandler</code>对象。</li>
  <li><em>errorhandler</em> - 如果指定，<code>errorhandler</code>必须是SAX <code>ErrorHandler</code>对象。</li>
 </ul> 
 <p><strong>示例</strong></p> 
 <pre><code class="lang-python">#!/usr/bin/python3

import xml.sax

class MovieHandler( xml.sax.ContentHandler ):
   def __init__(self):
      self.CurrentData = ""
      self.type = ""
      self.format = ""
      self.year = ""
      self.rating = ""
      self.stars = ""
      self.description = ""

   # Call when an element starts
   def startElement(self, tag, attributes):
      self.CurrentData = tag
      if tag == "movie":
         print ("*****Movie*****")
         title = attributes["title"]
         print ("Title:", title)

   # Call when an elements ends
   def endElement(self, tag):
      if self.CurrentData == "type":
         print ("Type:", self.type)
      elif self.CurrentData == "format":
         print ("Format:", self.format)
      elif self.CurrentData == "year":
         print ("Year:", self.year)
      elif self.CurrentData == "rating":
         print ("Rating:", self.rating)
      elif self.CurrentData == "stars":
         print ("Stars:", self.stars)
      elif self.CurrentData == "description":
         print ("Description:", self.description)
      self.CurrentData = ""

   # Call when a character is read
   def characters(self, content):
      if self.CurrentData == "type":
         self.type = content
      elif self.CurrentData == "format":
         self.format = content
      elif self.CurrentData == "year":
         self.year = content
      elif self.CurrentData == "rating":
         self.rating = content
      elif self.CurrentData == "stars":
         self.stars = content
      elif self.CurrentData == "description":
         self.description = content

if ( __name__ == "__main__"):

   # create an XMLReader
   parser = xml.sax.make_parser()
   # turn off namepsaces
   parser.setFeature(xml.sax.handler.feature_namespaces, 0)

   # override the default ContextHandler
   Handler = MovieHandler()
   parser.setContentHandler( Handler )

   parser.parse("movies.xml")
</code></pre> 
 <p>这将产生以下结果 -</p>   
 <pre><code class="lang-python">*****Movie*****
Title: Enemy Behind
Type: War, Thriller
Format: DVD
Year: 2003
Rating: PG
Stars: 10
Description: Talk about a US-Japan war
*****Movie*****
Title: Transformers
Type: Anime, Science Fiction
Format: DVD
Year: 1989
Rating: R
Stars: 8
Description: A schientific fiction
*****Movie*****
Title: Trigun
Type: Anime, Action
Format: DVD
Rating: PG
Stars: 10
Description: Vash the Stampede!
*****Movie*****
Title: Ishtar
Type: Comedy
Format: VHS
Rating: PG
Stars: 2
Description: Viewable boredom
</code></pre> 
 <p>有关SAX API文档的完整详细信息，请参阅<a target="_blank" href="http://docs.python.org/library/xml.sax.html" title="标准Python SAX API">标准Python SAX API</a>。</p> 
 <h2 id="h2--dom-api-xml"><a name="使用DOM API解析XML" class="reference-link"></a><span class="header-link octicon octicon-link"></span>使用DOM API解析XML</h2>
 <p>文档对象模型(“DOM”)是来自万维网联盟(W3C)的跨语言API，用于访问和修改XML文档。</p> 
 <p>DOM对于随机访问应用非常有用。SAX只允许您一次查看文档的一部分。如果想要查看一个SAX元素，则无法访问另一个。</p> 
 <p>以下是快速加载XML文档并使用<code>xml.dom</code>模块创建minidom对象的最简单方法。 minidom对象提供了一个简单的解析器方法，可以从XML文件快速创建一个DOM树。</p> 
 <p>示例调用<code>minidom</code>对象的<code>parse(file [，parser])</code>函数来解析由文件指定为DOM树对象的XML文件。</p> 
 <p><strong>示例</strong></p> 
 <pre><code class="lang-python">#!/usr/bin/python3

from xml.dom.minidom import parse
import xml.dom.minidom

# Open XML document using minidom parser
DOMTree = xml.dom.minidom.parse("movies.xml")
collection = DOMTree.documentElement
if collection.hasAttribute("shelf"):
   print ("Root element : %s" % collection.getAttribute("shelf"))

# Get all the movies in the collection
movies = collection.getElementsByTagName("movie")

# Print detail of each movie.
for movie in movies:
   print ("*****Movie*****")
   if movie.hasAttribute("title"):
      print ("Title: %s" % movie.getAttribute("title"))

   type = movie.getElementsByTagName('type')[0]
   print ("Type: %s" % type.childNodes[0].data)
   format = movie.getElementsByTagName('format')[0]
   print ("Format: %s" % format.childNodes[0].data)
   rating = movie.getElementsByTagName('rating')[0]
   print ("Rating: %s" % rating.childNodes[0].data)
   description = movie.getElementsByTagName('description')[0]
   print ("Description: %s" % description.childNodes[0].data)
</code></pre> 
 <p>这将产生以下结果 -</p> 
 <pre><code class="lang-shell">Root element : New Arrivals
*****Movie*****
Title: Enemy Behind
Type: War, Thriller
Format: DVD
Rating: PG
Description: Talk about a US-Japan war
*****Movie*****
Title: Transformers
Type: Anime, Science Fiction
Format: DVD
Rating: R
Description: A schientific fiction
*****Movie*****
Title: Trigun
Type: Anime, Action
Format: DVD
Rating: PG
Description: Vash the Stampede!
*****Movie*****
Title: Ishtar
Type: Comedy
Format: VHS
Rating: PG
Description: Viewable boredom
</code></pre> 
 <p>有关DOM API文档的完整详细信息，请参阅<a target="_blank" href="http://docs.python.org/library/xml.dom.html" title="标准Python DOM API">标准Python DOM API</a>。</p>
 <br>      
</div></body></html>