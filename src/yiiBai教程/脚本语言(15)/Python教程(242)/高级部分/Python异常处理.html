<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Python异常处理</h1><div style="width:100%;float:left;" class="article-content">   
 <p>Python提供了两个非常重要的功能来处理Python程序中的异常和错误，并在其中添加调试的函数功能 -</p> 
 <ul> 
  <li>异常处理 - 在本教程中介绍。这是一个列表标准Python中提供的异常 - 标准异常。</li>
  <li>断言 - 在<em>Python 3</em>教程中的断言中介绍。</li>
 </ul> 
 <h2 id="h2-u6807u51C6u5F02u5E38"><a name="标准异常" class="reference-link"></a><span class="header-link octicon octicon-link"></span>标准异常</h2>
 <p>以下是Python中可用的标准异常列表 -</p> 
 <table> 
  <thead> 
   <tr> 
    <th>编号</th> 
    <th>异常名称</th> 
    <th>描述</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>1</td> 
    <td>Exception</td> 
    <td>所有异常的基类</td> 
   </tr> 
   <tr> 
    <td>2</td> 
    <td>StopIteration</td> 
    <td>当迭代器的<code>next()</code>方法没有指向任何对象时引发。</td> 
   </tr> 
   <tr> 
    <td>3</td> 
    <td>SystemExit</td> 
    <td>由<code>sys.exit()</code>函数引发。</td> 
   </tr> 
   <tr> 
    <td>4</td> 
    <td>StandardError</td> 
    <td>除<code>StopIteration</code>和<code>SystemExit</code>之外的所有内置异常的基类。</td> 
   </tr> 
   <tr> 
    <td>5</td> 
    <td>ArithmeticError</td> 
    <td>数据计算出现的所有错误的基类。</td> 
   </tr> 
   <tr> 
    <td>6</td> 
    <td>OverflowError</td> 
    <td>当计算超过数字类型的最大限制时引发。</td> 
   </tr> 
   <tr> 
    <td>7</td> 
    <td>FloatingPointError</td> 
    <td>当浮点计算失败时触发。</td> 
   </tr> 
   <tr> 
    <td>8</td> 
    <td>ZeroDivisonError</td> 
    <td>对于所有的数字类型，当对零进行除数或模数时产生。</td> 
   </tr> 
   <tr> 
    <td>9</td> 
    <td>AssertionError</td> 
    <td>在<code>Assert</code>语句失败的情况下引发。</td> 
   </tr> 
   <tr> 
    <td>10</td> 
    <td>AttributeError</td> 
    <td>在属性引用或分配失败的情况下引发。</td> 
   </tr> 
   <tr> 
    <td>11</td> 
    <td>EOFError</td> 
    <td>当没有来自<code>raw_input()</code>或<code>input()</code>函数的输入并且达到文件结尾时引发。</td> 
   </tr> 
   <tr> 
    <td>12</td> 
    <td>ImportError</td> 
    <td>导入语句失败时引发。</td> 
   </tr> 
   <tr> 
    <td>13</td> 
    <td>KeyboardInterrupt</td> 
    <td>当用户中断程序执行时，通常按<code>Ctrl + c</code>。</td> 
   </tr> 
   <tr> 
    <td>14</td> 
    <td>LookupError</td> 
    <td>所有查找错误的基类。</td> 
   </tr> 
   <tr> 
    <td>15</td> 
    <td>IndexError</td> 
    <td>当序列中没有找到索引时引发。</td> 
   </tr> 
   <tr> 
    <td>16</td> 
    <td>KeyError</td> 
    <td>当在字典中找不到指定的键时引发。</td> 
   </tr> 
   <tr> 
    <td>17</td> 
    <td>NameError</td> 
    <td>当在本地或全局命名空间中找不到标识符时引发。</td> 
   </tr> 
   <tr> 
    <td>18</td> 
    <td>UnboundLocalError</td> 
    <td>当尝试访问函数或方法中的局部变量但未分配值时引发。</td> 
   </tr> 
   <tr> 
    <td>19</td> 
    <td>EnvironmentError</td> 
    <td>在Python环境之外发生的所有异常的基类。</td> 
   </tr> 
   <tr> 
    <td>20</td> 
    <td>IOError</td> 
    <td>在尝试打开不存在的文件时，输入/输出操作失败时触发，例如<code>print</code>语句或<code>open()</code>函数。</td> 
   </tr> 
   <tr> 
    <td>21</td> 
    <td>OSError</td> 
    <td>引起操作系统相关的错误。</td> 
   </tr> 
   <tr> 
    <td>22</td> 
    <td>SyntaxError</td> 
    <td>当Python语法有错误时引发。</td> 
   </tr> 
   <tr> 
    <td>23</td> 
    <td>IndentationError</td> 
    <td>当缩进未正确指定时触发。</td> 
   </tr> 
   <tr> 
    <td>24</td> 
    <td>SystemError</td> 
    <td>当解释器发现内部问题时引发，但遇到此错误时，Python解释器不会退出。</td> 
   </tr> 
   <tr> 
    <td>25</td> 
    <td>SystemExit</td> 
    <td>当Python解释器通过使用<code>sys.exit()</code>函数退出时引发。 如果没有在代码中处理，导致解释器退出。</td> 
   </tr> 
   <tr> 
    <td>26</td> 
    <td>TypeError</td> 
    <td>在尝试对指定数据类型无效的操作或函数时引发。</td> 
   </tr> 
   <tr> 
    <td>27</td> 
    <td>ValueError</td> 
    <td>当数据类型的内置函数具有有效参数类型时引发，但参数具有指定的无效值。</td> 
   </tr> 
   <tr> 
    <td>28</td> 
    <td>RuntimeError</td> 
    <td>产生的错误不属于任何类别时引发。</td> 
   </tr> 
   <tr> 
    <td>29</td> 
    <td>NotImplementedError</td> 
    <td>当需要在继承类中实现的抽象方法实际上没有实现时引发。</td> 
   </tr> 
  </tbody> 
 </table> 
 <h2 id="h2-python-"><a name="Python中的断言" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Python中的断言</h2>
 <p>断言是一个健全检查，可以在完成对程序的测试后打开或关闭。</p> 
 <ul> 
  <li><p>试想断言的最简单的方法就是将它与一个<code>raise-if</code>语句(或者更准确的说是一个加注<code>if</code>语句)相对应。测试表达式，如果结果为<code>false</code>，则会引发异常。</p> </li>
  <li><p>断言由版本<code>1.5</code>引入的<code>assert</code>语句来执行，它是Python的最新关键字。</p> </li>
  <li>程序员经常在函数开始时放置断言来检查有效的输入，并在函数调用后检查有效的输出。</li>
 </ul> 
 <h3 id="h3-assert-"><a name="assert语句" class="reference-link"></a><span class="header-link octicon octicon-link"></span>assert语句</h3>
 <p>当它遇到一个<code>assert</code>语句时，Python会评估求值它的的表达式，是否为所希望的那样。 如果表达式为<code>false</code>，Python会引发<code>AssertionError</code>异常。</p> 
 <p><code>assert</code>的语法是 -</p> 
 <pre><code class="lang-python">assert Expression[, Arguments]
</code></pre> 
 <p>如果断言失败，Python将使用<code>ArgumentExpression</code>作为<code>AssertionError</code>的参数。 使用<code>try-except</code>语句可以像任何其他异常一样捕获和处理<code>AssertionError</code>异常。 如果没有处理，它们将终止程序并产生回溯。<br><strong><br>示例</strong></p> 
 <p>这里将实现一个功能：将给定的温度从开尔文转换为华氏度。如果是负温度，该功能将退出 -</p> 
 <pre><code class="lang-python">#!/usr/bin/python3
def KelvinToFahrenheit(Temperature):
   assert (Temperature &gt;= 0),"Colder than absolute zero!"
   return ((Temperature-273)*1.8)+32

print (KelvinToFahrenheit(273))
print (int(KelvinToFahrenheit(505.78)))
print (KelvinToFahrenheit(-5))
</code></pre> 
 <p>当执行上述代码时，会产生以下结果 -</p> 
 <pre><code class="lang-python">32.0
451
Traceback (most recent call last):
File "test.py", line 9, in &lt;module&gt;
print KelvinToFahrenheit(-5)
File "test.py", line 4, in KelvinToFahrenheit
assert (Temperature &gt;= 0),"Colder than absolute zero!"
AssertionError: Colder than absolute zero!
</code></pre> 
 <h2 id="h2--"><a name="什么是异常？" class="reference-link"></a><span class="header-link octicon octicon-link"></span>什么是异常？</h2>
 <p>一个例外是在程序执行期间发生的一个事件，它破坏程序指令的正常流程。 一般来说，当Python脚本遇到无法应对的情况时，会引发异常。异常是一个表示错误的Python对象。</p> 
 <p>当Python脚本引发异常时，它必须立即处理异常，否则终止并退出。</p> 
 <h2 id="h2-u5904u7406u5F02u5E38"><a name="处理异常" class="reference-link"></a><span class="header-link octicon octicon-link"></span>处理异常</h2>
 <p>如果有一些可能引发异常的可疑代码，可以通过将可疑代码放在<code>try:</code>块中来保护您的程序。 在<code>try:</code>块之后，包括一个<code>except:</code>语句，然后是一个尽可能优雅地处理问题的代码块。</p> 
 <p><strong>语法</strong></p> 
 <p>下面是简单的语法<code>try .... except ... else</code>块 -</p> 
 <pre><code class="lang-python">try:
   You do your operations here
   ......................
except ExceptionI:
   If there is ExceptionI, then execute this block.
except ExceptionII:
   If there is ExceptionII, then execute this block.
   ......................
else:
   If there is no exception then execute this block.
</code></pre> 
 <p>以下是上述语法的几个重点 -</p> 
 <ul> 
  <li>一个<code>try</code>语句可以有多个<code>except</code>语句。 当<code>try</code>块包含可能引发不同类型的异常的语句时，这就很有用。</li>
  <li>还可以提供一个通用的<code>except</code>子句，它处理任何异常。</li>
  <li>在<code>except</code>子句之后，可以包含一个<code>else</code>子句。 如果<code>try:block</code>中的代码不引发异常，则<code>else</code>块中的代码将执行。</li>
  <li><code>else-block</code>是一个不需要<code>try:block</code>保护的代码的地方。</li>
 </ul> 
 <p><strong>示例</strong></p> 
 <p>此示例打开一个文件，将内容写入文件，并且优雅地出现，因为完全没有问题 -</p> 
 <pre><code class="lang-python">#!/usr/bin/python3

try:
   fh = open("testfile", "w")
   fh.write("This is my test file for exception handling!!")
except IOError:
   print ("Error: can\'t find file or read data")
else:
   print ("Written content in the file successfully")
   fh.close()
</code></pre> 
 <p>这产生以下结果 -</p> 
 <pre><code class="lang-python">Written content in the file successfully
</code></pre> 
 <p><strong>示例</strong></p> 
 <p>此示例尝试打开一个没有写入权限的文件，因此它引发了一个异常 -</p> 
 <pre><code class="lang-python">#!/usr/bin/python3

try:
   fh = open("testfile", "r")
   fh.write("This is my test file for exception handling!!")
except IOError:
   print ("Error: can\'t find file or read data")
else:
   print ("Written content in the file successfully")
</code></pre> 
 <p>这产生以下结果 -</p> 
 <pre><code class="lang-shell">Error: can't find file or read data
</code></pre> 
 <h3 id="h3-except-"><a name="except子句没有指定异常" class="reference-link"></a><span class="header-link octicon octicon-link"></span>except子句没有指定异常</h3>
 <p>也可以使用<code>except</code>语句，但不定义异常，如下所示 -</p> 
 <pre><code class="lang-shell">try:
   You do your operations here
   ......................
except:
   If there is any exception, then execute this block.
   ......................
else:
   If there is no exception then execute this block.
</code></pre> 
 <p>这种<code>try-except</code>语句捕获所有发生的异常。使用这种<code>try-except</code>语句不被认为是一个很好的编程实践，因为它捕获所有异常，但不会让程序员能更好地识别发生的问题的根本原因。</p> 
 <h3 id="h3-except-"><a name="except子句指定多个异常" class="reference-link"></a><span class="header-link octicon octicon-link"></span>except子句指定多个异常</h3>
 <p>还可以使用相同的<code>except</code>语句来处理多个异常，如下所示：</p>   
 <pre><code class="lang-python">try:
   You do your operations here
   ......................
except(Exception1[, Exception2[,...ExceptionN]]]):
   If there is any exception from the given exception list, 
   then execute this block.
   ......................
else:
   If there is no exception then execute this block.
</code></pre> 
 <h3 id="h3-try-finally-"><a name="try-finally子句" class="reference-link"></a><span class="header-link octicon octicon-link"></span>try-finally子句</h3>
 <p>可以使用<code>finally：</code>块和<code>try：</code>块。 <code>finally：</code>块是放置必须执行代码的地方，无论<code>try</code>块是否引发异常。 <code>try-finally</code>语句的语法是这样的 -</p> 
 <pre><code class="lang-python">try:
   You do your operations here;
   ......................
   Due to any exception, this may be skipped.
finally:
   This would always be executed.
   ......................
</code></pre> 
 <blockquote> 
  <p>注意 - 可以提供<code>except</code>子句或<code>finally</code>子句，但不能同时提供。不能使用<code>else</code>子句以及<code>finally</code>子句。</p> 
 </blockquote> 
 <p><strong>示例</strong></p> 
 <pre><code class="lang-python">#!/usr/bin/python3

try:
   fh = open("testfile", "w")
   fh.write("This is my test file for exception handling!!")
finally:
   print ("Error: can\'t find file or read data")
   fh.close()
</code></pre> 
 <p>如果没有以写入形式打开文件的权限，则会产生以下结果 -</p> 
 <pre><code class="lang-python">Error: can't find file or read data
</code></pre> 
 <p>同样的例子可以写得更干净如下 -</p> 
 <pre><code class="lang-python">#!/usr/bin/python3

try:
   fh = open("testfile", "w")
   try:
      fh.write("This is my test file for exception handling!!")
   finally:
      print ("Going to close the file")
      fh.close()
except IOError:
   print ("Error: can\'t find file or read data")
</code></pre> 
 <p>当<code>try</code>块中抛出异常时，执行将立即传递给<code>finally</code>块。 在<code>finally</code>块中的所有语句都被执行之后，异常被再次引发，如果存在于<code>try-except</code>语句的下一个更高的层中，则在<code>except</code>语句中处理异常。</p> 
 <h2 id="h2-u5F02u5E38u53C2u6570"><a name="异常参数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>异常参数</h2>
 <p>一个异常可以有一个参数，参数它是一个值，它提供有关该问题的其他信息。 参数的内容因异常而异。 可以通过在<code>except</code>子句中提供变量来捕获异常的参数，如下所示：</p> 
 <pre><code class="lang-python">try:
   You do your operations here
   ......................
except ExceptionType as Argument:
   You can print value of Argument here...
</code></pre> 
 <p>如果编写代码来处理单个异常，则可以在<code>except</code>语句中使用一个变量后跟异常的名称。 如果要捕获多个异常，可以使用一个变量后跟随异常的元组。</p> 
 <p>此变量接收大部分包含异常原因的异常值。 变量可以以元组的形式接收单个值或多个值。 该元组通常包含错误字符串，错误编号和错误位置。</p> 
 <p><strong>示例</strong></p> 
 <p>以下是一个例外 -</p> 
 <pre><code class="lang-python">#!/usr/bin/python3

# Define a function here.
def temp_convert(var):
   try:
      return int(var)
   except ValueError as Argument:
      print ("The argument does not contain numbers\n", Argument)

# Call above function here.
temp_convert("xyz")
</code></pre> 
 <p>这产生以下结果 -</p> 
 <pre><code class="lang-python">The argument does not contain numbers
invalid literal for int() with base 10: 'xyz'
</code></pre> 
 <h2 id="h2-u629Bu51FAu5F02u5E38"><a name="抛出异常" class="reference-link"></a><span class="header-link octicon octicon-link"></span>抛出异常</h2>
 <p>可以通过使用<code>raise</code>语句以多种方式引发异常。<code>raise</code>语句的一般语法如下 -</p> 
 <p><strong>语法</strong></p> 
 <pre><code class="lang-python">raise [Exception [, args [, traceback]]]
</code></pre> 
 <p>这里，<code>Exception</code>是异常的类型(例如，<code>NameError</code>)，<code>args</code>是异常参数的值。 参数是可选的; 如果没有提供，则异常参数为<code>None</code>。</p> 
 <p>最后一个参数<code>traceback</code>也是可选的(在实践中很少使用)，如果存在，则是用于异常的追溯对象。</p> 
 <p><strong>示例</strong></p> 
 <p>异常可以是字符串，类或对象。 Python核心引发的大多数异常都是类，一个参数是类的一个实例。 定义新的例外是非常容易的，可以做到如下 -</p> 
 <pre><code class="lang-python">def functionName( level ):
   if level &lt;1:
      raise Exception(level)
      # The code below to this would not be executed
      # if we raise the exception
   return level
</code></pre> 
 <blockquote> 
  <p>注意 - 为了捕获异常，“<code>except</code>”子句必须引用与类对象或简单字符串相同的异常。例如，为了捕获上述异常，必须写出<code>except</code>子句如下：</p> 
 </blockquote> 
 <pre><code class="lang-python">try:
   Business Logic here...
except Exception as e:
   Exception handling here using e.args...
else:
   Rest of the code here...
</code></pre> 
 <p>以下示例说明了使用引发异常 -</p> 
 <pre><code class="lang-python">#!/usr/bin/python3
def functionName( level ):
   if level &lt;1:
      raise Exception(level)
      # The code below to this would not be executed
      # if we raise the exception
   return level

try:
   l = functionName(-10)
   print ("level = ",l)
except Exception as e:
   print ("error in level argument",e.args[0])
</code></pre> 
 <p>这将产生以下结果 - </p> 
 <pre><code class="lang-shell">error in level argument -10
</code></pre> 
 <h2 id="h2-u7528u6237u5B9Au4E49u7684u5F02u5E38"><a name="用户定义的异常" class="reference-link"></a><span class="header-link octicon octicon-link"></span>用户定义的异常</h2>
 <p>Python还允许通过从标准内置异常导出类来创建自己的异常。</p> 
 <p>这是一个与<code>RuntimeError</code>有关的示例。 在这里，从<code>RuntimeError</code>类创建一个子类。 当需要在捕获异常时显示更多具体信息时，这就很有用了。</p> 
 <p>在<code>try</code>块中，用户定义的异常被引发并被捕获在<code>except</code>块中。 变量<code>e</code>用于创建<code>Networkerror</code>类的实例。</p> 
 <pre><code class="lang-python">class Networkerror(RuntimeError):
   def __init__(self, arg):
      self.args = arg
</code></pre> 
 <p>所以当定义了上面的类以后，就可以使用以下命令抛出异常 -</p> 
 <pre><code class="lang-python">try:
   raise Networkerror("Bad hostname")
except Networkerror,e:
   print e.args
</code></pre>
 <br>      
</div></body></html>