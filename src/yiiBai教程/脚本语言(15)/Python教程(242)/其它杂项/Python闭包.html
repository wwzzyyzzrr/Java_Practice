<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Python闭包</h1><div style="width:100%;float:left;" class="article-content">   
 <p>在本文中，您将了解什么是Python闭包，如何定义闭包以及应该如何使用闭包。</p> 
 <h2 id="h2-u5D4Cu5957u51FDu6570u4E2Du7684u975Eu5C40u90E8u53D8u91CF"><a name="嵌套函数中的非局部变量" class="reference-link"></a><span class="header-link octicon octicon-link"></span>嵌套函数中的非局部变量</h2>
 <p>在进入闭包之前，我们必须先了解一个嵌套函数和非局部变量。</p> 
 <p>在函数中定义另一个函数称为嵌套函数。嵌套函数可以访问包围范围内的变量。</p> 
 <p>在Python中，这些非局部变量只能在默认情况下读取，我们必须将它们显式地声明为非局部变量(使用<code>nonlocal</code>关键字)才能进行修改。</p> 
 <p>以下是访问非局部变量的嵌套函数的示例。</p> 
 <pre><code class="lang-python">def print_msg(msg):
# This is the outer enclosing function

    def printer():
# This is the nested function
        print(msg)

    printer()

# We execute the function
# Output: Hello
print_msg("Hello")
</code></pre> 
 <p>可以看到嵌套函数<code>printer()</code>能够访问封闭函数的非局部变量<code>msg</code>。</p> 
 <h2 id="h2-u5B9Au4E49u95EDu5305u51FDu6570"><a name="定义闭包函数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>定义闭包函数</h2>
 <p>在上面的例子中，如果函数<code>print_msg()</code>的最后一行返回<code>printer()</code>函数而不是调用它，会发生什么？ 如该函数定义如下 - </p> 
 <pre><code class="lang-python">def print_msg(msg):
# This is the outer enclosing function

    def printer():
# This is the nested function
        print(msg)

    return printer  # this got changed

# Now let's try calling this function.
# Output: Hello
another = print_msg("Hello")
another()
</code></pre> 
 <p>这样是不寻常的。</p> 
 <p><code>print_msg()</code>函数使用字符串“<code>Hello</code>”进行调用，返回的函数被绑定到另一个名称。 在调用<code>another()</code>时，尽管我们已经完成了<code>print_msg()</code>函数的执行，但仍然记住了这个消息。</p> 
 <p>一些数据(“<code>Hello</code>”)附加到代码中的这种技术在Python中称为闭包。</p> 
 <p>即使变量超出范围或函数本身从当前命名空间中删除，也会记住封闭范围内的值。</p> 
 <p>尝试在Python shell中运行以下内容以查看输出。</p> 
 <pre><code class="lang-python">&gt;&gt;&gt; del print_msg
&gt;&gt;&gt; another()
Hello
&gt;&gt;&gt; print_msg("Hello")
Traceback (most recent call last):
...
NameError: name 'print_msg' is not defined
</code></pre> 
 <h2 id="h2--"><a name="什么时候闭包？" class="reference-link"></a><span class="header-link octicon octicon-link"></span>什么时候闭包？</h2>
 <p>从上面的例子可以看出，当嵌套函数引用其封闭范围内的值时，在Python中有使用了一个闭包。</p> 
 <p>在Python中创建闭包必须满足的标准将在以下几点 - </p> 
 <ul> 
  <li>必须有一个嵌套函数(函数内部的函数)。</li>
  <li>嵌套函数必须引用封闭函数中定义的值。</li>
  <li>闭包函数必须返回嵌套函数。</li>
 </ul> 
 <h2 id="h2--"><a name="何时使用闭包？" class="reference-link"></a><span class="header-link octicon octicon-link"></span>何时使用闭包？</h2>
 <p><strong>那么闭包是什么好的？</strong></p> 
 <p>闭包可以避免使用全局值并提供某种形式的数据隐藏。它还可以提供面向对象的解决问题的解决方案。</p> 
 <p>当在类中几乎没有方法(大多数情况下是一种方法)时，闭包可以提供一个替代的和更优雅的解决方案。 但是当属性和方法的数量变大时，更好地实现一个类。</p> 
 <p>这是一个简单的例子，其中闭包可能比定义类和创建对象更为优先。</p>   
 <pre><code class="lang-python">def make_multiplier_of(n):
    def multiplier(x):
        return x * n
    return multiplier

# Multiplier of 3
times3 = make_multiplier_of(3)

# Multiplier of 5
times5 = make_multiplier_of(5)

# Output: 27
print(times3(9))

# Output: 15
print(times5(3))

# Output: 30
print(times5(times3(2)))
</code></pre> 
 <p>Python中的装饰器也可以广泛使用闭包。值得注意的是，可以找到封闭函数中包含的值。</p> 
 <p>所有函数对象都有一个<code>__closure__</code>属性，如果它是一个闭包函数，它返回一个单元格对象的元组。 参考上面的例子，我们知道<code>times3</code>和<code>times5</code>是闭包函数。</p> 
 <pre><code class="lang-python">&gt;&gt;&gt; make_multiplier_of.__closure__
&gt;&gt;&gt; times3.__closure__
(&lt;cell at 0x0000000002D155B8: int object at 0x000000001E39B6E0&gt;,)
</code></pre> 
 <p>单元格(<code>cell</code>)对象具有存储闭合值的属性：<code>cell_contents</code>。</p> 
 <pre><code class="lang-python">&gt;&gt;&gt; times3.__closure__[0].cell_contents
3
&gt;&gt;&gt; times5.__closure__[0].cell_contents
5
</code></pre>
 <br>      
</div></body></html>