<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Python修饰器</h1><div style="width:100%;float:left;" class="article-content">   
 <p>装饰器接收一个功能，添加一些功能并返回。 在本文中，您将学习如何创建装饰器，以及为什么要使用装饰器。</p> 
 <p>Python有一个有趣的功能，称为装饰器，以便为现有代码添加功能。</p> 
 <p>这也称为元编程，作为程序的一部分，尝试在编译时修改程序的另一部分。</p> 
 <h2 id="h2--"><a name="学习装修器之前需要了解什么？" class="reference-link"></a><span class="header-link octicon octicon-link"></span>学习装修器之前需要了解什么？</h2>
 <p>为了了解装饰器，我们首先在Python中了解一些基本的东西。</p> 
 <p>Python中的一切(是的，甚至是类)都是对象。 我们定义的名称只是绑定到这些对象的标识符。 函数也不例外，它们也是对象(带有属性)。 各种不同的名称可以绑定到同一个功能对象。</p> 
 <p>看看下面一个示例 - </p> 
 <pre><code class="lang-python">def first(msg):
    print(msg)    

first("Hello")

second = first
second("Hello")
</code></pre> 
 <p>当运行代码时，<code>first</code>和<code>second</code>函数都提供相同的输出。 这里名称<code>first</code>和<code>second</code>引用相同的函数对象。</p> 
 <p>函数可以作为参数传递给另一个函数。</p> 
 <p>如果您在Python中使用了<code>map</code>，<code>filter</code>和<code>reduce</code>等功能，那么您就了解了。</p> 
 <p>将其他函数作为参数的函数也称为高阶函数。下面是这样子的一个函数的例子。</p> 
 <pre><code class="lang-python">def inc(x):
    return x + 1

def dec(x):
    return x - 1

def operate(func, x):
    result = func(x)
    return result
</code></pre> 
 <p>我们调用函数如下 - </p> 
 <pre><code class="lang-python">&gt;&gt;&gt; operate(inc,3)
4
&gt;&gt;&gt; operate(dec,3)
2
</code></pre> 
 <p>此外，一个函数可以返回另一个函数。</p> 
 <pre><code class="lang-python">def is_called():
    def is_returned():
        print("Hello")
    return is_returned

new = is_called()

#Outputs "Hello"
new()
</code></pre> 
 <p>这里，<code>is_returned()</code>是一个定义的嵌套函数，在每次调用<code>is_called()</code>时返回。</p> 
 <h2 id="h2-u56DEu5230u88C5u9970u5668"><a name="回到装饰器" class="reference-link"></a><span class="header-link octicon octicon-link"></span>回到装饰器</h2>
 <p>实际上，实现特殊方法<code>__call__()</code>的任何对象都被称为可调用。 因此，在最基本的意义上，装饰器是可调用的，并且可以返回可调用。</p> 
 <p>基本上，装饰器接收一个函数，添加一些函数并返回。</p> 
 <pre><code class="lang-python">def make_pretty(func):
    def inner():
        print("I got decorated")
        func()
    return inner

def ordinary():
    print("I am ordinary")
</code></pre> 
 <p>当在shell中运行以下代码时，如下 -</p> 
 <pre><code class="lang-python">&gt;&gt;&gt; ordinary()
I am ordinary

&gt;&gt;&gt; # let's decorate this ordinary function
&gt;&gt;&gt; pretty = make_pretty(ordinary)
&gt;&gt;&gt; pretty()
I got decorated
I am ordinary
</code></pre> 
 <p>在上面的例子中，<code>make_pretty()</code>是一个装饰器。 在分配步骤。</p> 
 <pre><code class="lang-python">pretty = make_pretty(ordinary)
</code></pre> 
 <p>函数<code>ordinary()</code>得到了装饰，返回函数的名字：<code>pretty</code>。</p> 
 <p>可以看到装饰函数为原始函数添加了一些新功能。这类似于包装礼物。 装饰器作为包装纸。 装饰物品的性质(里面的实际礼物)不会改变。 但现在看起来很漂亮(因为装饰了)。</p> 
 <p>一般来说，我们装饰一个函数并重新分配它，</p> 
 <pre><code class="lang-python">ordinary = make_pretty(ordinary).
</code></pre> 
 <p>这是一个常见的结构，Python有一个简化的语法。</p> 
 <p>可以使用<code>@</code>符号和装饰器函数的名称，并将其放在要装饰的函数的定义之上。 例如，</p> 
 <pre><code class="lang-python">@make_pretty
def ordinary():
    print("I am ordinary")
</code></pre> 
 <p>上面代码相当于 - </p> 
 <pre><code class="lang-python">def ordinary():
    print("I am ordinary")
ordinary = make_pretty(ordinary)
</code></pre> 
 <h2 id="h2-u7528u53C2u6570u88C5u9970u51FDu6570"><a name="用参数装饰函数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>用参数装饰函数</h2>
 <p>上面的装饰器很简单，只适用于没有任何参数的函数。 如果有函数要接受如下的参数怎么办？</p> 
 <pre><code class="lang-python">def divide(a, b):
    return a/b
</code></pre> 
 <p>该函数有两个参数<code>a</code>和<code>b</code>。 我们知道，如果将<code>b</code>的值设置为<code>0</code>并传递那么是会出错的。</p> 
 <pre><code class="lang-python">&gt;&gt;&gt; divide(2,5)
0.4
&gt;&gt;&gt; divide(2,0)
Traceback (most recent call last):
...
ZeroDivisionError: division by zero
</code></pre> 
 <p>现在使用一个装饰器来检查这个错误。</p>   
 <pre><code class="lang-python">def smart_divide(func):
   def inner(a,b):
      print("I am going to divide",a,"and",b)
      if b == 0:
         print("Whoops! cannot divide")
         return

      return func(a,b)
   return inner

@smart_divide
def divide(a,b):
    return a/b
</code></pre> 
 <p>如果发生错误，这个新的实现将返回<code>None</code>。</p> 
 <pre><code class="lang-python">&gt;&gt;&gt; divide(2,5)
I am going to divide 2 and 5
0.4

&gt;&gt;&gt; divide(2,0)
I am going to divide 2 and 0
Whoops! cannot divide
</code></pre> 
 <p>以这种方式就可以装饰函数的参数了。</p> 
 <p>应该会注意到，装饰器中嵌套的<code>inner()</code>函数的参数与其装饰的函数的参数是一样的。 考虑到这一点，现在可以让一般装饰器使用任何数量的参数。</p> 
 <p>在Python中，这个由<code>function(* args，** kwargs)</code>完成。 这样，<code>args</code>将是位置参数的元组，<code>kwargs</code>将是关键字参数的字典。这样的装饰器的例子将是。</p> 
 <pre><code class="lang-python">def works_for_all(func):
    def inner(*args, **kwargs):
        print("I can decorate any function")
        return func(*args, **kwargs)
    return inner
</code></pre> 
 <h2 id="h2--python-"><a name="在Python中链接装饰器" class="reference-link"></a><span class="header-link octicon octicon-link"></span>在Python中链接装饰器</h2>
 <p>多个装饰器可以在Python中链接。</p> 
 <p>这就是说，一个函数可以用不同(或相同)装饰器多次装饰。只需将装饰器放置在所需函数之上。</p> 
 <pre><code class="lang-python">def star(func):
    def inner(*args, **kwargs):
        print("*" * 30)
        func(*args, **kwargs)
        print("*" * 30)
    return inner

def percent(func):
    def inner(*args, **kwargs):
        print("%" * 30)
        func(*args, **kwargs)
        print("%" * 30)
    return inner

@star
@percent
def printer(msg):
    print(msg)
printer("Hello")
</code></pre> 
 <p>执行上面代码，将输出结果如下 - </p> 
 <pre><code class="lang-python">******************************
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Hello
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
******************************
</code></pre> 
 <p>以上语法，</p> 
 <pre><code class="lang-python">@star
@percent
def printer(msg):
    print(msg)
</code></pre> 
 <p>相当于以下 - </p> 
 <pre><code class="lang-python">def printer(msg):
    print(msg)
printer = star(percent(printer))
</code></pre> 
 <p>链装饰器的顺序是重要的。 所以如果把顺序颠倒了执行结果就不一样了，如下 - </p> 
 <pre><code class="lang-python">@percent
@star
def printer(msg):
    print(msg)
</code></pre> 
 <p>执行上面代码，将输出结果如下 - </p> 
 <pre><code class="lang-python">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
******************************
Hello
******************************
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
</code></pre>
 <br>      
</div></body></html>