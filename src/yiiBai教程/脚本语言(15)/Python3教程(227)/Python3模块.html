<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Python3模块</h1><div style="width:100%;float:left;" class="article-content">   
 <div> 
  <div>
    模块可以让你从逻辑上组织你的Python代码。&nbsp;将相关的代码放到一个模块使代码更容易理解和使用。&nbsp;模块是可以绑定和参考任意命名的Python对象属性。 
  </div> 
 </div> 
 <div> 
  <p style="text-align:justify;"> 简单地说，一个模块是 Python 代码的文件。&nbsp;一个模块可以定义函数，类和变量。一个模块也可以包括可运行的代码。 </p> 
  <h2> 示例 </h2> 
  <p style="text-align:justify;"> 例如：一个名为 aname 模块的 Python代码通常放在一个指定为 aname.py 的文件中。这里有一个简单的模块，support.py 的例子 </p> 
  <pre>def print_func( par ):
   print "Hello : ", par
   return</pre> 
  <h2> import&nbsp;语句 </h2> 
  <p style="text-align:justify;"> 您可以通过在其他一些Python源文件执行一个import语句，来使用任何Python源文件作为一个模块。import&nbsp;语句的语法如下： </p> 
  <pre>import module1[, module2[,... moduleN]&nbsp;</pre> 
  <p style="text-align:justify;"> 当解释程序遇到import语句，如果模块存在于搜索路径它将导入这个模块。搜索路径是一个目录列表，解释器导入模块之前将进行搜索。例如，要导入模块 hello.py，需要在脚本的顶部放置下面的命令&nbsp;- </p> 
  <pre>#!/usr/bin/python3

# Import module support
import support

# Now you can call defined function that module as follows
support.print_func("Zara")
</pre> 
  <div>
    当执行上面的代码，它产生以下结果&nbsp;- 
  </div> 
  <pre>Hello : Zara&nbsp;</pre> 
  <p style="text-align:justify;"> 模块被加载一次，不管它是导入(import)的次数。如果多个导入出现，这可以防止模块执行一遍又一遍。 </p> 
  <h2> from...import&nbsp;语句 </h2> 
  <p style="text-align:justify;"> 从Python的声明语句，您可以从一个模块中导入特定的属性到当前的命名空间。from...import&nbsp;的语法如下- </p> 
  <pre>from modname import name1[, name2[, ... nameN]]</pre> 
  <div>
    例如，从&nbsp;fib&nbsp;模块导入&nbsp;fibonacci&nbsp;函数，使用下面的语句- 
  </div> 
  <pre>#!/usr/bin/python3

# Fibonacci numbers module

def fib(n): # return Fibonacci series up to n
    result = []
    a, b = 0, 1
    while b &lt; n:
        result.append(b)
        a, b = b, a+b
    return result</pre> 
  <pre>&gt;&gt;&gt; from fib import fib
&gt;&gt;&gt; fib(100)
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]&nbsp;</pre> 
  <p style="text-align:justify;"> 此语句不导入整个&nbsp;fib&nbsp;模块到当前的命名空间;&nbsp;它只是从&nbsp;fib&nbsp;模块导入全局符号表中的项目fibonacci。 </p> 
  <h2> from...import *&nbsp;语句: </h2> 
  <div>
    也可以使用下面的 import 语句， 将一个模块的所有名称导入到当前的命名空间&nbsp;- 
  </div> 
  <pre>from modname import *&nbsp;</pre> 
  <p style="text-align:justify;"> 这提供了一种简单的方法来导入模块到当前命名空间中的所有项目;&nbsp;不过，这一说法应该尽量少用。 </p> 
  <h2> 
   <div>
     执行模块作为脚本 
   </div> </h2> 
  <p style="text-align:justify;"> 在一个模块，模块名(做为一个字符串)可以作为全局变量__name__的值。该模块中的代码会被执行，就好像导入它一样，但设定为“__main__”的 __name__。这意味着，通过在模块的末尾添加以下代码： </p> 
  <pre>#!/usr/bin/python3

# Fibonacci numbers module

def fib(n): # return Fibonacci series up to n
    result = []
    a, b = 0, 1
    while b &lt; n:
        result.append(b)
        a, b = b, a+b
    return result
if __name__ == "__main__":
    f=fib(100)
    print(f)</pre> 
  <div>
    当我们运行上面的代码，以下输出将显示 
  </div> 
  <pre>[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]</pre> 
  <h2> 
   <div>
     查找模块 
   </div> </h2> 
  <div>
    当导入模块，在下面 Python解释器将搜索模块的序列&nbsp;- 
  </div> 
  <ul> 
   <li> 
    <div>
      当前目录。 
    </div> </li> 
   <li> <p style="text-align:justify;"> 如果没有找到该模块，然后 Python 将搜索 shell 变量&nbsp;PYTHONPATH&nbsp;的每个目录. </p> </li> 
   <li> <p style="text-align:justify;"> 如果这些方法都失败(未找到)，Python检查默认路径。&nbsp;在UNIX上，默认路径通常是&nbsp;/usr/local/lib/python3/. </p> </li> 
  </ul> 
  <p style="text-align:justify;"> 模块搜索路径被存储在系统模块sys作为所述的 sys.path 变量。sys.path中变量包含当前目录，PYTHONPATH和安装相关的默认目录。 </p> 
  <h2> PYTHONPATH&nbsp;变量: </h2> 
  <p style="text-align:justify;"> PYTHONPATH&nbsp;是一个环境变量，它由一个目录列表组成。Python路径中的语法与 shell 变量PATH相同。 </p> 
  <div>
    下面是 Windows系统中一个典型的 PYTHONPATH&nbsp;： 
  </div> 
  <pre>set PYTHONPATH=c:\python34\lib;</pre> 
  <div>
    这里是 UNIX 系统的典型 PYTHONPATH&nbsp;： 
  </div> 
  <pre>set PYTHONPATH=/usr/local/lib/python</pre> 
  <h2> 
   <div>
     命名空间和范围界定 
   </div> </h2> 
  <p style="text-align:justify;"> 变量名称(标识)映射到对象。命名空间是一组变量(键)及其相应的对象(值)的字典。 </p> 
  <p style="text-align:justify;"> 使用Python编写的语句可以在本地命名空间和全局命名空间访问变量。如果本地和全局变量具有相同的名称，局部变量将覆盖全局变量。 </p> 
  <p style="text-align:justify;"> 每个函数都有它自己的本地名称空间。&nbsp;类方法与普通的函数遵循相同的范围规则。 </p> 
  <p style="text-align:justify;"> Python作出明智的猜测变量是局部还是全局的。它假定任何变量赋值在函数中的值是局部的。 </p> 
  <p style="text-align:justify;"> 因此，为了给一个函数内给一个全局变量赋值，&nbsp;您必须使用global语句。 </p> 
  <p style="text-align:justify;"> 声明全局 VarName 告诉 Python 的 VarName 是一个全局变量。Python停止在局部命名空间搜索该变量。 </p> 
  <p style="text-align:justify;"> 例如，我们在全局命名空间定义一个变量Money。在函数变量&nbsp;Money，我们给的&nbsp;Money&nbsp;的值，因此&nbsp;Python&nbsp;假定&nbsp;Money&nbsp;作为一个局部变量。&nbsp;然而，我们将其设置之前计算局部变量&nbsp;Money&nbsp;的值，&nbsp;所以一个 UnboundLocalError 错误被引发。取消全局声明解决了这个问题。 </p>   
  <pre>#!/usr/bin/python3

Money = 2000
def AddMoney():
   # Uncomment the following line to fix the code:
   # global Money
   Money = Money + 1

print (Money)
AddMoney()
print (Money)</pre> 
  <h2> dir( ) 函数 </h2> 
  <div>
    使用 dir()内置函数返回一个包含由模块定义的名称字符串的排序列表。 
  </div> 
  <p style="text-align:justify;"> 该列表包含一个模块中定义的所有的模块，变量和函数的名称。下面是一个简单的例子&nbsp;- </p> 
  <pre>#!/usr/bin/python3

# Import built-in module math
import math

content = dir(math)

print (content)</pre> 
  <div>
    当执行上面的代码，它产生以下结果&nbsp;- 
  </div> 
  <pre>['__doc__', '__file__', '__name__', 'acos', 'asin', 'atan', 
'atan2', 'ceil', 'cos', 'cosh', 'degrees', 'e', 'exp', 
'fabs', 'floor', 'fmod', 'frexp', 'hypot', 'ldexp', 'log',
'log10', 'modf', 'pi', 'pow', 'radians', 'sin', 'sinh', 
'sqrt', 'tan', 'tanh']&nbsp;</pre> 
  <p style="text-align:justify;"> 在这里，特殊字符串变量__name__是模块的名称，__file__是加载模块的文件名。 </p> 
  <h2> globals()&nbsp;和&nbsp;locals()&nbsp;函数− </h2> 
  <div>
    globals()&nbsp;和&nbsp;locals()函数可用于在全局和局部名字空间返回名称，取决于从哪里调用它们。 
  </div> 
  <p style="text-align:justify;"> 如果&nbsp;locals()&nbsp;从函数中调用，&nbsp;它会返回所有可以从函数访问的名字。 </p> 
  <div>
    如果 globals() 可以在一个函数中调用，它将返回所有可以在全局范围内，可从函数访问的名字。 
  </div> 
  <p style="text-align:justify;"> 两种这些函数的返回类型是字典。因此，名称可以使用&nbsp;keys()&nbsp;函数来提取。 </p> 
  <h2> reload()&nbsp;函数 </h2> 
  <div>
    当模块被导入到一个脚本，在模块的顶层部的代码只执行一次。 
  </div> 
  <p style="text-align:justify;"> 因此，如果你希望模块重新执行的顶层代码，&nbsp;可以使用&nbsp;reload()函数。在reload()函数会再次导入先前导入模块。reload()函数的语法是这样的&nbsp;- </p> 
  <pre>reload(module_name)&nbsp;</pre> 
  <p style="text-align:justify;"> 在这里，module_name&nbsp;是要重新加载模块，而不是包含模块名称的字符串。例如，要重新加载模块&nbsp;hello，请执行下列操作&nbsp;− </p> 
  <pre>reload(hello)</pre> 
  <h2> 
   <div>
     Python包 
   </div> </h2> 
  <div>
    包是一个分层文件目录结构，定义由模块和子包和子子包等一个单一的Python应用环境。 
  </div> 
  <div>
    考虑在 Phone 目录下找到的文件Pots.py。此文件的源代码如下面的行&nbsp;- 
  </div> 
  <pre>#!/usr/bin/python3

def Pots():
   print ("I'm Pots Phone")  </pre> 
  <div>
    类似的方式，这里有不同功能的两个相同名称文件如下 - 
  </div> 
  <ul> 
   <li> <p style="text-align:justify;"> Phone/Isdn.py有一个函数 Isdn() </p> </li> 
   <li> <p style="text-align:justify;"> Phone/G3.py&nbsp;有一个函数&nbsp;G3() </p> </li> 
  </ul> 
  <div>
    现在，在&nbsp;Phone&nbsp;目录中创建一个文件__init__.py- 
  </div> 
  <ul> 
   <li> Phone/__init__.py </li> 
  </ul> 
  <p style="text-align:justify;"> 为了让所有的功能可用，当导入Phone，需要把明确 import 语句在 __init__.py 中如下&nbsp;- </p> 
  <pre>from Pots import Pots
from Isdn import Isdn
from G3 import G3</pre> 
  <div>
    在添加这些行到&nbsp;__init__.py&nbsp;后，当导入&nbsp;Phone&nbsp;包所有的这些类可用。 
  </div> 
  <pre>#!/usr/bin/python3

# Now import your Phone Package.
import Phone

Phone.Pots()
Phone.Isdn()
Phone.G3()</pre> 
  <div>
    当执行上面的代码，它产生以下结果&nbsp;- 
  </div> 
  <pre>I'm Pots Phone
I'm 3G Phone
I'm ISDN Phone&nbsp;</pre> 
  <p style="text-align:justify;"> 在上面的例子中，我们已经在每个文件采取一个单一的函数示例，但可以保留多个函数在文件中。您还可以定义这些Python类不同的文件中，然后你可以创建包在那些类之外。 </p> 
 </div>
 <br>      
</div></body></html>