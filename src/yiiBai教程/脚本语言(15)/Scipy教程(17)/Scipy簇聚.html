<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Scipy簇聚</h1><div style="width:100%;float:left;" class="article-content">   
 <p>K均值聚类是一种在一组未标记数据中查找聚类和聚类中心的方法。 直觉上，我们可以将一个群集(簇聚)看作 - 包含一组数据点，其点间距离与群集外点的距离相比较小。 给定一个K中心的初始集合，K均值算法重复以下两个步骤 -</p> 
 <ul> 
  <li>对于每个中心，比其他中心更接近它的训练点的子集(其聚类)被识别出来。</li>
  <li>计算每个聚类中数据点的每个要素的平均值，并且此平均向量将成为该聚类的新中心。</li>
 </ul> 
 <p>重复这两个步骤，直到中心不再移动或分配不再改变。 然后，可以将新点<code>x</code>分配给最接近的原型的群集。 SciPy库通过集群包提供了K-Means算法的良好实现。 下面来了解如何使用它。</p> 
 <h2 id="h2-scipy-k-means"><a name="SciPy中实现K-Means" class="reference-link"></a><span class="header-link octicon octicon-link"></span>SciPy中实现K-Means</h2>
 <p>我们来看看并理解如何在SciPy中实现K-Means。</p> 
 <p><strong>导入K-Means</strong></p> 
 <p>下面来看看每个导入的函数的实现和用法。</p> 
 <pre><code class="lang-python">from SciPy.cluster.vq import kmeans,vq,whiten
</code></pre> 
 <p><strong>数据生成</strong></p> 
 <p>我们需要生成(模拟)一些数据来探索聚类。参考以下代码 - </p> 
 <pre><code class="lang-python">from numpy import vstack,array
from numpy.random import rand

# data generation with three features
data = vstack((rand(100,3) + array([.5,.5,.5]),rand(100,3)))
</code></pre> 
 <p>现在，我们来看看生成的模拟数据，上述程序将生成以下输出。</p> 
 <pre><code class="lang-shell">[[ 1.34103331  1.13924682  0.68465819]
 [ 1.28481332  0.91318917  0.84225546]
 [ 0.96498008  1.42382266  0.83564809]
 [ 1.37049373  0.66635033  1.46568707]
 [ 0.87424166  0.86090225  1.22545336]
 [ 1.0264795   0.90724604  1.46837972]
 [ 1.40996857  1.37769991  1.39805802]
 [ 0.964556    0.71632157  1.47983347]
 [ 0.69909637  1.21695335  1.46434369]
 [ 1.01887602  0.86448455  1.02242951]
 [ 0.82573176  1.19165063  1.09085707]
 [ 0.64378227  0.70673944  0.69484097]
 [ 1.16087103  0.64371977  0.89720984]
 [ 1.23410673  0.56805382  1.33534058]
 [ 0.50417695  1.29632466  0.96589447]
 [ 0.91395183  1.39173555  1.0748435 ]
 [ 1.04540644  1.20721464  0.97173727]
 ... ...
 [ 0.79250839  0.48689797  0.42250824]
 [ 0.05846914  0.83469742  0.57586067]
 [ 0.0308333   0.8642561   0.1111777 ]
 [ 0.61327069  0.43425013  0.99716439]
 [ 0.81698148  0.91098877  0.12706862]
 [ 0.60665992  0.55999208  0.57454962]
 [ 0.13894142  0.03315365  0.43182983]
 [ 0.62293781  0.34701877  0.61229591]]
</code></pre> 
 <p>根据每个要素标准化一组观察值。 在运行K-Means之前，使用白化重新缩放观察集的每个特征维度是有好处的。 每个特征除以所有观测值的标准偏差以给出其单位差异。</p> 
 <p><strong>美化数据</strong></p> 
 <p>我们可使用以下代码来美白数据。</p> 
 <pre><code class="lang-python"># whitening of data
data = whiten(data)
print (data)
</code></pre> 
 <h2 id="h2--k-"><a name="用三个集群计算K均值" class="reference-link"></a><span class="header-link octicon octicon-link"></span>用三个集群计算K均值</h2>
 <p>现在使用以下代码计算三个群集的K均值。</p>   
 <pre><code class="lang-python"># computing K-Means with K = 3 (2 clusters)
centroids,_ = kmeans(data,3)
</code></pre> 
 <p>上述代码对形成K个簇的一组观测向量执行K均值。 K-Means算法调整质心直到不能获得足够的进展，即失真的变化，因为最后一次迭代小于某个阈值。 在这里，可以通过使用下面给出的代码打印<code>centroids</code>变量来观察簇。</p> 
 <pre><code class="lang-python">print(centroids)
</code></pre> 
 <p>上面的代码将生成以下输出。</p> 
 <pre><code class="lang-python">print(centroids)[ [ 2.26034702  1.43924335  1.3697022 ]
                  [ 2.63788572  2.81446462  2.85163854]
                  [ 0.73507256  1.30801855  1.44477558] ]
</code></pre> 
 <p>使用下面给出的代码将每个值分配给一个集群。</p> 
 <pre><code class="lang-python"># assign each sample to a cluster
clx,_ = vq(data,centroids)
</code></pre> 
 <p><code>vq</code>函数将<code>'M'</code>中的每个观察向量与<code>'N'</code> <code>obs</code>数组与<code>centroids</code>进行比较，并将观察值分配给最近的聚类。 它返回每个观察和失真的聚类。 我们也可以检查失真。使用下面的代码检查每个观察的聚类。</p> 
 <pre><code class="lang-python"># check clusters of observation
print (clx)
</code></pre> 
 <p>上面的代码将生成以下输出。</p> 
 <pre><code class="lang-python">array([1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 2, 0, 2, 0, 1, 1, 1,
0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0,
0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
0, 1,  0, 0, 0, 0, 1, 0, 0, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 0, 2, 2, 2, 2, 2, 0, 0,
2, 2, 2, 1, 0, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 0, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], dtype=int32)
</code></pre> 
 <p>上述数组的不同值 - <code>0</code>,<code>1</code>,<code>2</code>表示簇。</p>
 <br>      
</div></body></html>