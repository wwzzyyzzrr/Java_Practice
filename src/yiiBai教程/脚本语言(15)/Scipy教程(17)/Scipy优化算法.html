<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Scipy优化算法</h1><div style="width:100%;float:left;" class="article-content">   
 <p><code>scipy.optimize</code>包提供了几种常用的优化算法。 该模块包含以下几个方面 -</p> 
 <ul> 
  <li>使用各种算法(例如BFGS，Nelder-Mead单纯形，牛顿共轭梯度，COBYLA或SLSQP)的无约束和约束最小化多元标量函数(<code>minimize()</code>)</li>
  <li>全局(蛮力)优化程序(例如，<code>anneal()</code>，<code>basinhopping()</code>)</li>
  <li>最小二乘最小化(<code>leastsq()</code>)和曲线拟合(<code>curve_fit()</code>)算法</li>
  <li>标量单变量函数最小化(<code>minim_scalar()</code>)和根查找(<code>newton()</code>)</li>
  <li>使用多种算法(例如，Powell，Levenberg-Marquardt混合或Newton-Krylov等大规模方法)的多元方程系统求解(root)</li>
 </ul> 
 <p><strong>多变量标量函数的无约束和约束最小化</strong></p> 
 <p><code>minimize()</code>函数为<code>scipy.optimize</code>中的多变量标量函数提供了无约束和约束最小化算法的通用接口。 为了演示最小化函数，考虑使<code>NN</code>变量的<code>Rosenbrock</code>函数最小化的问题 -<br><img src="http://www.yiibai.com/uploads/images/201803/0503/124090349_54034.png" alt=""></p> 
 <p>这个函数的最小值是<code>0</code>，当<code>xi = 1</code>时达到。</p> 
 <h2 id="h2-nelder-mead-"><a name="Nelder–Mead单纯形算法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Nelder–Mead单纯形算法</h2>
 <p>在下面的例子中，<code>minimize()</code>例程与Nelder-Mead单纯形算法(<code>method ='Nelder-Mead'</code>)一起使用(通过方法参数选择)。参考下面的例子。</p> 
 <pre><code class="lang-python">import numpy as np
from scipy.optimize import minimize

def rosen(x):

x0 = np.array([1.3, 0.7, 0.8, 1.9, 1.2])
res = minimize(rosen, x0, method='nelder-mead')

print(res.x)
</code></pre> 
 <p>上述程序将生成以下输出 - </p> 
 <pre><code class="lang-python">[7.93700741e+54  -5.41692163e+53  6.28769150e+53  1.38050484e+55  -4.14751333e+54]
</code></pre> 
 <p>简单算法只需要函数评估，对于简单的最小化问题是一个不错的选择。 但是，由于它不使用任何梯度评估，因此可能需要较长时间才能找到最小值。</p> 
 <p>另一种只需要函数调用来寻找最小值的优化算法就是鲍威尔方法，它可以通过在<code>minimize()</code>函数中设置<code>method ='powell'</code>来实现。</p> 
 <h2 id="h2-u6700u5C0Fu4E8Cu4E58"><a name="最小二乘" class="reference-link"></a><span class="header-link octicon octicon-link"></span>　最小二乘</h2>
 <p>求解一个带有变量边界的非线性最小二乘问题。 给定残差<code>f(x)</code>(n个实变量的m维实函数)和损失函数<code>rho(s)</code>(标量函数)，最小二乘法找到代价函数<code>F(x)</code>的局部最小值。 看看下面的例子。</p> 
 <p>在这个例子中，<code>Rosenbrock</code>函数的最小值不受自变量的限制。</p> 
 <pre><code class="lang-python">#Rosenbrock Function
def fun_rosenbrock(x):
   return np.array([10 * (x[1] - x[0]**2), (1 - x[0])])

from scipy.optimize import least_squares
input = np.array([2, 2])
res = least_squares(fun_rosenbrock, input)

print (res)
</code></pre> 
 <p>请注意，我们只提供残差的向量。 该算法将成本函数构造为残差的平方和，这给出了<code>Rosenbrock()</code>函数。 确切的最小值是<code>x = [1.0,1.0]</code>。</p> 
 <p>上述程序将生成以下输出 - </p> 
 <pre><code class="lang-python">active_mask: array([ 0., 0.])
      cost: 9.8669242910846867e-30
      fun: array([ 4.44089210e-15, 1.11022302e-16])
      grad: array([ -8.89288649e-14, 4.44089210e-14])
      jac: array([[-20.00000015,10.],[ -1.,0.]])
   message: '`gtol` termination condition is satisfied.'
      nfev: 3
      njev: 3
   optimality: 8.8928864934219529e-14
      status: 1
      success: True
         x: array([ 1., 1.])
</code></pre> 
 <h2 id="h2-u6C42u6839"><a name="求根" class="reference-link"></a><span class="header-link octicon octicon-link"></span>求根</h2>
 <p>让我们了解求根如何在SciPy中使用。</p> 
 <p><strong>标量函数</strong></p> 
 <p>如果有一个单变量方程，则可以尝试四种不同的寻根算法。 这些算法中的每一个都需要预期根的时间间隔的端点(因为函数会改变符号)。 一般来说，<code>brentq</code>是最好的选择，但其他方法可能在某些情况下或学术目的有用。</p> 
 <p><strong>定点求解</strong></p> 
 <p>与找到函数零点密切相关的问题是找到函数的固定点的问题。 函数的固定点是函数评估返回点的点:<code>g(x)= x</code>。 显然，<code>gg</code>的不动点是<code>f(x)= g(x)-x</code>的根。 等价地，<code>ff</code>的根是<code>g(x)= f(x)+ x</code>的固定点。 例程<code>fixed_point</code>提供了一个简单的迭代方法，使用<code>Aitkens</code>序列加速度来估计<code>gg</code>的固定点，如果给出起点的话。</p> 
 <p><strong>方程组</strong><br>使用<code>root()</code>函数可以找到一组非线性方程的根。 有几种方法可供选择，其中<code>hybr</code>(默认)和<code>lm</code>分别使用<code>Powell</code>的混合方法和<code>MINPACK</code>中的Levenberg-Marquardt方法。</p> 
 <p>下面的例子考虑了单变量超越方程。<br><img src="http://www.yiibai.com/uploads/images/201803/0503/486100315_23611.png" alt=""></p> 
 <p>其根可以求解如下 -</p>   
 <pre><code class="lang-python">import numpy as np
from scipy.optimize import root
def func(x):
   return x*2 + 2 * np.cos(x)
sol = root(func, 0.3)
print (sol)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">fjac: array([[-1.]])
fun: array([ 2.22044605e-16])
message: 'The solution converged.'
   nfev: 10
   qtf: array([ -2.77644574e-12])
      r: array([-3.34722409])
   status: 1
   success: True
      x: array([-0.73908513])
</code></pre>
 <br>      
</div></body></html>