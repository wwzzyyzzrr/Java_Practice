<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Scipy FFTpack</h1><div style="width:100%;float:left;" class="article-content">   
 <p>对时域信号计算傅里叶变换以检查其在频域中的行为。 傅里叶变换可用于信号和噪声处理，图像处理，音频信号处理等领域。SciPy提供<code>fftpack</code>模块，可让用户计算快速傅立叶变换。</p> 
 <p>以下是一个正弦函数的例子，它将用于使用<code>fftpack</code>模块计算傅里叶变换。</p> 
 <h2 id="h2-u5FEBu901Fu5085u7ACBu53F6u53D8u6362"><a name="快速傅立叶变换" class="reference-link"></a><span class="header-link octicon octicon-link"></span>快速傅立叶变换</h2>
 <p>下面来了解一下快速傅立叶变换的细节。</p> 
 <p><strong>一维离散傅立叶变换</strong></p> 
 <p>长度为<code>N</code>的序列<code>x [n]</code>的<code>FFT y [k]</code>由<code>fft()</code>计算，逆变换使用<code>ifft()</code>计算。 看看下面的例子</p> 
 <pre><code class="lang-python">#Importing the fft and inverse fft functions from fftpackage
from scipy.fftpack import fft

#create an array with random n numbers
x = np.array([1.0, 2.0, 1.0, -1.0, 1.5])

#Applying the fft function
y = fft(x)
print (y)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">[ 4.50000000+0.j          2.08155948-1.65109876j -1.83155948+1.60822041j
 -1.83155948-1.60822041j  2.08155948+1.65109876j]
</code></pre> 
 <p>再看另一个示例 - </p> 
 <pre><code class="lang-python">#Importing the fft and inverse fft functions from fftpackage
from scipy.fftpack import fft
from scipy.fftpack import ifft

#create an array with random n numbers
x = np.array([1.0, 2.0, 1.0, -1.0, 1.5])

#Applying the fft function
y = fft(x)
#FFT is already in the workspace, using the same workspace to for inverse transform

yinv = ifft(y)

print (yinv)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">[ 1.0+0.j  2.0+0.j  1.0+0.j -1.0+0.j  1.5+0.j]
</code></pre> 
 <p><code>scipy.fftpack</code>模块允许计算快速傅立叶变换。 作为一个例子，一个(嘈杂的)输入信号可能看起来如下 -</p> 
 <pre><code class="lang-python">import numpy as np
time_step = 0.02
period = 5.
time_vec = np.arange(0, 20, time_step)
sig = np.sin(2 * np.pi / period * time_vec) + 0.5 *np.random.randn(time_vec.size)
print (sig.size)
</code></pre> 
 <p>我们正以<code>0.02</code>秒的时间步长创建一个信号。 最后一条语句显示信号<code>sig</code>的大小。 输出结果如下 -</p> 
 <pre><code class="lang-shell">1000
</code></pre> 
 <p>我们不知道信号频率; 只知道信号<code>sig</code>的采样时间步长。 信号应该来自实际函数，所以傅里叶变换将是对称的。 <code>scipy.fftpack.fftfreq()</code>函数将生成采样频率，<code>scipy.fftpack.fft()</code>将计算快速傅里叶变换。</p> 
 <p>下面通过一个例子来理解这一点。</p>   
 <pre><code class="lang-python">from scipy import fftpack
sample_freq = fftpack.fftfreq(sig.size, d = time_step)
sig_fft = fftpack.fft(sig)
print (sig_fft)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">array([ 
   25.45122234 +0.00000000e+00j,   6.29800973 +2.20269471e+00j,
   11.52137858 -2.00515732e+01j,   1.08111300 +1.35488579e+01j,
   …….])
</code></pre> 
 <h2 id="h2-u79BBu6563u4F59u5F26u53D8u6362"><a name="离散余弦变换" class="reference-link"></a><span class="header-link octicon octicon-link"></span>离散余弦变换</h2>
 <p>离散余弦变换(DCT)根据以不同频率振荡的余弦函数的和表示有限数据点序列。 SciPy提供了一个带有函数<code>idct</code>的DCT和一个带有函数<code>idct</code>的相应IDCT。看看下面的一个例子。</p> 
 <pre><code class="lang-python">from scipy.fftpack import dct
mydict = dct(np.array([4., 3., 5., 10., 5., 3.]))
print(mydict)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">[ 60.          -3.48476592 -13.85640646  11.3137085    6.          -6.31319305]
</code></pre> 
 <p>逆离散余弦变换从其离散余弦变换(DCT)系数重建序列。 <code>idct</code>函数是<code>dct</code>函数的反函数。 可通过下面的例子来理解这一点。</p> 
 <pre><code class="lang-python">from scipy.fftpack import dct
from scipy.fftpack import idct
d = idct(np.array([4., 3., 5., 10., 5., 3.]))
print(d)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">[ 39.15085889 -20.14213562  -6.45392043   7.13341236   8.14213562
  -3.83035081]
</code></pre>
 <br>      
</div></body></html>