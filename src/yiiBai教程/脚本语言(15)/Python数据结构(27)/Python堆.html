<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Python堆</h1><div style="width:100%;float:left;" class="article-content">   
 <p>堆是一种特殊的树结构，其中每个父节点小于或等于其子节点。 然后它被称为最小堆(<code>Min Heap</code>)。 如果每个父节点大于或等于其子节点，则称它为最大堆(<code>Max Heap</code>)。 实施优先级队列是非常有用的，在该队列中，具有较高权重的队列项目在处理中具有更高的优先级。在本章中，我们将学习使用python实现堆数据结构。</p> 
 <p><strong>创建一个堆</strong></p> 
 <p>堆是通过使用python内建的名称为<code>heapq</code>的库创建的。 该库具有对堆数据结构进行各种操作的相关功能。 以下是这些函数的列表 - </p> 
 <ul> 
  <li><code>heapify</code> - 此函数将常规列表转换为堆。 在结果堆中，最小的元素被推到索引位置<code>0</code>。但是其余的数据元素不一定被排序。</li>
  <li><code>heappush</code> - 这个函数在堆中添加一个元素而不改变当前堆。</li>
  <li><code>heappop</code> - 该函数返回堆中最小的数据元素。</li>
  <li><code>heapreplace</code> - 该函数用函数中提供的新值替换最小的数据元素。</li>
 </ul> 
 <p>通过简单地使用具有<code>heapify</code>函数的元素列表来创建堆。 在下面的例子中，提供了一个元素列表，<code>heapify</code>函数重新排列了元素到最初位置的元素。</p> 
 <pre><code class="lang-python">import heapq

H = [21,1,45,78,3,5]
# Use heapify to rearrange the elements
heapq.heapify(H)
print(H)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">[1, 3, 5, 78, 21, 45]
</code></pre> 
 <p><strong>插入堆</strong></p> 
 <p>将数据元素插入堆总是在最后一个索引处添加元素。 但是，只有在值最小的情况下，才可以再次应用<code>heapify</code>函数将新添加的元素添加到第一个索引。 在下面的例子中，插入数字 - <code>8</code> 。</p> 
 <pre><code class="lang-python">import heapq
H = [21,1,45,78,3,5]
# Covert to a heap
heapq.heapify(H)
print(H)
# Add element
heapq.heappush(H,8)
print(H)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p>   
 <pre><code class="lang-shell">[1, 3, 5, 78, 21, 45]
[1, 3, 5, 78, 21, 45, 8]
</code></pre> 
 <p><strong>从堆中移除</strong></p> 
 <p>可以使用此功能在第一个索引处移除元素。 在下面的例子中，函数将始终删除索引位置<code>1</code>处的元素。</p> 
 <pre><code class="lang-python">import heapq

H = [21,1,45,78,3,5]
# Create the heap

heapq.heapify(H)
print(H)

# Remove element from the heap
heapq.heappop(H)

print(H)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">[1, 3, 5, 78, 21, 45]
[3, 21, 5, 78, 45]
</code></pre> 
 <p><strong>替换堆</strong></p> 
 <p><code>heapreplace</code>函数总是删除堆中最小的元素，并在未被任何顺序修复的地方插入新的传入元素。参考以下示例 - </p> 
 <pre><code class="lang-python">import heapq

H = [21,1,45,78,3,5]
# Create the heap

heapq.heapify(H)
print(H)

# Replace an element
heapq.heapreplace(H,6)
print(H)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">[1, 3, 5, 78, 21, 45]
[3, 6, 5, 78, 21, 45]
</code></pre>
 <br>      
</div></body></html>