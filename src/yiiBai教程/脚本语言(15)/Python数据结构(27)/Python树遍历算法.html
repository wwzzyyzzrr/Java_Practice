<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Python树遍历算法</h1><div style="width:100%;float:left;" class="article-content">   
 <p>遍历是访问树的所有节点的过程，也可以打印它们的值。 因为所有节点都通过边(链接)连接，所以始终从根(头)节点开始。 也就是说，我们不能随机访问树中的一个节点。 这里介绍三种方式来遍历一棵树 -</p> 
 <ul> 
  <li>顺序遍历</li>
  <li>前序遍历</li>
  <li>后序遍历</li>
 </ul> 
 <h2 id="h2-u6309u987Au5E8Fu904Du5386"><a name="按顺序遍历" class="reference-link"></a><span class="header-link octicon octicon-link"></span>按顺序遍历</h2>
 <p>在这种遍历方法中，首先访问左侧子树，然后访问根，然后访问右侧子树。 我们应该永远记住每个节点本身可能代表一个子树。</p> 
 <p>在下面的python程序中，使用<code>Node</code>类为根节点以及左右节点创建占位符。 然后创建一个<code>insert()</code>函数来将数据添加到树中。 最后，<code>Inorder</code>遍历逻辑通过创建一个空列表，并首先添加添加根节点或父节点，然后左节点来实现。 最后添加左节点以完成<code>Inorder</code>遍历。 请注意，对于每个子树重复此过程，直到遍历所有节点。</p> 
 <pre><code class="lang-python">class Node:

    def __init__(self, data):

        self.left = None
        self.right = None
        self.data = data
# Insert Node
    def insert(self, data):

        if self.data:
            if data &lt; self.data:
                if self.left is None:
                    self.left = Node(data)
                else:
                    self.left.insert(data)
            elif data &gt; self.data:
                if self.right is None:
                    self.right = Node(data)
                else:
                    self.right.insert(data)
        else:
            self.data = data

# Print the Tree
    def PrintTree(self):
        if self.left:
            self.left.PrintTree()
        print( self.data),
        if self.right:
            self.right.PrintTree()

# Inorder traversal
# Left -&gt; Root -&gt; Right
    def inorderTraversal(self, root):
        res = []
        if root:
            res = self.inorderTraversal(root.left)
            res.append(root.data)
            res = res + self.inorderTraversal(root.right)
        return res

root = Node(27)
root.insert(14)
root.insert(35)
root.insert(10)
root.insert(19)
root.insert(31)
root.insert(42)
print(root.inorderTraversal(root))
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">[10, 14, 19, 27, 31, 35, 42]
</code></pre> 
 <h2 id="h2-u524Du5E8Fu904Du5386"><a name="前序遍历" class="reference-link"></a><span class="header-link octicon octicon-link"></span>前序遍历</h2>
 <p>在这种遍历方法中，首先访问根节点，然后访问左边的子树，最后访问右边的子树。</p> 
 <p>在下面的python程序中，使用<code>Node</code>类为根节点以及左右节点创建占位符。 然后创建一个<code>insert()</code>函数来将数据添加到树中。 最后，前序遍历遍历逻辑通过创建一个空列表并首先添加根节点，然后添加左节点来实现。 最后添加右节点以完成前序遍历。 请注意，对于每个子树重复此过程，直到遍历所有节点。</p> 
 <pre><code class="lang-python">class Node:

    def __init__(self, data):

        self.left = None
        self.right = None
        self.data = data
# Insert Node
    def insert(self, data):

        if self.data:
            if data &lt; self.data:
                if self.left is None:
                    self.left = Node(data)
                else:
                    self.left.insert(data)
            elif data &gt; self.data:
                if self.right is None:
                    self.right = Node(data)
                else:
                    self.right.insert(data)
        else:
            self.data = data

# Print the Tree
    def PrintTree(self):
        if self.left:
            self.left.PrintTree()
        print( self.data),
        if self.right:
            self.right.PrintTree()

# Preorder traversal
# Root -&gt; Left -&gt;Right
    def PreorderTraversal(self, root):
        res = []
        if root:
            res.append(root.data)
            res = res + self.PreorderTraversal(root.left)
            res = res + self.PreorderTraversal(root.right)
        return res

root = Node(27)
root.insert(14)
root.insert(35)
root.insert(10)
root.insert(19)
root.insert(31)
root.insert(42)
print(root.PreorderTraversal(root))
</code></pre> 
 <p>当上面的代码被执行时，它会产生以下结果 -</p>   
 <pre><code class="lang-shell">[27, 14, 10, 19, 35, 31, 42]
</code></pre> 
 <h2 id="h2-u540Eu5E8Fu904Du5386"><a name="后序遍历" class="reference-link"></a><span class="header-link octicon octicon-link"></span>后序遍历</h2>
 <p>在这个遍历方法中，最后访问根节点。 首先遍历左子树，然后遍历右子树，最后遍历根节点。</p> 
 <p>在下面的python程序中，使用<code>Node</code>类为根节点以及左右节点创建占位符。 然后创建一个<code>insert()</code>函数来将数据添加到树中。 最后，通过创建一个空列表并添加左节点，然后添加右节点来实现后序遍历逻辑。 最后，添加根或父节点以完成后序遍历。 请注意，对于每个子树重复此过程，直到遍历所有节点。参考以下代码实现 - </p> 
 <pre><code class="lang-python">class Node:

    def __init__(self, data):

        self.left = None
        self.right = None
        self.data = data
# Insert Node
    def insert(self, data):

        if self.data:
            if data &lt; self.data:
                if self.left is None:
                    self.left = Node(data)
                else:
                    self.left.insert(data)
            elif data &gt; self.data:
                if self.right is None:
                    self.right = Node(data)
                else:
                    self.right.insert(data)
        else:
            self.data = data

# Print the Tree
    def PrintTree(self):
        if self.left:
            self.left.PrintTree()
        print( self.data),
        if self.right:
            self.right.PrintTree()

# Postorder traversal
# Left -&gt;Right -&gt; Root
    def PostorderTraversal(self, root):
        res = []
        if root:
            res = self.PostorderTraversal(root.left)
            res = res + self.PostorderTraversal(root.right)
            res.append(root.data)
        return res

root = Node(27)
root.insert(14)
root.insert(35)
root.insert(10)
root.insert(19)
root.insert(31)
root.insert(42)
print(root.PostorderTraversal(root))
</code></pre> 
 <p>当上面的代码被执行时，它会产生以下结果 -</p> 
 <pre><code class="lang-shell">[10, 19, 14, 31, 42, 35, 27]
</code></pre>
 <br>      
</div></body></html>