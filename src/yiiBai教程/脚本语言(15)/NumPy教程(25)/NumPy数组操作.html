<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">NumPy数组操作</h1><div style="width:100%;float:left;" class="article-content">   
 <h1 id="h1-numpy-"><a name="NumPy - 数组操作" class="reference-link"></a><span class="header-link octicon octicon-link"></span>NumPy - 数组操作</h1>
 <p>NumPy包中有几个例程用于处理<code>ndarray</code>对象中的元素。 它们可以分为以下类型：</p> 
 <h2 id="h2-u4FEEu6539u5F62u72B6"><a name="修改形状" class="reference-link"></a><span class="header-link octicon octicon-link"></span>修改形状</h2>
 <table> 
  <thead> 
   <tr> 
    <th>序号</th> 
    <th>形状及描述</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>1.</td> 
    <td><code>reshape</code> 不改变数据的条件下修改形状</td> 
   </tr> 
   <tr> 
    <td>2.</td> 
    <td><code>flat</code> 数组上的一维迭代器</td> 
   </tr> 
   <tr> 
    <td>3.</td> 
    <td><code>flatten</code> 返回折叠为一维的数组副本</td> 
   </tr> 
   <tr> 
    <td>4.</td> 
    <td><code>ravel</code> 返回连续的展开数组</td> 
   </tr> 
  </tbody> 
 </table> 
 <h3 id="h3--code-numpy-reshape-code-"><a name="<code>numpy.reshape</code>" class="reference-link"></a><span class="header-link octicon octicon-link"></span><code>numpy.reshape</code></h3>
 <p>这个函数在不改变数据的条件下修改形状，它接受如下参数：</p> 
 <pre><code>numpy.reshape(arr, newshape, order')
</code></pre>
 <p>其中：</p> 
 <ul> 
  <li><code>arr</code>：要修改形状的数组</li>
  <li><code>newshape</code>：整数或者整数数组，新的形状应当兼容原有形状</li>
  <li><code>order</code>：<code>'C'</code>为 C 风格顺序，<code>'F'</code>为 F 风格顺序，<code>'A'</code>为保留原顺序。</li>
 </ul> 
 <p>例子</p> 
 <pre><code class="lang-python">import numpy as np
a = np.arange(8)
print '原始数组：'
print a
print '\n'

b = a.reshape(4,2)
print '修改后的数组：'
print b
</code></pre> 
 <p>输出如下：</p> 
 <pre><code>原始数组：
[0 1 2 3 4 5 6 7]

修改后的数组：
[[0 1]
 [2 3]
 [4 5]
 [6 7]]
</code></pre>
 <h3 id="h3--code-numpy-ndarray-flat-code-"><a name="<code>numpy.ndarray.flat</code>" class="reference-link"></a><span class="header-link octicon octicon-link"></span><code>numpy.ndarray.flat</code></h3>
 <p>该函数返回数组上的一维迭代器，行为类似 Python 内建的迭代器。</p> 
 <p>例子</p> 
 <pre><code class="lang-python">import numpy as np
a = np.arange(8).reshape(2,4)
print '原始数组：'
print a
print '\n'

print '调用 flat 函数之后：'
# 返回展开数组中的下标的对应元素
print a.flat[5]
</code></pre> 
 <p>输出如下：</p> 
 <pre><code>原始数组：
[[0 1 2 3]
 [4 5 6 7]]

调用 flat 函数之后：
5
</code></pre>
 <h3 id="h3--code-numpy-ndarray-flatten-code-"><a name="<code>numpy.ndarray.flatten</code>" class="reference-link"></a><span class="header-link octicon octicon-link"></span><code>numpy.ndarray.flatten</code></h3>
 <p>该函数返回折叠为一维的数组副本，函数接受下列参数：</p> 
 <pre><code class="lang-python">ndarray.flatten(order)
</code></pre> 
 <p>其中：</p> 
 <ul> 
  <li><code>order</code>：<code>'C'</code> — 按行，<code>'F'</code> — 按列，<code>'A'</code> — 原顺序，<code>'k'</code> — 元素在内存中的出现顺序。</li>
 </ul> 
 <p>例子</p> 
 <pre><code class="lang-python">import numpy as np
a = np.arange(8).reshape(2,4)

print '原数组：'
print a
print '\n'  
# default is column-major

print '展开的数组：'
print a.flatten()
print '\n'  

print '以 F 风格顺序展开的数组：'
print a.flatten(order = 'F')
</code></pre> 
 <p>输出如下：</p> 
 <pre><code>原数组：
[[0 1 2 3]
 [4 5 6 7]]

展开的数组：
[0 1 2 3 4 5 6 7]

以 F 风格顺序展开的数组：
[0 4 1 5 2 6 3 7]
</code></pre>
 <h3 id="h3--code-numpy-ravel-code-"><a name="<code>numpy.ravel</code>" class="reference-link"></a><span class="header-link octicon octicon-link"></span><code>numpy.ravel</code></h3>
 <p>这个函数返回展开的一维数组，并且按需生成副本。返回的数组和输入数组拥有相同数据类型。这个函数接受两个参数。</p> 
 <pre><code class="lang-python">numpy.ravel(a, order)
</code></pre> 
 <p>构造器接受下列参数：</p> 
 <ul> 
  <li><code>order</code>：<code>'C'</code> — 按行，<code>'F'</code> — 按列，<code>'A'</code> — 原顺序，<code>'k'</code> — 元素在内存中的出现顺序。</li>
 </ul> 
 <p>例子</p> 
 <pre><code class="lang-python">import numpy as np
a = np.arange(8).reshape(2,4)

print '原数组：'
print a
print '\n'  

print '调用 ravel 函数之后：'
print a.ravel()  
print '\n'

print '以 F 风格顺序调用 ravel 函数之后：'
print a.ravel(order = 'F')
</code></pre> 
 <pre><code>原数组：
[[0 1 2 3]
 [4 5 6 7]]

调用 ravel 函数之后：
[0 1 2 3 4 5 6 7]

以 F 风格顺序调用 ravel 函数之后：
[0 4 1 5 2 6 3 7]
</code></pre>
 <h2 id="h2-u7FFBu8F6Cu64CDu4F5C"><a name="翻转操作" class="reference-link"></a><span class="header-link octicon octicon-link"></span>翻转操作</h2>
 <table> 
  <thead> 
   <tr> 
    <th>序号</th> 
    <th>操作及描述</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>1.</td> 
    <td><code>transpose</code> 翻转数组的维度</td> 
   </tr> 
   <tr> 
    <td>2.</td> 
    <td><code>ndarray.T</code> 和<code>self.transpose()</code>相同</td> 
   </tr> 
   <tr> 
    <td>3.</td> 
    <td><code>rollaxis</code> 向后滚动指定的轴</td> 
   </tr> 
   <tr> 
    <td>4.</td> 
    <td><code>swapaxes</code> 互换数组的两个轴</td> 
   </tr> 
  </tbody> 
 </table> 
 <h3 id="h3--code-numpy-transpose-code-"><a name="<code>numpy.transpose</code>" class="reference-link"></a><span class="header-link octicon octicon-link"></span><code>numpy.transpose</code></h3>
 <p>这个函数翻转给定数组的维度。如果可能的话它会返回一个视图。函数接受下列参数：</p> 
 <pre><code class="lang-python">numpy.transpose(arr, axes)
</code></pre> 
 <p>其中：</p> 
 <ul> 
  <li><code>arr</code>：要转置的数组</li>
  <li><code>axes</code>：整数的列表，对应维度，通常所有维度都会翻转。</li>
 </ul> 
 <p>例子</p> 
 <pre><code class="lang-python">import numpy as np
a = np.arange(12).reshape(3,4)

print '原数组：'
print a  
print '\n'

print '转置数组：'
print np.transpose(a)
</code></pre> 
 <p>输出如下：</p> 
 <pre><code>原数组：
[[ 0 1 2 3]
 [ 4 5 6 7]
 [ 8 9 10 11]]

转置数组：
[[ 0 4 8]
 [ 1 5 9]
 [ 2 6 10]
 [ 3 7 11]]
</code></pre>
 <h3 id="h3--code-numpy-ndarray-t-code-"><a name="<code>numpy.ndarray.T</code>" class="reference-link"></a><span class="header-link octicon octicon-link"></span><code>numpy.ndarray.T</code></h3>
 <p>该函数属于<code>ndarray</code>类，行为类似于<code>numpy.transpose</code>。</p> 
 <p>例子</p> 
 <pre><code class="lang-python">import numpy as np
a = np.arange(12).reshape(3,4)

print '原数组：'
print a
print '\n'  

print '转置数组：'
print a.T
</code></pre> 
 <p>输出如下：</p> 
 <pre><code>原数组：
[[ 0 1 2 3]
 [ 4 5 6 7]
 [ 8 9 10 11]]

转置数组：
[[ 0 4 8]
 [ 1 5 9]
 [ 2 6 10]
 [ 3 7 11]]
</code></pre>
 <h3 id="h3--code-numpy-rollaxis-code-"><a name="<code>numpy.rollaxis</code>" class="reference-link"></a><span class="header-link octicon octicon-link"></span><code>numpy.rollaxis</code></h3>
 <p>该函数向后滚动特定的轴，直到一个特定位置。这个函数接受三个参数：</p> 
 <pre><code>numpy.rollaxis(arr, axis, start)
</code></pre>
 <p>其中：</p> 
 <ul> 
  <li><code>arr</code>：输入数组</li>
  <li><code>axis</code>：要向后滚动的轴，其它轴的相对位置不会改变</li>
  <li><code>start</code>：默认为零，表示完整的滚动。会滚动到特定位置。</li>
 </ul> 
 <p>例子</p> 
 <pre><code class="lang-python"># 创建了三维的 ndarray
import numpy as np
a = np.arange(8).reshape(2,2,2)

print '原数组：'
print a
print '\n'
# 将轴 2 滚动到轴 0(宽度到深度)

print '调用 rollaxis 函数：'
print np.rollaxis(a,2)  
# 将轴 0 滚动到轴 1：(宽度到高度)
print '\n'

print '调用 rollaxis 函数：'
print np.rollaxis(a,2,1)
</code></pre> 
 <p>输出如下：</p> 
 <pre><code>原数组：
[[[0 1]
 [2 3]]
 [[4 5]
 [6 7]]]

调用 rollaxis 函数：
[[[0 2]
 [4 6]]
 [[1 3]
 [5 7]]]

调用 rollaxis 函数：
[[[0 2]
 [1 3]]
 [[4 6]
 [5 7]]]
</code></pre>
 <h3 id="h3--code-numpy-swapaxes-code-"><a name="<code>numpy.swapaxes</code>" class="reference-link"></a><span class="header-link octicon octicon-link"></span><code>numpy.swapaxes</code></h3>
 <p>该函数交换数组的两个轴。对于 1.10 之前的 NumPy 版本，会返回交换后数组的试图。这个函数接受下列参数：</p> 
 <pre><code class="lang-python">numpy.swapaxes(arr, axis1, axis2)
</code></pre> 
 <ul> 
  <li><code>arr</code>：要交换其轴的输入数组</li>
  <li><code>axis1</code>：对应第一个轴的整数</li>
  <li><code>axis2</code>：对应第二个轴的整数</li>
 </ul> 
 <pre><code class="lang-python"># 创建了三维的 ndarray
import numpy as np
a = np.arange(8).reshape(2,2,2)

print '原数组：'
print a
print '\n'  
# 现在交换轴 0(深度方向)到轴 2(宽度方向)

print '调用 swapaxes 函数后的数组：'
print np.swapaxes(a, 2, 0)
</code></pre> 
 <p>输出如下：</p> 
 <pre><code>原数组：
[[[0 1]
 [2 3]]

 [[4 5]
  [6 7]]]

调用 swapaxes 函数后的数组：
[[[0 4]
 [2 6]]

 [[1 5]
  [3 7]]]
</code></pre>
 <h2 id="h2-u4FEEu6539u7EF4u5EA6"><a name="修改维度" class="reference-link"></a><span class="header-link octicon octicon-link"></span>修改维度</h2>
 <table> 
  <thead> 
   <tr> 
    <th>序号</th> 
    <th>维度和描述</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>1.</td> 
    <td><code>broadcast</code> 产生模仿广播的对象</td> 
   </tr> 
   <tr> 
    <td>2.</td> 
    <td><code>broadcast_to</code> 将数组广播到新形状</td> 
   </tr> 
   <tr> 
    <td>3.</td> 
    <td><code>expand_dims</code> 扩展数组的形状</td> 
   </tr> 
   <tr> 
    <td>4.</td> 
    <td><code>squeeze</code> 从数组的形状中删除单维条目</td> 
   </tr> 
  </tbody> 
 </table> 
 <h3 id="h3--code-broadcast-code-"><a name="<code>broadcast</code>" class="reference-link"></a><span class="header-link octicon octicon-link"></span><code>broadcast</code></h3>
 <p>如前所述，NumPy 已经内置了对广播的支持。 此功能模仿广播机制。 它返回一个对象，该对象封装了将一个数组广播到另一个数组的结果。</p> 
 <p>该函数使用两个数组作为输入参数。 下面的例子说明了它的用法。</p> 
 <pre><code class="lang-python">import numpy as np
x = np.array([[1], [2], [3]])
y = np.array([4, 5, 6])  

# 对 y 广播 x
b = np.broadcast(x,y)  
# 它拥有 iterator 属性，基于自身组件的迭代器元组

print '对 y 广播 x：'
r,c = b.iters
print r.next(), c.next()
print r.next(), c.next()
print '\n'  
# shape 属性返回广播对象的形状

print '广播对象的形状：'
print b.shape
print '\n'  
# 手动使用 broadcast 将 x 与 y 相加
b = np.broadcast(x,y)
c = np.empty(b.shape)

print '手动使用 broadcast 将 x 与 y 相加：'
print c.shape
print '\n'  
c.flat = [u + v for (u,v) in b]

print '调用 flat 函数：'
print c
print '\n'  
# 获得了和 NumPy 内建的广播支持相同的结果

print 'x 与 y 的和：'
print x + y
</code></pre> 
 <p>输出如下：</p> 
 <pre><code>对 y 广播 x：
1 4
1 5

广播对象的形状：
(3, 3)

手动使用 broadcast 将 x 与 y 相加：
(3, 3)

调用 flat 函数：
[[ 5. 6. 7.]
 [ 6. 7. 8.]
 [ 7. 8. 9.]]

x 与 y 的和：
[[5 6 7]
 [6 7 8]
 [7 8 9]]
</code></pre>
 <h3 id="h3--code-numpy-broadcast_to-code-"><a name="<code>numpy.broadcast_to</code>" class="reference-link"></a><span class="header-link octicon octicon-link"></span><code>numpy.broadcast_to</code></h3>
 <p>此函数将数组广播到新形状。 它在原始数组上返回只读视图。 它通常不连续。 如果新形状不符合 NumPy 的广播规则，该函数可能会抛出<code>ValueError</code>。</p> 
 <p>注意 - 此功能可用于 1.10.0 及以后的版本。</p> 
 <p>该函数接受以下参数。</p> 
 <pre><code class="lang-python">numpy.broadcast_to(array, shape, subok)
</code></pre> 
 <p>例子</p> 
 <pre><code class="lang-python">import numpy as np
a = np.arange(4).reshape(1,4)

print '原数组：'
print a
print '\n'  

print '调用 broadcast_to 函数之后：'
print np.broadcast_to(a,(4,4))
</code></pre> 
 <p>输出如下：</p> 
 <pre><code>[[0  1  2  3]
 [0  1  2  3]
 [0  1  2  3]
 [0  1  2  3]]
</code></pre>
 <h3 id="h3--code-numpy-expand_dims-code-"><a name="<code>numpy.expand_dims</code>" class="reference-link"></a><span class="header-link octicon octicon-link"></span><code>numpy.expand_dims</code></h3>
 <p>函数通过在指定位置插入新的轴来扩展数组形状。该函数需要两个参数：</p> 
 <pre><code>numpy.expand_dims(arr, axis)
</code></pre>
 <p>其中：</p> 
 <ul> 
  <li><code>arr</code>：输入数组</li>
  <li><code>axis</code>：新轴插入的位置</li>
 </ul> 
 <p>例子</p> 
 <pre><code class="lang-python">import numpy as np
x = np.array(([1,2],[3,4]))

print '数组 x：'
print x
print '\n'  
y = np.expand_dims(x, axis = 0)

print '数组 y：'
print y
print '\n'

print '数组 x 和 y 的形状：'
print x.shape, y.shape
print '\n'  
# 在位置 1 插入轴
y = np.expand_dims(x, axis = 1)

print '在位置 1 插入轴之后的数组 y：'
print y
print '\n'  

print 'x.ndim 和 y.ndim：'
print x.ndim,y.ndim
print '\n'  

print 'x.shape 和 y.shape：'
print x.shape, y.shape
</code></pre> 
 <p>输出如下：</p> 
 <pre><code>数组 x：
[[1 2]
 [3 4]]

数组 y：
[[[1 2]
 [3 4]]]

数组 x 和 y 的形状：
(2, 2) (1, 2, 2)

在位置 1 插入轴之后的数组 y：
[[[1 2]]
 [[3 4]]]

x.shape 和 y.shape：
2 3

x.shape and y.shape:
(2, 2) (2, 1, 2)
</code></pre>
 <h3 id="h3--code-numpy-squeeze-code-"><a name="<code>numpy.squeeze</code>" class="reference-link"></a><span class="header-link octicon octicon-link"></span><code>numpy.squeeze</code></h3>
 <p>函数从给定数组的形状中删除一维条目。 此函数需要两个参数。</p> 
 <pre><code class="lang-python">numpy.squeeze(arr, axis)
</code></pre> 
 <p>其中：</p> 
 <ul> 
  <li><code>arr</code>：输入数组</li>
  <li><code>axis</code>：整数或整数元组，用于选择形状中单一维度条目的子集</li>
 </ul> 
 <p>例子</p> 
 <pre><code class="lang-python">import numpy as np  
x = np.arange(9).reshape(1,3,3)

print '数组 x：'
print x
print '\n'  
y = np.squeeze(x)

print '数组 y：'
print y
print '\n'  

print '数组 x 和 y 的形状：'
print x.shape, y.shape
</code></pre> 
 <p>输出如下：</p> 
 <pre><code>数组 x：
[[[0 1 2]
 [3 4 5]
 [6 7 8]]]

数组 y：
[[0 1 2]
 [3 4 5]
 [6 7 8]]

数组 x 和 y 的形状：
(1, 3, 3) (3, 3)
</code></pre>
 <h2 id="h2-u6570u7EC4u7684u8FDEu63A5"><a name="数组的连接" class="reference-link"></a><span class="header-link octicon octicon-link"></span>数组的连接</h2>
 <table> 
  <thead> 
   <tr> 
    <th>序号</th> 
    <th>数组及描述</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>1.</td> 
    <td><code>concatenate</code> 沿着现存的轴连接数据序列</td> 
   </tr> 
   <tr> 
    <td>2.</td> 
    <td><code>stack</code> 沿着新轴连接数组序列</td> 
   </tr> 
   <tr> 
    <td>3.</td> 
    <td><code>hstack</code> 水平堆叠序列中的数组(列方向)</td> 
   </tr> 
   <tr> 
    <td>4.</td> 
    <td><code>vstack</code> 竖直堆叠序列中的数组(行方向)</td> 
   </tr> 
  </tbody> 
 </table> 
 <h3 id="h3--code-numpy-concatenate-code-"><a name="<code>numpy.concatenate</code>" class="reference-link"></a><span class="header-link octicon octicon-link"></span><code>numpy.concatenate</code></h3>
 <p>数组的连接是指连接。 此函数用于沿指定轴连接相同形状的两个或多个数组。 该函数接受以下参数。</p> 
 <pre><code class="lang-python">numpy.concatenate((a1, a2, ...), axis)
</code></pre> 
 <p>其中：</p> 
 <ul> 
  <li><code>a1, a2, ...</code>：相同类型的数组序列</li>
  <li><code>axis</code>：沿着它连接数组的轴，默认为 0</li>
 </ul> 
 <p>例子</p> 
 <pre><code class="lang-python">import numpy as np
a = np.array([[1,2],[3,4]])

print '第一个数组：'
print a
print '\n'  
b = np.array([[5,6],[7,8]])

print '第二个数组：'
print b
print '\n'  
# 两个数组的维度相同

print '沿轴 0 连接两个数组：'
print np.concatenate((a,b))
print '\n'  

print '沿轴 1 连接两个数组：'
print np.concatenate((a,b),axis = 1)
</code></pre> 
 <p>输出如下：</p> 
 <pre><code>第一个数组：
[[1 2]
 [3 4]]

第二个数组：
[[5 6]
 [7 8]]

沿轴 0 连接两个数组：
[[1 2]
 [3 4]
 [5 6]
 [7 8]]

沿轴 1 连接两个数组：
[[1 2 5 6]
 [3 4 7 8]]
</code></pre>
 <h3 id="h3--code-numpy-stack-code-"><a name="<code>numpy.stack</code>" class="reference-link"></a><span class="header-link octicon octicon-link"></span><code>numpy.stack</code></h3>
 <p>此函数沿新轴连接数组序列。 此功能添加自 NumPy 版本 1.10.0。 需要提供以下参数。</p> 
 <pre><code class="lang-python">numpy.stack(arrays, axis)
</code></pre> 
 <p>其中：</p> 
 <ul> 
  <li><code>arrays</code>：相同形状的数组序列</li>
  <li><code>axis</code>：返回数组中的轴，输入数组沿着它来堆叠</li>
 </ul> 
 <pre><code class="lang-python">import numpy as np
a = np.array([[1,2],[3,4]])

print '第一个数组：'
print a
print '\n'
b = np.array([[5,6],[7,8]])

print '第二个数组：'
print b
print '\n'  

print '沿轴 0 堆叠两个数组：'
print np.stack((a,b),0)
print '\n'  

print '沿轴 1 堆叠两个数组：'
print np.stack((a,b),1)
</code></pre> 
 <p>输出如下：</p> 
 <pre><code>第一个数组：
[[1 2]
 [3 4]]

第二个数组：
[[5 6]
 [7 8]]

沿轴 0 堆叠两个数组：
[[[1 2]
 [3 4]]
 [[5 6]
 [7 8]]]

沿轴 1 堆叠两个数组：
[[[1 2]
 [5 6]]
 [[3 4]
 [7 8]]]
</code></pre>
 <h3 id="h3--code-numpy-hstack-code-"><a name="<code>numpy.hstack</code>" class="reference-link"></a><span class="header-link octicon octicon-link"></span><code>numpy.hstack</code></h3>
 <p><code>numpy.stack</code>函数的变体，通过堆叠来生成水平的单个数组。</p> 
 <p>例子</p> 
 <pre><code class="lang-python">import numpy as np
a = np.array([[1,2],[3,4]])

print '第一个数组：'
print a
print '\n'  
b = np.array([[5,6],[7,8]])

print '第二个数组：'
print b
print '\n'  

print '水平堆叠：'
c = np.hstack((a,b))
print c
print '\n'
</code></pre> 
 <p>输出如下：</p> 
 <pre><code>第一个数组：
[[1 2]
 [3 4]]

第二个数组：
[[5 6]
 [7 8]]

水平堆叠：
[[1 2 5 6]
 [3 4 7 8]]
</code></pre>
 <h3 id="h3--code-numpy-vstack-code-"><a name="<code>numpy.vstack</code>" class="reference-link"></a><span class="header-link octicon octicon-link"></span><code>numpy.vstack</code></h3>
 <p><code>numpy.stack</code>函数的变体，通过堆叠来生成竖直的单个数组。</p> 
 <pre><code class="lang-python">import numpy as np
a = np.array([[1,2],[3,4]])

print '第一个数组：'
print a
print '\n'  
b = np.array([[5,6],[7,8]])

print '第二个数组：'
print b
print '\n'

print '竖直堆叠：'
c = np.vstack((a,b))
print c
</code></pre> 
 <p>输出如下：</p> 
 <pre><code>第一个数组：
[[1 2]
 [3 4]]

第二个数组：
[[5 6]
 [7 8]]

竖直堆叠：
[[1 2]
 [3 4]
 [5 6]
 [7 8]]
</code></pre>
 <h2 id="h2-u6570u7EC4u5206u5272"><a name="数组分割" class="reference-link"></a><span class="header-link octicon octicon-link"></span>数组分割</h2>
 <table> 
  <thead> 
   <tr> 
    <th>序号</th> 
    <th>数组及操作</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>1.</td> 
    <td><code>split</code> 将一个数组分割为多个子数组</td> 
   </tr> 
   <tr> 
    <td>2.</td> 
    <td><code>hsplit</code> 将一个数组水平分割为多个子数组(按列)</td> 
   </tr> 
   <tr> 
    <td>3.</td> 
    <td><code>vsplit</code> 将一个数组竖直分割为多个子数组(按行)</td> 
   </tr> 
  </tbody> 
 </table> 
 <h3 id="h3--code-numpy-split-code-"><a name="<code>numpy.split</code>" class="reference-link"></a><span class="header-link octicon octicon-link"></span><code>numpy.split</code></h3>
 <p>该函数沿特定的轴将数组分割为子数组。函数接受三个参数：</p>   
 <pre><code>numpy.split(ary, indices_or_sections, axis)
</code></pre>
 <p>其中：</p> 
 <ul> 
  <li><code>ary</code>：被分割的输入数组</li>
  <li><code>indices_or_sections</code>：可以是整数，表明要从输入数组创建的，等大小的子数组的数量。 如果此参数是一维数组，则其元素表明要创建新子数组的点。</li>
  <li><code>axis</code>：默认为 0</li>
 </ul> 
 <p>例子</p> 
 <pre><code class="lang-python">import numpy as np
a = np.arange(9)

print '第一个数组：'
print a
print '\n'  

print '将数组分为三个大小相等的子数组：'
b = np.split(a,3)
print b
print '\n'  

print '将数组在一维数组中表明的位置分割：'
b = np.split(a,[4,7])
print b
</code></pre> 
 <p>输出如下：</p> 
 <pre><code>第一个数组：
[0 1 2 3 4 5 6 7 8]

将数组分为三个大小相等的子数组：
[array([0, 1, 2]), array([3, 4, 5]), array([6, 7, 8])]

将数组在一维数组中表明的位置分割：
[array([0, 1, 2, 3]), array([4, 5, 6]), array([7, 8])]
</code></pre>
 <h3 id="h3--code-numpy-hsplit-code-"><a name="<code>numpy.hsplit</code>" class="reference-link"></a><span class="header-link octicon octicon-link"></span><code>numpy.hsplit</code></h3>
 <p><code>numpy.hsplit</code>是<code>split()</code>函数的特例，其中轴为 1 表示水平分割，无论输入数组的维度是什么。</p> 
 <pre><code class="lang-python">import numpy as np
a = np.arange(16).reshape(4,4)

print '第一个数组：'
print a
print '\n'  

print '水平分割：'
b = np.hsplit(a,2)
print b
print '\n'
</code></pre> 
 <p>输出：</p> 
 <pre><code>第一个数组：
[[ 0 1 2 3]
 [ 4 5 6 7]
 [ 8 9 10 11]
 [12 13 14 15]]

水平分割：                                                         
[array([[ 0,  1],                                                             
       [ 4,  5],                                                              
       [ 8,  9],                                                              
       [12, 13]]), array([[ 2,  3],                                           
       [ 6,  7],                                                              
       [10, 11],                                                              
       [14, 15]])]
</code></pre>
 <h3 id="h3--code-numpy-vsplit-code-"><a name="<code>numpy.vsplit</code>" class="reference-link"></a><span class="header-link octicon octicon-link"></span><code>numpy.vsplit</code></h3>
 <p><code>numpy.vsplit</code>是<code>split()</code>函数的特例，其中轴为 0 表示竖直分割，无论输入数组的维度是什么。下面的例子使之更清楚。</p> 
 <pre><code class="lang-python">import numpy as np
a = np.arange(16).reshape(4,4)

print '第一个数组：'
print a
print '\n'

print '竖直分割：'
b = np.vsplit(a,2)
print b
</code></pre> 
 <p>输出如下：</p> 
 <pre><code>第一个数组：
[[ 0 1 2 3]
 [ 4 5 6 7]
 [ 8 9 10 11]
 [12 13 14 15]]

竖直分割：                                                           
[array([[0, 1, 2, 3],                                                         
       [4, 5, 6, 7]]), array([[ 8,  9, 10, 11],                               
       [12, 13, 14, 15]])]
</code></pre>
 <h2 id="h2--"><a name="添加/删除元素" class="reference-link"></a><span class="header-link octicon octicon-link"></span>添加/删除元素</h2>
 <table> 
  <thead> 
   <tr> 
    <th>序号</th> 
    <th>元素及描述</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>1.</td> 
    <td><code>resize</code> 返回指定形状的新数组</td> 
   </tr> 
   <tr> 
    <td>2.</td> 
    <td><code>append</code> 将值添加到数组末尾</td> 
   </tr> 
   <tr> 
    <td>3.</td> 
    <td><code>insert</code> 沿指定轴将值插入到指定下标之前</td> 
   </tr> 
   <tr> 
    <td>4.</td> 
    <td><code>delete</code> 返回删掉某个轴的子数组的新数组</td> 
   </tr> 
   <tr> 
    <td>5.</td> 
    <td><code>unique</code> 寻找数组内的唯一元素</td> 
   </tr> 
  </tbody> 
 </table> 
 <h3 id="h3--code-numpy-resize-code-"><a name="<code>numpy.resize</code>" class="reference-link"></a><span class="header-link octicon octicon-link"></span><code>numpy.resize</code></h3>
 <p>此函数返回指定大小的新数组。 如果新大小大于原始大小，则包含原始数组中的元素的重复副本。 该函数接受以下参数。</p> 
 <pre><code class="lang-python">numpy.resize(arr, shape)
</code></pre> 
 <p>其中：</p> 
 <ul> 
  <li><code>arr</code>：要修改大小的输入数组</li>
  <li><code>shape</code>：返回数组的新形状</li>
 </ul> 
 <p>例子</p> 
 <pre><code class="lang-python">import numpy as np
a = np.array([[1,2,3],[4,5,6]])

print '第一个数组：'
print a
print '\n'

print '第一个数组的形状：'
print a.shape
print '\n'  
b = np.resize(a, (3,2))

print '第二个数组：'
print b
print '\n'  

print '第二个数组的形状：'
print b.shape
print '\n'  
# 要注意 a 的第一行在 b 中重复出现，因为尺寸变大了

print '修改第二个数组的大小：'
b = np.resize(a,(3,3))
print b
</code></pre> 
 <p>输出如下：</p> 
 <pre><code>第一个数组：
[[1 2 3]
 [4 5 6]]

第一个数组的形状：
(2, 3)

第二个数组：
[[1 2]
 [3 4]
 [5 6]]

第二个数组的形状：
(3, 2)

修改第二个数组的大小：
[[1 2 3]
 [4 5 6]
 [1 2 3]]
</code></pre>
 <h3 id="h3--code-numpy-append-code-"><a name="<code>numpy.append</code>" class="reference-link"></a><span class="header-link octicon octicon-link"></span><code>numpy.append</code></h3>
 <p>此函数在输入数组的末尾添加值。 附加操作不是原地的，而是分配新的数组。 此外，输入数组的维度必须匹配否则将生成<code>ValueError</code>。</p> 
 <p>函数接受下列函数：</p> 
 <pre><code>numpy.append(arr, values, axis)
</code></pre>
 <p>其中：</p> 
 <ul> 
  <li><code>arr</code>：输入数组</li>
  <li><code>values</code>：要向<code>arr</code>添加的值，比如和<code>arr</code>形状相同(除了要添加的轴)</li>
  <li><code>axis</code>：沿着它完成操作的轴。如果没有提供，两个参数都会被展开。</li>
 </ul> 
 <p>例子</p> 
 <pre><code class="lang-python">import numpy as np
a = np.array([[1,2,3],[4,5,6]])

print '第一个数组：'
print a
print '\n'  

print '向数组添加元素：'
print np.append(a, [7,8,9])
print '\n'  

print '沿轴 0 添加元素：'
print np.append(a, [[7,8,9]],axis = 0)
print '\n'  

print '沿轴 1 添加元素：'
print np.append(a, [[5,5,5],[7,8,9]],axis = 1)
</code></pre> 
 <p>输出如下：</p> 
 <pre><code>第一个数组：
[[1 2 3]
 [4 5 6]]

向数组添加元素：
[1 2 3 4 5 6 7 8 9]

沿轴 0 添加元素：
[[1 2 3]
 [4 5 6]
 [7 8 9]]

沿轴 1 添加元素：
[[1 2 3 5 5 5]
 [4 5 6 7 8 9]]
</code></pre>
 <h2 id="h2--code-numpy-insert-code-"><a name="<code>numpy.insert</code>" class="reference-link"></a><span class="header-link octicon octicon-link"></span><code>numpy.insert</code></h2>
 <p>此函数在给定索引之前，沿给定轴在输入数组中插入值。 如果值的类型转换为要插入，则它与输入数组不同。 插入没有原地的，函数会返回一个新数组。 此外，如果未提供轴，则输入数组会被展开。</p> 
 <p><code>insert()</code>函数接受以下参数：</p> 
 <pre><code class="lang-python">numpy.insert(arr, obj, values, axis)
</code></pre> 
 <p>其中：</p> 
 <ul> 
  <li><code>arr</code>：输入数组</li>
  <li><code>obj</code>：在其之前插入值的索引</li>
  <li><code>values</code>：要插入的值</li>
  <li><code>axis</code>：沿着它插入的轴，如果未提供，则输入数组会被展开</li>
 </ul> 
 <p>例子</p> 
 <pre><code class="lang-python">import numpy as np
a = np.array([[1,2],[3,4],[5,6]])

print '第一个数组：'
print a
print '\n'  

print '未传递 Axis 参数。 在插入之前输入数组会被展开。'
print np.insert(a,3,[11,12])
print '\n'  
print '传递了 Axis 参数。 会广播值数组来配输入数组。'

print '沿轴 0 广播：'
print np.insert(a,1,[11],axis = 0)
print '\n'  

print '沿轴 1 广播：'
print np.insert(a,1,11,axis = 1)
</code></pre> 
 <h3 id="h3--code-numpy-delete-code-"><a name="<code>numpy.delete</code>" class="reference-link"></a><span class="header-link octicon octicon-link"></span><code>numpy.delete</code></h3>
 <p>此函数返回从输入数组中删除指定子数组的新数组。 与<code>insert()</code>函数的情况一样，如果未提供轴参数，则输入数组将展开。 该函数接受以下参数：</p> 
 <pre><code class="lang-python">Numpy.delete(arr, obj, axis)
</code></pre> 
 <p>其中：</p> 
 <ul> 
  <li><code>arr</code>：输入数组</li>
  <li><code>obj</code>：可以被切片，整数或者整数数组，表明要从输入数组删除的子数组</li>
  <li><code>axis</code>：沿着它删除给定子数组的轴，如果未提供，则输入数组会被展开</li>
 </ul> 
 <p>例子</p> 
 <pre><code class="lang-python">import numpy as np
a = np.arange(12).reshape(3,4)

print '第一个数组：'
print a
print '\n'  

print '未传递 Axis 参数。 在插入之前输入数组会被展开。'
print np.delete(a,5)
print '\n'  

print '删除第二列：'  
print np.delete(a,1,axis = 1)
print '\n'  

print '包含从数组中删除的替代值的切片：'
a = np.array([1,2,3,4,5,6,7,8,9,10])
print np.delete(a, np.s_[::2])
</code></pre> 
 <p>输出如下：</p> 
 <pre><code>第一个数组：
[[ 0 1 2 3]
 [ 4 5 6 7]
 [ 8 9 10 11]]

未传递 Axis 参数。 在插入之前输入数组会被展开。
[ 0 1 2 3 4 6 7 8 9 10 11]

删除第二列：
[[ 0 2 3]
 [ 4 6 7]
 [ 8 10 11]]

包含从数组中删除的替代值的切片：
[ 2 4 6 8 10]
</code></pre>
 <h3 id="h3--code-numpy-unique-code-"><a name="<code>numpy.unique</code>" class="reference-link"></a><span class="header-link octicon octicon-link"></span><code>numpy.unique</code></h3>
 <p>此函数返回输入数组中的去重元素数组。 该函数能够返回一个元组，包含去重数组和相关索引的数组。 索引的性质取决于函数调用中返回参数的类型。</p> 
 <pre><code class="lang-python">numpy.unique(arr, return_index, return_inverse, return_counts)
</code></pre> 
 <p>其中：</p> 
 <ul> 
  <li><code>arr</code>：输入数组，如果不是一维数组则会展开</li>
  <li><code>return_index</code>：如果为<code>true</code>，返回输入数组中的元素下标</li>
  <li><code>return_inverse</code>：如果为<code>true</code>，返回去重数组的下标，它可以用于重构输入数组</li>
  <li><code>return_counts</code>：如果为<code>true</code>，返回去重数组中的元素在原数组中的出现次数</li>
 </ul> 
 <p>例子</p> 
 <pre><code class="lang-python">import numpy as np
a = np.array([5,2,6,2,7,5,6,8,2,9])

print '第一个数组：'
print a
print '\n'  

print '第一个数组的去重值：'
u = np.unique(a)
print u
print '\n'  

print '去重数组的索引数组：'
u,indices = np.unique(a, return_index = True)
print indices
print '\n'  

print '我们可以看到每个和原数组下标对应的数值：'
print a
print '\n'  

print '去重数组的下标：'
u,indices = np.unique(a,return_inverse = True)
print u
print '\n'

print '下标为：'
print indices
print '\n'  

print '使用下标重构原数组：'
print u[indices]
print '\n'  

print '返回去重元素的重复数量：'
u,indices = np.unique(a,return_counts = True)
print u
print indices
</code></pre> 
 <p>输出如下：</p> 
 <pre><code>第一个数组：
[5 2 6 2 7 5 6 8 2 9]

第一个数组的去重值：
[2 5 6 7 8 9]

去重数组的索引数组：
[1 0 2 4 7 9]

我们可以看到每个和原数组下标对应的数值：
[5 2 6 2 7 5 6 8 2 9]

去重数组的下标：
[2 5 6 7 8 9]

下标为：
[1 0 2 0 3 1 2 4 0 5]

使用下标重构原数组：
[5 2 6 2 7 5 6 8 2 9]

返回唯一元素的重复数量：
[2 5 6 7 8 9]
 [3 2 2 1 1 1]
</code></pre>
 <br>      
</div></body></html>