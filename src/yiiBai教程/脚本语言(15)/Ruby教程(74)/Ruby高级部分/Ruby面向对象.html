<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Ruby面向对象</h1><div style="width:100%;float:left;" class="article-content">   
 <p>Ruby是一种真正面向对象的语言，可以嵌入超文本标记语言。 Ruby中的一切都是一个对象。 所有的数字，字符串甚至类都是一个对象。 整个Ruby语言基本上建立在对象和数据的概念上。</p> 
 <p>OOP是一种使用对象及其交互来设计应用程序和计算机程序的编程概念。</p> 
 <p>以下是OOP中的一些基本概念：</p> 
 <ul> 
  <li>封装</li>
  <li>多态性</li>
  <li>继承</li>
  <li>抽象化</li>
 </ul> 
 <p><strong>封装：</strong>它隐藏来自其他对象的类的实现细节，这由于该类对其余的代码不可用。 其主要目的是保护数据免受数据非法操纵。</p> 
 <p><strong>多态：</strong> 以不同的方式为不同的数据输入表示一个运算符或者函数。</p> 
 <p><strong>继承：</strong> 它从预定义类创建新类。 新类继承其父类的行为，父类也称为超类。 以这种方式，可以使预定义的类更可重用和有用。</p> 
 <p><strong>抽象：</strong> 它通过针对问题的建模分类来隐藏类的复杂性。</p> 
 <h2 id="h2-ruby-"><a name="Ruby类" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Ruby类</h2>
 <p>Ruby类定义数据类型的蓝图(或模板)。 它定义了该类名称是什么意思。</p> 
 <p>一个类定义是使用<code>class</code>关键字，后跟类名称，并以<code>end</code>关键字结束。</p> 
 <p>通常，类的名称必须以大写字母开头。 具有多个单词的类名称时，在每个单词首字母大写并且不用分隔字符在一起组成。</p> 
 <p><strong>创建类</strong></p> 
 <p>使用以下命令创建一个名称为：<code>Dog</code> 的类，</p> 
 <pre><code class="lang-ruby">#!/usr/bin/ruby   
# file : dog.rb

class Dog

  def initialize(name="Wong")
    @name = name
  end

  def say_welcome
    puts "Welcome  #{@name}!"
  end

  def say_bye
    puts "Bye  #{@name}, See you soon."
  end
 end
</code></pre> 
 <p>创建一个新类: <code>Dog</code> 。 <code><a target="_blank" href="https://github.com/name" title="@name" class="at-link">@name</a></code>是可用于<code>Dog</code>类的所有方法的实例变量。它在<code>say_welcome</code>和<code>say_bye</code>方法中使用。</p> 
 <h2 id="h2-ruby-"><a name="Ruby对象" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Ruby对象</h2>
 <p>在Ruby中，一切东西都是一个对象。 当创建对象时，它们通过方法进行来执行具体的操作。 因此，一个对象是数据和方法的组合。</p> 
 <p>要创建一个对象，首先要定义一个类。定义一个类可用于创建多个对象。 使用<code>new</code>关键字声明对象。</p> 
 <h3 id="h3-u521Bu5EFAu5BF9u8C61"><a name="创建对象" class="reference-link"></a><span class="header-link octicon octicon-link"></span>创建对象</h3>
 <p><strong>示例：</strong></p> 
 <p>在上一步中，已经创建了一个名为<code>Dog</code>的类。 现在来创建<code>Dog</code>类的一个对象: <code>aDog</code>，并使用以下命令，</p> 
 <pre><code class="lang-ruby">aDog = Dog.new('旺财')
</code></pre> 
 <p>完整示例代码 - </p> 
 <pre><code class="lang-ruby">#!/usr/bin/ruby   
# file : dog.rb

class Dog

  def initialize(name="Wong")
    @name = name
  end

  def say_welcome
    puts "Welcome  #{@name}!"
  end

  def say_bye
    puts "Bye  #{@name}, See you soon."
  end
 end


# 创建对象

aDog = Dog.new('旺财')

aDog.say_welcome

aDog.say_bye
</code></pre> 
 <p>执行上面示例代码，得到结果如下 -</p> 
 <pre><code class="lang-shell">F:\worksp\ruby&gt;ruby dog.rb
Welcome  旺财!
Bye  旺财, See you soon.

F:\worksp\ruby&gt;
</code></pre> 
 <h2 id="h2-ruby-"><a name="Ruby方法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Ruby方法</h2>
 <p>方法是在类的主体内定义的函数。 Ruby中的数据只能通过方法访问。 当调用方法时，Ruby会根据一个跟踪路径来查找。可以使用<code>ancestors</code>方法找出方法名称。</p> 
 <h3 id="h3-u5B9Au4E49u65B9u6CD5"><a name="定义方法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>定义方法</h3>
 <p>方法用<code>def</code>关键字定义，并以<code>end</code>关键字结尾。</p> 
 <p>定义一个方法：<code>get_name</code>，所下示例显示。</p> 
 <pre><code class="lang-shell">F:\worksp\ruby&gt;irb
irb(main):006:0&gt; def get_name
irb(main):007:1&gt;   puts "My name is Maxsu"
irb(main):008:1&gt; end
=&gt; :get_name
irb(main):009:0&gt; get_name
My name is Maxsu
=&gt; nil
irb(main):010:0&gt;
</code></pre> 
 <p><code>def</code>关键字开始方法名称的定义。 然后编写方法的具体实现。 最后一行 <code>end</code> 表示该方法定义完成。</p> 
 <h3 id="h3-u5B9Eu4F8Bu65B9u6CD5"><a name="实例方法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>实例方法</h3>
 <p>实例方法也使用<code>def</code>关键字定义，只能在类实例中使用。</p> 
 <p><strong>示例：</strong></p>   
 <pre><code class="lang-ruby">#!/usr/bin/ruby -w   
# file : instance-methods.rb

# define a class   
class Circle   
   # constructor method   
   def initialize(r)   
      @radius = r   
   end   
   # instance method   
   def getArea   
      3.14 * @radius * @radius   
   end   
end   

# create an object   
circle = Circle.new(200)   

# call instance methods   
a = circle.getArea()   
puts "Area of the box is : #{a}"
</code></pre> 
 <p>执行上面代码，得到以下结果 -</p> 
 <pre><code class="lang-shell">F:\worksp\ruby&gt;ruby instance-methods.rb
Area of the box is : 125600.0

F:\worksp\ruby&gt;
</code></pre> 
 <h2 id="h2-ruby-"><a name="Ruby继承" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Ruby继承</h2>
 <p>在继承中，使用预定义的类创建新类。新创建的类称为派生类，派生类的类称为基类。 通过继承可以重新使用代码，从而降低程序的复杂性。</p> 
 <p>Ruby不支持多级继承。而是支持混合型(mixins)。</p> 
 <p>在Ruby中，<code>&lt;</code>字符用于创建一个子类。 语法如下所示：</p> 
 <pre><code class="lang-ruby">parentClass &lt; subClass
</code></pre> 
 <p><strong>示例</strong></p> 
 <pre><code class="lang-ruby">#!/usr/bin/ruby   
# file : inheritance.rb
class Parent   

    def initialize   
        puts "Parent class created"   
    end   
end   

class Child &lt; Parent   

   def initialize   
       super   
       puts "Child class created"   
   end   
end   

Parent.new   
Child.new
</code></pre> 
 <p>在上面的例子中，创建了两个类：一个是<code>Base</code>类，另一个是派生的<code>Child</code>类。<code>super</code>方法调用<code>Parent</code>类的构造函数。</p> 
 <p>最后的两行实例化了这两个类。</p> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-ruby">F:\worksp\ruby&gt;ruby inheritance.rb
Parent class created
Parent class created
Child class created

F:\worksp\ruby&gt;
</code></pre> 
 <p>在输出中，首先创建<code>Parent</code>类的对象，派生的<code>Child</code>类也调用其父类的构造函数，然后创建<code>Child</code>类。</p> 
 <h2 id="h2-ruby-"><a name="Ruby构造函数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Ruby构造函数</h2>
 <p>创建对象时自动调用构造函数，并且不返回任何值。 在Ruby中，构造函数叫作：<code>initialize</code>。</p> 
 <p>构造函数的主要目的是启动对象的状态,它们不能被继承。使用<code>super</code>方法调用父对象构造函数。</p> 
 <p><strong>示例：</strong></p> 
 <pre><code class="lang-ruby">#!/usr/bin/ruby   
# file: class-initialize.rb
class Parent   

    def initialize   
        puts "Parent is created"   
    end   

end   

Parent.new
</code></pre> 
 <p>执行上面代码，得到以下结果 -</p> 
 <pre><code class="lang-shell">F:\worksp\ruby&gt;ruby class-initialize.rb
Parent is created

F:\worksp\ruby&gt;
</code></pre>
 <br>      
</div></body></html>