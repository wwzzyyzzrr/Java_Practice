<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Ruby解析XML(REXML)</h1><div style="width:100%;float:left;" class="article-content">   
 <p>XML是可扩展的标记语言，如HTML。它允许程序员开发可以被其他应用程序读取的应用程序，而不管使用的是什么操作系统和开发语言。</p> 
 <p>它可用于保存中小型数据量，不用在后端有任何基于SQL的技术。</p> 
 <p>REXML是一个纯Ruby的XML处理器。 它表示一个完整的XML文档，包括PI，doctype等。一个XML文档有一个可以由<code>root()</code>访问的单个子对象。 如果想要为创建的文档提供XML声明，则必须自己添加一个。 REXML文档不为您写入默认声明。</p> 
 <p>REXML灵感来自于Java的Electric XML库。 它的API易于使用，体积小巧，并遵循Ruby方法的方法命名和代码流。</p> 
 <p>它支持树和流文档解析。 <code>Steam</code>解析比树解析快<code>1.5</code>倍。 但是，在流解析中无法访问某些功能(如XPath)。</p> 
 <h3 id="h3-rexml-"><a name="REXML功能：" class="reference-link"></a><span class="header-link octicon octicon-link"></span>REXML功能：</h3>
 <ul> 
  <li>它100％使用Ruby语言编写。</li>
  <li>它包含少于2000行代码，因此更轻巧。</li>
  <li>它的方法和类很容易理解。</li>
  <li>它随Ruby安装一起提供，不需要单独安装。</li>
  <li>它用于DOM和SAX解析。</li>
 </ul> 
 <h2 id="h2--xml-"><a name="解析XML和访问元素" class="reference-link"></a><span class="header-link octicon octicon-link"></span>解析XML和访问元素</h2>
 <p>现在，从解析XML文档开始，下面是一个示例代码：</p> 
 <pre><code class="lang-ruby">require "rexml/document"  
file = File.new( "trial-1.xml" )  
doc = REXML::Document.new file
</code></pre> 
 <p>在上面的代码中，第<code>3</code>行用于解析提供的文件。</p> 
 <p><strong>示例</strong></p> 
 <pre><code class="lang-ruby">require 'rexml/document'   
# file ： rexml-example.rb

include REXML   

file = File.new("trial-1.xml")   
doc = Document.new(file)   
puts docs
</code></pre> 
 <p>在上面的代码中，<code>require</code>语句加载了REXML库。 然后包括REXML表示不必使用像<code>REXML:: Document</code>这样的名称。创建了<code>trial-1.xml</code>文件。并将文档显示在屏幕上。</p> 
 <pre><code class="lang-xml">F:\worksp\ruby&gt;ruby rexml-example.rb
&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;root&gt;
        Hello, this is first REXML use.
&lt;/root&gt;

F:\worksp\ruby&gt;
</code></pre> 
 <p><code>Document.new</code>方法将<code>IO</code>，<code>String</code>对象或<code>Document</code>作为参数。此参数指定必须读取XML文档的内容。</p> 
 <p>如果Document构造函数使用<code>Document</code>作为参数，则将其所有元素节点克隆到新的Document对象。 如果构造函数接受一个String参数，则字符串将包含一个XML文档。</p> 
 <h2 id="h2-xml-here-document-"><a name="XML 和 “Here Document”" class="reference-link"></a><span class="header-link octicon octicon-link"></span>XML 和 “Here Document”</h2>
 <p><strong>这里文档</strong>(“Here Document”)是一种指定文本块，保留换行符，空格或使用文本标识的方法。</p> 
 <p>使用“<code>&lt;&lt;</code>”命令后跟令牌字符串构建文档。</p> 
 <p>在Ruby中，“<code>&lt;&lt;</code>”和令牌字符串之间不应有空格。</p> 
 <p><strong>实例</strong></p> 
 <pre><code class="lang-ruby">#!/usr/bin/env ruby   
# file ： rexml-heredoc.rb

require 'rexml/document'   
include REXML   

info = &lt;&lt;XML   
&lt;info&gt;   
 &lt;name&gt;Maxsu&lt;/name&gt;   
 &lt;street&gt;人民大道&lt;/street&gt;   
 &lt;city&gt;海口&lt;/city&gt;   
 &lt;contact&gt;9854126575&lt;/contact&gt;   
 &lt;country&gt;中国&lt;/country&gt;   
&lt;/info&gt;   
XML   

document = Document.new( info )   
puts document
</code></pre> 
 <p>执行上面代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">F:\worksp\ruby&gt;ruby rexml-heredoc.rb
&lt;info&gt;
 &lt;name&gt;Maxsu&lt;/name&gt;
 &lt;street&gt;人民大道&lt;/street&gt;
 &lt;city&gt;海口&lt;/city&gt;
 &lt;contact&gt;9854126575&lt;/contact&gt;
 &lt;country&gt;中国&lt;/country&gt;
&lt;/info&gt;

F:\worksp\ruby&gt;
</code></pre> 
 <p>在这里，在这里使用文档信息。 包括<code>&lt;&lt;EOF</code>和<code>EOF</code>之间的所有字符都是信息的一部分。</p> 
 <p>对于XML解析示例，使用以下XML文件代码作为输入：</p> 
 <pre><code class="lang-ruby">

</code></pre> 
 <p>执行上面代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">#!/usr/bin/ruby -w   

require 'rexml/document'
# file : rexml-newxml.rb

include REXML   
xmlfile = File.new("trial-2.xml")   
xmldoc = Document.new(xmlfile)   

# Now get the root element   
root = xmldoc.root   
puts "Root element : " + root.attributes["shelf"]   

# This will output all the cloth titles.   
xmldoc.elements.each("collection/clothing"){   
   |e| puts "cloth Title : " + e.attributes["title"]   
}   

# This will output all the cloth types.   
xmldoc.elements.each("collection/clothing/type") {   
   |e| puts "cloth Type : " + e.text   
}   

# This will output all the cloth description.   
xmldoc.elements.each("collection/clothing/description") {   
   |e| puts "cloth Description : " + e.text   
}
</code></pre> 
 <h2 id="h2-ruby-xml-dom-"><a name="Ruby XML DOM类似的解析" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Ruby XML DOM类似的解析</h2>
 <p>这里演示以树形解析XML数据。 将以上文件<code>trial.xml</code>代码作为输入。</p>   
 <pre><code class="lang-xml">#!/usr/bin/ruby -w   

require 'rexml/document'   
include REXML   

xmlfile = File.new("trial.xml")   
xmldoc = Document.new(xmlfile)   

# Now get the root element   
root = xmldoc.root   
puts "Root element : " + root.attributes["shelf"]   

# This will output all the cloth titles.   
xmldoc.elements.each("collection/clothing"){   
   |e| puts "cloth Title : " + e.attributes["title"]   
}   

# This will output all the cloth types.   
xmldoc.elements.each("collection/clothing/type") {   
   |e| puts "cloth Type : " + e.text   
}   

# This will output all the cloth description.   
xmldoc.elements.each("collection/clothing/description") {   
   |e| puts "cloth Description : " + e.text   
}
</code></pre> 
 <h2 id="h2-ruby-xml-sax-"><a name="Ruby XML以SAX类似的解析" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Ruby XML以SAX类似的解析</h2>
 <p>这里演示以流的方式解析XML数据。 将文件<code>trial.xml</code>代码作为输入。 在这里将定义一个侦听器类，其方法将被解析器的回调目标。</p> 
 <p>建议不要对小文件使用类似SAX的解析。</p> 
 <pre><code class="lang-ruby">#!/usr/bin/ruby -w   

require 'rexml/document'   
require 'rexml/streamlistener'   
include REXML   

class MyListener   
  include REXML::StreamListener   
  def tag_start(*args)   
    puts "tag_start: #{args.map {|x| x.inspect}.join(', ')}"   
  end   

  def text(data)   
    return if data =~ /^\w*$/     # whitespace only   
    abbrev = data[0..40] + (data.length &gt; 40 ? "..." : "")   
    puts "  text   :   #{abbrev.inspect}"   
  end   
end   

list = MyListener.new   
xmlfile = File.new("trial.xml")   
Document.parse_stream(xmlfile, list)
</code></pre>
 <br>      
</div></body></html>