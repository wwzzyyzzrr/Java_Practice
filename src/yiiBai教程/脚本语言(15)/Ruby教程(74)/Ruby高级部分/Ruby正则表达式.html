<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Ruby正则表达式</h1><div style="width:100%;float:left;" class="article-content">   
 <p>正则表达式也拼写为 <code>regexp</code>，它用于保存正则表达式，用于将模式与字符串匹配。 在Ruby中，一个模式写在正斜杠字符之间。 它们描述一个字符串的内容。 Ruby正则表达式更类似于Perl正则表达式。</p> 
 <p><strong>语法</strong></p> 
 <pre><code class="lang-ruby">/search string/
</code></pre> 
 <p><code>Ruby 1.9</code>使用Oniguruma正则表达式库，但<code>Ruby 2.0</code>使用Onigmo正则表达式库。 Onigmo是Oniguruma的一个分支子库，增加了一些新功能。</p> 
 <h2 id="h2--match-"><a name="=~ 和 #match操作符" class="reference-link"></a><span class="header-link octicon octicon-link"></span>=~ 和 #match操作符</h2>
 <p>通过使用<code>=~</code>和<code>#match</code>操作符来实现模式匹配。</p> 
 <h3 id="h3--strong-strong-"><a name="<strong>=~</strong>" class="reference-link"></a><span class="header-link octicon octicon-link"></span><strong>=~</strong></h3>
 <p>这是基本的匹配模式，这里使用两个操作数。 一个是正则表达式，另一个是字符串。 正则表达式与字符串匹配。</p> 
 <p>如果找到匹配，则运算符返回第一个匹配索引，否则返回零(nil)。</p> 
 <p><strong>示例：</strong></p> 
 <pre><code class="lang-ruby">F:\worksp\ruby&gt;irb
irb(main):001:0&gt; /yii/ =~ 'Hello, welcom to yiibai.com.'
=&gt; 17
irb(main):002:0&gt; /to/ =~ 'Hello, welcom to yiibai.com.'
=&gt; 14
irb(main):003:0&gt; /too/ =~ 'Hello, welcom to yiibai.com.'
=&gt; nil
irb(main):004:0&gt;
</code></pre> 
 <h3 id="h3--match"><a name="#match" class="reference-link"></a><span class="header-link octicon octicon-link"></span>#match</h3>
 <p>该运算符返回匹配数据对象，否则返回零(nil)。</p> 
 <pre><code class="lang-ruby">F:\worksp\ruby&gt;irb
irb(main):001:0&gt; /yiibai/.match('Ruby tutorial at yiibai.com')
=&gt; #&lt;MatchData "yiibai"&gt;
irb(main):002:0&gt; /Ruby/.match('Ruby tutorial at yiibai.com')
=&gt; #&lt;MatchData "Ruby"&gt;
irb(main):003:0&gt; /Py/.match('Ruby tutorial at yiibai.com')
=&gt; nil
irb(main):004:0&gt;
</code></pre> 
 <h3 id="h3-u5143u5B57u7B26u548Cu8F6Cu4E49"><a name="元字符和转义" class="reference-link"></a><span class="header-link octicon octicon-link"></span>元字符和转义</h3>
 <p>元字符在模式中具有特定含义。 要匹配一个字符串，它们将被转回(<code>\</code>)或转义。 一些元字符是(，)，(.)，(？)，(+)，( - )，(*)，[，]，{，}。否则返回匹配的字符串。</p> 
 <p><strong>示例：</strong></p> 
 <pre><code class="lang-shell">F:\worksp\ruby&gt;irb
&lt;elcome to our site\./.match('Does Hello, welcome to our site.')
=&gt; #&lt;MatchData "Hello, welcome to our site."&gt;
irb(main):003:0&gt; /2 \* 2 \+ 3 \- 1 = \?/.match('Does 2 * 2 + 3 - 1 = ?')
=&gt; #&lt;MatchData "2 * 2 + 3 - 1 = ?"&gt;
irb(main):004:0&gt; /2 * 2 + 3 - 1 = ?/.match('Does 2 * 2 + 3 - 1 = ?')
=&gt; nil
irb(main):005:0&gt;
</code></pre> 
 <h2 id="h2-u5B57u7B26u7C7B"><a name="字符类" class="reference-link"></a><span class="header-link octicon octicon-link"></span>字符类</h2>
 <p>元字符在模式中具有特定含义。 要匹配一个字符串，它们将被转回(<code>\</code>)或转义。</p> 
 <p>一个字符类被包围在方括号内。</p> 
 <p><strong>[ab]</strong></p> 
 <p>这里，<code>[ab]</code>表示<code>a</code>或<code>b</code>。 与<code>/ab/</code>相反，它表示<code>a</code>和<code>b</code>。</p> 
 <p><strong>示例</strong></p> 
 <pre><code class="lang-shell">F:\worksp\ruby&gt;irb
irb(main):001:0&gt; /j[afdvs]av/.match('java')
=&gt; nil
irb(main):002:0&gt; /j[afdvs]va/.match('java')
=&gt; #&lt;MatchData "java"&gt;
irb(main):003:0&gt; /j[afdvs]va/.match('jpva')
=&gt; nil
irb(main):004:0&gt;
</code></pre> 
 <p><strong>[a-d]</strong></p> 
 <p>这里，<code>[a-d]</code>等同于<code>[abcd]</code>。 连字符(<code>-</code> )字符类表示字符的范围。</p> 
 <p><strong>示例</strong></p> 
 <pre><code class="lang-shell">F:\worksp\ruby&gt;irb
irb(main):001:0&gt; /[a-ge-p]/.match('go')
=&gt; #&lt;MatchData "g"&gt;
irb(main):002:0&gt; /[a-fe-p]/.match('go')
=&gt; #&lt;MatchData "g"&gt;
irb(main):003:0&gt;
</code></pre> 
 <p><strong>[^a-d]</strong></p> 
 <p><code>^</code>符号表示范围中不存在的任何其他字符。</p> 
 <p><strong>示例</strong></p>   
 <pre><code class="lang-ruby">F:\worksp\ruby&gt;irb
irb(main):001:0&gt; /[^a-ge-p]/.match('go')
=&gt; nil
irb(main):002:0&gt; /[^a-ge-n]/.match('go')
=&gt; #&lt;MatchData "o"&gt;
irb(main):003:0&gt; /[^a-fe-n]/.match('go')
=&gt; #&lt;MatchData "o"&gt;
irb(main):004:0&gt; /[^a-fh-n]/.match('go')
=&gt; #&lt;MatchData "g"&gt;
irb(main):005:0&gt;
</code></pre> 
 <h2 id="h2-u91CDu590D"><a name="重复" class="reference-link"></a><span class="header-link octicon octicon-link"></span>重复</h2>
 <p>现在定义的字符与单个字符匹配。在重复元字符的帮助下，可以指定需要发生的次数。 这些元字符称为量词。</p> 
 <ul> 
  <li><code>*</code> : 零次或多次</li>
  <li><code>+</code> : 一次或多次</li>
  <li><code>?</code> : 零次或一次(可选)</li>
  <li><code>{n}</code> : 正好<code>n</code>次</li>
  <li><code>{n, }</code>: <code>n</code>次以上</li>
  <li><code>{,m}</code> : <code>m</code>次以下</li>
  <li><code>{n,m}</code> : 至少<code>n</code>和最多<code>m</code>次</li>
 </ul> 
 <p><strong>实例</strong></p> 
 <pre><code class="lang-shell">irb(main):006:0&gt; "SSSIT".match(/S{3}+[[:upper:]]+[[:upper:]]/)
=&gt; #&lt;MatchData "SSSIT"&gt;
irb(main):007:0&gt;
irb(main):008:0*
irb(main):009:0* "yiiBaicom".match(/[[:lower:]]+[[:upper:]]+com/)
=&gt; nil
irb(main):010:0&gt; "yiiBAIcom".match(/[[:lower:]]+[[:upper:]]+com/)
=&gt; #&lt;MatchData "yiiBAIcom"&gt;
irb(main):011:0&gt;
</code></pre> 
 <h2 id="h2-u5206u7EC4"><a name="分组" class="reference-link"></a><span class="header-link octicon octicon-link"></span>分组</h2>
 <p>分组使用括号将项目组合在一起。将这些术语分组成一个。</p> 
 <p>示例：</p> 
 <pre><code class="lang-shell">F:\worksp\ruby&gt;irb
irb(main):001:0&gt; /[aeiou]\w{2}/.match('family')
=&gt; #&lt;MatchData "ami"&gt;
irb(main):003:0&gt; /([aeiou]\w){2}/.match('family')
=&gt; #&lt;MatchData "amil" 1:"il"&gt;
irb(main):004:0&gt;
</code></pre> 
 <p>在这个例子中，第一个模式匹配一个元音，后跟两个字符。</p> 
 <p>在第二种模式中，它匹配一个元音后跟一个字符，两次。</p> 
 <p><strong>(?:..)</strong></p> 
 <p>此表达式提供分组而不捕获。 它结合术语而不创建反向引用。</p> 
 <p>示例：</p> 
 <pre><code class="lang-shell">irb(main):006:0&gt; /I(n)(de)pen\2\1tly/.match('independently')
=&gt; nil
irb(main):007:0&gt; /i(n)(de)pen\2\1tly/.match('independently')
=&gt; #&lt;MatchData "independently" 1:"n" 2:"de"&gt;
irb(main):009:0&gt; /i(?:n)(de)pen\1ntly/.match('independently')
=&gt; #&lt;MatchData "independently" 1:"de"&gt;
irb(main):010:0&gt;
</code></pre>
 <br>      
</div></body></html>