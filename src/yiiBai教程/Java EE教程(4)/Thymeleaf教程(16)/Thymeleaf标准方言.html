<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Thymeleaf标准方言</h1><div style="width:100%;float:left;" class="article-content">   
 <p>本节将带您了解一些最重要的概念，以了解以标准或SpringStandard方言编写的Thymeleaf模板。</p> 
 <h2 id="h2-1-"><a name="1. 什么是标准方言？" class="reference-link"></a><span class="header-link octicon octicon-link"></span>1. 什么是标准方言？</h2>
 <p>Thymeleaf是非常非常可扩展的，它允许自定义的名字来定义一组模板属性(或者甚至是标签)，用自定语法评估计算表达式和应用逻辑。它更像是一个模板引擎框架。</p> 
 <p>它还带有一些称为标准方言(称为<em>Standard</em>和<em>SpringStandard</em>)的东西，它们定义了一组功能，这些功能应该足以满足大多数情况。可以识别这些标准方言在模板中的使用，因为它将包含以<code>th</code>前缀开头的属性，如<code>&lt;span th:text="..."&gt;</code>。</p> 
 <p>请注意，<em>Standard</em>和<em>SpringStandard</em>方言几乎完全相同，只是<em>SpringStandard</em>包含了集成到Spring MVC应用程序中的特定功能(例如，使用Spring表达式语言进行表达式评估而不是OGNL)。</p> 
 <h2 id="h2-2-"><a name="2. 标准表达式语法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2. 标准表达式语法</h2>
 <p>大多数Thymeleaf属性允许将它们的值设置为或包含表达式，由于它们使用的方言，我们将其称为标准表达式。这些表达式可以有五种类型:</p> 
 <ul> 
  <li><code>${...}</code> : 变量表达式。</li>
  <li><code>*{...}</code> : 选择表达式。</li>
  <li><code>#{...}</code> : 消息 (i18n) 表达式。</li>
  <li><code>@{...}</code> : 链接 (URL) 表达式。</li>
  <li><code>~{...}</code> : 片段表达式。</li>
 </ul> 
 <h3 id="h3-2-1-"><a name="2.1 变量表达式" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2.1 变量表达式</h3>
 <p>变量表达式是OGNL表达式 - 如果将<em>Thymeleaf</em> 与<em>Spring</em> - 集成在上下文变量上(也称为Spring术语中的模型属性)，则为<em>Spring EL</em>。 它们看起来像这样:</p> 
 <pre><code class="lang-jsp">${session.user.name}
</code></pre> 
 <p>它们作为属性值或作为它们的一部分，取决于属性:</p> 
 <pre><code class="lang-jsp">&lt;span th:text="${book.author.name}"&gt;
</code></pre> 
 <p>上面的表达式与下面是相同的(在OGNL和SpringEL中):</p> 
 <pre><code class="lang-java">((Book)context.getVariable("book")).getAuthor().getName()
</code></pre> 
 <p>但是不仅在涉及输出的场景中找到变量表达式，而且还可以使用更复杂的处理方式，如:条件，迭代…等等。</p> 
 <pre><code class="lang-jsp">&lt;li th:each="book : ${books}"&gt;
</code></pre> 
 <p>这里<code>${books}</code>从上下文中选择名为<code>books</code>的变量，并在<code>th:each</code>中使用循环将其评估为迭代器。</p> 
 <h3 id="h3-2-2-"><a name="2.2 选择表达式" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2.2 选择表达式</h3>
 <p>选择表达式就像变量表达式一样，它们不是整个上下文变量映射上执行，而是在先前选择的对象。 它们看起来像这样:</p> 
 <pre><code class="lang-jsp">*{customer.name}
</code></pre> 
 <p>它们所作用的对象由<code>th:object</code>属性指定:</p> 
 <pre><code class="lang-jsp">&lt;div th:object="${book}"&gt;
  ...
  &lt;span th:text="*{title}"&gt;...&lt;/span&gt;
  ...
&lt;/div&gt;
</code></pre> 
 <p>所以这相当于:</p> 
 <pre><code class="lang-java">{
  // th:object="${book}"
  final Book selection = (Book) context.getVariable("book");
  // th:text="*{title}"
  output(selection.getTitle());
}
</code></pre> 
 <h3 id="h3-2-3-i18n-"><a name="2.3 消息(i18n)表达式" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2.3 消息(i18n)表达式</h3>
 <p>消息表达式(通常称为文本外部化，国际化或i18n)允许从外部源(如:<code>.properties</code>)文件中检索特定于语言环境的消息，通过键来引用这引用消息。</p> 
 <p>在Spring应用程序中，它将自动与Spring的MessageSource机制集成。如下 - </p> 
 <pre><code>#{main.title}
#{message.entrycreated(${entryId})}
</code></pre>
 <p>以下是在模板中使用它们的方式:</p> 
 <pre><code class="lang-html">&lt;table&gt;
  ...
  &lt;th th:text="#{header.address.city}"&gt;...&lt;/th&gt;
  &lt;th th:text="#{header.address.country}"&gt;...&lt;/th&gt;
  ...
&lt;/table&gt;
</code></pre> 
 <p>请注意，如果希望消息键由上下文变量的值确定，或者希望将变量指定为参数，则可以在消息表达式中使用变量表达式:</p> 
 <pre><code class="lang-jsp">#{${config.adminWelcomeKey}(${session.user.name})}
</code></pre> 
 <h3 id="h3-2-4-url-"><a name="2.4 链接(URL)表达式" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2.4 链接(URL)表达式</h3>
 <p>链接表达式在构建URL并向其添加有用的上下文和会话信息(通常称为URL重写的过程)。<br>因此，对于部署在Web服务器的<code>/myapp</code>上下文中的Web应用程序，可以使用以下表达式:</p> 
 <pre><code class="lang-jsp">&lt;a th:href="@{/order/list}"&gt;...&lt;/a&gt;
</code></pre> 
 <p>可以转换成如下的东西:</p> 
 <pre><code class="lang-jsp">&lt;a href="/myapp/order/list"&gt;...&lt;/a&gt;
</code></pre> 
 <p>甚至，如果需要保持会话，并且cookie未启用(或者服务器还不知道)，那么生成的格式为:</p> 
 <pre><code class="lang-html">&lt;a href="/myapp/order/list;jsessionid=s2ds3fa31abd241e2a01932"&gt;...&lt;/a&gt;
</code></pre> 
 <p>网址也可以带参数，如下所示:</p> 
 <pre><code class="lang-jsp">&lt;a th:href="@{/order/details(id=${orderId},type=${orderType})}"&gt;...&lt;/a&gt;
</code></pre> 
 <p>这将产生类似以下的结果 - </p> 
 <pre><code class="lang-html">&lt;!-- 注意＆符号会在标签属性中进行HTML转义... --&gt;
&lt;a href="/myapp/order/details?id=23&amp;type=online"&gt;...&lt;/a&gt;
</code></pre> 
 <p>链接表达式可以是相对的，在这种情况下，应用程序上下文将不会被加到URL的前面:</p> 
 <pre><code class="lang-jsp">&lt;a th:href="@{../documents/report}"&gt;...&lt;/a&gt;
</code></pre> 
 <p>也是服务器相对的(同样，没有应用程序上下文的前缀):</p> 
 <pre><code class="lang-html">&lt;a th:href="@{~/contents/main}"&gt;...&lt;/a&gt;
</code></pre> 
 <p>和协议相关(就像绝对URL一样，但浏览器将使用与正在显示的页面相同的HTTP或HTTPS协议):</p> 
 <pre><code class="lang-html">&lt;a th:href="@{//static.mycompany.com/res/initial}"&gt;...&lt;/a&gt;
</code></pre> 
 <p>当然，链接表达式也可以是绝对的:</p> 
 <pre><code class="lang-html">&lt;a th:href="@{http://www.mycompany.com/main}"&gt;...&lt;/a&gt;
</code></pre> 
 <p>但是绝对(或协议相对)URL ，在Thymeleaf链接表达式中应该添加什么值？ 很简单:由响应过滤器定义URL重写:在基于Servlet的Web应用程序中，对于每个输出的URL(上下文相对，相对，绝对…)，在显示URL之前，Thymeleaf总是调用<code>HttpServletResponse.encodeUrl(...)</code>机制。 这意味着一个过滤器可以通过包装HttpServletResponse对象来为应用程序执行自定义的URL重写。</p> 
 <h3 id="h3-2-5-"><a name="2.5 片段表达式" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2.5 片段表达式</h3>
 <p>片段表达式是一种简单的方法用来表示标记的片段并将其移动到模板中。 由于这些表达式，片段可以被复制，传递给其他模板的参数等等。</p> 
 <p>最常见的是使用<code>th:insert</code>或<code>th:replace</code>来插入片段:</p>   
 <pre><code class="lang-html">&lt;div th:insert="~{commons :: main}"&gt;...&lt;/div&gt;
</code></pre> 
 <p>但是它们可以在任何地方使用，就像任何其他变量一样:</p> 
 <pre><code class="lang-jsp">&lt;div th:with="frag=~{footer :: #main/text()}"&gt;
  &lt;p th:insert="${frag}"&gt;
&lt;/div&gt;
</code></pre> 
 <p>片段表达式可以有参数。</p> 
 <h3 id="h3-2-6-"><a name="2.6 文字和操作" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2.6 文字和操作</h3>
 <p>有很多类型的文字和操作可用，它们分别如下:</p> 
 <ul> 
  <li><p>文字</p> 
   <ul> 
    <li>文本文字，例如:<code>'one text'</code>, <code>'Another one!'</code>,<code>…</code></li>
    <li>数字文字，例如:<code>0</code>,<code>10</code>, <code>314</code>, <code>31.01</code>, <code>112.83</code>,<code>…</code></li>
    <li>布尔文字，例如:<code>true</code>,<code>false</code></li>
    <li>Null文字，例如:<code>Null</code></li>
    <li>文字标记，例如:<code>one</code>, <code>sometext</code>, <code>main</code>,<code>…</code></li>
   </ul> </li>
  <li><p>文本操作:</p> 
   <ul> 
    <li>字符串连接:<code>+</code></li>
    <li>文字替换:<code>|The name is ${name}|</code></li>
   </ul> </li>
  <li><p>算术运算:</p> 
   <ul> 
    <li>二进制操作:<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></li>
    <li>减号(一元运算符):<code>-</code></li>
   </ul> </li>
  <li><p>布尔运算:</p> 
   <ul> 
    <li>二进制运算符，<code>and</code>,<code>or</code></li>
    <li>布尔否定(一元运算符):<code>!</code>,<code>not</code></li>
   </ul> </li>
  <li><p>比较和相等:</p> 
   <ul> 
    <li>比较运算符:<code>&gt;</code>,<code>&lt;</code>,<code>&gt;=</code>,<code>&lt;=</code>(<code>gt</code>,<code>lt</code>,<code>ge</code>,<code>le</code>)</li>
    <li>相等运算符:<code>==</code>, <code>!=</code> (<code>eq</code>, <code>ne</code>)</li>
   </ul> </li>
  <li><p>条件操作符:</p> 
   <ul> 
    <li>If-then:<code>(if) ? (then)</code></li>
    <li>If-then-else:<code>(if) ? (then) : (else)</code></li>
    <li>Default: <code>(value) ?: (defaultvalue)</code></li>
   </ul> </li>
 </ul> 
 <h2 id="h2-2-7-"><a name="2.7 表达式预处理" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2.7 表达式预处理</h2>
 <p>关于表达式的最后一件事是知道表达式预处理，在<code>__</code>之间指定，如下所示:</p> 
 <pre><code class="lang-jsp">#{selection.__${sel.code}__}
</code></pre> 
 <p>上面代码中，第一个被执行的变量表达式是:<code>${sel.code}</code>，并且将使用它的结果作为表达式的一部分(假设<code>${sel.code}</code>的结果为:<code>ALL</code>)，在此处执行国际化的情况下(这将查找与关键<code>selection.ALL</code>消息)。</p> 
 <h2 id="h2-3-"><a name="3. 基本的属性" class="reference-link"></a><span class="header-link octicon octicon-link"></span>3. 基本的属性</h2>
 <p>下面来看看标准方言中的几个最基本的属性。 从<code>th:</code>文本开始，它代替了标签的主体:</p> 
 <pre><code class="lang-jsp">&lt;p th:text="#{msg.welcome}"&gt;Welcome everyone!&lt;/p&gt;
</code></pre> 
 <p>现在，<code>th:each</code>重复它所在元素的次数，由它的表达式返回的数组或列表所指定的次数，为迭代元素创建一个内部变量，其语法与Java的foreach表达式相同:</p> 
 <pre><code class="lang-html">&lt;li th:each="book : ${books}" th:text="${book.title}"&gt;En las Orillas del Sar&lt;/li&gt;
</code></pre> 
 <p>最后，Thymeleaf为特定的XHTML和HTML5属性提供了许多<code>th</code>属性，这些属性只评估它们的表达式，并将这些属性的值设置为结果。</p> 
 <pre><code class="lang-html">&lt;form th:action="@{/createOrder}"&gt;
&lt;input type="button" th:value="#{form.submit}" /&gt;
&lt;a th:href="@{/admin/users}"&gt;
</code></pre>
 <br>      
</div></body></html>