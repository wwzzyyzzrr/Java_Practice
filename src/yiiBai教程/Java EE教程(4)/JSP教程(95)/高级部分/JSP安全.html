<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">JSP安全</h1><div style="width:100%;float:left;" class="article-content">   
 <p>在JSP和servlet开发的应用程序中，Web开发人员可以使用几种机制来保护应用程序。资源通过在应用程序部署描述符中标识它们并向其分配角色来以声明方式进行保护。</p> 
 <p>有几个级别的身份验证可用，从使用标识符和密码的基本身份验证到使用证书的复杂身份验证。</p> 
 <h2 id="h2-u57FAu4E8Eu89D2u8272u7684u8BA4u8BC1"><a name="基于角色的认证" class="reference-link"></a><span class="header-link octicon octicon-link"></span>基于角色的认证</h2>
 <p>servlet规范中的认证机制使用了一种称为基于角色的安全性技术。这个做法是，不是在用户级别限制资源，而是创建角色并通过角色限制资源。</p> 
 <p>可以在文件<code>tomcat-users.xml</code>中定义不同的角色，<code>tomcat-users.xml</code>位于Tomcat的主目录<code>conf</code>中。此文件的示例如下所示 -</p> 
 <pre><code class="lang-xml">&lt;?xml version = '1.0' encoding = 'utf-8'?&gt;
&lt;tomcat-users&gt;
   &lt;role rolename = "tomcat"/&gt;
   &lt;role rolename = "role1"/&gt;
   &lt;role rolename = "manager"/&gt;
   &lt;role rolename = "admin"/&gt;
   &lt;user username = "tomcat" password = "tomcat" roles = "tomcat"/&gt;
   &lt;user username = "role1" password = "tomcat" roles = "role1"/&gt;
   &lt;user username = "both" password = "tomcat" roles = "tomcat,role1"/&gt;
   &lt;user username = "admin" password = "secret" roles = "admin,manager"/&gt;
&lt;/tomcat-users&gt;
</code></pre> 
 <p>此文件定义了用户名，密码和角色之间的简单映射。请注意，给定的用户可能有多个角色; 例如，<code>username =“both”</code>有两个角色：<code>“tomcat”</code>角色和<code>“role1”</code>角色。</p> 
 <p>当确定并定义了不同的角色，就可以通过使用<code>WEB-INF</code>目录中<code>web.xml</code>文件中的<code>&lt;security-constraint&gt;</code>元素，将基于角色的安全限制放在不同的Web应用程序资源上。</p> 
 <p>以下是<em>web.xml</em>中的示例元素项 -</p> 
 <pre><code class="lang-xml">&lt;web-app&gt;
   ...
   &lt;security-constraint&gt;
      &lt;web-resource-collection&gt;
         &lt;web-resource-name&gt;SecuredBookSite&lt;/web-resource-name&gt;
         &lt;url-pattern&gt;/secured/*&lt;/url-pattern&gt;
         &lt;http-method&gt;GET&lt;/http-method&gt;
         &lt;http-method&gt;POST&lt;/http-method&gt;
      &lt;/web-resource-collection&gt;

      &lt;auth-constraint&gt;
         &lt;description&gt;
            Let only managers use this app
         &lt;/description&gt;
         &lt;role-name&gt;manager&lt;/role-name&gt;
      &lt;/auth-constraint&gt;
   &lt;/security-constraint&gt;

   &lt;security-role&gt;
      &lt;role-name&gt;manager&lt;/role-name&gt;
   &lt;/security-role&gt;

   &lt;login-config&gt;
      &lt;auth-method&gt;BASIC&lt;/auth-method&gt;
   &lt;/login-config&gt;
   ...
&lt;/web-app&gt;
</code></pre> 
 <p>以上元素项将意味着 - </p> 
 <ul> 
  <li>对与<code>/secured/*</code>匹配的URL的任何HTTP GET或POST请求将受到安全限制。</li>
  <li>具有<code>manager</code>角色的人员可获得安全资源。</li>
  <li><code>login-config</code>元素用于描述BASIC认证形式。</li>
 </ul> 
 <p>如果尝试浏览包含<code>/security</code>目录的任何URL，将显示以下对话框，要求输入用户名和密码。 如果提供了用户：<code>admin</code>和密码：<code>secrer</code>，那么可以访问与<code>/secured/*</code>匹配的URL，因为我们已将用户管理员定义为允许访问该资源的<code>manager</code>角色。</p> 
 <h2 id="h2-u57FAu4E8Eu8868u5355u7684u8BA4u8BC1"><a name="基于表单的认证" class="reference-link"></a><span class="header-link octicon octicon-link"></span>基于表单的认证</h2>
 <p>使用表单身份验证方法时，必须提供登录表单以提示用户输入用户名和密码。 以下是<code>login.jsp</code>的简单代码。 这有助于为同一目的创建一个表单 -</p> 
 <pre><code class="lang-html">&lt;html&gt;
   &lt;body bgcolor = "#ffffff"&gt;

      &lt;form method = "POST" action ="j_security_check"&gt;
         &lt;table border = "0"&gt;
            &lt;tr&gt;
               &lt;td&gt;Login&lt;/td&gt;
               &lt;td&gt;&lt;input type = "text" name="j_username"&gt;&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
               &lt;td&gt;Password&lt;/td&gt;
               &lt;td&gt;&lt;input type = "password" name="j_password"&gt;&lt;/td&gt;
            &lt;/tr&gt;
         &lt;/table&gt;
         &lt;input type = "submit" value = "Login!"&gt;

      &lt;/form&gt;

   &lt;/body&gt;
&lt;/html&gt;
</code></pre> 
 <p>在这里，必须确保登录表单中有包含名为：<code>j_username</code>和<code>j_password</code>的表单元素。 <code>&lt;form&gt;</code>标签中的操作必须是<code>j_security_check</code>。必须用作表单方法： <code>POST</code>。 同时，还需要修改<code>&lt;login-config&gt;</code>标签，将<code>auth-method</code>指定为<code>FORM</code> -</p> 
 <pre><code class="lang-xml">&lt;web-app&gt;
   ...
   &lt;security-constraint&gt;
      &lt;web-resource-collection&gt;
         &lt;web-resource-name&gt;SecuredBookSite&lt;/web-resource-name&gt;
         &lt;url-pattern&gt;/secured/*&lt;/url-pattern&gt;
            &lt;http-method&gt;GET&lt;/http-method&gt;
            &lt;http-method&gt;POST&lt;/http-method&gt;
      &lt;/web-resource-collection&gt;

      &lt;auth-constraint&gt;
         &lt;description&gt;Let only managers use this app&lt;/description&gt;
         &lt;role-name&gt;manager&lt;/role-name&gt;
      &lt;/auth-constraint&gt;
   &lt;/security-constraint&gt;

   &lt;security-role&gt;
      &lt;role-name&gt;manager&lt;/role-name&gt;
   &lt;/security-role&gt;

   &lt;login-config&gt;
      &lt;auth-method&gt;FORM&lt;/auth-method&gt;
      &lt;form-login-config&gt;
         &lt;form-login-page&gt;/login.jsp&lt;/form-login-page&gt;
         &lt;form-error-page&gt;/error.jsp&lt;/form-error-page&gt;
      &lt;/form-login-config&gt;
   &lt;/login-config&gt;
   ...
&lt;/web-app&gt;
</code></pre> 
 <p>现在当尝试访问URL <code>/secured/*</code>任何资源时，将显示上述表单，询问用户ID和密码。 当容器看到<code>j_security_check</code>操作时，它使用一些内部机制来认证调用者。</p> 
 <p>如果登录成功并且呼叫者被授权访问受保护的资源，则容器使用会话ID从该点起为调用者标识登录会话。容器使用包含<code>session-id</code>的cookie维护登录会话。 服务器将cookie发送回客户端，只要主调用方后续请求者提供该cookie，容器将知道调用者是谁。</p> 
 <p>如果登录失败，则服务器返回通过表单错误页面设置标识的页面</p> 
 <p>这里，<code>j_security_check</code>是使用表单登录的应用程序必须为登录表单指定的操作。 同样的形式，还应该有一个名为<code>j_username</code>的文本输入控件和一个名为<code>j_password</code>的密码输入控件。当看到这个，这意味着表单中包含的信息将被提交到服务器，这将检查名称和密码。 这是如何完成的是服务器特定的。</p> 
 <p>检查标准领域实现，以了解<code>j_security_check</code>如何用于Tomcat容器。</p> 
 <h2 id="h2-servlet-jsp-"><a name="Servlet/JSP中的程序安全性" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Servlet/JSP中的程序安全性</h2>
 <p><code>HttpServletRequest</code>对象提供以下方法，可用于在运行时挖掘安全信息 -</p> 
 <table> 
  <thead> 
   <tr> 
    <th>编号</th> 
    <th>方法</th> 
    <th>描述</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>1</td> 
    <td><code>String getAuthType()</code></td> 
    <td><code>getAuthType()</code>方法返回一个<code>String</code>对象，该对象表示用于保护Servlet的认证方案的名称。</td> 
   </tr> 
   <tr> 
    <td>2</td> 
    <td><code>boolean isUserInRole(java.lang.String role)</code></td> 
    <td><code>isUserInRole()</code>方法返回一个布尔值：如果用户处于给定角色，则返回<code>true</code>，否则返回<code>false</code>。</td> 
   </tr> 
   <tr> 
    <td>3</td> 
    <td><code>String getProtocol()</code></td> 
    <td><code>getProtocol()</code>方法返回一个String对象，表示用于发送请求的协议。可以检查该值以确定是否使用安全协议。</td> 
   </tr> 
   <tr> 
    <td>4</td> 
    <td><code>boolean isSecure()</code></td> 
    <td><code>isSecure()</code>方法返回一个布尔值，表示是否使用HTTPS进行请求。值设置为<code>true</code>意味着它是和连接是安全的。 值设置为<code>false</code>表示请求不是安全的。</td> 
   </tr> 
   <tr> 
    <td>5</td> 
    <td><code>Principle getUserPrinciple()</code></td> 
    <td><code>getUserPrinciple()</code>方法返回一个<code>java.security.Principle</code>对象，该对象包含当前已验证用户的名称。</td> 
   </tr> 
  </tbody> 
 </table> 
 <p>例如，对于链接到管理员的页面的JSP，可以使用以下代码 -</p>   
 <pre><code class="lang-html">&lt;% if (request.isUserInRole("manager")) { %&gt;
   &lt;a href = "managers/mgrreport.jsp"&gt;Manager Report&lt;/a&gt;
   &lt;a href = "managers/personnel.jsp"&gt;Personnel Records&lt;/a&gt;
&lt;% } %&gt;
</code></pre> 
 <p>通过检查用户在JSP或Servlet中的角色，可以自定义该页面，仅向用户显示可以访问的项目。 如果需要在认证表单中输入用户名，可以在请求对象中调用<code>getRemoteUser()</code>方法。</p>
 <br>      
</div></body></html>