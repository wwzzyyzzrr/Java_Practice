<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">MongoDB聚合</h1><div style="width:100%;float:left;" class="article-content">   
 <p>聚合操作处理数据记录并返回计算结果。 聚合操作将多个文档中的值组合在一起，并可对分组数据执行各种操作，以返回单个结果。 在SQL中的 <code>count(*)</code>与<code>group by</code>组合相当于mongodb 中的聚合功能。</p> 
 <h2 id="h2-aggregate-"><a name="aggregate()方法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>aggregate()方法</h2>
 <p>对于MongoDB中的聚合，应该使用<code>aggregate()</code>方法。</p> 
 <p><strong>语法</strong></p> 
 <p><code>aggregate()</code>方法的基本语法如下 -</p> 
 <pre><code class="lang-shell">&gt;db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)
</code></pre> 
 <p><strong>示例</strong></p> 
 <p>假设在集合中，有以下数据 -</p> 
 <pre><code class="lang-shell">db.article.insert([
{
   _id: 100,
   title: 'MongoDB Overview',
   description: 'MongoDB is no sql database',
   by_user: 'Maxsu',
   url: 'http://www.yiibai.com',
   tags: ['mongodb', 'database', 'NoSQL'],
   likes: 100
},
{
   _id: 101,
   title: 'NoSQL Overview', 
   description: 'No sql database is very fast',
   by_user: 'Maxsu',
   url: 'http://www.yiibai.com',
   tags: ['mongodb', 'database', 'NoSQL'],
   likes: 10
},
{
   _id: 102,
   title: 'Neo4j Overview', 
   description: 'Neo4j is no sql database',
   by_user: 'Kuber',
   url: 'http://www.neo4j.com',
   tags: ['neo4j', 'database', 'NoSQL'],
   likes: 750
},
{
   _id: 103,
   title: 'MySQL Overview', 
   description: 'MySQL is sql database',
   by_user: 'Curry',
   url: 'http://www.yiibai.com/mysql/',
   tags: ['MySQL', 'database', 'SQL'],
   likes: 350
}])
</code></pre> 
 <p>现在从上面的集合中，如果要显示一个列表，说明每个用户写入了多少个教程，那么可使用以下<code>aggregate()</code>方法 -</p> 
 <pre><code class="lang-shell">&gt; db.article.aggregate([{$group : {_id : "$by_user", num_tutorial : {$sum : 1}}}])
{ "_id" : "Curry", "num_tutorial" : 1 }
{ "_id" : "Kuber", "num_tutorial" : 1 }
{ "_id" : "Maxsu", "num_tutorial" : 2 }
&gt;
</code></pre> 
 <p>对于上述用例的Sql等效查询是：</p> 
 <pre><code class="lang-sql">select by_user, count(*) as num_tutorial from `article` group by by_user;
</code></pre> 
 <p>在上面的例子中，我们按字段<code>by_user</code>分组了文档，并且每次发生的<code>by_user</code>的前一个值的值都被递增。以下是可用聚合表达式的列表。</p> 
 <table> 
  <thead> 
   <tr> 
    <th>表达式</th> 
    <th>描述</th> 
    <th>示例</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td><code>$sum</code></td> 
    <td>从集合中的所有文档中求出定义的值。</td> 
    <td><code>db.mycol.aggregate([{$group : {_id : "$by_user", num_tutorial : {$sum : "$likes"}}}])</code></td> 
   </tr> 
   <tr> 
    <td><code>$avg</code></td> 
    <td>计算集合中所有文档的所有给定值的平均值。</td> 
    <td><code>db.mycol.aggregate([{$group : {_id : "$by_user", num_tutorial : {$avg : "$likes"}}}])</code></td> 
   </tr> 
   <tr> 
    <td><code>$min</code></td> 
    <td>从集合中的所有文档获取相应值的最小值。</td> 
    <td><code>db.mycol.aggregate([{$group : {_id : "$by_user", num_tutorial : {$min : "$likes"}}}])</code></td> 
   </tr> 
   <tr> 
    <td><code>$max</code></td> 
    <td>从集合中的所有文档获取相应值的最大值。</td> 
    <td><code>db.mycol.aggregate([{$group : {_id : "$by_user", num_tutorial : {$max : "$likes"}}}])</code></td> 
   </tr> 
   <tr> 
    <td><code>$push</code></td> 
    <td>将值插入到生成的文档中的数组中。</td> 
    <td><code>db.mycol.aggregate([{$group : {_id : "$by_user", url : {$push: "$url"}}}])</code></td> 
   </tr> 
   <tr> 
    <td><code>$addToSet</code></td> 
    <td>将值插入生成的文档中的数组，但不会创建重复项。</td> 
    <td><code>db.mycol.aggregate([{$group : {_id : "$by_user", url : {$addToSet : "$url"}}}])</code></td> 
   </tr> 
   <tr> 
    <td><code>$first</code></td> 
    <td>根据分组从源文档获取第一个文档。 通常情况下，这只适用于以前应用的“<code>$sort</code>”阶段。</td> 
    <td><code>db.mycol.aggregate([{$group : {_id : "$by_user", first_url : {$first : "$url"}}}])</code></td> 
   </tr> 
   <tr> 
    <td><code>$last</code></td> 
    <td>根据分组从源文档获取最后一个文档。通常情况下，这只适用于以前应用的“<code>$sort</code>”阶段。</td> 
    <td><code>db.mycol.aggregate([{$group : {_id : "$by_user", last_url : {$last : "$url"}}}])</code></td> 
   </tr> 
  </tbody> 
 </table> 
 <h2 id="h2-u7BA1u9053u6982u5FF5"><a name="管道概念" class="reference-link"></a><span class="header-link octicon octicon-link"></span>管道概念</h2>
 <p>在UNIX命令中，shell管道可以对某些输入执行操作，并将输出用作下一个命令的输入。 MongoDB也在聚合框架中支持类似的概念。每一组输出可作为另一组文档的输入，并生成一组生成的文档(或最终生成的JSON文档在管道的末尾)。这样就可以再次用于下一阶段等等。</p> 
 <p>以下是在聚合框架可能的阶段 -</p> 
 <ul> 
  <li><code>$project</code> - 用于从集合中选择一些特定字段。</li>
  <li><code>$match</code> - 这是一个过滤操作，因此可以减少作为下一阶段输入的文档数量。</li>
  <li><code>$group</code> - 这是上面讨论的实际聚合。</li>
  <li><code>$sort</code> - 排序文档。</li>
  <li><code>$skip</code> - 通过这种方式，可以在给定数量的文档的文档列表中向前跳过。</li>
  <li><code>$limit</code> - 限制从当前位置开始的给定数量的文档数量。</li>
  <li><code>$unwind</code> - 用于展开正在使用数组的文档。使用数组时，数据是预先加入的，此操作将被撤销，以便再次单独使用文档。 因此，在这个阶段，将增加下一阶段的文件数量。</li>
 </ul>
 <br>      
</div></body></html>