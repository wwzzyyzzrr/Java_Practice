<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Python连接MongoDB操作</h1><div style="width:100%;float:left;" class="article-content">   
 <p>本教程的目的是介绍如何使用Python连接MongoDB数据库，并通过PyMongo操作MongoDB数据库。</p> 
 <h2 id="h2-1-pymongo"><a name="1.安装PyMongo" class="reference-link"></a><span class="header-link octicon octicon-link"></span>1.安装PyMongo</h2>
 <blockquote> 
  <p>注意：请勿安装“bson”软件包。 PyMongo配有自己的bson包; 执行“<code>pip install bson</code>”或“<code>easy_install bson</code>”则会安装与PyMongo不兼容的第三方软件包。</p> 
 </blockquote> 
 <p><strong>使用pip安装</strong></p> 
 <p>我们建议在所有平台上使用pip来安装pymongo：</p> 
 <pre><code class="lang-shell">C:\Users\Administrator&gt;python -m pip install pymongo
Collecting pymongo
  Downloading pymongo-3.4.0.tar.gz (583kB)
... ....
Installing collected packages: pymongo
  Running setup.py install for pymongo ... done
Successfully installed pymongo-3.4.0
</code></pre> 
 <p>要获得pymongo的特定版本：</p> 
 <pre><code class="lang-shell">$ python -m pip install pymongo==3.1.1
</code></pre> 
 <p>要升级pymongo的版本：</p> 
 <pre><code class="lang-shell">$ python -m pip install --upgrade pymongo
</code></pre> 
 <p><strong>Python版本依赖</strong></p> 
 <p>PyMongo支持CPython 2.6,2.7,3.3+，PyPy和PyPy3。</p> 
 <p>GSSAPI和TLS的可选依赖关系：</p> 
 <p>GSSAPI认证需要Windows上的Unix或WinKerberos上的pykerberos。PyMongo可以自动安装正确的依赖关系：</p> 
 <pre><code class="lang-shell">$ python -m pip install pymongo[gssapi]
</code></pre> 
 <h2 id="h2-2-mongoclient-"><a name="2.使用MongoClient建立连接" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2.使用MongoClient建立连接</h2>
 <p>使用PyMongo时，第一步是运行 mongod 实例创建一个MongoClient。如下：</p> 
 <pre><code class="lang-python">from pymongo import MongoClient
client = MongoClient()
</code></pre> 
 <p>上述代码将连接默认主机和端口。 也可以明确指定主机和端口，如下所示：</p> 
 <pre><code class="lang-python">from pymongo import MongoClient
#client = MongoClient()
client = MongoClient('localhost', 27017)
</code></pre> 
 <p>或使用MongoDB URI格式：</p> 
 <pre><code class="lang-python">client = MongoClient('mongodb://localhost:27017/')
</code></pre> 
 <h2 id="h2-3-"><a name="3.获取数据库" class="reference-link"></a><span class="header-link octicon octicon-link"></span>3.获取数据库</h2>
 <p>MongoDB的一个实例可以支持多个独立的数据库。 在使用PyMongo时，可以使用MongoClient实例上的属性的方式来访问数据库：</p> 
 <pre><code class="lang-python">db = client.pythondb
</code></pre> 
 <p>如果数据库名称使用属性方式访问无法正常工作(如：<code>python-db</code>)，则可以使用字典样式访问：</p> 
 <pre><code class="lang-python">db = client['python-db']
</code></pre> 
 <h2 id="h2-4-"><a name="4.获取集合" class="reference-link"></a><span class="header-link octicon octicon-link"></span>4.获取集合</h2>
 <p>集合是存储在MongoDB中的一组文档，可以类似于关系数据库中的表。 在PyMongo中获取集合的工作方式与获取数据库相同：</p> 
 <pre><code class="lang-shell">collection = db.python_collection
</code></pre> 
 <p>或(使用字典方式访问)：</p> 
 <pre><code class="lang-shell">collection = db['python-collection']
</code></pre> 
 <p>MongoDB中关于集合(和数据库)的一个重要注意事项是它们是懒创建的 - 上述任何命令都没有在MongoDB服务器上实际执行任何操作。当第一个文档插入集合时才创建集合和数据库。</p> 
 <p>集合是存储在MongoDB中的一组文档，可以被认为大致相当于关系数据库中的表。 在PyMongo中获取集合的工作方式与获取数据库相同：</p> 
 <h2 id="h2-5-"><a name="5.文档" class="reference-link"></a><span class="header-link octicon octicon-link"></span>5.文档</h2>
 <p>MongoDB中的数据使用JSON方式来表示文档(并存储)。 在PyMongo中使用字典来表示文档。例如，以下字典可能用于表示博客文章：</p> 
 <pre><code class="lang-python">import datetime
from pymongo import MongoClient
client = MongoClient()

post = {"author": "Mike",
         "text": "My first blog post!",
         "tags": ["mongodb", "python", "pymongo"],
         "date": datetime.datetime.utcnow()}
`
</code></pre> 
 <h2 id="h2-6-"><a name="6.插入文档" class="reference-link"></a><span class="header-link octicon octicon-link"></span>6.插入文档</h2>
 <p>要将文档插入到集合中，可以使用<code>insert_one()</code>方法：</p> 
 <pre><code class="lang-python">#!/usr/bin/python3
#coding=utf-8

import datetime
from pymongo import MongoClient
client = MongoClient()

db = client.pythondb

post = {"author": "Maxsu",
         "text": "My first blog post!",
         "tags": ["mongodb", "python", "pymongo"],
         "date": datetime.datetime.utcnow()}

posts = db.posts
post_id = posts.insert_one(post).inserted_id
print ("post id is ", post_id)
</code></pre> 
 <p>执行上面代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">post id is  595965fe4959eb09c4451091
</code></pre> 
 <p>插入文档时，如果文档尚未包含“<code>_id</code>”键，则会自动添加“<code>_id</code>”。 “<code>_id</code>”的值在集合中必须是唯一的。 <code>insert_one()</code>返回一个<code>InsertOneResult</code>的实例。 有关“<code>_id</code>”的更多信息，请参阅<a target="_blank" href="http://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.insert_one" title="有关_id文档">有关_id文档</a>。</p> 
 <p>插入第一个文档后，实际上已经在服务器上创建了帖子(<code>posts</code>)集合。可以列出数据库中的所有集合：</p> 
 <pre><code class="lang-python">#!/usr/bin/python3
#coding=utf-8

import datetime
from pymongo import MongoClient
client = MongoClient()

db = client.pythondb

"""
post = {"author": "Maxsu",
         "text": "My first blog post!",
         "tags": ["mongodb", "python", "pymongo"],
         "date": datetime.datetime.utcnow()}

posts = db.posts
post_id = posts.insert_one(post).inserted_id
print ("post id is ", post_id)
"""
cur_collection = db.collection_names(include_system_collections=False)

print("cur_collection is :", cur_collection)
</code></pre> 
 <p>执行上面代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">cur_collection is : ['posts']
</code></pre> 
 <h2 id="h2-7-find_one-"><a name="7.使用find_one()获取单个文档" class="reference-link"></a><span class="header-link octicon octicon-link"></span>7.使用find_one()获取单个文档</h2>
 <p>MongoDB中执行的最基本的查询类型是<code>find_one()</code>。 此方法返回与查询匹配的单个文档(如果没有匹配，则返回<code>None</code>)。 当知道只有一个匹配的文档，或只对第一个匹配感兴趣时则可考虑使用<code>find_one()</code>方法。下面示例中使用<code>find_one()</code>从帖子(<code>posts</code>)集中获取第一个文档：</p> 
 <pre><code class="lang-python">#!/usr/bin/python3
#coding=utf-8

import datetime
import pprint
from pymongo import MongoClient

client = MongoClient()

db = client.pythondb
'''
post = {"author": "Maxsu",
         "text": "My first blog post!",
         "tags": ["mongodb", "python", "pymongo"],
         "date": datetime.datetime.utcnow()}
'''
posts = db.posts
#post_id = posts.insert_one(post).inserted_id
#print ("post id is ", post_id)

pprint.pprint(posts.find_one())
</code></pre> 
 <p>执行上面代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">{'_id': ObjectId('595965fe4959eb09c4451091'),
 'author': 'Maxsu',
 'date': datetime.datetime(2017, 7, 2, 21, 30, 38, 402000),
 'tags': ['mongodb', 'python', 'pymongo'],
 'text': 'My first blog post!'}
</code></pre> 
 <p>结果是匹配之前插入的字典格式(Json)。注意: 返回的文档包含一个“<code>_id</code>”，它是在插入时自动添加的。</p> 
 <p><code>find_one()</code>方法还支持查询结果文档必须匹配的特定元素。要查询作者是“<code>Maxsu</code>”的文档，可以指定查询的条件，如下所示：</p> 
 <pre><code class="lang-python">#!/usr/bin/python3
#coding=utf-8

import datetime
import pprint
from pymongo import MongoClient

client = MongoClient()

db = client.pythondb
post = {"author": "Minsu",
         "text": "This blog post belong to Minsu!",
         "tags": ["MySQL", "Oracle", "pymongo"],
         "date": datetime.datetime.utcnow()}

posts = db.posts
post_id = posts.insert_one(post).inserted_id

post = posts.find_one({"author": "Maxsu"})
pprint.pprint(post)
#print (post)
</code></pre> 
 <p>执行上面代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">{'_id': ObjectId('595965fe4959eb09c4451091'),
 'author': 'Maxsu',
 'date': datetime.datetime(2017, 7, 2, 21, 30, 38, 402000),
 'tags': ['mongodb', 'python', 'pymongo'],
 'text': 'My first blog post!'}
</code></pre> 
 <h2 id="h2-8-objectid-"><a name="8.通过ObjectId查询" class="reference-link"></a><span class="header-link octicon octicon-link"></span>8.通过ObjectId查询</h2>
 <p>也可以通过它的<code>_id</code>找到一个帖子(<code>post</code>)，下面的示例子中演示如何根据给定的一个<code>ObjectId</code>查询数据：</p> 
 <pre><code class="lang-python">#!/usr/bin/python3
#coding=utf-8

import datetime
import pprint
from pymongo import MongoClient

client = MongoClient()

db = client.pythondb

post = {"_id": 100,
         "author": "Kuber",
         "text": "This is is my first post!",
         "tags": ["Docker", "Shell", "pymongo"],
         "date": datetime.datetime.utcnow()}

posts = db.posts
post_id = posts.insert_one(post).inserted_id

print("post_id is :", post_id)
post = posts.find_one({"_id": post_id})
print("Find By Post ID:")
pprint.pprint(post)
#print (post)
</code></pre> 
 <p>执行上面代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">post_id is : 100
Find By Post ID:
{'_id': 100,
 'author': 'Kuber',
 'date': datetime.datetime(2017, 7, 3, 14, 14, 8, 28000),
 'tags': ['Docker', 'Shell', 'pymongo'],
 'text': 'This is is my first post!'}
</code></pre> 
 <p>Web应用程序中的常见任务是从请求URL获取ObjectId并找到匹配的文档。 在这种情况下，必须将<code>ObjectId</code>从一个字符串转换到<code>find_one()</code>：</p> 
 <pre><code class="lang-python">from bson.objectid import ObjectId

# The web framework gets post_id from the URL and passes it as a string
def get(post_id):
    # Convert from string to ObjectId:
    document = client.db.collection.find_one({'_id': ObjectId(post_id)})
</code></pre> 
 <h2 id="h2-9-unicode-"><a name="9.关于Unicode字符串的注释" class="reference-link"></a><span class="header-link octicon octicon-link"></span>9.关于Unicode字符串的注释</h2>
 <p>您可能已经注意到，我们先前存储的常规Python字符串在从服务器检索时看起来是不同的(例如，u’Mike而不是“Mike”)。一个简短的解释是有序的字符串。</p> 
 <p>MongoDB以BSON格式存储数据。BSON字符串是UTF-8编码的，所以PyMongo必须确保它存储的任何字符串只包含有效的<code>UTF-8</code>数据。 常规字符串(<code>&lt;type'str'&gt;</code>)被验证并保存不变。 Unicode字符串(<code>&lt;type'unicode'&gt;</code>)首先被编码为<code>UTF-8</code>。 我们的示例字符串在Python shell中表示为<code>u'Mike</code>而不是<code>“Mike”</code>的原因是PyMongo将每个BSON字符串解码为Python <code>unicode</code>字符串，而不是常规str。</p> 
 <h2 id="h2-10-"><a name="10.批量插入" class="reference-link"></a><span class="header-link octicon octicon-link"></span>10.批量插入</h2>
 <p>为了执行更复杂一些的查询，我们再插入一些文档。 除了插入单个文档外，还可以通过将列表作为第一个参数传递给<code>insert_many()</code>来执行批量插入操作。 这将在列表中插入每个文档，只向服务器发送一个命令：</p>   
 <pre><code class="lang-python">#!/usr/bin/python3
#coding=utf-8

import datetime
import pprint
from pymongo import MongoClient

client = MongoClient()

db = client.pythondb

new_posts = [{"_id": 1000,
               "author": "Curry",
               "text": "Another post!",
               "tags": ["bulk", "insert"],
               "date": datetime.datetime(2017, 11, 12, 11, 14)},
              {"_id": 1001,"author": "Maxsu",
               "title": "MongoDB is fun",
               "text": "and pretty easy too!",
               "date": datetime.datetime(2019, 11, 10, 10, 45)}]

posts = db.posts
result = posts.insert_many(new_posts)
print("Bulk Inserts Result is :", result.inserted_ids)
#print (post)
</code></pre> 
 <p>执行上面代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">Bulk Inserts Result is : [1000, 1001]
</code></pre> 
 <p>有几个有趣的事情要注意这个例子：</p> 
 <ul> 
  <li><code>insert_many()</code>的结果现在返回两个<code>ObjectId</code>实例，每个ID表示插入的一个文档。</li>
  <li><code>new_posts[1]</code>具有与其他帖子不同的“形状”(数据结构) - 没有“<code>tags</code>”字段，添加了一个新字段“<code>title</code>”。MongoDB是无模式的，表示的就是这个意思。</li>
 </ul> 
 <h2 id="h2-11-"><a name="11.查询多个文档" class="reference-link"></a><span class="header-link octicon octicon-link"></span>11.查询多个文档</h2>
 <p>要查询获得超过单个文档作为查询的结果，可使用<code>find()</code>方法。<code>find()</code>返回一个<code>Cursor</code>实例，它允许遍历所有匹配的文档。如下示例，遍历帖子集合中的每个文档：</p> 
 <pre><code class="lang-python">#!/usr/bin/python3
#coding=utf-8

import datetime
import pprint
from pymongo import MongoClient

client = MongoClient()

db = client.pythondb

posts = db.posts
for post in posts.find():
    pprint.pprint(post)
</code></pre> 
 <p>执行上面代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">{'_id': ObjectId('595965fe4959eb09c4451091'),
 'author': 'Maxsu',
 'date': datetime.datetime(2017, 7, 2, 21, 30, 38, 402000),
 'tags': ['mongodb', 'python', 'pymongo'],
 'text': 'My first blog post!'}
{'_id': 100,
 'author': 'Kuber',
 'date': datetime.datetime(2017, 7, 3, 14, 14, 8, 28000),
 'tags': ['Docker', 'Shell', 'pymongo'],
 'text': 'This is is my first post!'}
{'_id': 1000,
 'author': 'Curry',
 'date': datetime.datetime(2017, 11, 12, 11, 14),
 'tags': ['bulk', 'insert'],
 'text': 'Another post!'}
{'_id': 1001,
 'author': 'Maxsu',
 'date': datetime.datetime(2019, 11, 10, 10, 45),
 'text': 'and pretty easy too!',
 'title': 'MongoDB is fun'}
</code></pre> 
 <p>类似使用<code>find_one()</code>一样，我们可以将文档传递给<code>find()</code>来限制返回的结果。 在这里，只希望得到作者是“Maxsu”的文档：</p> 
 <pre><code class="lang-python">#!/usr/bin/python3
#coding=utf-8

import datetime
import pprint
from pymongo import MongoClient

client = MongoClient()

db = client.pythondb

posts = db.posts
for post in posts.find({"author": "Maxsu"}):
    pprint.pprint(post)
</code></pre> 
 <p>执行上面的代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">{'_id': ObjectId('595965fe4959eb09c4451091'),
 'author': 'Maxsu',
 'date': datetime.datetime(2017, 7, 2, 21, 30, 38, 402000),
 'tags': ['mongodb', 'python', 'pymongo'],
 'text': 'My first blog post!'}
{'_id': 1001,
 'author': 'Maxsu',
 'date': datetime.datetime(2019, 11, 10, 10, 45),
 'text': 'and pretty easy too!',
 'title': 'MongoDB is fun'}
</code></pre> 
 <h2 id="h2-12-"><a name="12.计数统计" class="reference-link"></a><span class="header-link octicon octicon-link"></span>12.计数统计</h2>
 <p>如果只想知道有多少文档匹配查询，可以执行<code>count()</code>方法操作，而不是一个完整的查询。 可以得到一个集合中的所有文档的计数：</p> 
 <pre><code class="lang-python">#!/usr/bin/python3
#coding=utf-8

import datetime
import pprint
from pymongo import MongoClient

client = MongoClient()

db = client.pythondb
posts = db.posts

print("posts count is = ", posts.count())

print("posts's author is Maxsu count is =", posts.find({"author": "Maxsu"}).count())
</code></pre> 
 <p>执行上面代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">posts count is =  4
posts's author is Maxsu count is = 2
</code></pre> 
 <h2 id="h2-13-"><a name="13.范围查询" class="reference-link"></a><span class="header-link octicon octicon-link"></span>13.范围查询</h2>
 <p>MongoDB支持许多不同类型的高级查询。例如，可以执行一个查询，将结果限制在比特定日期更早的帖子，而且还可以按作者对结果进行排序：</p> 
 <pre><code class="lang-python">#!/usr/bin/python3
#coding=utf-8

import datetime
import pprint
from pymongo import MongoClient

client = MongoClient()

db = client.pythondb
posts = db.posts

d = datetime.datetime(2019, 11, 12, 12)
for post in posts.find({"date": {"$lt": d}}).sort("author"):
    pprint.pprint(post)
</code></pre> 
 <p>这里使用特殊的“<code>$lt</code>”运算符做范围查询，并且还可以调用<code>sort()</code>来按作者对结果进行排序。</p> 
 <h2 id="h2-14-"><a name="14.索引" class="reference-link"></a><span class="header-link octicon octicon-link"></span>14.索引</h2>
 <p>添加索引可以帮助加速某些查询，并且还可以添加额外的功能来查询和存储文档。在这个例子中，将演示如何在一个键上创建一个唯一的索引，该索引将拒绝已经存在值的文档插入。</p> 
 <p>首先，我们创建索引：</p> 
 <pre><code class="lang-python">result = db.profiles.create_index([('user_id', pymongo.ASCENDING)], unique=True)
sorted(list(db.profiles.index_information()))
</code></pre> 
 <p>请注意，现在有两个索引：一个是MongoDB自动创建的在<code>_id</code>索引，另一个是刚刚创建在<code>user_id</code>上的索引。</p> 
 <p>现在来设置一些用户配置文件：</p> 
 <pre><code class="lang-python">user_profiles = [{'user_id': 211, 'name': 'Luke'},{'user_id': 212, 'name': 'Ziltoid'}]
result = db.profiles.insert_many(user_profiles)
</code></pre> 
 <p>该索引将阻止 <code>user_id</code> 已经在集合中的文档插入：</p> 
 <pre><code class="lang-python">new_profile = {'user_id': 213, 'name': 'Drew'}
duplicate_profile = {'user_id': 212, 'name': 'Tommy'}
result = db.profiles.insert_one(new_profile)  # This is fine.
result = db.profiles.insert_one(duplicate_profile)
## 出现错误提示...
Traceback (most recent call last):
DuplicateKeyError: E11000 duplicate key error index: test_database.profiles.$user_id_1 dup key: { : 212 }
</code></pre>
 <br>      
</div></body></html>