<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">MongoDB固定循环集合</h1><div style="width:100%;float:left;" class="article-content">   
 <p>MongoDB固定集合(<strong>Capped collections</strong>)是固定大小的循环集合，遵循插入顺序以支持创建，读取和删除操作的高性能。 通过循环，当分配给集合的固定大小被耗尽时，它将开始删除集合中最旧的文档，而不用提供任何明确的命令。</p> 
 <p>如果更新导致增加的文档大小，固定集合会限制文档的更新。 由于上限集合按照磁盘存储的顺序存储文档，因此可确保文档大小不会增加磁盘上分配的大小。固定集合最适用于存储日志信息，缓存数据或任何其他高容量数据。</p> 
 <h2 id="h2-u521Bu5EFAu56FAu5B9Au96C6u5408"><a name="创建固定集合" class="reference-link"></a><span class="header-link octicon octicon-link"></span>创建固定集合</h2>
 <p>要创建一个固定集合，可使用 <code>createCollection</code> 命令，但是<code>capped</code>选项的值为<code>true</code>，并指定以字节为单位的最大集合大小。</p> 
 <pre><code class="lang-shell">&gt;db.createCollection("cappedLogCollection",{capped:true,size:99999})
</code></pre> 
 <p>除了指定集合大小，还可以使用<code>max</code>参数限制集合中的文档数量 -</p> 
 <pre><code class="lang-shell">&gt;db.createCollection("cappedLogCollection",{capped:true,size:99999,max:1000})
</code></pre> 
 <p>如果要查看集合是否固定，请使用以下<code>isCapped</code>命令 -</p> 
 <pre><code class="lang-shell">&gt;db.cappedLogCollection.isCapped()
</code></pre> 
 <p>如果想要将一个集合转换为上限的集合，则可以使用以下代码进行操作：</p> 
 <pre><code class="lang-shell">&gt;db.runCommand({"convertToCapped":"posts",size:99999})
</code></pre> 
 <p>此代码将现有的<code>post</code>转换为固定集合。</p> 
 <h2 id="h2-u67E5u8BE2u56FAu5B9Au96C6u5408"><a name="查询固定集合" class="reference-link"></a><span class="header-link octicon octicon-link"></span>查询固定集合</h2>
 <p>默认情况下，在固定集合上查询将以插入顺序显示结果。 但是，如果要以相反的顺序检索文档，请使用<code>sort</code>命令，如以下代码所示 -</p>   
 <pre><code class="lang-shell">&gt; db.cappedLogCollection.find().sort({$natural:-1})
</code></pre> 
 <p>关于固定集合值得注意的几个要点 -</p> 
 <ul> 
  <li>无法从固定集合中删除文档。</li>
  <li>固定集合中没有默认索引，甚至不在<code>_id</code>字段上。</li>
  <li>在插入新文档时，MongoDB不需要在磁盘上实际寻找一个容纳新文档的位置。它可以随便地将新文档插入集合的尾部。这样就使得在固定集合中的插入操作非常快。</li>
  <li>类似地，在读取文档的同时，MongoDB按照磁盘上存储的顺序返回文档。这样使读取操作非常快。</li>
 </ul>
 <br>      
</div></body></html>