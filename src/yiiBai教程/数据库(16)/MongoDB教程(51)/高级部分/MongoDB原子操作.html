<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">MongoDB原子操作</h1><div style="width:100%;float:left;" class="article-content">   
 <p>MongoDB不支持多文档原子事务。 但是，它可以为单个文档提供了原子操作。 因此，如果文档有一百个字段，则更新语句将更新或不更新所有字段的值，因此在原始级别保持原子性。</p> 
 <h2 id="h2-u539Fu5B50u64CDu4F5Cu6A21u578Bu6570u636E"><a name="原子操作模型数据" class="reference-link"></a><span class="header-link octicon octicon-link"></span>原子操作模型数据</h2>
 <p>维持原子性的推荐方法是将所有相关信息保存在一起，并使用嵌入式文档在一个文档中一起更新。 这将确保单个文档的所有更新都是原子的。</p> 
 <p>考虑以下产品文件 -</p> 
 <pre><code class="lang-shell">{
   "_id":1,
   "product_name": "Huawei P9",
   "category": "mobiles",
   "product_total": 5,
   "product_available": 3,
   "product_bought_by": [
      {
         "customer": "Kobe",
         "date": "2017-07-08"
      },
      {
         "customer": "Maxsu",
         "date": "2018-07-28"
      }
   ]
}
</code></pre> 
 <p>在上面这个文档中，已经在<code>product_bought_by</code>字段中嵌入了购买产品的客户的信息。 现在，当有新客户购买产品，首先查看<code>product_available</code>字段检查产品存货是否仍然够用。</p> 
 <p>如果可用，则减少<code>product_available</code>字段的值，并将新客户的嵌入式文档插入到<code>product_bought_by</code>字段中。下面将使用<code>findAndModify</code>命令来执行此功能，因为它会以同样的方式搜索和更新文档。</p>   
 <pre><code class="lang-shell">&gt;db.products.findAndModify({ 
   query:{_id:2,product_available:{$gt:0}}, 
   update:{ 
      $inc:{product_available:-1}, 
      $push:{product_bought_by:{customer:"Curry",date:"2017-08-08"}} 
   }    
})
</code></pre> 
 <p>嵌入式文档和使用<code>findAndModify</code>查询的方法确保产品购买信息仅在产品可用时才更新。 而整个这个事务在同一个查询中是原子的。</p> 
 <p>与此相反的是如果分别保留产品数量，以及谁购买产品的信息。在这种情况下，我们将首先使用第一个查询检查产品是否可用。然后在第二个查询中更新购买信息。 但是，有可能在执行这两个查询时(还未执行完)，其他一些用户已经购买了该产品，并且此产品缺货了。但是由于程序执行过程中并不知晓，第二个查询将根据第一个查询的结果更新购买信息。这会导致数据库不一致，因为产品已经没有库存，但是仍然断续销售。</p>
 <br>      
</div></body></html>