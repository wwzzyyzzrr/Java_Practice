<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Redis分区</h1><div style="width:100%;float:left;" class="article-content">   
 <p>分区是将数据拆分为多个Redis实例的过程，因此每个实例只包含一部分键。</p> 
 <h2 id="h2-u5206u533Au7684u4F18u70B9"><a name="分区的优点" class="reference-link"></a><span class="header-link octicon octicon-link"></span>分区的优点</h2>
 <ul> 
  <li>它允许更大的数据库，使用更多计算机的内存总和。如果没有分区，则限制为单个计算机可以支持的内存量。</li>
  <li>它允许将计算能力扩展到多个核心和多个计算机，并将网络带宽扩展到多个计算机和网络适配器。</li>
 </ul> 
 <h2 id="h2-u5206u533Au7684u7F3Au70B9"><a name="分区的缺点" class="reference-link"></a><span class="header-link octicon octicon-link"></span>分区的缺点</h2>
 <ul> 
  <li>通常不支持涉及多个键的操作。 例如，如果两个集合存储在映射到不同Redis实例的键中，则不能执行两个集合之间的交集操作。</li>
  <li>不能使用涉及多个键的Redis事务。</li>
  <li>分区粒度是关键，因此不可能使用单个巨大的键(如非常大的排序集合)来分割数据集。</li>
  <li>使用分区时，数据处理更复杂。 例如，必须处理多个<strong>RDB/AOF</strong>文件，并获得数据的备份，您需要聚合来自多个实例和主机的持久性文件。</li>
  <li>添加和删除容量可能很复杂。 例如，Redis Cluster支持大多数透明的数据重新平衡，具有在运行时添加和删除节点的能力。但是，其他系统(如客户端分区和代理)不支持此功能。但可以使用一种叫作<strong>Presharding</strong>的技术来处理这方面的问题。</li>
 </ul> 
 <h2 id="h2-u5206u533Au7C7Bu578B"><a name="分区类型" class="reference-link"></a><span class="header-link octicon octicon-link"></span>分区类型</h2>  
 <p>Redis中有两种类型的分区。假设有四个Redis实例：<code>R0</code>，<code>R1</code>，<code>R2</code>，<code>R3</code>以许多代表用户的键，如<code>user：1</code>，<code>user：2</code>，…等等。</p> 
 <h3 id="h3-u8303u56F4u5206u533A"><a name="范围分区" class="reference-link"></a><span class="header-link octicon octicon-link"></span>范围分区</h3>
 <p>范围分区通过将对象的范围映射到特定的Redis实例来实现。假设在上面示例中，从ID 0到ID 10000的用户将进入实例<code>R0</code>，而从ID 10001到ID 20000的用户将进入实例<code>R1</code>，以此类推。</p> 
 <h2 id="h2-u54C8u5E0Cu5206u533A"><a name="哈希分区" class="reference-link"></a><span class="header-link octicon octicon-link"></span>哈希分区</h2>
 <p>在这种类型的分区中，使用散列函数(例如，模函数)将键转换成数字，然后将数据存储在不同的Redis实例中。</p>
 <br>      
</div></body></html>