<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Redis快速入门</h1><div style="width:100%;float:left;" class="article-content">   
 <p>Redis是一个开源，高级的键值存储和一个适用的解决方案，用于构建高性能，可扩展的Web应用程序。</p> 
 <p>Redis有三个主要特点，使它优越于其它键值数据存储系统 - </p> 
 <ul> 
  <li>Redis将其数据库完全保存在内存中，仅使用磁盘进行持久化。</li>
  <li>与其它键值数据存储相比，Redis有一组相对丰富的数据类型。</li>
  <li>Redis可以将数据复制到任意数量的从机中。</li>
 </ul> 
 <p>Redis官方网网站是：<a target="_blank" href="http://www.redis.io/">http://www.redis.io/</a> ，如下：</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201702/2202/222090243_50067.png" alt=""></p> 
 <h2 id="h2-redis-"><a name="Redis的优点" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Redis的优点</h2>
 <p>以下是<strong>Redis</strong>的一些优点。</p> 
 <ul> 
  <li><strong>异常快</strong> - Redis非常快，每秒可执行大约<code>110000</code>次的设置(<code>SET</code>)操作，每秒大约可执行<code>81000</code>次的读取/获取(<code>GET</code>)操作。</li>
  <li><strong>支持丰富的数据类型</strong> - Redis支持开发人员常用的大多数数据类型，例如列表，集合，排序集和散列等等。这使得Redis很容易被用来解决各种问题，因为我们知道哪些问题可以更好使用地哪些数据类型来处理解决。</li>
  <li><strong>操作具有原子性</strong> - 所有Redis操作都是原子操作，这确保如果两个客户端并发访问，Redis服务器能接收更新的值。</li>
  <li><strong>多实用工具</strong> - Redis是一个多实用工具，可用于多种用例，如：缓存，消息队列(Redis本地支持发布/订阅)，应用程序中的任何短期数据，例如，web应用程序中的会话，网页命中计数等。</li>
 </ul> 
 <h2 id="h2-redis-"><a name="Redis与其他键值存储系统" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Redis与其他键值存储系统</h2>
 <ul> 
  <li><p>Redis是键值数据库系统的不同进化路线，它的值可以包含更复杂的数据类型，可在这些数据类型上定义原子操作。</p> </li>
  <li><p>Redis是一个内存数据库，但在磁盘数据库上是持久的，因此它代表了一个不同的权衡，在这种情况下，在不能大于存储器(内存)的数据集的限制下实现非常高的写和读速度。</p> </li>
  <li><p>内存数据库的另一个优点是，它与磁盘上的相同数据结构相比，复杂数据结构在内存中存储表示更容易操作。 因此，Redis可以做很少的内部复杂性。</p> </li>
 </ul> 
 <h2 id="h2-1-redis-"><a name="1. Redis环境安装配置" class="reference-link"></a><span class="header-link octicon octicon-link"></span>1. Redis环境安装配置</h2>
 <p>在本章中，您将了解和学习Redis的环境安装设置。</p> 
 <h2 id="h2--ubuntu-redis"><a name="在Ubuntu上安装Redis" class="reference-link"></a><span class="header-link octicon octicon-link"></span>在Ubuntu上安装Redis</h2>
 <p>要在Ubuntu上安装Redis，打开终端并键入以下命令 -</p> 
 <pre><code class="lang-shell">[yiibai@ubuntu:~]$ sudo apt-get update 
[yiibai@ubuntu:~]$ sudo apt-get install redis-server
</code></pre> 
 <p>这将在Ubuntu机器上安装Redis。</p> 
 <p><strong>启动Redis</strong></p> 
 <pre><code class="lang-shell">[yiibai@ubuntu:~]$ redis-server
[2988] 07 Feb 17:09:42.485 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf
[2988] 07 Feb 17:09:42.488 # Unable to set the max number of files limit to 10032 (Operation not permitted), setting the max clients configuration to 3984.
[2988] 07 Feb 17:09:42.490 # Warning: 32 bit instance detected but no memory lim
                _._
           _.-``__ ''-._
      _.-``    `.  `_.  ''-._           Redis 2.8.4 (00000000/0) 32 bit
  .-`` .-```.  ```\/    _.,_ ''-._
 (    '      ,       .-`  | `,    )     Running in stand alone mode
 |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379
 |    `-._   `._    /     _.-'    |     PID: 2988
  `-._    `-._  `-./  _.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |           http://redis.io
  `-._    `-._`-.__.-'_.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |
  `-._    `-._`-.__.-'_.-'    _.-'
      `-._    `-.__.-'    _.-'
          `-._        _.-'
              `-.__.-'

[2988] 07 Feb 17:09:42.581 # Server started, Redis version 2.8.4
[2988] 07 Feb 17:09:42.582 # WARNING overcommit_memory is set to 0! Background s                                                                                        ' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_m
[2988] 07 Feb 17:09:42.582 * The server is now ready to accept connections on po
</code></pre> 
 <p><strong>检查Redis是否正在工作</strong></p> 
 <pre><code class="lang-shell">[yiibai@ubuntu:~]$ redis-cli
</code></pre> 
 <p>这将打开一个<strong>redis</strong>提示，如下所示 - </p> 
 <pre><code class="lang-shell">redis 127.0.0.1:6379&gt;
</code></pre> 
 <p>在上面的提示中，<code>127.0.0.1</code>是计算机的IP地址，<code>6379</code>是运行<strong>Redis</strong>服务器的端口。 现在键入以下<code>PING</code>命令。</p> 
 <pre><code class="lang-shell">redis 127.0.0.1:6379&gt; ping 
PONG
</code></pre> 
 <p>这表明<strong>Redis</strong>已成功在您的计算机上安装了。</p> 
 <p>在Ubuntu上安装<strong>Redis桌面管理</strong></p> 
 <p>要在Ubuntu上安装<strong>Redis</strong>桌面管理器，可从 <a target="_blank" href="http://redisdesktop.com/download">http://redisdesktop.com/download</a> 下载该软件包，安装即可。</p> 
 <p>打开下载的软件包并安装。</p> 
 <p><strong>Redis桌面管理器</strong>将提供用于管理Redis的键和数据的UI。</p> 
 <h2 id="h2-2-redis-"><a name="2. Redis配置" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2. Redis配置</h2>
 <p>在Redis中，在Redis的根目录下有一个配置文件(<code>redis.conf</code>)。当然您可以通过Redis <code>CONFIG</code>命令获取和设置所有的<strong>Redis</strong>配置。</p> 
 <p><strong>语法</strong><br>以下是Redis中的<code>CONFIG</code>命令的基本语法。</p> 
 <pre><code class="lang-shell">redis 127.0.0.1:6379&gt; CONFIG GET CONFIG_SETTING_NAME
</code></pre> 
 <p><strong>示例</strong></p> 
 <pre><code class="lang-shell">redis 127.0.0.1:6379&gt; CONFIG GET loglevel  
1) "loglevel" 
2) "notice"
</code></pre> 
 <blockquote> 
  <p>要获取所有配置设置，请使用<code>*</code>代替<code>CONFIG_SETTING_NAME</code></p> 
 </blockquote> 
 <p><strong>示例</strong></p> 
 <pre><code class="lang-shell">redis 127.0.0.1:6379&gt; CONFIG GET *
  1) "dbfilename"
  2) "dump.rdb"
  3) "requirepass"
  4) ""
  5) "masterauth"
  6) ""
  7) "unixsocket"
  8) ""
  9) "logfile"
 10) "/var/log/redis/redis-server.log"
 11) "pidfile"
 12) "/var/run/redis/redis-server.pid"
 13) "maxmemory"
 14) "3221225472"
 15) "maxmemory-samples"
 16) "3"
 17) "timeout"
 18) "0"
 19) "tcp-keepalive"
 20) "0"
 21) "auto-aof-rewrite-percentage"
 22) "100"
 23) "auto-aof-rewrite-min-size"
 24) "67108864"
 25) "hash-max-ziplist-entries"
 26) "512"
 27) "hash-max-ziplist-value"
 28) "64"
 29) "list-max-ziplist-entries"
 30) "512"
 31) "list-max-ziplist-value"
 32) "64"
 33) "set-max-intset-entries"
 34) "512"
 35) "zset-max-ziplist-entries"
 36) "128"
 37) "zset-max-ziplist-value"
 38) "64"
 39) "lua-time-limit"
 40) "5000"
 41) "slowlog-log-slower-than"
 42) "10000"
 43) "slowlog-max-len"
 44) "128"
 45) "port"
 46) "6379"
 47) "databases"
 48) "16"
 49) "repl-ping-slave-period"
 50) "10"
 51) "repl-timeout"
 52) "60"
 53) "repl-backlog-size"
 54) "1048576"
 55) "repl-backlog-ttl"
 56) "3600"
 57) "maxclients"
 58) "3984"
 59) "watchdog-period"
 60) "0"
 61) "slave-priority"
 62) "100"
 63) "min-slaves-to-write"
 64) "0"
 65) "min-slaves-max-lag"
 66) "10"
 67) "hz"
 68) "10"
 69) "no-appendfsync-on-rewrite"
 70) "no"
 71) "slave-serve-stale-data"
 72) "yes"
 73) "slave-read-only"
 74) "yes"
 75) "stop-writes-on-bgsave-error"
 76) "yes"
 77) "daemonize"
 78) "yes"
 79) "rdbcompression"
 80) "yes"
 81) "rdbchecksum"
 82) "yes"
 83) "activerehashing"
 84) "yes"
 85) "repl-disable-tcp-nodelay"
 86) "no"
 87) "aof-rewrite-incremental-fsync"
 88) "yes"
 89) "appendonly"
 90) "no"
 91) "dir"
 92) "/var/lib/redis"
 93) "maxmemory-policy"
 94) "noeviction"
 95) "appendfsync"
 96) "everysec"
 97) "save"
 98) "900 1 300 10 60 10000"
 99) "loglevel"
100) "notice"
101) "client-output-buffer-limit"
102) "normal 0 0 0 slave 268435456 67108864 60 pubsub 33554432 8388608 60"
103) "unixsocketperm"
104) "0"
105) "slaveof"
106) ""
107) "notify-keyspace-events"
108) ""
109) "bind"
110) "127.0.0.1"
</code></pre> 
 <h2 id="h2-u7F16u8F91u914Du7F6E"><a name="编辑配置" class="reference-link"></a><span class="header-link octicon octicon-link"></span>编辑配置</h2>
 <p>要更新配置，可以直接编辑<code>redis.conf</code>文件，也可以通过<code>CONFIG set</code>命令更新配置。</p> 
 <p><strong>语法</strong><br>以下是<code>CONFIG SET</code>命令的基本语法。</p> 
 <pre><code class="lang-shell">redis 127.0.0.1:6379&gt; CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE
</code></pre> 
 <p><strong>示例</strong></p> 
 <pre><code class="lang-shell">redis 127.0.0.1:6379&gt; CONFIG SET loglevel "notice" 
OK 
redis 127.0.0.1:6379&gt; CONFIG GET loglevel  
1) "loglevel" 
2) "notice"
</code></pre> 
 <h2 id="h2-3-redis-"><a name="3. Redis数据类型" class="reference-link"></a><span class="header-link octicon octicon-link"></span>3. Redis数据类型</h2>
 <p>Redis支持<code>5</code>种数据类型。</p> 
 <h2 id="h2-u5B57u7B26u4E32"><a name="字符串" class="reference-link"></a><span class="header-link octicon octicon-link"></span>字符串</h2>
 <p>Redis中的字符串是一个字节序列。Redis中的字符串是二进制安全的，这意味着它们的长度不由任何特殊的终止字符决定。因此，可以在一个字符串中存储高达<code>512</code>兆字节的任何内容。</p> 
 <p><strong>示例</strong></p> 
 <pre><code class="lang-shell">redis 127.0.0.1:6379&gt; set name "yiibai.com" 
OK 
redis 127.0.0.1:6379&gt; get name 
"yiibai.com"
</code></pre> 
 <p>在上面的示例中，<code>set</code>和<code>get</code>是Redis命令，<code>name</code>是Redis中使用的键，<code>yiibai.com</code>是存储在Redis中的字符串的值。</p> 
 <blockquote> 
  <p>注 - Redis命令不区分大小写，如<code>SET</code>,<code>Set</code>和<code>set</code>都是同一个命令。字符串值的最大长度为 512MB。</p> 
 </blockquote> 
 <h2 id="h2--"><a name="散列/哈希" class="reference-link"></a><span class="header-link octicon octicon-link"></span>散列/哈希</h2>
 <p>Redis散列/哈希(Hashes)是键值对的集合。Redis散列/哈希是字符串字段和字符串值之间的映射。因此，它们用于表示对象。</p> 
 <p><strong>示例</strong></p> 
 <pre><code class="lang-shell">redis 127.0.0.1:6379&gt; HMSET ukey username "yiibai" password "passswd123" points 200
</code></pre> 
 <p>在上述示例中，散列/哈希数据类型用于存储包含用户的基本信息的用户对象。这里<code>HMSET</code>，<code>HGETALL</code>是Redis的命令，而<code>ukey</code>是键的名称。</p> 
 <p>每个散列/哈希可以存储多达<code>2^32 - 1</code>个健-值对(超过<code>40</code>亿个)。</p> 
 <h2 id="h2-u5217u8868"><a name="列表" class="reference-link"></a><span class="header-link octicon octicon-link"></span>列表</h2>
 <p>Redis列表只是字符串列表，按插入顺序排序。您可以向Redis列表的头部或尾部添加元素。</p> 
 <p><strong>示例</strong></p> 
 <pre><code class="lang-shell">redis 127.0.0.1:6379&gt; lpush alist redis 
(integer) 1 
redis 127.0.0.1:6379&gt; lpush alist mongodb 
(integer) 2 
redis 127.0.0.1:6379&gt; lpush alist sqlite 
(integer) 3 
redis 127.0.0.1:6379&gt; lrange alist 0 10  

1) "sqlite" 
2) "mongodb" 
3) "redis"
</code></pre> 
 <p>列表的最大长度为<code>2^32 - 1</code>个元素(<code>4294967295</code>，每个列表可容纳超过<code>40</code>亿个元素)。</p> 
 <h2 id="h2-u96C6u5408"><a name="集合" class="reference-link"></a><span class="header-link octicon octicon-link"></span>集合</h2>
 <p>Redis集合是字符串的无序集合。在Redis中，您可以添加，删除和测试成员存在的时间O(1)复杂性。</p> 
 <p><strong>示例</strong></p> 
 <pre><code class="lang-shell">redis 127.0.0.1:6379&gt; sadd yiibailist redis 
(integer) 1 
redis 127.0.0.1:6379&gt; sadd yiibailist mongodb 
(integer) 1 
redis 127.0.0.1:6379&gt; sadd yiibailist sqlite 
(integer) 1 
redis 127.0.0.1:6379&gt; sadd yiibailist sqlite 
(integer) 0 
redis 127.0.0.1:6379&gt; smembers yiibailist  

1) "sqlite" 
2) "mongodb" 
3) "redis"
</code></pre> 
 <blockquote> 
  <p>注意 - 在上面的示例中，<code>sqlite</code>被添加了两次，但是由于集合的唯一属性，所以它只算添加一次。</p> 
 </blockquote> 
 <p>一个集合中的最大成员数量为<code>2^32 - 1</code>(即<code>4294967295</code>，每个集合中元素数量可达<code>40</code>亿个)个。</p> 
 <h2 id="h2-u53EFu6392u5E8Fu96C6u5408"><a name="可排序集合" class="reference-link"></a><span class="header-link octicon octicon-link"></span>可排序集合</h2>
 <p>Redis可排序集合类似于Redis集合，是不重复的字符集合。 不同之处在于，排序集合的每个成员都与分数相关联，这个分数用于按最小分数到最大分数来排序的排序集合。虽然成员是唯一的，但分数值可以重复。</p> 
 <p><strong>示例</strong></p> 
 <pre><code class="lang-shell">redis 127.0.0.1:6379&gt; zadd yiibaiset 0 redis
(integer) 1 
redis 127.0.0.1:6379&gt; zadd yiibaiset 0 mongodb
(integer) 1 
redis 127.0.0.1:6379&gt; zadd yiibaiset 1 sqlite
(integer) 1 
redis 127.0.0.1:6379&gt; zadd yiibaiset 1 sqlite
(integer) 0 
redis 127.0.0.1:6379&gt; ZRANGEBYSCORE yiibaiset 0 1000  

1) "mongodb" 
2) "redis" 
3) "sqlite"
</code></pre> 
 <p>因为 ‘<code>sqlite</code>‘ 的排序值是 1 ，其它两个元素的排序值是 0 ，所以 ‘<code>sqlite</code>‘ 排在最后一个位置上。</p> 
 <h2 id="h2-4-redis-"><a name="4. Redis命令" class="reference-link"></a><span class="header-link octicon octicon-link"></span>4. Redis命令</h2>
 <p>Redis命令是用于在Redis服务器上执行一些操作。<br>要在Redis服务器上运行命令，需要一个Redis客户端。Redis客户端在Redis包中有提供，这个包在我们前面的安装教程中就有安装过了。</p> 
 <p><strong>语法</strong><br>以下是Redis客户端的基本语法。</p> 
 <pre><code class="lang-shell">[yiibai@ubuntu:~]$ redis-cli
</code></pre> 
 <p><strong>示例</strong><br>以下示例说明了如何启动Redis客户端。</p> 
 <p>要启动Redis客户端，请打开终端并键入命令<code>redis-cli</code>。 这将连接到您的本地Redis服务器，现在可以运行任何的Redis命令了。</p> 
 <pre><code class="lang-shell">[yiibai@ubuntu:~]$redis-cli 
redis 127.0.0.1:6379&gt; 
redis 127.0.0.1:6379&gt; PING  
PONG
</code></pre> 
 <p>在上面的示例中，连接到到在本地机器上运行的Redis服务器并执行<code>PING</code>命令，该命令检查服务器是否正在运行。</p> 
 <h2 id="h2-u5728u8FDCu7A0Bu670Du52A1u5668u4E0Au8FD0u884Cu547Du4EE4"><a name="在远程服务器上运行命令" class="reference-link"></a><span class="header-link octicon octicon-link"></span>在远程服务器上运行命令</h2>
 <p>要在Redis远程服务器上运行命令，需要通过客户端<code>redis-cli</code>连接到服务器</p> 
 <p><strong>语法</strong></p> 
 <pre><code class="lang-shell">[yiibai@ubuntu:~]$ redis-cli -h host -p port -a password
</code></pre> 
 <p><strong>示例</strong><br>以下示例显示如何连接到Redis远程服务器，在主机(host)<code>127.0.0.1</code>，端口(port)<code>6379</code>上运行，并使用密码为 <code>mypass</code>。</p> 
 <pre><code class="lang-shell">[yiibai@ubuntu:~]$ redis-cli -h 127.0.0.1 -p 6379 -a "mypass" 
redis 127.0.0.1:6379&gt; 
redis 127.0.0.1:6379&gt; PING  
PONG
</code></pre> 
 <h2 id="h2-5-redis-"><a name="5. Redis键命令" class="reference-link"></a><span class="header-link octicon octicon-link"></span>5. Redis键命令</h2>
 <p>Redis键命令用于管理<strong>Redis</strong>中的键。以下是使用redis键命令的语法。</p> 
 <p><strong>语法</strong></p> 
 <pre><code class="lang-shell">redis 127.0.0.1:6379&gt; COMMAND KEY_NAME
</code></pre> 
 <p><strong>示例</strong></p> 
 <pre><code class="lang-shell">redis 127.0.0.1:6379&gt; SET akey redis
OK 
redis 127.0.0.1:6379&gt; DEL akey
(integer) 1
127.0.0.1:6379&gt; GET akey
(nil)
</code></pre> 
 <p>在上面的例子中，<code>DEL</code>是Redis的命令，而<code>akey</code>是键的名称。如果键被删除，则命令的输出将为<code>(integer) 1</code>，否则为<code>(integer) 0</code>。</p> 
 <h2 id="h2-redis-"><a name="Redis键命令" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Redis键命令</h2>
 <p>下表列出了与键相关的一些基本命令。</p> 
 <table> 
  <thead> 
   <tr> 
    <th>编号</th> 
    <th>命令</th> 
    <th>描述</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>1</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/keys_del.html" title="DEL key">DEL key</a></td> 
    <td>此命令删除一个指定键(如果存在)。</td> 
   </tr> 
   <tr> 
    <td>2</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/keys_dump.html" title="DUMP key">DUMP key</a></td> 
    <td>此命令返回存储在指定键的值的序列化版本。</td> 
   </tr> 
   <tr> 
    <td>3</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/keys_exists.html" title="EXISTS key">EXISTS key</a></td> 
    <td>此命令检查键是否存在。</td> 
   </tr> 
   <tr> 
    <td>4</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/keys_expire.html" title="EXPIRE key">EXPIRE key seconds</a></td> 
    <td>设置键在指定时间秒数之后到期/过期。</td> 
   </tr> 
   <tr> 
    <td>5</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/keys_expireat.html" title="EXPIREAT key timestamp">EXPIREAT key timestamp</a></td> 
    <td>设置在指定时间戳之后键到期/过期。这里的时间是Unix时间戳格式。</td> 
   </tr> 
   <tr> 
    <td>6</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/keys_pexpire.html" title="PEXPIRE key milliseconds">PEXPIRE key milliseconds</a></td> 
    <td>设置键的到期时间(以毫秒为单位)。</td> 
   </tr> 
   <tr> 
    <td>7</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/keys_pexpireat.html" title="PEXPIREAT key milliseconds-timestamp">PEXPIREAT key milliseconds-timestamp</a></td> 
    <td>以Unix时间戳形式来设置键的到期时间(以毫秒为单位)。</td> 
   </tr> 
   <tr> 
    <td>8</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/keys_keys.html" title="KEYS pattern">KEYS pattern</a></td> 
    <td>查找与指定模式匹配的所有键。</td> 
   </tr> 
   <tr> 
    <td>9</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/keys_move.html" title="MOVE key db">MOVE key db</a></td> 
    <td>将键移动到另一个数据库。</td> 
   </tr> 
   <tr> 
    <td>10</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/keys_persist.html" title="PERSIST key">PERSIST key</a></td> 
    <td>删除指定键的过期时间，得永生。</td> 
   </tr> 
   <tr> 
    <td>11</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/keys_pttl.html" title="PTTL key">PTTL key</a></td> 
    <td>获取键的剩余到期时间。</td> 
   </tr> 
   <tr> 
    <td>12</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/keys_randomkey.html" title="RANDOMKEY">RANDOMKEY</a></td> 
    <td>从Redis返回一个随机的键。</td> 
   </tr> 
   <tr> 
    <td>13</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/keys_rename.html" title="RENAME key newkey">RENAME key newkey</a></td> 
    <td>更改键的名称。</td> 
   </tr> 
   <tr> 
    <td>14</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/keys_pttl.html" title="PTTL key">PTTL key</a></td> 
    <td>获取键到期的剩余时间(以毫秒为单位)。</td> 
   </tr> 
   <tr> 
    <td>15</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/keys_renamenx.html" title="RENAMENX key newkey">RENAMENX key newkey</a></td> 
    <td>如果新键不存在，重命名键。</td> 
   </tr> 
   <tr> 
    <td>16</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/keys_type.html" title="TYPE key">TYPE key</a></td> 
    <td>返回存储在键中的值的数据类型。</td> 
   </tr> 
  </tbody> 
 </table> 
 <h2 id="h2-6-redis-"><a name="6. Redis字符串" class="reference-link"></a><span class="header-link octicon octicon-link"></span>6. Redis字符串</h2>
 <p>Redis字符串命令用于管理Redis中的字符串值。以下是使用Redis字符串命令的语法。</p> 
 <pre><code class="lang-shell">redis 127.0.0.1:6379&gt; COMMAND KEY_NAME
</code></pre> 
 <p><strong>示例</strong></p> 
 <pre><code class="lang-shell">redis 127.0.0.1:6379&gt; SET mykey "redis" 
OK 
redis 127.0.0.1:6379&gt; GET mykey 
"redis"
</code></pre> 
 <p>在上面的例子中，<code>SET</code>和<code>GET</code>是redis中的命令，而<code>mykey</code>是键的名称。</p> 
 <h2 id="h2-redis-"><a name="Redis字符串命令" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Redis字符串命令</h2>
 <p>下表列出了一些用于在<strong>Redis</strong>中管理字符串的基本命令。</p> 
 <table> 
  <thead> 
   <tr> 
    <th>编号</th> 
    <th>命令</th> 
    <th>描述说明</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>1</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/strings_set.html" title="SET key value">SET key value</a></td> 
    <td>此命令设置指定键的值。</td> 
   </tr> 
   <tr> 
    <td>2</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/strings_get.html" title="GET key">GET key</a></td> 
    <td>获取指定键的值。</td> 
   </tr> 
   <tr> 
    <td>3</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/strings_getrange.html" title="GETRANGE key start end">GETRANGE key start end</a></td> 
    <td>获取存储在键上的字符串的子字符串。</td> 
   </tr> 
   <tr> 
    <td>4</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/strings_getset.html" title="GETSET key value">GETSET key value</a></td> 
    <td>设置键的字符串值并返回其旧值。</td> 
   </tr> 
   <tr> 
    <td>5</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/strings_getbit.html" title="GETBIT key offset">GETBIT key offset</a></td> 
    <td>返回在键处存储的字符串值中偏移处的位值。</td> 
   </tr> 
   <tr> 
    <td>6</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/strings_mget.html" title="MGET key1 [key2..]">MGET key1 [key2..]</a></td> 
    <td>获取所有给定键的值</td> 
   </tr> 
   <tr> 
    <td>7</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/strings_setbit.html" title="SETBIT key offset value">SETBIT key offset value</a></td> 
    <td>存储在键上的字符串值中设置或清除偏移处的位</td> 
   </tr> 
   <tr> 
    <td>8</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/strings_setex.html" title="SETEX key seconds value">SETEX key seconds value</a></td> 
    <td>使用键和到期时间来设置值</td> 
   </tr> 
   <tr> 
    <td>9</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/strings_setnx.html" title="SETNX key value">SETNX key value</a></td> 
    <td>设置键的值，仅当键不存在时</td> 
   </tr> 
   <tr> 
    <td>10</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/strings_setrange.html" title="SETRANGE key offset value">SETRANGE key offset value</a></td> 
    <td>在指定偏移处开始的键处覆盖字符串的一部分</td> 
   </tr> 
   <tr> 
    <td>11</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/strings_strlen.html" title="STRLEN key">STRLEN key</a></td> 
    <td>获取存储在键中的值的长度</td> 
   </tr> 
   <tr> 
    <td>12</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/strings_mset.html" title="MSET key value [key value ...]">MSET key value [key value …]</a></td> 
    <td>为多个键分别设置它们的值</td> 
   </tr> 
   <tr> 
    <td>13</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/strings_msetnx.html" title="MSETNX key value [key value ...]">MSETNX key value [key value …]</a></td> 
    <td>为多个键分别设置它们的值，仅当键不存在时</td> 
   </tr> 
   <tr> 
    <td>14</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/strings_psetex.html" title="PSETEX key milliseconds value">PSETEX key milliseconds value</a></td> 
    <td>设置键的值和到期时间(以毫秒为单位)</td> 
   </tr> 
   <tr> 
    <td>15</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/strings_incr.html" title="INCR key">INCR key</a></td> 
    <td>将键的整数值增加<code>1</code></td> 
   </tr> 
   <tr> 
    <td>16</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/strings_incrby.html" title="INCRBY key increment">INCRBY key increment</a></td> 
    <td>将键的整数值按给定的数值增加</td> 
   </tr> 
   <tr> 
    <td>17</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/strings_incrbyfloat.html" title="INCRBYFLOAT key increment">INCRBYFLOAT key increment</a></td> 
    <td>将键的浮点值按给定的数值增加</td> 
   </tr> 
   <tr> 
    <td>18</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/strings_decr.html" title="DECR key">DECR key</a></td> 
    <td>将键的整数值减<code>1</code></td> 
   </tr> 
   <tr> 
    <td>19</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/strings_decrby.html" title="DECRBY key decrement">DECRBY key decrement</a></td> 
    <td>按给定数值减少键的整数值</td> 
   </tr> 
   <tr> 
    <td>20</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/strings_append.html" title="APPEND key value">APPEND key value</a></td> 
    <td>将指定值附加到键</td> 
   </tr> 
  </tbody> 
 </table> 
 <h2 id="h2-7-redis-"><a name="7. Redis哈希" class="reference-link"></a><span class="header-link octicon octicon-link"></span>7. Redis哈希</h2>
 <p>Redis Hashes是字符串字段和字符串值之间的映射(类似于PHP中的数组类型)。 因此，它们是表示对象的完美数据类型。</p> 
 <p>在Redis中，每个哈希(散列)可以存储多达4亿个键-值对。</p> 
 <h2 id="h2-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h2>
 <pre><code class="lang-shell">redis 127.0.0.1:6379&gt; HMSET myhash name "redis tutorial" 
description "redis basic commands for caching" likes 20 visitors 23000 
OK 
127.0.0.1:6379&gt; HGETALL myhash
1) "field1"
2) "Hello"
3) "field2"
4) "World"
5) "name"
6) "redis tutorial"
</code></pre> 
 <p>在上面的例子中，在名称为’<code>myhash</code>‘的哈希中设置了Redis教程的详细信息(名称，描述，喜欢，访问者)。</p> 
 <h2 id="h2-8-redis-"><a name="8. Redis列表" class="reference-link"></a><span class="header-link octicon octicon-link"></span>8. Redis列表</h2>
 <p>Redis列表只是字符串列表，按插入顺序排序。可以在列表的头部或尾部添加Redis列表中的元素。</p> 
 <p>列表的最大长度为<code>2^32 - 1</code>个元素(即<code>4294967295</code>，每个列表可存储超过40亿个元素)。</p> 
 <h2 id="h2-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h2>
 <pre><code class="lang-shell">redis 127.0.0.1:6379&gt; LPUSH mylist "redis" 
(integer) 1 
redis 127.0.0.1:6379&gt; LPUSH mylist "mongodb"
(integer) 2 
redis 127.0.0.1:6379&gt; LPUSH mylist "mysql"
(integer) 3 
redis 127.0.0.1:6379&gt; LRANGE mylist 0 10  
1) "mysql" 
2) "mongodb" 
3) "redis"
</code></pre> 
 <p>在上面的示例中，通过命令<code>LPUSH</code>将三个值插入到名称为“<code>mylist</code>”的Redis列表中。</p> 
 <h2 id="h2-8-redis-"><a name="8. Redis集合" class="reference-link"></a><span class="header-link octicon octicon-link"></span>8. Redis集合</h2>
 <p>Redis集合是唯一字符串的无序集合。 唯一值表示集合中不允许键中有重复的数据。</p> 
 <p>在Redis中设置添加，删除和测试成员的存在(恒定时间O(1)，而不考虑集合中包含的元素数量)。列表的最大长度为<code>2^32 - 1</code>个元素(即4294967295，每组集合超过40亿个元素)。</p> 
 <h2 id="h2-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h2>
 <pre><code class="lang-shell">redis 127.0.0.1:6379&gt; SADD myset "redis" 
(integer) 1 
redis 127.0.0.1:6379&gt; SADD myset "mongodb" 
(integer) 1 
redis 127.0.0.1:6379&gt; SADD myset "mysql" 
(integer) 1 
redis 127.0.0.1:6379&gt; SADD myset "mysql" 
(integer) 0 
redis 127.0.0.1:6379&gt; SMEMBERS "myset"  
1) "mysql" 
2) "mongodb" 
3) "redis"
</code></pre> 
 <p>在上面的示例中，通过命令<code>SADD</code>将三个值插入到名称为“<code>myset</code>”的Redis集合中。</p> 
 <h2 id="h2-9-redis-"><a name="9. Redis发送订阅" class="reference-link"></a><span class="header-link octicon octicon-link"></span>9. Redis发送订阅</h2>
 <p>Redis发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。<br>Redis 发布订阅(pub/sub)实现了消息系统，发送者(在redis术语中称为发布者)在接收者(订阅者)接收消息时发送消息。传送消息的链路称为信道。</p> 
 <p>在Redis中，客户端可以订阅任意数量的信道。</p> 
 <h2 id="h2-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h2>
 <p>以下示例说明了发布用户概念的工作原理。 在以下示例中，一个客户端订阅名为“<code>redisChat</code>”的信道。</p> 
 <pre><code class="lang-shell">redis 127.0.0.1:6379&gt; SUBSCRIBE redisChat  
Reading messages... (press Ctrl-C to quit) 
1) "subscribe" 
2) "redisChat" 
3) (integer) 1
</code></pre> 
 <p>现在，两个客户端在名称为“<code>redisChat</code>”的相同信道上发布消息，并且上述订阅的客户端接收消息。</p> 
 <pre><code class="lang-shell">redis 127.0.0.1:6379&gt; PUBLISH redisChat "Redis is a great caching technique"  
(integer) 1  
redis 127.0.0.1:6379&gt; PUBLISH redisChat "Learn redis by yiibai"  
(integer) 1   
1) "message" 
2) "redisChat" 
3) "Redis is a great caching technique" 
1) "message" 
2) "redisChat" 
3) "Learn redis by yiibai"
</code></pre> 
 <h2 id="h2-10-redis-"><a name="10. Redis事务" class="reference-link"></a><span class="header-link octicon octicon-link"></span>10. Redis事务</h2>
 <p>Redis事务允许在单个步骤中执行一组命令。以下是事务的两个属性：</p> 
 <ul> 
  <li>事务中的所有命令作为单个隔离操作并按顺序执行。不可以在执行Redis事务的中间向另一个客户端发出的请求。</li>
  <li>Redis事务也是原子的。原子意味着要么处理所有命令，要么都不处理。</li>
 </ul> 
 <h2 id="h2-u8BEDu6CD5u793Au4F8B"><a name="语法示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>语法示例</h2>
 <p>Redis事务由命令<code>MULTI</code>命令启动，然后需要传递一个应该在事务中执行的命令列表，然后整个事务由<code>EXEC</code>命令执行。</p> 
 <pre><code class="lang-shell">redis 127.0.0.1:6379&gt; MULTI 
OK 
List of commands here 
redis 127.0.0.1:6379&gt; EXEC
</code></pre> 
 <h2 id="h2-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h2>
 <p>以下示例说明了如何启动和执行Redis事务。</p> 
 <pre><code class="lang-shell">redis 127.0.0.1:6379&gt; MULTI 
OK 
redis 127.0.0.1:6379&gt; SET mykey "redis" 
QUEUED 
redis 127.0.0.1:6379&gt; GET mykey 
QUEUED 
redis 127.0.0.1:6379&gt; INCR visitors 
QUEUED 
redis 127.0.0.1:6379&gt; EXEC  
1) OK 
2) "redis" 
3) (integer) 1
</code></pre> 
 <h2 id="h2-11-redis-"><a name="11. Redis脚本" class="reference-link"></a><span class="header-link octicon octicon-link"></span>11. Redis脚本</h2>
 <p>Redis脚本用于使用Lua解释器来执行脚本。从<code>Redis 2.6.0</code>版开始内置到Redis中。使用脚本的命令是<strong>EVAL</strong>命令。</p> 
 <h2 id="h2-u8BEDu6CD5"><a name="语法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>语法</h2>
 <p>以下是<code>EVAL</code>命令的基本语法。</p> 
 <pre><code class="lang-shell">redis 127.0.0.1:6379&gt; EVAL script numkeys key [key ...] arg [arg ...]
</code></pre> 
 <h2 id="h2-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h2>
 <p>以下示例说明了Redis脚本的工作原理。</p> 
 <pre><code class="lang-shell">redis 127.0.0.1:6379&gt; EVAL "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}" 2 key1 
key2 first second  
1) "key1" 
2) "key2" 
3) "first" 
4) "second"
</code></pre> 
 <h2 id="h2-12-redis-"><a name="12.     Redis连接" class="reference-link"></a><span class="header-link octicon octicon-link"></span>12. Redis连接</h2>
 <p>Redis中的连接命令基本上是用于管理与Redis服务器的客户端连接。</p> 
 <h2 id="h2-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h2>
 <p>以下示例说明客户端如何向Redis服务器验证自身，并检查服务器是否正在运行。</p> 
 <pre><code class="lang-shell">redis 127.0.0.1:6379&gt; AUTH "password" 
OK 
redis 127.0.0.1:6379&gt; PING 
PONG
</code></pre> 
 <h2 id="h2-redis-"><a name="Redis连接命令" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Redis连接命令</h2>
 <p>下表列出了与Redis连接相关的一些基本命令。</p> 
 <table> 
  <thead> 
   <tr> 
    <th>序号</th> 
    <th>命令</th> 
    <th>说明</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>1</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/connection_auth.html" title="AUTH password">AUTH password</a></td> 
    <td>使用给定的密码验证服务器</td> 
   </tr> 
   <tr> 
    <td>2</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/connection_echo.html" title="ECHO message">ECHO message</a></td> 
    <td>打印给定的字符串信息</td> 
   </tr> 
   <tr> 
    <td>3</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/connection_ping.html" title="PING">PING</a></td> 
    <td>检查服务器是否正在运行</td> 
   </tr> 
   <tr> 
    <td>4</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/connection_quit.html" title="QUIT">QUIT</a></td> 
    <td>关闭当前连接</td> 
   </tr> 
   <tr> 
    <td>5</td> 
    <td><a target="_blank" href="http://www.yiibai.com/redis/connection_select.html" title="SELECT index">SELECT index</a></td> 
    <td>更改当前连接的所选数据库</td> 
   </tr> 
  </tbody> 
 </table> 
 <h2 id="h2-13-redis-"><a name="13.     Redis服务器" class="reference-link"></a><span class="header-link octicon octicon-link"></span>13. Redis服务器</h2>
 <p>Redis服务器命令基本上是用于管理Redis服务器。</p> 
 <h2 id="h2-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h2>
 <p>以下示例说明了如何获取有关服务器的所有统计信息和信息。</p> 
 <pre><code class="lang-shell">127.0.0.1:6379&gt; info
# Server
redis_version:2.8.4
redis_git_sha1:00000000
redis_git_dirty:0
redis_build_id:8f6097d7914679ca
redis_mode:standalone
os:Linux 3.19.0-25-generic i686
arch_bits:32
multiplexing_api:epoll
gcc_version:4.8.2
process_id:1004
run_id:1e53acea2aa628199c4e438a3ed815d96eebc036
tcp_port:6379
uptime_in_seconds:888450
uptime_in_days:10
hz:10
lru_clock:1861984
config_file:/etc/redis/redis.conf

# Clients
connected_clients:1
client_longest_output_list:0
client_biggest_input_buf:0
blocked_clients:0

# Memory
used_memory:424872
used_memory_human:414.91K
used_memory_rss:6709248
used_memory_peak:424464
used_memory_peak_human:414.52K
used_memory_lua:22528
mem_fragmentation_ratio:15.79
mem_allocator:jemalloc-3.4.1

# Persistence
loading:0
rdb_changes_since_last_save:0
rdb_bgsave_in_progress:0
rdb_last_save_time:1486607123
rdb_last_bgsave_status:ok
rdb_last_bgsave_time_sec:0
rdb_current_bgsave_time_sec:-1
aof_enabled:0
aof_rewrite_in_progress:0
aof_rewrite_scheduled:0
aof_last_rewrite_time_sec:-1
aof_current_rewrite_time_sec:-1
aof_last_bgrewrite_status:ok

# Stats
total_connections_received:1
total_commands_processed:263
instantaneous_ops_per_sec:0
rejected_connections:0
sync_full:0
sync_partial_ok:0
sync_partial_err:0
expired_keys:0
evicted_keys:0
keyspace_hits:257
keyspace_misses:0
pubsub_channels:0
pubsub_patterns:0
latest_fork_usec:4793

# Replication
role:master
connected_slaves:0
master_repl_offset:0
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0

# CPU
used_cpu_sys:24.65
used_cpu_user:15.84
used_cpu_sys_children:0.08
used_cpu_user_children:0.00

# Keyspace
db0:keys=14,expires=0,avg_ttl=0
db1:keys=1,expires=0,avg_ttl=0
127.0.0.1:6379&gt;
</code></pre> 
 <h2 id="h2-14-redis-"><a name="14. Redis备份" class="reference-link"></a><span class="header-link octicon octicon-link"></span>14. Redis备份</h2>
 <p>Redis数据库可以使用安全的方案，使得进行连接的任何客户端在执行命令之前都需要进行身份验证。要保护Redis安全，需要在配置文件中设置密码。</p> 
 <h2 id="h2-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h2>
 <p>下面的示例显示了保护Redis实例的步骤。</p> 
 <pre><code class="lang-shell">127.0.0.1:6379&gt; CONFIG get requirepass 
1) "requirepass" 
2) ""
</code></pre> 
 <p>默认情况下，此属性为空，这表示还没有为此实例设置密码。您可以通过执行以下命令更改此属性。</p> 
 <pre><code class="lang-shell">127.0.0.1:6379&gt; CONFIG set requirepass "yiibai" 
OK 
127.0.0.1:6379&gt; CONFIG get requirepass 
1) "requirepass" 
2) "yiibai"
</code></pre> 
 <p>设置密码后，如果任何客户端运行命令而不进行身份验证，则会返回一个<strong>(error) NOAUTH Authentication required.</strong>的错误信息。 因此，客户端需要使用AUTH命令来验证。</p> 
 <h2 id="h2-u8BEDu6CD5"><a name="语法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>语法</h2>
 <p>以下是AUTH命令的基本语法。</p> 
 <pre><code class="lang-shell">127.0.0.1:6379&gt; AUTH password
</code></pre> 
 <h2 id="h2-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h2>
 <pre><code class="lang-shell">127.0.0.1:6379&gt; AUTH "yiibai" 
OK 
127.0.0.1:6379&gt; SET mykey "Test value" 
OK 
127.0.0.1:6379&gt; GET mykey 
"Test value"
</code></pre> 
 <h2 id="h2-15-redis-"><a name="15. Redis客户端连接" class="reference-link"></a><span class="header-link octicon octicon-link"></span>15. Redis客户端连接</h2>
 <p>Redis在配置的监听TCP端口和Unix套接字上等待和接受客户端的连接(如果已启用)。 当接受新的客户端连接时，执行以下操作 -</p> 
 <ul> 
  <li>由于Redis使用复用和非阻塞<code>I/O</code>，因此客户端套接字处于非阻塞状态。</li>
  <li>设置<code>TCP_NODELAY</code>选项是为了确保连接不延迟。</li>
  <li>创建可读文件事件，以便Redis能够在套接字上读取新数据时收集客户端查询。</li>
 </ul> 
 <h2 id="h2-u6700u5927u5BA2u6237u6570"><a name="最大客户数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>最大客户数</h2>
 <p>在Redis配置文件(<code>redis.conf</code>)中，有一个名称为<code>maxclients</code>的属性，它描述了可以连接到Redis的客户端的最大数量。</p> 
 <p>以下是命令的基本语法。</p>   
 <pre><code class="lang-shell">127.0.0.1:6379&gt; config get maxclients
1) "maxclients"
2) "3984"
</code></pre> 
 <p>默认情况下，此属性设置为<code>10000</code>(取决于操作系统的文件描述符限制的最大数量)，但您可以更改此属性。</p> 
 <h2 id="h2-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h2>
 <p>在以下示例中，我们已将客户端的最大数目设置为<code>100000</code>，并启动服务器。</p> 
 <pre><code class="lang-shell">yiibai@ubuntu:~$ redis-server --maxclients 100000
</code></pre> 
 <h2 id="h2-u5BA2u6237u7AEFu547Du4EE4"><a name="客户端命令" class="reference-link"></a><span class="header-link octicon octicon-link"></span>客户端命令</h2>
 <table> 
  <thead> 
   <tr> 
    <th>编号</th> 
    <th>命令</th> 
    <th>描述</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>1</td> 
    <td>CLIENT LIST</td> 
    <td>返回连接到Redis服务器的客户端列表</td> 
   </tr> 
   <tr> 
    <td>2</td> 
    <td>CLIENT SETNAME</td> 
    <td>为当前连接分配/设置新的名称</td> 
   </tr> 
   <tr> 
    <td>3</td> 
    <td>CLIENT GETNAME</td> 
    <td>返回由<code>CLIENT SETNAME</code>设置的当前连接的名称</td> 
   </tr> 
   <tr> 
    <td>4</td> 
    <td>CLIENT PAUSE</td> 
    <td>这是一个连接控制命令，能够将所有Redis客户端按指定的时间量(以毫秒为单位)挂起</td> 
   </tr> 
   <tr> 
    <td>5</td> 
    <td>CLIENT KILL</td> 
    <td>此命令关闭指定的客户端连接。</td> 
   </tr> 
  </tbody> 
 </table> 
 <h2 id="h2-16-redis-"><a name="16. Redis管道" class="reference-link"></a><span class="header-link octicon octicon-link"></span>16. Redis管道</h2>
 <p>Redis是一个TCP服务器，支持请求/响应协议。 在Redis中，请求通过以下步骤完成：</p> 
 <ul> 
  <li>客户端向服务器发送查询，并从套接字读取，通常以阻塞的方式，用于服务器响应。</li>
  <li>服务器处理命令并将响应发送回客户端。</li>
 </ul> 
 <h2 id="h2-u7BA1u9053u7684u610Fu4E49"><a name="管道的意义" class="reference-link"></a><span class="header-link octicon octicon-link"></span>管道的意义</h2>
 <p>管道的基本含义是，客户端可以向服务器发送多个请求，而不必等待回复，并最终在一个步骤中读取回复。</p> 
 <h3 id="h3-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h3>
 <p>要检查Redis管道，只需启动Redis实例，并在终端中键入以下命令。</p> 
 <pre><code class="lang-shell">$(echo -en "PING\r\n SET tutorial redis\r\nGET tutorial\r\nINCR 
visitor\r\nINCR visitor\r\nINCR visitor\r\n"; sleep 10) | nc localhost 6379  
+PONG 
+OK 
redis 
:1 
:2 
:3
</code></pre> 
 <p>在上面的例子中，我们将使用PING命令检查Redis连接。这里设置了一个名称为<code>tutorial</code>的字符串，值为<code>redis</code>。 然后得到键值，并增加 <code>visitor</code> 数量三次。 在结果中，我们可以看到所有命令都提交到Redis一次，Redis在一个步骤中提供所有命令的输出。</p> 
 <h2 id="h2-u7BA1u9053u7684u597Du5904"><a name="管道的好处" class="reference-link"></a><span class="header-link octicon octicon-link"></span>管道的好处</h2>
 <p>这种技术的好处是大大提高了协议性能。通过管道从连接到本地主机速度增加五倍，因特网连接的至少快一百倍。</p> 
 <h2 id="h2-17-redis-"><a name="17. Redis分区" class="reference-link"></a><span class="header-link octicon octicon-link"></span>17. Redis分区</h2>
 <p>分区是将数据拆分为多个Redis实例的过程，因此每个实例只包含一部分键。</p> 
 <h2 id="h2-u5206u533Au7684u4F18u70B9"><a name="分区的优点" class="reference-link"></a><span class="header-link octicon octicon-link"></span>分区的优点</h2>
 <ul> 
  <li>它允许更大的数据库，使用更多计算机的内存总和。如果没有分区，则限制为单个计算机可以支持的内存量。</li>
  <li>它允许将计算能力扩展到多个核心和多个计算机，并将网络带宽扩展到多个计算机和网络适配器。</li>
 </ul> 
 <h2 id="h2-u5206u533Au7684u7F3Au70B9"><a name="分区的缺点" class="reference-link"></a><span class="header-link octicon octicon-link"></span>分区的缺点</h2>
 <ul> 
  <li>通常不支持涉及多个键的操作。 例如，如果两个集合存储在映射到不同Redis实例的键中，则不能执行两个集合之间的交集操作。</li>
  <li>不能使用涉及多个键的Redis事务。</li>
  <li>分区粒度是关键，因此不可能使用单个巨大的键(如非常大的排序集合)来分割数据集。</li>
  <li>使用分区时，数据处理更复杂。 例如，必须处理多个<strong>RDB/AOF</strong>文件，并获得数据的备份，您需要聚合来自多个实例和主机的持久性文件。</li>
  <li>添加和删除容量可能很复杂。 例如，Redis Cluster支持大多数透明的数据重新平衡，具有在运行时添加和删除节点的能力。但是，其他系统(如客户端分区和代理)不支持此功能。但可以使用一种叫作<strong>Presharding</strong>的技术来处理这方面的问题。</li>
 </ul> 
 <h2 id="h2-u5206u533Au7C7Bu578B"><a name="分区类型" class="reference-link"></a><span class="header-link octicon octicon-link"></span>分区类型</h2>
 <p>Redis中有两种类型的分区。假设有四个Redis实例：<code>R0</code>，<code>R1</code>，<code>R2</code>，<code>R3</code>以许多代表用户的键，如<code>user：1</code>，<code>user：2</code>，…等等。</p> 
 <h3 id="h3-u8303u56F4u5206u533A"><a name="范围分区" class="reference-link"></a><span class="header-link octicon octicon-link"></span>范围分区</h3>
 <p>范围分区通过将对象的范围映射到特定的Redis实例来实现。假设在上面示例中，从ID 0到ID 10000的用户将进入实例<code>R0</code>，而从ID 10001到ID 20000的用户将进入实例<code>R1</code>，以此类推。</p> 
 <h3 id="h3-u54C8u5E0Cu5206u533A"><a name="哈希分区" class="reference-link"></a><span class="header-link octicon octicon-link"></span>哈希分区</h3>
 <p>在这种类型的分区中，使用散列函数(例如，模函数)将键转换成数字，然后将数据存储在不同的Redis实例中。</p> 
 <h2 id="h2-18-java-redis"><a name="18.     Java连接Redis" class="reference-link"></a><span class="header-link octicon octicon-link"></span>18. Java连接Redis</h2>
 <p>在Java程序中使用Redis之前，需要确保在机器上安装了Redis的Java驱动程序和Java环境。可以先在将Java电脑上并配置好环境。</p> 
 <h2 id="h2-u5B89u88C5"><a name="安装" class="reference-link"></a><span class="header-link octicon octicon-link"></span>安装</h2>
 <p>现在，让我们看看如何设置Redis Java驱动程序。</p> 
 <ul> 
  <li>下载<code>jedis.jar</code> - <a target="_blank" href="http://repo1.maven.org/maven2/redis/clients/jedis/2.1.0/jedis-2.1.0-sources.jar">http://repo1.maven.org/maven2/redis/clients/jedis/2.1.0/jedis-2.1.0-sources.jar</a> ，确保下载的<code>jedis.jar</code>是最新版本。</li>
  <li>将<code>jedis.jar</code>包含到类路径中。</li>
 </ul> 
 <h2 id="h2-java-redis-"><a name="Java连接到Redis服务器" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Java连接到Redis服务器</h2>
 <p>请参考以下一个简单的示例代码 - </p> 
 <pre><code class="lang-java">import redis.clients.jedis.Jedis; 

public class RedisJava { 
   public static void main(String[] args) { 
      //Connecting to Redis server on localhost 
      Jedis jedis = new Jedis("localhost"); 
      System.out.println("Connection to server sucessfully"); 
      //check whether server is running or not 
      System.out.println("Server is running: "+jedis.ping()); 
   } 
}
</code></pre> 
 <p>现在，编译并运行上面的程序来测试与Redis服务器的连接。可以根据需要更改路径。假设<code>jedis.jar</code>的当前版本在当前路径中可以使用。<br>执行上面代码，将生成以下结果 - </p> 
 <pre><code class="lang-java">$javac RedisJava.java 
$java RedisJava 
Connection to server sucessfully 
Server is running: PONG
</code></pre> 
 <h3 id="h3-redis-java-"><a name="Redis Java字符串示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Redis Java字符串示例</h3>
 <pre><code class="lang-java">import redis.clients.jedis.Jedis; 

public class RedisStringJava { 
   public static void main(String[] args) { 
      //Connecting to Redis server on localhost 
      Jedis jedis = new Jedis("localhost"); 
      System.out.println("Connection to server sucessfully"); 
      //set the data in redis string 
      jedis.set("tutorial-name", "Redis tutorial"); 
      // Get the stored data and print it 
      System.out.println("Stored string in redis:: "+ jedis.get("tutorialname")); 
   } 
}
</code></pre> 
 <p>执行上面代码，将生成以下结果 - </p> 
 <pre><code class="lang-java">$javac RedisStringJava.java 
$java RedisStringJava 
Connection to server sucessfully 
Stored string in redis:: Redis tutorial
</code></pre> 
 <h3 id="h3-redis-java-"><a name="Redis Java列表示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Redis Java列表示例</h3>
 <pre><code class="lang-java">import redis.clients.jedis.Jedis; 

public class RedisListJava { 
   public static void main(String[] args) { 
      //Connecting to Redis server on localhost 
      Jedis jedis = new Jedis("localhost"); 
      System.out.println("Connection to server sucessfully"); 

      //store data in redis list 
      jedis.lpush("tutorial-list", "Redis"); 
      jedis.lpush("tutorial-list", "Mongodb"); 
      jedis.lpush("tutorial-list", "Mysql"); 
      // Get the stored data and print it 
      List&lt;String&gt; list = jedis.lrange("tutorial-list", 0 ,5); 

      for(int i = 0; i&lt;list.size(); i++) { 
         System.out.println("Stored string in redis:: "+list.get(i)); 
      } 
   } 
}
</code></pre> 
 <p>执行上面代码，将生成以下结果 - </p> 
 <pre><code class="lang-java">$javac RedisListJava.java 
$java RedisListJava 
Connection to server sucessfully 
Stored string in redis:: Redis 
Stored string in redis:: Mongodb 
Stored string in redis:: Mysql
</code></pre> 
 <h3 id="h3-redis-java-"><a name="Redis Java键示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Redis Java键示例</h3>
 <pre><code class="lang-java">import redis.clients.jedis.Jedis; 

public class RedisKeyJava { 
   public static void main(String[] args) { 
      //Connecting to Redis server on localhost 
      Jedis jedis = new Jedis("localhost"); 
      System.out.println("Connection to server sucessfully"); 
      //store data in redis list 
      // Get the stored data and print it 
      List&lt;String&gt; list = jedis.keys("*"); 

      for(int i = 0; i&lt;list.size(); i++) { 
         System.out.println("List of stored keys:: "+list.get(i)); 
      } 
   } 
}
</code></pre> 
 <p>执行上面代码，将生成以下结果 - </p> 
 <pre><code class="lang-java">$javac RedisKeyJava.java 
$java RedisKeyJava 
Connection to server sucessfully 
List of stored keys:: tutorial-name 
List of stored keys:: tutorial-list
</code></pre> 
 <h2 id="h2-19-php-redis"><a name="19. PHP连接Redis" class="reference-link"></a><span class="header-link octicon octicon-link"></span>19. PHP连接Redis</h2>
 <p>在php程序中使用Redis之前，需要确保在机器上安装了Redis的PHP驱动程序和PHP环境。可以先在将PHP电脑上并配置好环境。</p> 
 <h2 id="h2-u5B89u88C5"><a name="安装" class="reference-link"></a><span class="header-link octicon octicon-link"></span>安装</h2>
 <p>现在，让我们看看如何设置Redis PHP驱动程序。<br>从github库下载<code>phpredis</code>=&gt; <a target="_blank" href="http://github.com/nicolasff/phpredis。">http://github.com/nicolasff/phpredis。</a> 当下载它之后，提取文件到<code>phpredis</code>目录。在Ubuntu上，安装以下扩展。</p> 
 <pre><code class="lang-shell">cd phpredis 
sudo phpize 
sudo ./configure 
sudo make 
sudo make install
</code></pre> 
 <p>现在，将“<code>modules</code>”文件夹的内容复制并粘贴到PHP扩展目录中，并在<code>php.ini</code>中添加以下行。</p> 
 <pre><code class="lang-shell">extension = redis.so
</code></pre> 
 <p>现在，Redis PHP安装完成！</p> 
 <h2 id="h2--redis-"><a name="使用连接到Redis服务器" class="reference-link"></a><span class="header-link octicon octicon-link"></span>使用连接到Redis服务器</h2>
 <pre><code class="lang-php">&lt;?php 
   //Connecting to Redis server on localhost 
   $redis = new Redis(); 
   $redis-&gt;connect('127.0.0.1', 6379); 
   echo "Connection to server sucessfully"; 
   //check whether server is running or not 
   echo "Server is running: ".$redis-&gt;ping(); 
?&gt;
</code></pre> 
 <p>当程序执行时，将产生以下结果。</p> 
 <pre><code class="lang-shell">Connection to server sucessfully 
Server is running: PONG
</code></pre> 
 <h2 id="h2-redis-php-"><a name="Redis PHP字符串示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Redis PHP字符串示例</h2>
 <pre><code class="lang-php">&lt;?php 
   //Connecting to Redis server on localhost 
   $redis = new Redis(); 
   $redis-&gt;connect('127.0.0.1', 6379); 
   echo "Connection to server sucessfully"; 
   //set the data in redis string 
   $redis-&gt;set("tutorial-name", "Redis tutorial"); 
   // Get the stored data and print it 
   echo "Stored string in redis:: " .$redis→get("tutorial-name"); 
?&gt;
</code></pre> 
 <p>执行上面代码，将生成以下结果 - </p> 
 <pre><code class="lang-java">Connection to server sucessfully 
Stored string in redis:: Redis tutorial
</code></pre> 
 <h2 id="h2-redis-php-"><a name="Redis php列表示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Redis php列表示例</h2>
 <pre><code class="lang-php">&lt;?php 
   //Connecting to Redis server on localhost 
   $redis = new Redis(); 
   $redis-&gt;connect('127.0.0.1', 6379); 
   echo "Connection to server sucessfully"; 
   //store data in redis list 
   $redis-&gt;lpush("tutorial-list", "Redis"); 
   $redis-&gt;lpush("tutorial-list", "Mongodb"); 
   $redis-&gt;lpush("tutorial-list", "Mysql");  

   // Get the stored data and print it 
   $arList = $redis-&gt;lrange("tutorial-list", 0 ,5); 
   echo "Stored string in redis:: "; 
   print_r($arList); 
?&gt;
</code></pre> 
 <p>执行上面代码，将生成以下结果 - </p> 
 <pre><code class="lang-php">Connection to server sucessfully 
Stored string in redis:: 
Redis 
Mongodb 
Mysql
</code></pre> 
 <h2 id="h2-redis-php-"><a name="Redis php键示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Redis php键示例</h2>
 <pre><code class="lang-php">&lt;?php 
   //Connecting to Redis server on localhost 
   $redis = new Redis(); 
   $redis-&gt;connect('127.0.0.1', 6379); 
   echo "Connection to server sucessfully"; 
   // Get the stored keys and print it 
   $arList = $redis-&gt;keys("*"); 
   echo "Stored keys in redis:: " 
   print_r($arList); 
?&gt;
</code></pre> 
 <p>执行上面代码，将生成以下结果 - </p> 
 <pre><code class="lang-php">Connection to server sucessfully 
Stored string in redis:: 
tutorial-name 
tutorial-list
</code></pre> 
 <h2 id="h2-20-c-redis"><a name="20. C#连接Redis" class="reference-link"></a><span class="header-link octicon octicon-link"></span>20. C#连接Redis</h2>
 <p> 前面我们已经准备成功开启Redis服务，其端口号为6379，接下来我们就看看如何使用C#语言来操作Redis。就如MongoDB一样，要操作Redis服务，自然就需要下载C#的客户端，这里通过Nuget下载了“ServiceStack.Redis”客户端，引入成功之后，就可以使用C#来对Redis服务进行操作了。</p> 
 <p> 由于Redis一般是用来作为缓存的，也就是一般我们把一些不经常改变的数据通过Redis缓存起来，之后用户的请求就不需要再访问数据库，而可以直接从Redis缓存中直接获取，这样就可以减轻数据库服务器的压力以及加快响应速度。既然是用来做缓存的，也就是通过指定key值来把对应Value保存起来，之后再根据key值来获得之前缓存的值。具体的操作代码如下所示，这里就不过多介绍了。</p> 
 <p>请参考以下代码 - </p> 
 <pre><code class="lang-csharp">class Program
    {
        static void Main(string[] args)
        {
            //在Redis中存储常用的5种数据类型：String,Hash,List,SetSorted set
            var client = new RedisClient("127.0.0.1", 6379);
            //AddString(client);
            //AddHash(client);
            //AddList(client);
            //AddSet(client);
            AddSetSorted(client);

            Console.ReadLine();
        }

        private static void AddString(RedisClient client)
        {
            var timeOut = new TimeSpan(0,0,0,30);
            client.Add("Test", "Learninghard", timeOut);
            while (true)
            {
                if (client.ContainsKey("Test"))
                {
                    Console.WriteLine("String Key: Test -Value: {0}, 当前时间: {1}", client.Get&lt;string&gt;("Test"), DateTime.Now);
                    Thread.Sleep(10000);
                }
                else
                {
                    Console.WriteLine("Value 已经过期了，当前时间：{0}", DateTime.Now);
                    break;
                }
            }

            var person = new Person() {Name = "Learninghard", Age = 26};
            client.Add("lh", person);
            var cachePerson = client.Get&lt;Person&gt;("lh");
            Console.WriteLine("Person's Name is : {0}, Age: {1}", cachePerson.Name, cachePerson.Age);
        }

        private static void AddHash(RedisClient client)
        {
            if (client == null) throw new ArgumentNullException("client");

            client.SetEntryInHash("HashId", "Name", "Learninghard");
            client.SetEntryInHash("HashId", "Age", "26");
            client.SetEntryInHash("HashId", "Sex", "男");

            var hashKeys = client.GetHashKeys("HashId");
            foreach (var key in hashKeys)
            {
                Console.WriteLine("HashId--Key:{0}", key);
            }

            var haskValues = client.GetHashValues("HashId");
            foreach (var value in haskValues)
            {
                Console.WriteLine("HashId--Value:{0}", value);
            }

            var allKeys = client.GetAllKeys(); //获取所有的key。
            foreach (var key in allKeys)
            {
                Console.WriteLine("AllKey--Key:{0}", key);
            }
        }

        private static void AddList(RedisClient client)
        {
            if (client == null) throw new ArgumentNullException("client");

            client.EnqueueItemOnList("QueueListId", "1.Learnghard");  //入队
            client.EnqueueItemOnList("QueueListId", "2.张三");
            client.EnqueueItemOnList("QueueListId", "3.李四");
            client.EnqueueItemOnList("QueueListId", "4.王五");
            var queueCount = client.GetListCount("QueueListId");

            for (var i = 0; i &lt; queueCount; i++)
            {
                Console.WriteLine("QueueListId出队值：{0}", client.DequeueItemFromList("QueueListId"));   //出队(队列先进先出)
            }

            client.PushItemToList("StackListId", "1.Learninghard");  //入栈
            client.PushItemToList("StackListId", "2.张三");
            client.PushItemToList("StackListId", "3.李四");
            client.PushItemToList("StackListId", "4.王五");

            var stackCount = client.GetListCount("StackListId");
            for (var i = 0; i &lt; stackCount; i++)
            {
                Console.WriteLine("StackListId出栈值：{0}", client.PopItemFromList("StackListId"));   //出栈(栈先进后出)
            }
        }

        //它是string类型的无序集合。set是通过hash table实现的，添加，删除和查找,对集合我们可以取并集，交集，差集
        private static void AddSet(RedisClient client)
        {
            if (client == null) throw new ArgumentNullException("client");

            client.AddItemToSet("Set1001", "A");
            client.AddItemToSet("Set1001", "B");
            client.AddItemToSet("Set1001", "C");
            client.AddItemToSet("Set1001", "D");
            var hastset1 = client.GetAllItemsFromSet("Set1001");
            foreach (var item in hastset1)
            {
                Console.WriteLine("Set无序集合Value:{0}", item); //出来的结果是无须的
            }

            client.AddItemToSet("Set1002", "K");
            client.AddItemToSet("Set1002", "C");
            client.AddItemToSet("Set1002", "A");
            client.AddItemToSet("Set1002", "J");
            var hastset2 = client.GetAllItemsFromSet("Set1002");
            foreach (var item in hastset2)
            {
                Console.WriteLine("Set无序集合ValueB:{0}", item); //出来的结果是无须的
            }

            var hashUnion = client.GetUnionFromSets(new string[] { "Set1001", "Set1002" });
            foreach (var item in hashUnion)
            {
                Console.WriteLine("求Set1001和Set1002的并集:{0}", item); //并集
            }

            var hashG = client.GetIntersectFromSets(new string[] { "Set1001", "Set1002" });
            foreach (var item in hashG)
            {
                Console.WriteLine("求Set1001和Set1002的交集:{0}", item);  //交集
            }

            var hashD = client.GetDifferencesFromSet("Set1001", new string[] { "Set1002" });  //[返回存在于第一个集合，但是不存在于其他集合的数据。差集]
            foreach (var item in hashD)
            {
                Console.WriteLine("求Set1001和Set1002的差集:{0}", item);  //差集
            }

        }

        /*
        sorted set 是set的一个升级版本，它在set的基础上增加了一个顺序的属性，这一属性在添加修改.元素的时候可以指定，
        * 每次指定后，zset(表示有序集合)会自动重新按新的值调整顺序。可以理解为有列的表，一列存 value,一列存顺序。操作中key理解为zset的名字.
        */
        private static void AddSetSorted(RedisClient client)
        {
            if (client == null) throw new ArgumentNullException("client");

            client.AddItemToSortedSet("SetSorted1001", "A");
            client.AddItemToSortedSet("SetSorted1001", "B");
            client.AddItemToSortedSet("SetSorted1001", "C");
            var listSetSorted = client.GetAllItemsFromSortedSet("SetSorted1001");
            foreach (var item in listSetSorted)
            {
                Console.WriteLine("SetSorted有序集合{0}", item);
            }

            client.AddItemToSortedSet("SetSorted1002", "A", 400);
            client.AddItemToSortedSet("SetSorted1002", "D", 200);
            client.AddItemToSortedSet("SetSorted1002", "B", 300);

            // 升序获取第一个值:"D"
            var list = client.GetRangeFromSortedSet("SetSorted1002", 0, 0);

            foreach (var item in list)
            {
                Console.WriteLine(item);
            }

            //降序获取第一个值:"A"
            list = client.GetRangeFromSortedSetDesc("SetSorted1002", 0, 0);

            foreach (var item in list)
            {
                Console.WriteLine(item);
            }
        }
    }

    class Person
    {
        public string Name { get; set; }
        public int Age { get; set; }
    }
</code></pre> 
 <p>如何要想查看自己操作是否成功，也可以像MongoDB那样下载一个客户端工具，这里推荐一款Redis Desktop Manager。这个工具就相当于SQL Server的客户端工具一样。通过这款工具可以查看Redis服务器中保存的数据和对应格式。其使用也非常简单，只需要添加一个Redis服务连接即可。该工具的下载地址为：<a target="_blank" href="http://pan.baidu.com/s/1sjp55Ul">http://pan.baidu.com/s/1sjp55Ul</a></p>
 <br>      
</div></body></html>