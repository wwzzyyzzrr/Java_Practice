<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Cassandra的架构</h1><div style="width:100%;float:left;" class="article-content">   
 <p>Cassandra旨在处理多个节点之间的大数据工作负载，而无需担心单点故障。 它在其节点之间具有对等分布式系统，数据分布在集群中的所有节点上。</p> 
 <ul> 
  <li>在Cassandra中，每个节点是独立的，同时与其他节点互连。 集群中的所有节点都扮演着相同的角色。</li>
  <li>集群中的每个节点都可以接受读取和写入请求，而不管数据实际位于集群中的位置。</li>
  <li>在一个节点发生故障的情况下，可以从网络中的其他节点提供读/写请求。</li>
 </ul> 
 <h2 id="h2-cassandra-"><a name="Cassandra中的数据复制" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Cassandra中的数据复制</h2>
 <p>在Cassandra中，集群中的节点作为给定数据片段的副本。 如果某些节点以超时值响应，Cassandra会将最新的值返回给客户端。 返回最新值后，Cassandra会在后台执行读取修复，以更新旧值。</p> 
 <p>请参阅以下图示，以了解Cassandra如何在集群中的节点之间使用数据复制的原理图，以确保没有单点故障。</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201704/1604/791110439_68337.png" alt=""></p> 
 <h2 id="h2-cassandra-"><a name="Cassandra的组成部分" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Cassandra的组成部分</h2>
 <p>Cassandra的主要组成部分主要有：</p> 
 <ul> 
  <li><strong>节点(Node)</strong>：Cassandra节点是存储数据的地方。</li>
  <li><strong>数据中心(Data center)</strong>：数据中心是相关节点的集合。</li>
  <li><strong>集群(Cluster)</strong>：集群是包含一个或多个数据中心的组件。</li>
  <li><strong>提交日志(Commit log)</strong>：在Cassandra中，提交日志是一个崩溃恢复机制。 每个写入操作都将写入提交日志。</li>
  <li><strong>存储表(Mem-table)</strong>：内存表是内存驻留的数据结构。 提交日志后，数据将被写入内存表。 有时，对于单列系列，将有多个内容表。</li>
  <li><strong>SSTable</strong>：当内容达到阈值时，它是从内存表刷新数据的磁盘文件。</li>
  <li><strong>布鲁姆过滤器(Bloom filter)</strong>：这些只是快速，非确定性的，用于测试元素是否是集合成员的算法。 它是一种特殊的缓存。 每次查询后都会访问Bloom过滤器。</li>
 </ul> 
 <h2 id="h2-cassandra-"><a name="Cassandra查询语言" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Cassandra查询语言</h2>
 <p>Cassandra查询语言(CQL)用于通过其节点访问Cassandra。 CQL将数据库(Keyspace)视为表的容器。 程序员使用<code>cqlsh</code>：提示使用CQL或单独的应用程序语言驱动程序。<br>客户端可以接近任何节点进行读写操作。 该节点(协调器)在客户机和保存数据的节点之间扮演代理。</p> 
 <h2 id="h2-u5199u64CDu4F5C"><a name="写操作" class="reference-link"></a><span class="header-link octicon octicon-link"></span>写操作</h2>  
 <p>节点的每个写入活动都由写入节点的提交日志捕获。 之后，数据将被捕获并存储在内存表中。 每当内存表已满时，数据将被写入<code>SStable</code>数据文件。 所有写入在整个集群中自动分区和复制。 Cassandra定期整合SSTables，丢弃不必要的数据。</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201704/1604/251110445_61946.png" alt=""></p> 
 <h2 id="h2-u8BFBu64CDu4F5C"><a name="读操作" class="reference-link"></a><span class="header-link octicon octicon-link"></span>读操作</h2>
 <p>在读操作中，Cassandra从<code>mem-table</code>中获取值，并检查<code>bloom</code>过滤器以找到包含所需数据的适当SSTable。</p> 
 <p>有三种类型的读请求被协调者发送给副本。</p> 
 <ul> 
  <li>直接请求</li>
  <li>摘要要求</li>
  <li>读修复请求</li>
 </ul> 
 <p>协调器发送的直接请求到副本中的一个。 之后，协调器将摘要请求发送到由一致性级别指定的副本数，并检查返回的数据是否是更新的数据。</p> 
 <p>之后，协调器将所有剩余的副本发送摘要请求。 如果任何节点发出过期值，后台读修复请求将更新该数据。 这个过程称为读修复机制。</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201704/1704/580120406_72497.png" alt=""></p>
 <br>      
</div></body></html>