<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">PostgreSQL锁</h1><div style="width:100%;float:left;" class="article-content">   
 <p>锁或独占锁或写锁阻止用户修改行或整个表。 在<code>UPDATE</code>和<code>DELETE</code>修改的行在事务的持续时间内被自动独占锁定。 这将阻止其他用户更改行，直到事务被提交或回退。</p> 
 <p>用户必须等待其他用户当他们都尝试修改同一行时。 如果他们修改不同的行，不需要等待。 SELECT查询不必等待。</p> 
 <p>数据库自动执行锁定。 然而，在某些情况下，必须手动控制锁定。 手动锁定可以通过使用<code>LOCK</code>命令完成。 它允许指定事务的锁类型和范围。</p> 
 <h2 id="h2-lock-"><a name="LOCK命令的语法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>LOCK命令的语法</h2>
 <p><code>LOCK</code>命令的基本语法如下：</p> 
 <pre><code class="lang-sql">LOCK [ TABLE ]
name
 IN
lock_mode
</code></pre> 
 <ul> 
  <li><code>name</code>：要锁定的现有表的锁名称(可选模式限定)。 如果在表名之前指定了<code>ONLY</code>，则仅该表被锁定 如果未指定<code>ONLY</code>，则表及其所有后代表(如果有)被锁定。</li>
  <li><code>lock_mode</code>：锁模式指定此锁与之冲突的锁。 如果未指定锁定模式，则使用最严格的访问模式<code>ACCESS EXCLUSIVE</code>。 可能的值是：<code>ACCESS SHARE</code>，<code>ROW SHARE</code>，<code>ROW EXCLUSIVE</code>，<code>SHARE UPDATE EXCLUSIVE</code>，<code>SHARE</code>，<code>SHARE ROW EXCLUSIVE</code>，<code>EXCLUSIVE</code>，<code>ACCESS EXCLUSIVE</code>。</li>
 </ul> 
 <h2 id="h2-u6B7Bu9501"><a name="死锁" class="reference-link"></a><span class="header-link octicon octicon-link"></span>死锁</h2>
 <p>当两个事务正在等待彼此完成操作时，可能会发生死锁。 虽然PostgreSQL可以检测到它们并使用<code>ROLLBACK</code>结束，但死锁仍然可能不方便。 为了防止您的应用程序遇到此问题，请确保以这样的方式进行设计，以使其以相同的顺序锁定对象。</p> 
 <h2 id="h2-u54A8u8BE2u9501"><a name="咨询锁" class="reference-link"></a><span class="header-link octicon octicon-link"></span>咨询锁</h2>
 <p>PostgreSQL提供了创建具有应用程序定义含义的锁的方法。这些称为咨询锁(劝告锁,英文为：<strong>advisory locks</strong>)。 由于系统不强制使用它，因此应用程序正确使用它们。 咨询锁可用于锁定针对MVCC模型策略。</p> 
 <p>例如，咨询锁的常见用途是模拟所谓的“平面文件”数据管理系统的典型的悲观锁定策略。 虽然存储在表中的标志可以用于相同的目的，但是建议锁更快，避免了表的膨胀，并且在会话结束时被服务器自动清除。</p> 
 <h2 id="h2-u793Au4F8B"><a name="示例" class="reference-link"></a><span class="header-link octicon octicon-link"></span>示例</h2>
 <p>考虑表<code>COMPANY</code>有以下记录：</p>   
 <pre><code class="lang-sql">testdb# select * from COMPANY;
 id | name  | age | address   | salary
----+-------+-----+-----------+--------
  1 | Paul  |  32 | California|  20000
  2 | Allen |  25 | Texas     |  15000
  3 | Teddy |  23 | Norway    |  20000
  4 | Mark  |  25 | Rich-Mond |  65000
  5 | David |  27 | Texas     |  85000
  6 | Kim   |  22 | South-Hall|  45000
  7 | James |  24 | Houston   |  10000
(7 rows)
</code></pre> 
 <p>以下示例在<code>ACCESS EXCLUSIVE</code>模式下将<code>COMPANY</code>表锁定在<code>yiibai_db</code>数据库中。 <code>LOCK</code>语句仅在事务模式下工作：</p> 
 <pre><code class="lang-sql">yiibai_db=#BEGIN;
LOCK TABLE company1 IN ACCESS EXCLUSIVE MODE;
</code></pre> 
 <p>PostgreSQL上面的语句将产生以下结果：</p> 
 <pre><code class="lang-shell">LOCK TABLE
</code></pre> 
 <p>上述消息表示表被锁定，直到事务结束并完成事务，必须回滚或提交事务。</p>
 <br>      
</div></body></html>