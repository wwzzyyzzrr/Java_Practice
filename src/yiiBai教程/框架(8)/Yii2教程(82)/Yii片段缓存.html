<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Yii片段缓存</h1><div style="width:100%;float:left;" class="article-content">   
 <div> 
  <div>
    片段缓存提供商网页的一个片段缓存。 
  </div> 
 </div> 
 <div> 
  <div>
    第1步&nbsp;-&nbsp;添加一个新的&nbsp;actionFragmentCaching()方法到&nbsp;SiteController&nbsp;控制器中。 
  </div> 
  <pre>public function actionFragmentCaching() {
   $user = new MyUser();
   $user-&gt;name = "cached user name";
   $user-&gt;email = "cacheduseremail@yiibai.com";
   $user-&gt;save();
   $models = MyUser::find()-&gt;all();
   return $this-&gt;render('cachedview', ['models' =&gt; $models]);
}</pre> 
  <div>
    在上面的代码中，我们创建了一个新用户，并显示在一个&nbsp;cachedview&nbsp;视图文件中。 
  </div> 
  <div>
    第2步&nbsp;-&nbsp;现在，创建一个新文件&nbsp;cachedview.php&nbsp;在&nbsp;views/site&nbsp;文件夹中。 
  </div> 
  <pre>&lt;?php if ($this-&gt;beginCache('cachedview')) { ?&gt;
   &lt;?php foreach ($models as $model): ?&gt;
      &lt;?= $model-&gt;id; ?&gt;
      &lt;?= $model-&gt;name; ?&gt;
      &lt;?= $model-&gt;email; ?&gt;
      &lt;br/&gt;
   &lt;?php endforeach; ?&gt;
&lt;?php $this-&gt;endCache(); } ?&gt;
&lt;?php echo "Count:", \app\models\MyUser::find()-&gt;count(); ?&gt;</pre> 
  <div>
    我们在一对&nbsp;beginCache()和&nbsp;endCache()方法中包围的内容生成逻辑。 
  </div> 
  <div>
    如在高速缓存中找到内容，beginCache()方法将呈现它。 
  </div> 
  <div>
    第3步&nbsp;-&nbsp;打开&nbsp;
   <a target="_blank" href="http://localhost:8080/index.php?r=site/fragment-caching">http://localhost:8080/index.php?r=site/fragment-caching</a>&nbsp;重新加载页面。将输出以下内容。
   <br> 
   <img src="/uploads/tutorial/20160605/1-160605222U4K1.png" width="765" height="536" title="Yii片段缓存" alt="Yii片段缓存">
   <br> 
  </div> 
  <div>
    请注意，beginCache()&nbsp;和&nbsp;endCache()&nbsp;之前的内容已被缓存。在数据库中，示例中有共&nbsp;13&nbsp;用户，但只有12个被显示。 
  </div> 
  <h2> 
   <div>
     页面缓存 
   </div> </h2> 
  <div>
    页面缓存提供整个网页的内容缓存。页面缓存是由&nbsp;yii\filter\PageCache&nbsp;类支持。 
  </div> 
  <div>
    步骤1&nbsp;-&nbsp;在&nbsp;SiteController&nbsp;修改&nbsp;behaviors()函数。 
  </div> 
  <pre>public function behaviors() {
   return [
      'access' =&gt; [
         'class' =&gt; AccessControl::className(),
         'only' =&gt; ['logout'],
         'rules' =&gt; [
            [
               'actions' =&gt; ['logout'],
               'allow' =&gt; true,
               'roles' =&gt; ['@'],
            ],
         ],
      ],
      'verbs' =&gt; [
         'class' =&gt; VerbFilter::className(),
         'actions' =&gt; [
            'logout' =&gt; ['post'],
         ],
      ],
      [
         'class' =&gt; 'yii\filters\PageCache',
         'only' =&gt; ['index'],
         'duration' =&gt; 60
      ],
   ];
}</pre> 
  <div>
    上面的代码缓存索引页为 60 秒。 
  </div> 
  <div>
    第2步&nbsp;-&nbsp;打开&nbsp;
   <a target="_blank" href="http://localhost:8080/index.php?r=site/index">http://localhost:8080/index.php?r=site/index</a>&nbsp;然后，修改索引视图文件的消息内容。
   <br> 
   <img src="/uploads/tutorial/20160605/1-16060522291W95.png" alt="">
   <br> 
  </div> 
  <div>
    如果重新载入页面，因为页面被缓存，不会注意到有任何更改。等待一分钟，然后再重新加载页面。 
  </div> 
  <h2> HTTP缓存 </h2> 
  <div>
    Web应用程序也可以使用客户端的缓存。要使用它需要为控制器中动作配置&nbsp;yii\filter\HttpCache&nbsp;过滤器。 
  </div> 
  <div>
    在&nbsp;Last-Modified头&nbsp;使用时间戳来指示该页面是否已被修改。 
  </div> 
  <div>
    第1步&nbsp;-&nbsp;要启用发送&nbsp;Last-Modified&nbsp;头，配置&nbsp;yii\filter\HttpCache::$lastModified&nbsp;属性。 
  </div>   
  <pre>public function behaviors() {
   return [
      [
         'class' =&gt; 'yii\filters\HttpCache',
         'only' =&gt; ['index'],
         'lastModified' =&gt; function ($action, $params) {
            $q = new \yii\db\Query();
            return $q-&gt;from('news')-&gt;max('created_at');
         },
      ],
   ];
}</pre> 
  <div>
    在上面的代码中，我们只有在&nbsp;index&nbsp;动作中启用了HTTP缓存。 
  </div> 
  <div>
    应生成基于用户的&nbsp;name&nbsp;和&nbsp;email&nbsp;表头的&nbsp;HTTP&nbsp;标头。 
  </div> 
  <div>
    当浏览器中首次打开&nbsp;index&nbsp;动作页面，则在服务器端生成内容并发送给浏览器端。 
  </div> 
  <div>
    第二次，如果&nbsp;name&nbsp;或&nbsp;email&nbsp;没有改变，服务器将不能再生成页面。 
  </div> 
  <div>
    ETag头提供表示页面内容的哈希值。如果页面被改变时，哈希也将被改变。 
  </div> 
  <div>
    第2步&nbsp;-&nbsp;要启用发送ETag头，需要配置&nbsp;yii\filters\HttpCache::$etagSeed&nbsp;属性。 
  </div> 
  <pre>public function behaviors() {
   return [
      [
         'class' =&gt; 'yii\filters\HttpCache',
         'only' =&gt; ['index'],
         'etagSeed' =&gt; function ($action, $params) {
            $user = $this-&gt;findModel(\Yii::$app-&gt;request-&gt;get('id'));
            return serialize([$user-&gt;name, $user-&gt;email]);
         },
      ],
   ];
}</pre> 
  <div>
    在上面的代码中，我们只有在&nbsp;index&nbsp;动作中启用了HTTP缓存。 
  </div> 
  <div>
    应生成基于用户的&nbsp;name&nbsp;和&nbsp;email&nbsp;表头的&nbsp;HTTP&nbsp;标头。 
  </div> 
  <div>
    当浏览器中首次打开&nbsp;index&nbsp;动作页面，则在服务器端生成内容并发送给浏览器端。 
  </div> 
  <div>
    第二次，如果&nbsp;name&nbsp;或&nbsp;email&nbsp;没有改变，服务器将不能再生成页面。 
  </div> 
  <div> 
   <br> 
  </div> 
 </div>
 <br>      
</div></body></html>