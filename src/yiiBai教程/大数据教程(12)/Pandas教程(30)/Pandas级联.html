<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Pandas级联</h1><div style="width:100%;float:left;" class="article-content">   
 <p><strong>Pandas</strong>提供了各种工具(功能)，可以轻松地将<code>Series</code>，<code>DataFrame</code>和<code>Panel</code>对象组合在一起。</p> 
 <pre><code class="lang-python">pd.concat(objs,axis=0,join='outer',join_axes=None,
ignore_index=False)
</code></pre> 
 <p>其中，</p> 
 <ul> 
  <li><em>objs</em> - 这是Series，DataFrame或Panel对象的序列或映射。</li>
  <li><em>axis</em> - <code>{0，1，...}</code>，默认为<code>0</code>，这是连接的轴。</li>
  <li><em>join</em> - <code>{'inner', 'outer'}</code>，默认<code>inner</code>。如何处理其他轴上的索引。联合的外部和交叉的内部。</li>
  <li><em>ignore_index</em> − 布尔值，默认为<code>False</code>。如果指定为<code>True</code>，则不要使用连接轴上的索引值。结果轴将被标记为：<code>0，...，n-1</code>。</li>
  <li><em>join_axes</em> - 这是Index对象的列表。用于其他<code>(n-1)</code>轴的特定索引，而不是执行内部/外部集逻辑。</li>
 </ul> 
 <h2 id="h2-u8FDEu63A5u5BF9u8C61"><a name="连接对象" class="reference-link"></a><span class="header-link octicon octicon-link"></span>连接对象</h2>
 <p><code>concat()</code>函数完成了沿轴执行级联操作的所有重要工作。下面代码中，创建不同的对象并进行连接。</p> 
 <pre><code class="lang-python">import pandas as pd
one = pd.DataFrame({
         'Name': ['Alex', 'Amy', 'Allen', 'Alice', 'Ayoung'],
         'subject_id':['sub1','sub2','sub4','sub6','sub5'],
         'Marks_scored':[98,90,87,69,78]},
         index=[1,2,3,4,5])
two = pd.DataFrame({
         'Name': ['Billy', 'Brian', 'Bran', 'Bryce', 'Betty'],
         'subject_id':['sub2','sub4','sub3','sub6','sub5'],
         'Marks_scored':[89,80,79,97,88]},
         index=[1,2,3,4,5])
rs = pd.concat([one,two])
print(rs)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">   Marks_scored    Name subject_id
1            98    Alex       sub1
2            90     Amy       sub2
3            87   Allen       sub4
4            69   Alice       sub6
5            78  Ayoung       sub5
1            89   Billy       sub2
2            80   Brian       sub4
3            79    Bran       sub3
4            97   Bryce       sub6
5            88   Betty       sub5
</code></pre> 
 <p>假设想把特定的键与每个碎片的DataFrame关联起来。可以通过使用键参数来实现这一点 -</p> 
 <pre><code class="lang-python">import pandas as pd
one = pd.DataFrame({
         'Name': ['Alex', 'Amy', 'Allen', 'Alice', 'Ayoung'],
         'subject_id':['sub1','sub2','sub4','sub6','sub5'],
         'Marks_scored':[98,90,87,69,78]},
         index=[1,2,3,4,5])
two = pd.DataFrame({
         'Name': ['Billy', 'Brian', 'Bran', 'Bryce', 'Betty'],
         'subject_id':['sub2','sub4','sub3','sub6','sub5'],
         'Marks_scored':[89,80,79,97,88]},
         index=[1,2,3,4,5])
rs = pd.concat([one,two],keys=['x','y'])
print(rs)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">     Marks_scored    Name subject_id
x 1            98    Alex       sub1
  2            90     Amy       sub2
  3            87   Allen       sub4
  4            69   Alice       sub6
  5            78  Ayoung       sub5
y 1            89   Billy       sub2
  2            80   Brian       sub4
  3            79    Bran       sub3
  4            97   Bryce       sub6
  5            88   Betty       sub5
</code></pre> 
 <p>结果的索引是重复的; 每个索引重复。如果想要生成的对象必须遵循自己的索引，请将<code>ignore_index</code>设置为<code>True</code>。参考以下示例代码 - </p> 
 <pre><code class="lang-python">import pandas as pd
one = pd.DataFrame({
         'Name': ['Alex', 'Amy', 'Allen', 'Alice', 'Ayoung'],
         'subject_id':['sub1','sub2','sub4','sub6','sub5'],
         'Marks_scored':[98,90,87,69,78]},
         index=[1,2,3,4,5])
two = pd.DataFrame({
         'Name': ['Billy', 'Brian', 'Bran', 'Bryce', 'Betty'],
         'subject_id':['sub2','sub4','sub3','sub6','sub5'],
         'Marks_scored':[89,80,79,97,88]},
         index=[1,2,3,4,5])
rs = pd.concat([one,two],keys=['x','y'],ignore_index=True)

print(rs)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">   Marks_scored    Name subject_id
0            98    Alex       sub1
1            90     Amy       sub2
2            87   Allen       sub4
3            69   Alice       sub6
4            78  Ayoung       sub5
5            89   Billy       sub2
6            80   Brian       sub4
7            79    Bran       sub3
8            97   Bryce       sub6
9            88   Betty       sub5
</code></pre> 
 <p>观察，索引完全改变，键也被覆盖。如果需要沿<code>axis=1</code>添加两个对象，则会添加新列。</p> 
 <pre><code class="lang-python">import pandas as pd
one = pd.DataFrame({
         'Name': ['Alex', 'Amy', 'Allen', 'Alice', 'Ayoung'],
         'subject_id':['sub1','sub2','sub4','sub6','sub5'],
         'Marks_scored':[98,90,87,69,78]},
         index=[1,2,3,4,5])
two = pd.DataFrame({
         'Name': ['Billy', 'Brian', 'Bran', 'Bryce', 'Betty'],
         'subject_id':['sub2','sub4','sub3','sub6','sub5'],
         'Marks_scored':[89,80,79,97,88]},
         index=[1,2,3,4,5])
rs = pd.concat([one,two],axis=1)
print(rs)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">   Marks_scored    Name subject_id  Marks_scored   Name subject_id
1            98    Alex       sub1            89  Billy       sub2
2            90     Amy       sub2            80  Brian       sub4
3            87   Allen       sub4            79   Bran       sub3
4            69   Alice       sub6            97  Bryce       sub6
5            78  Ayoung       sub5            88  Betty       sub5
</code></pre> 
 <h4 id="h4-u4F7Fu7528u9644u52A0u8FDEu63A5"><a name="使用附加连接" class="reference-link"></a><span class="header-link octicon octicon-link"></span>使用附加连接</h4>
 <p>连接的一个有用的快捷方式是在Series和DataFrame实例的<code>append</code>方法。这些方法实际上早于<code>concat()</code>方法。 它们沿<code>axis=0</code>连接，即索引 -</p> 
 <pre><code class="lang-python">import pandas as pd
one = pd.DataFrame({
         'Name': ['Alex', 'Amy', 'Allen', 'Alice', 'Ayoung'],
         'subject_id':['sub1','sub2','sub4','sub6','sub5'],
         'Marks_scored':[98,90,87,69,78]},
         index=[1,2,3,4,5])
two = pd.DataFrame({
         'Name': ['Billy', 'Brian', 'Bran', 'Bryce', 'Betty'],
         'subject_id':['sub2','sub4','sub3','sub6','sub5'],
         'Marks_scored':[89,80,79,97,88]},
         index=[1,2,3,4,5])
rs = one.append(two)
print(rs)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">   Marks_scored    Name subject_id
1            98    Alex       sub1
2            90     Amy       sub2
3            87   Allen       sub4
4            69   Alice       sub6
5            78  Ayoung       sub5
1            89   Billy       sub2
2            80   Brian       sub4
3            79    Bran       sub3
4            97   Bryce       sub6
5            88   Betty       sub5
</code></pre> 
 <p><code>append()</code>函数也可以带多个对象 -</p> 
 <pre><code class="lang-python">import pandas as pd

one = pd.DataFrame({
         'Name': ['Alex', 'Amy', 'Allen', 'Alice', 'Ayoung'],
         'subject_id':['sub1','sub2','sub4','sub6','sub5'],
         'Marks_scored':[98,90,87,69,78]},
         index=[1,2,3,4,5])

two = pd.DataFrame({
         'Name': ['Billy', 'Brian', 'Bran', 'Bryce', 'Betty'],
         'subject_id':['sub2','sub4','sub3','sub6','sub5'],
         'Marks_scored':[89,80,79,97,88]},
         index=[1,2,3,4,5])
rs = one.append([two,one,two])
print(rs)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p>   
 <pre><code class="lang-shell">   Marks_scored    Name subject_id
1            98    Alex       sub1
2            90     Amy       sub2
3            87   Allen       sub4
4            69   Alice       sub6
5            78  Ayoung       sub5
1            89   Billy       sub2
2            80   Brian       sub4
3            79    Bran       sub3
4            97   Bryce       sub6
5            88   Betty       sub5
1            98    Alex       sub1
2            90     Amy       sub2
3            87   Allen       sub4
4            69   Alice       sub6
5            78  Ayoung       sub5
1            89   Billy       sub2
2            80   Brian       sub4
3            79    Bran       sub3
4            97   Bryce       sub6
5            88   Betty       sub5
</code></pre> 
 <h2 id="h2-u65F6u95F4u5E8Fu5217"><a name="时间序列" class="reference-link"></a><span class="header-link octicon octicon-link"></span>时间序列</h2>
 <p><em>Pandas</em>为时间序列数据的工作时间提供了一个强大的工具，尤其是在金融领域。在处理时间序列数据时，我们经常遇到以下情况 -</p> 
 <ul> 
  <li>生成时间序列</li>
  <li>将时间序列转换为不同的频率</li>
 </ul> 
 <p><em>Pandas</em>提供了一个相对紧凑和自包含的工具来执行上述任务。</p> 
 <h3 id="h3-u83B7u53D6u5F53u524Du65F6u95F4"><a name="获取当前时间" class="reference-link"></a><span class="header-link octicon octicon-link"></span>获取当前时间</h3>
 <p><code>datetime.now()</code>用于获取当前的日期和时间。</p> 
 <pre><code class="lang-python">import pandas as pd
print pd.datetime.now()
</code></pre> 
 <p>上述代码执行结果如下 - </p> 
 <pre><code class="lang-shell">2017-11-03 02:17:45.997992
</code></pre> 
 <h4 id="h4-u521Bu5EFAu4E00u4E2Au65F6u95F4u6233"><a name="创建一个时间戳" class="reference-link"></a><span class="header-link octicon octicon-link"></span>创建一个时间戳</h4>
 <p>时间戳数据是时间序列数据的最基本类型，它将数值与时间点相关联。 对于<em>Pandas</em>对象来说，意味着使用时间点。举个例子 -</p> 
 <pre><code class="lang-python">import pandas as pd
time = pd.Timestamp('2018-11-01')
print(time)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">2018-11-01 00:00:00
</code></pre> 
 <p>也可以转换整数或浮动时期。这些的默认单位是纳秒(因为这些是如何存储时间戳的)。 然而，时代往往存储在另一个可以指定的单元中。 再举一个例子 - </p> 
 <pre><code class="lang-python">import pandas as pd
time = pd.Timestamp(1588686880,unit='s')
print(time)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">2020-05-05 13:54:40
</code></pre> 
 <h4 id="h4-u521Bu5EFAu4E00u4E2Au65F6u95F4u8303u56F4"><a name="创建一个时间范围" class="reference-link"></a><span class="header-link octicon octicon-link"></span>创建一个时间范围</h4>
 <pre><code class="lang-python">import pandas as pd

time = pd.date_range("12:00", "23:59", freq="30min").time
print(time)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">[datetime.time(12, 0) datetime.time(12, 30) datetime.time(13, 0)
 datetime.time(13, 30) datetime.time(14, 0) datetime.time(14, 30)
 datetime.time(15, 0) datetime.time(15, 30) datetime.time(16, 0)
 datetime.time(16, 30) datetime.time(17, 0) datetime.time(17, 30)
 datetime.time(18, 0) datetime.time(18, 30) datetime.time(19, 0)
 datetime.time(19, 30) datetime.time(20, 0) datetime.time(20, 30)
 datetime.time(21, 0) datetime.time(21, 30) datetime.time(22, 0)
 datetime.time(22, 30) datetime.time(23, 0) datetime.time(23, 30)]
</code></pre> 
 <h4 id="h4-u6539u53D8u65F6u95F4u7684u9891u7387"><a name="改变时间的频率" class="reference-link"></a><span class="header-link octicon octicon-link"></span>改变时间的频率</h4>
 <pre><code class="lang-python">import pandas as pd

time = pd.date_range("12:00", "23:59", freq="H").time
print(time)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">[datetime.time(12, 0) datetime.time(13, 0) datetime.time(14, 0)
 datetime.time(15, 0) datetime.time(16, 0) datetime.time(17, 0)
 datetime.time(18, 0) datetime.time(19, 0) datetime.time(20, 0)
 datetime.time(21, 0) datetime.time(22, 0) datetime.time(23, 0)]
</code></pre> 
 <h4 id="h4-u8F6Cu6362u4E3Au65F6u95F4u6233"><a name="转换为时间戳" class="reference-link"></a><span class="header-link octicon octicon-link"></span>转换为时间戳</h4>
 <p>要转换类似日期的对象(例如字符串，时代或混合)的序列或类似列表的对象，可以使用<code>to_datetime</code>函数。当传递时将返回一个Series(具有相同的索引)，而类似列表被转换为<code>DatetimeIndex</code>。 看看下面的例子 -</p> 
 <pre><code class="lang-python">import pandas as pd

time = pd.to_datetime(pd.Series(['Jul 31, 2009','2019-10-10', None]))
print(time)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">0   2009-07-31
1   2019-10-10
2          NaT
dtype: datetime64[ns]
</code></pre> 
 <p><code>NaT</code>表示不是一个时间的值(相当于<code>NaN</code>)</p> 
 <p>举一个例子，</p> 
 <pre><code class="lang-python">import pandas as pd
import pandas as pd
time = pd.to_datetime(['2009/11/23', '2019.12.31', None])
print(time)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">DatetimeIndex(['2009-11-23', '2019-12-31', 'NaT'], dtype='datetime64[ns]', freq=None)
</code></pre>
 <br>      
</div></body></html>