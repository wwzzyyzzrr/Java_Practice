<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Pandas分组（GroupBy）</h1><div style="width:100%;float:left;" class="article-content">   
 <p>任何分组(<em>groupby</em>)操作都涉及原始对象的以下操作之一。它们是 - </p> 
 <ul> 
  <li>分割对象</li>
  <li>应用一个函数</li>
  <li>结合的结果</li>
 </ul> 
 <p>在许多情况下，我们将数据分成多个集合，并在每个子集上应用一些函数。在应用函数中，可以执行以下操作 -</p> 
 <ul> 
  <li><em>聚合</em> - 计算汇总统计</li>
  <li><em>转换</em> - 执行一些特定于组的操作</li>
  <li><em>过滤</em> - 在某些情况下丢弃数据</li>
 </ul> 
 <p>下面来看看创建一个DataFrame对象并对其执行所有操作 -</p> 
 <pre><code class="lang-python">import pandas as pd

ipl_data = {'Team': ['Riders', 'Riders', 'Devils', 'Devils', 'Kings',
         'kings', 'Kings', 'Kings', 'Riders', 'Royals', 'Royals', 'Riders'],
         'Rank': [1, 2, 2, 3, 3,4 ,1 ,1,2 , 4,1,2],
         'Year': [2014,2015,2014,2015,2014,2015,2016,2017,2016,2014,2015,2017],
         'Points':[876,789,863,673,741,812,756,788,694,701,804,690]}
df = pd.DataFrame(ipl_data)

print (df)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">    Points  Rank    Team  Year
0      876     1  Riders  2014
1      789     2  Riders  2015
2      863     2  Devils  2014
3      673     3  Devils  2015
4      741     3   Kings  2014
5      812     4   kings  2015
6      756     1   Kings  2016
7      788     1   Kings  2017
8      694     2  Riders  2016
9      701     4  Royals  2014
10     804     1  Royals  2015
11     690     2  Riders  2017
</code></pre> 
 <h2 id="h2-u5C06u6570u636Eu62C6u5206u6210u7EC4"><a name="将数据拆分成组" class="reference-link"></a><span class="header-link octicon octicon-link"></span>将数据拆分成组</h2>
 <p>Pandas对象可以分成任何对象。有多种方式来拆分对象，如 -</p> 
 <ul> 
  <li><em>obj.groupby(‘key’)</em></li>
  <li><em>obj.groupby([‘key1’,’key2’])</em></li>
  <li><em>obj.groupby(key,axis=1)</em></li>
 </ul> 
 <p>现在来看看如何将分组对象应用于DataFrame对象</p> 
 <p><strong>示例</strong></p> 
 <pre><code class="lang-python">import pandas as pd

ipl_data = {'Team': ['Riders', 'Riders', 'Devils', 'Devils', 'Kings',
         'kings', 'Kings', 'Kings', 'Riders', 'Royals', 'Royals', 'Riders'],
         'Rank': [1, 2, 2, 3, 3,4 ,1 ,1,2 , 4,1,2],
         'Year': [2014,2015,2014,2015,2014,2015,2016,2017,2016,2014,2015,2017],
         'Points':[876,789,863,673,741,812,756,788,694,701,804,690]}
df = pd.DataFrame(ipl_data)

print (df.groupby('Team'))
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">&lt;pandas.core.groupby.DataFrameGroupBy object at 0x00000245D60AD518&gt;
</code></pre> 
 <h2 id="h2-u67E5u770Bu5206u7EC4"><a name="查看分组" class="reference-link"></a><span class="header-link octicon octicon-link"></span>查看分组</h2>
 <pre><code class="lang-python">import pandas as pd
ipl_data = {'Team': ['Riders', 'Riders', 'Devils', 'Devils', 'Kings',
         'kings', 'Kings', 'Kings', 'Riders', 'Royals', 'Royals', 'Riders'],
         'Rank': [1, 2, 2, 3, 3,4 ,1 ,1,2 , 4,1,2],
         'Year': [2014,2015,2014,2015,2014,2015,2016,2017,2016,2014,2015,2017],           'Points':[876,789,863,673,741,812,756,788,694,701,804,690]}
df = pd.DataFrame(ipl_data)

print (df.groupby('Team').groups)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 -</p> 
 <pre><code class="lang-shell">{
'Devils': Int64Index([2, 3], dtype='int64'), 
'Kings': Int64Index([4, 6, 7], dtype='int64'), 
'Riders': Int64Index([0, 1, 8, 11], dtype='int64'), 
'Royals': Int64Index([9, 10], dtype='int64'), 
'kings': Int64Index([5], dtype='int64')
}
</code></pre> 
 <p><strong>示例</strong></p> 
 <p>按多列分组 -</p> 
 <pre><code class="lang-python">import pandas as pd
ipl_data = {'Team': ['Riders', 'Riders', 'Devils', 'Devils', 'Kings',
         'kings', 'Kings', 'Kings', 'Riders', 'Royals', 'Royals', 'Riders'],
         'Rank': [1, 2, 2, 3, 3,4 ,1 ,1,2 , 4,1,2],
         'Year': [2014,2015,2014,2015,2014,2015,2016,2017,2016,2014,2015,2017],
         'Points':[876,789,863,673,741,812,756,788,694,701,804,690]}
df = pd.DataFrame(ipl_data)
print (df.groupby(['Team','Year']).groups)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 -</p> 
 <pre><code class="lang-shell">{
('Devils', 2014): Int64Index([2], dtype='int64'), 
('Devils', 2015): Int64Index([3], dtype='int64'), 
('Kings', 2014): Int64Index([4], dtype='int64'),
('Kings', 2016): Int64Index([6], dtype='int64'),
('Kings', 2017): Int64Index([7], dtype='int64'), 
('Riders', 2014): Int64Index([0], dtype='int64'), 
('Riders', 2015): Int64Index([1], dtype='int64'), 
('Riders', 2016): Int64Index([8], dtype='int64'), 
('Riders', 2017): Int64Index([11], dtype='int64'),
('Royals', 2014): Int64Index([9], dtype='int64'), 
('Royals', 2015): Int64Index([10], dtype='int64'), 
('kings', 2015): Int64Index([5], dtype='int64')
}
</code></pre> 
 <h2 id="h2-u8FEDu4EE3u904Du5386u5206u7EC4"><a name="迭代遍历分组" class="reference-link"></a><span class="header-link octicon octicon-link"></span>迭代遍历分组</h2>
 <p>使用<code>groupby</code>对象，可以遍历类似<code>itertools.obj</code>的对象。</p> 
 <pre><code class="lang-python">import pandas as pd

ipl_data = {'Team': ['Riders', 'Riders', 'Devils', 'Devils', 'Kings',
         'kings', 'Kings', 'Kings', 'Riders', 'Royals', 'Royals', 'Riders'],
         'Rank': [1, 2, 2, 3, 3,4 ,1 ,1,2 , 4,1,2],
         'Year': [2014,2015,2014,2015,2014,2015,2016,2017,2016,2014,2015,2017],
         'Points':[876,789,863,673,741,812,756,788,694,701,804,690]}
df = pd.DataFrame(ipl_data)

grouped = df.groupby('Year')

for name,group in grouped:
    print (name)
    print (group)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">2014
   Points  Rank    Team  Year
0     876     1  Riders  2014
2     863     2  Devils  2014
4     741     3   Kings  2014
9     701     4  Royals  2014
2015
    Points  Rank    Team  Year
1      789     2  Riders  2015
3      673     3  Devils  2015
5      812     4   kings  2015
10     804     1  Royals  2015
2016
   Points  Rank    Team  Year
6     756     1   Kings  2016
8     694     2  Riders  2016
2017
    Points  Rank    Team  Year
7      788     1   Kings  2017
11     690     2  Riders  2017
</code></pre> 
 <p>默认情况下，<code>groupby</code>对象具有与分组名相同的标签名称。</p> 
 <h2 id="h2-u9009u62E9u4E00u4E2Au5206u7EC4"><a name="选择一个分组" class="reference-link"></a><span class="header-link octicon octicon-link"></span>选择一个分组</h2>
 <p>使用<code>get_group()</code>方法，可以选择一个组。参考以下示例代码 - </p> 
 <pre><code class="lang-python">import pandas as pd

ipl_data = {'Team': ['Riders', 'Riders', 'Devils', 'Devils', 'Kings',
         'kings', 'Kings', 'Kings', 'Riders', 'Royals', 'Royals', 'Riders'],
         'Rank': [1, 2, 2, 3, 3,4 ,1 ,1,2 , 4,1,2],
         'Year': [2014,2015,2014,2015,2014,2015,2016,2017,2016,2014,2015,2017],
         'Points':[876,789,863,673,741,812,756,788,694,701,804,690]}
df = pd.DataFrame(ipl_data)

grouped = df.groupby('Year')
print (grouped.get_group(2014))
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">   Points  Rank    Team  Year
0     876     1  Riders  2014
2     863     2  Devils  2014
4     741     3   Kings  2014
9     701     4  Royals  2014
</code></pre> 
 <h2 id="h2-u805Au5408"><a name="聚合" class="reference-link"></a><span class="header-link octicon octicon-link"></span>聚合</h2>
 <p>聚合函数为每个组返回单个聚合值。当创建了分组(<em>group by</em>)对象，就可以对分组数据执行多个聚合操作。</p> 
 <p>一个比较常用的是通过聚合或等效的<code>agg</code>方法聚合 -</p> 
 <pre><code class="lang-python">import pandas as pd
import numpy as np

ipl_data = {'Team': ['Riders', 'Riders', 'Devils', 'Devils', 'Kings',
         'kings', 'Kings', 'Kings', 'Riders', 'Royals', 'Royals', 'Riders'],
         'Rank': [1, 2, 2, 3, 3,4 ,1 ,1,2 , 4,1,2],
         'Year': [2014,2015,2014,2015,2014,2015,2016,2017,2016,2014,2015,2017],
         'Points':[876,789,863,673,741,812,756,788,694,701,804,690]}
df = pd.DataFrame(ipl_data)

grouped = df.groupby('Year')
print (grouped['Points'].agg(np.mean))
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p>   
 <pre><code class="lang-shell">Year
2014    795.25
2015    769.50
2016    725.00
2017    739.00
Name: Points, dtype: float64
</code></pre> 
 <p>另一种查看每个分组的大小的方法是应用<code>size()</code>函数 -</p> 
 <pre><code class="lang-python">import pandas as pd
import numpy as np

ipl_data = {'Team': ['Riders', 'Riders', 'Devils', 'Devils', 'Kings',
         'kings', 'Kings', 'Kings', 'Riders', 'Royals', 'Royals', 'Riders'],
         'Rank': [1, 2, 2, 3, 3,4 ,1 ,1,2 , 4,1,2],
         'Year': [2014,2015,2014,2015,2014,2015,2016,2017,2016,2014,2015,2017],
         'Points':[876,789,863,673,741,812,756,788,694,701,804,690]}
df = pd.DataFrame(ipl_data)
grouped = df.groupby('Team')
print (grouped.agg(np.size))
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">Team                      
Devils       2     2     2
Kings        3     3     3
Riders       4     4     4
Royals       2     2     2
kings        1     1     1
</code></pre> 
 <h2 id="h2-u4E00u6B21u5E94u7528u591Au4E2Au805Au5408u51FDu6570"><a name="一次应用多个聚合函数" class="reference-link"></a><span class="header-link octicon octicon-link"></span>一次应用多个聚合函数</h2>
 <p>通过分组系列，还可以传递函数的列表或字典来进行聚合，并生成<code>DataFrame</code>作为输出 -</p> 
 <pre><code class="lang-python">import pandas as pd
import numpy as np

ipl_data = {'Team': ['Riders', 'Riders', 'Devils', 'Devils', 'Kings',
         'kings', 'Kings', 'Kings', 'Riders', 'Royals', 'Royals', 'Riders'],
         'Rank': [1, 2, 2, 3, 3,4 ,1 ,1,2 , 4,1,2],
         'Year': [2014,2015,2014,2015,2014,2015,2016,2017,2016,2014,2015,2017],
         'Points':[876,789,863,673,741,812,756,788,694,701,804,690]}
df = pd.DataFrame(ipl_data)

grouped = df.groupby('Team')
agg = grouped['Points'].agg([np.sum, np.mean, np.std])
print (agg)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">         sum        mean         std
Team                                
Devils  1536  768.000000  134.350288
Kings   2285  761.666667   24.006943
Riders  3049  762.250000   88.567771
Royals  1505  752.500000   72.831998
kings    812  812.000000         NaN
</code></pre> 
 <h2 id="h2-u8F6Cu6362"><a name="转换" class="reference-link"></a><span class="header-link octicon octicon-link"></span>转换</h2>
 <p>分组或列上的转换返回索引大小与被分组的索引相同的对象。因此，转换应该返回与组块大小相同的结果。</p> 
 <pre><code class="lang-python">import pandas as pd
import numpy as np

ipl_data = {'Team': ['Riders', 'Riders', 'Devils', 'Devils', 'Kings',
         'kings', 'Kings', 'Kings', 'Riders', 'Royals', 'Royals', 'Riders'],
         'Rank': [1, 2, 2, 3, 3,4 ,1 ,1,2 , 4,1,2],
         'Year': [2014,2015,2014,2015,2014,2015,2016,2017,2016,2014,2015,2017],
         'Points':[876,789,863,673,741,812,756,788,694,701,804,690]}
df = pd.DataFrame(ipl_data)

grouped = df.groupby('Team')
score = lambda x: (x - x.mean()) / x.std()*10
print (grouped.transform(score))
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">       Points       Rank       Year
0   12.843272 -15.000000 -11.618950
1    3.020286   5.000000  -3.872983
2    7.071068  -7.071068  -7.071068
3   -7.071068   7.071068   7.071068
4   -8.608621  11.547005 -10.910895
5         NaN        NaN        NaN
6   -2.360428  -5.773503   2.182179
7   10.969049  -5.773503   8.728716
8   -7.705963   5.000000   3.872983
9   -7.071068   7.071068  -7.071068
10   7.071068  -7.071068   7.071068
11  -8.157595   5.000000  11.618950
</code></pre> 
 <h2 id="h2-u8FC7u6EE4"><a name="过滤" class="reference-link"></a><span class="header-link octicon octicon-link"></span>过滤</h2>
 <p>过滤根据定义的标准过滤数据并返回数据的子集。<code>filter()</code>函数用于过滤数据。</p> 
 <pre><code class="lang-python">import pandas as pd
import numpy as np
ipl_data = {'Team': ['Riders', 'Riders', 'Devils', 'Devils', 'Kings',
         'kings', 'Kings', 'Kings', 'Riders', 'Royals', 'Royals', 'Riders'],
         'Rank': [1, 2, 2, 3, 3,4 ,1 ,1,2 , 4,1,2],
         'Year': [2014,2015,2014,2015,2014,2015,2016,2017,2016,2014,2015,2017],
         'Points':[876,789,863,673,741,812,756,788,694,701,804,690]}
df = pd.DataFrame(ipl_data)
filter = df.groupby('Team').filter(lambda x: len(x) &gt;= 3)

print (filter)
</code></pre> 
 <p>执行上面示例代码，得到以下结果 - </p> 
 <pre><code class="lang-shell">    Points  Rank    Team  Year
0      876     1  Riders  2014
1      789     2  Riders  2015
4      741     3   Kings  2014
6      756     1   Kings  2016
7      788     1   Kings  2017
8      694     2  Riders  2016
11     690     2  Riders  2017
</code></pre> 
 <p>在上述过滤条件下，要求返回三次以上参加IPL的队伍。</p>
 <br>      
</div></body></html>