<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">Elasticsearch模块</h1><div style="width:100%;float:left;" class="article-content">   
 <p><strong>Elasticsearch</strong>由多个模块组成，这些模块负责其功能。 这些模块有以下两种类型的设置 -</p> 
 <ul> 
  <li><p><strong>静态设置</strong> - 在启动<strong>Elasticsearch</strong>之前，需要在配置文件(<code>elasticsearch.yml</code>)中配置这些设置。需要更新集群中的所有关注节点以反映这些设置的更改。</p> </li>
  <li><p><strong>动态设置</strong> - 这些设置可以在实时Elasticsearch上设置。</p> </li>
 </ul> 
 <p>我们将在本章的以下部分讨论<strong>Elasticsearch</strong>中的每个模块。</p> 
 <h2 id="h2-u96C6u7FA4u7EA7u8DEFu7531u548Cu788Eu7247u5206u914D"><a name="集群级路由和碎片分配" class="reference-link"></a><span class="header-link octicon octicon-link"></span>集群级路由和碎片分配</h2>
 <p>集群级别设置决定将碎片分配给不同节点，以及将碎片重新分配给平衡集群。这些是以下设置来控制碎片分配 -</p> 
 <p>集群级碎片分配- </p> 
 <ul> 
  <li><p><code>cluster.routing.allocation.enable</code> 可能的值及说明 - </p> 
   <ul> 
    <li><code>all</code> - 此默认值允许为所有种类的碎片分配碎片。</li>
    <li><code>primaries</code> - 这允许只为主碎片分配碎片。</li>
    <li><code>new_primaries</code>- 这允许只为新索引的主碎片分配碎片。</li>
    <li><code>none</code>- 这不允许任何碎片分配。</li>
   </ul> </li>
  <li><p><code>cluster.routing.allocation.node_concurrent_recoveries</code> - 一个数字值(默认为<code>2</code> )，它限制了并发碎片恢复的数量。</p> </li>
  <li><p><code>cluster.routing.allocation.node_initial_primaries_recoveries</code> - 一个数字值(默认为 <code>4</code> )，它限制了并行初始初级恢复的数量。</p> </li>
  <li><p><code>cluster.routing.allocation.same_shard.host</code> - 布尔值(默认为<code>false</code>), 它限制了同一物理节点中同一碎片的多个副本的分配。</p> </li>
  <li><p><code>indices.recovery.concurrent _streams</code> - 一个数字值(默认为<code>3</code> )，它控制在从对等体碎片恢复碎片时每个节点的开放网络流的数量。</p> </li>
  <li><p><code>indices.recovery.concurrent_small_file_streams</code> - 一个数字值(默认为<code>2</code> )，这控制了在碎片恢复时对于小于<code>5mb</code>的小文件的每个节点的开放流的数量。</p> </li>
  <li><p><code>cluster.routing.rebalance.enable</code>可能的值及说明 - </p> 
   <ul> 
    <li><code>all</code> - 此默认值允许平衡所有种类的碎片。</li>
    <li><code>primaries</code>- 这允许只对主碎片进行碎片平衡。</li>
    <li><code>replicas</code> - 这允许只对副本碎片进行碎片平衡。</li>
    <li><code>none</code> - 这不允许任何类型的碎片平衡。</li>
   </ul> </li>
  <li><p><code>cluster.routing.allocation.allow_rebalance</code> 可能的值及说明 - </p> 
   <ul> 
    <li><code>always</code> - 此默认值始终允许重新平衡。</li>
    <li><code>indices_primaries _active</code> - 这允许在分配集群中的所有主碎片时进行重新平衡。</li>
    <li><code>Indices_all_active</code> - 这允许在分配所有主碎片和副本碎片时重新平衡。</li>
   </ul> </li>
  <li><p><code>cluster.routing.allocation.cluster _concurrent_rebalance</code> - 一个数字值(默认为<code>2</code> ), 这限制了集群中的并发碎片平衡数。</p> </li>
  <li><p><code>cluster.routing.allocation.balance.shard</code> - 一个浮点数值(默认为<code>0.45f</code> ),这定义了在每个节点上分配的碎片的权重因子。</p> </li>
  <li><p><code>cluster.routing.allocation.balance.index</code> - 一个浮点数值(默认为<code>0.55f</code> ),这定义了在特定节点上分配的每个索引的碎片数量的比率。</p> </li>
  <li><p><code>cluster.routing.allocation.balance.threshold</code> - 一个浮点数值(默认为<code>1.0f</code> ),这定义了在特定节点上分配的每个索引的碎片数量的比率。</p> </li>
  <li><p><code>cluster.routing.allocation .balance.threshold</code> - 非负浮点值(默认为<code>1.0f</code>)这是应该执行的操作的最小优化值。</p> </li>
 </ul> 
 <h3 id="h3-u57FAu4E8Eu78C1u76D8u7684u788Eu7247u5206u914D"><a name="基于磁盘的碎片分配" class="reference-link"></a><span class="header-link octicon octicon-link"></span>基于磁盘的碎片分配</h3>
 <table> 
  <thead> 
   <tr> 
    <th>设置</th> 
    <th>可能的值</th> 
    <th>描述</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>cluster.routing.allocation.disk.threshold_enabled</td> 
    <td>布尔值(默认为<code>true</code>)</td> 
    <td>这启用和禁用磁盘分配决策程序。</td> 
   </tr> 
   <tr> 
    <td>cluster.routing.allocation.disk.watermark.low</td> 
    <td>字符串值(默认为<code>85％</code>)</td> 
    <td>这表示磁盘的最大使用; 此后，无法将其他碎片分配给该磁盘。</td> 
   </tr> 
   <tr> 
    <td>cluster.routing.allocation.disk.watermark.high</td> 
    <td>字符串值(默认为<code>90％</code>)</td> 
    <td>这表示分配时的最大使用量; 如果在分配时达到这一点，Elasticsearch将把该碎片分配给另一个磁盘。</td> 
   </tr> 
   <tr> 
    <td>cluster.info.update.interval</td> 
    <td>字符串值(默认<code>30s</code>)</td> 
    <td>这是磁盘用法，检查两个时间之间的间隔。</td> 
   </tr> 
   <tr> 
    <td>cluster.routing.allocation.disk.include_relocations</td> 
    <td>布尔值(默认为<code>true</code>)</td> 
    <td>这决定在计算磁盘使用率时是否考虑当前分配的分片。</td> 
   </tr> 
   <tr> 
    <td></td> 
    <td></td> 
    <td></td> 
   </tr> 
   <tr> 
    <td></td> 
    <td></td> 
   </tr> 
  </tbody> 
 </table> 
 <h2 id="h2-u53D1u73B0"><a name="发现" class="reference-link"></a><span class="header-link octicon octicon-link"></span>发现</h2>
 <p>此模块帮助集群发现和维护其中的所有节点的状态。在从集群添加或删除节点时集群的状态发生更改。集群名称设置用于在不同集群之间创建逻辑差异。有一些模块，可以帮助您使用云供应商提供的API -</p> 
 <ul> 
  <li>Azure发现</li>
  <li>EC2发现</li>
  <li>Google计算引擎发现</li>
  <li>Zen发现</li>
 </ul> 
 <h2 id="h2-u7F51u5173"><a name="网关" class="reference-link"></a><span class="header-link octicon octicon-link"></span>网关</h2>
 <p>此模块在整个群集重新启动时维护群集状态和分片数据。以下是此模块的静态设置 -</p> 
 <table> 
  <thead> 
   <tr> 
    <th>设置</th> 
    <th>可能的值</th> 
    <th>描述</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>gateway.expected_nodes</td> 
    <td>数值(默认为<code>0</code>)</td> 
    <td>预期在群集中用于恢复本地碎片的节点数。</td> 
   </tr> 
   <tr> 
    <td>gateway.expected_master_nodes</td> 
    <td>数值(默认为<code>0</code>)</td> 
    <td>在开始恢复之前预期在群集中的主节点数。</td> 
   </tr> 
   <tr> 
    <td>gateway.expected_data_nodes</td> 
    <td>数值(默认为<code>0</code>)</td> 
    <td>开始恢复之前群集中预期的数据节点数。</td> 
   </tr> 
   <tr> 
    <td>gateway.recover_after_time</td> 
    <td>字符串值(默认为<code>5m</code>)</td> 
    <td>这用于指定恢复进程将等待启动的时间，而不考虑在集群中加入的节点数。1. gateway.recover_after_nodes 2. gateway.recover_after_master_nodes 3. gateway.recover_after_data_nodes</td> 
   </tr> 
  </tbody> 
 </table> 
 <h2 id="h2-http"><a name="HTTP" class="reference-link"></a><span class="header-link octicon octicon-link"></span>HTTP</h2>
 <p>此模块管理HTTP客户端和Elasticsearch API之间的通信。可以通过将<code>http.enabled</code>的值更改为<code>false</code>来禁用此模块。 以下是控制此模块的设置(在<code>elasticsearch.yml</code>中配置)</p> 
 <table> 
  <thead> 
   <tr> 
    <th>编号</th> 
    <th>设置</th> 
    <th>描述</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>1</td> 
    <td>http.port</td> 
    <td>访问<strong>Elasticsearch</strong>的端口，范围为<code>9200-9300</code>。</td> 
   </tr> 
   <tr> 
    <td>2</td> 
    <td>http.publish_port</td> 
    <td>此端口用于HTTP客户端，并且在防火墙的情况下也很有用。</td> 
   </tr> 
   <tr> 
    <td>3</td> 
    <td>http.bind_host</td> 
    <td>http服务的主机地址。</td> 
   </tr> 
   <tr> 
    <td>4</td> 
    <td>http.publish_host</td> 
    <td>http客户端的主机地址。</td> 
   </tr> 
   <tr> 
    <td>5</td> 
    <td>http.max_content_length</td> 
    <td>这是http请求中内容的最大值。其默认值为<code>100mb</code>。</td> 
   </tr> 
   <tr> 
    <td>6</td> 
    <td>http.max_initial_line_length</td> 
    <td>这是URL的最大值，其默认值为<code>4kb</code>。</td> 
   </tr> 
   <tr> 
    <td>7</td> 
    <td>http.max_header_size</td> 
    <td>这是最大http报头大小，其默认值为<code>8kb</code>。</td> 
   </tr> 
   <tr> 
    <td>8</td> 
    <td>http.compression</td> 
    <td>这启用或禁用对压缩的支持，其默认值为<code>false</code>。</td> 
   </tr> 
   <tr> 
    <td>9</td> 
    <td>http.pipelinig</td> 
    <td>这将启用或禁用HTTP通道线。</td> 
   </tr> 
   <tr> 
    <td>10</td> 
    <td>http.pipelining.max_events</td> 
    <td>这会限制在关闭HTTP请求之前排队的事件数。</td> 
   </tr> 
  </tbody> 
 </table> 
 <h2 id="h2-u7D22u5F15"><a name="索引" class="reference-link"></a><span class="header-link octicon octicon-link"></span>索引</h2>  
 <p>此模块维护对每个索引全局设置的设置。以下设置主要与内存使用有关 -</p> 
 <h3 id="h3-u65ADu8DEFu5668"><a name="断路器" class="reference-link"></a><span class="header-link octicon octicon-link"></span>断路器</h3>
 <p>这用于防止操作引起<code>OutOfMemroyError</code>。 该设置主要限制JVM堆大小。 例如，<code>indices.breaker.total.limit</code>设置，JVM堆的默认为<code>70％</code>。</p> 
 <h3 id="h3-fielddata-"><a name="Fielddata缓存" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Fielddata缓存</h3>
 <p>这主要用于在字段上聚合时。建议分配它足够的内存。 可以使用<code>indices.fielddata.cache.size</code>设置控制用于字段数据高速缓存的内存量。</p> 
 <h3 id="h3-u8282u70B9u67E5u8BE2u7F13u5B58"><a name="节点查询缓存" class="reference-link"></a><span class="header-link octicon octicon-link"></span>节点查询缓存</h3>
 <p>此内存用于缓存查询结果。此缓存使用最近最少使用(LRU)逐出策略。 <code>Indices.queries.cahce.size</code>设置控制此缓存的内存大小。</p> 
 <h3 id="h3-u7D22u5F15u7F13u51B2u533A"><a name="索引缓冲区" class="reference-link"></a><span class="header-link octicon octicon-link"></span>索引缓冲区</h3>
 <p>此缓冲区将新创建的文档存储在索引中，并在缓冲区已满时将其刷新。设置为<code>indices.memory.index_buffer_size</code>控制为此缓冲区分配的堆的大小。</p> 
 <h3 id="h3-shard-"><a name="Shard请求缓存" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Shard请求缓存</h3>
 <p>此缓存用于存储每个分片的本地搜索数据。缓存可以在创建索引期间启用，也可以通过发送URL参数来禁用。</p> 
 <pre><code>Disable cache - ?request_cache = true
Enable cache "index.requests.cache.enable": true
</code></pre>
 <h3 id="h3-u7D22u5F15u6062u590D"><a name="索引恢复" class="reference-link"></a><span class="header-link octicon octicon-link"></span>索引恢复</h3>
 <p>它在恢复过程中控制资源。以下是一些设置 -</p> 
 <table> 
  <thead> 
   <tr> 
    <th>设置</th> 
    <th>默认值</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>indices.recovery.concurrent_streams</td> 
    <td>3</td> 
   </tr> 
   <tr> 
    <td>indices.recovery.concurrent_small_file_streams</td> 
    <td>2</td> 
   </tr> 
   <tr> 
    <td>indices.recovery.file_chunk_size</td> 
    <td>512kb</td> 
   </tr> 
   <tr> 
    <td>indices.recovery.translog_ops</td> 
    <td>1000</td> 
   </tr> 
   <tr> 
    <td>indices.recovery.translog_size</td> 
    <td>512kb</td> 
   </tr> 
   <tr> 
    <td>indices.recovery.compress</td> 
    <td>true</td> 
   </tr> 
   <tr> 
    <td>indices.recovery.max_bytes_per_sec</td> 
    <td>40mb</td> 
   </tr> 
  </tbody> 
 </table> 
 <h3 id="h3-ttl-"><a name="TTL间隔" class="reference-link"></a><span class="header-link octicon octicon-link"></span>TTL间隔</h3>
 <p>生存时间(TTL)间隔定义文档的时间，之后文档将被删除。 以下是控制此过程的动态设置 -</p> 
 <table> 
  <thead> 
   <tr> 
    <th>设置</th> 
    <th>默认值</th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr> 
    <td>indices.ttl.interval</td> 
    <td>60</td> 
   </tr> 
   <tr> 
    <td>indices.ttl.bulk_size</td> 
    <td>1000</td> 
   </tr> 
  </tbody> 
 </table> 
 <h3 id="h3-u8282u70B9"><a name="节点" class="reference-link"></a><span class="header-link octicon octicon-link"></span>节点</h3>
 <p>每个节点有一个选项是否是数据节点。可以通过更改<code>node.data</code>设置更改此属性。将值设置为<code>false</code>将定义该节点不是数据节点。</p>
 <br>      
</div></body></html>