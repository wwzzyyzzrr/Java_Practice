<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">R语言数据重塑</h1><div style="width:100%;float:left;" class="article-content">   
 <p>R中的数据重整是关于将数据组织成行和列的方式。 R中的大多数时间数据处理是通过将输入数据作为数据帧来完成的。 很容易从数据帧的行和列中提取数据，但是有些情况下，我们需要的格式与收到的格式不同。 R具有许多函数，用于在数据帧中拆分，合并和更改行到列，反之亦然。</p> 
 <h2 id="h2-u5728u6570u636Eu6846u4E2Du8FDEu63A5u5217u548Cu884C"><a name="在数据框中连接列和行" class="reference-link"></a><span class="header-link octicon octicon-link"></span>在数据框中连接列和行</h2>
 <p>我们可以使用<code>cbind()</code>函数连接多个向量来创建数据帧。也可以使用<code>rbind()</code>函数合并两个数据帧。</p> 
 <pre><code class="lang-r"># Create vector objects.
city &lt;- c("Tampa","Seattle","Hartford","Denver")
state &lt;- c("FL","WA","CT","CO")
zipcode &lt;- c(33602,98104,06161,80294)

# Combine above three vectors into one data frame.
addresses &lt;- cbind(city,state,zipcode)

# Print a header.
cat("# # # # The First data frame\n") 

# Print the data frame.
print(addresses)

# Create another data frame with similar columns
new.address &lt;- data.frame(
   city = c("Lowry","Charlotte"),
   state = c("CO","FL"),
   zipcode = c("80230","33949"),
   stringsAsFactors = FALSE
)

# Print a header.
cat("# # # The Second data frame\n") 

# Print the data frame.
print(new.address)

# Combine rows form both the data frames.
all.addresses &lt;- rbind(addresses,new.address)

# Print a header.
cat("# # # The combined data frame\n") 

# Print the result.
print(all.addresses)
</code></pre> 
 <p>当我们执行上述代码时，会产生以下结果 -</p> 
 <pre><code class="lang-shell"># # # # The First data frame
     city       state zipcode
[1,] "Tampa"    "FL"  "33602"
[2,] "Seattle"  "WA"  "98104"
[3,] "Hartford" "CT"   "6161" 
[4,] "Denver"   "CO"  "80294"

# # # The Second data frame
       city       state   zipcode
1      Lowry      CO      80230
2      Charlotte  FL      33949

# # # The combined data frame
       city      state zipcode
1      Tampa     FL    33602
2      Seattle   WA    98104
3      Hartford  CT     6161
4      Denver    CO    80294
5      Lowry     CO    80230
6     Charlotte  FL    33949
</code></pre> 
 <h2 id="h2-u5408u5E76u6570u636Eu5E27"><a name="合并数据帧" class="reference-link"></a><span class="header-link octicon octicon-link"></span>合并数据帧</h2>
 <p>可以使用<code>merge()</code>函数合并两个数据帧。数据帧必须具有相同的列名称，合并发生。</p> 
 <p>在下面的例子中，我们考虑了Pima印度妇女的糖尿病数据库，可以在名称为<code>“MASS”</code>的库中找到。 我们根据血压值(<code>“bp”</code>)和体重指数(<code>“bmi”</code>)合并两个数据集。 在选择这两列进行合并时，这两个变量的值在两个数据集中匹配的记录被组合在一起以形成单个数据帧。参考以下代码实现 - </p> 
 <pre><code class="lang-r">library(MASS)
merged.Pima &lt;- merge(x = Pima.te, y = Pima.tr,
   by.x = c("bp", "bmi"),
   by.y = c("bp", "bmi")
)
print(merged.Pima)
nrow(merged.Pima)
</code></pre> 
 <p>当我们执行上述代码时，会产生以下结果 -</p> 
 <pre><code class="lang-shell"> npreg.x glu.x skin.x ped.x age.x type.x npreg.y glu.y skin.y
1  60 33.8       1   117     23 0.466    27     No       2   125     20
2  64 29.7       2    75     24 0.370    33     No       2   100     23
3  64 31.2       5   189     33 0.583    29    Yes       3   158     13
4  64 33.2       4   117     27 0.230    24     No       1    96     27
5  66 38.1       3   115     39 0.150    28     No       1   114     36
6  68 38.5       2   100     25 0.324    26     No       7   129     49
7  70 27.4       1   116     28 0.204    21     No       0   124     20
8  70 33.1       4    91     32 0.446    22     No       9   123     44
9  70 35.4       9   124     33 0.282    34     No       6   134     23
10 72 25.6       1   157     21 0.123    24     No       4    99     17
11 72 37.7       5    95     33 0.370    27     No       6   103     32
12 74 25.9       9   134     33 0.460    81     No       8   126     38
13 74 25.9       1    95     21 0.673    36     No       8   126     38
14 78 27.6       5    88     30 0.258    37     No       6   125     31
15 78 27.6      10   122     31 0.512    45     No       6   125     31
16 78 39.4       2   112     50 0.175    24     No       4   112     40
17 88 34.5       1   117     24 0.403    40    Yes       4   127     11
   ped.y age.y type.y
1  0.088    31     No
2  0.368    21     No
3  0.295    24     No
4  0.289    21     No
5  0.289    21     No
6  0.439    43    Yes
7  0.254    36    Yes
8  0.374    40     No
9  0.542    29    Yes
10 0.294    28     No
11 0.324    55     No
12 0.162    39     No
13 0.162    39     No
14 0.565    49    Yes
15 0.565    49    Yes
16 0.236    38     No
17 0.598    28     No
</code></pre> 
 <h2 id="h2-u62C6u5206u6570u636Eu548Cu91CDu6784u6570u636E"><a name="拆分数据和重构数据" class="reference-link"></a><span class="header-link octicon octicon-link"></span>拆分数据和重构数据</h2>
 <p>R编程最有趣的一个方面是在多个步骤中改变数据的形状以获得所需的形状。 用于执行此操作的函数称为<code>melt()</code>和<code>cast()</code>。</p> 
 <p>考虑使用<code>“MASS”</code>库中存在的数据集。</p>   
 <pre><code class="lang-r">library(MASS)
print(ships)
</code></pre> 
 <p>当我们执行上述代码时，会产生以下结果 -</p> 
 <pre><code class="lang-shell">     type year   period   service   incidents
1     A   60     60        127         0
2     A   60     75         63         0
3     A   65     60       1095         3
4     A   65     75       1095         4
5     A   70     60       1512         6
.............
.............
8     A   75     75       2244         11
9     B   60     60      44882         39
10    B   60     75      17176         29
11    B   65     60      28609         58
............
............
17    C   60     60      1179          1
18    C   60     75       552          1
19    C   65     60       781          0
............
............
</code></pre> 
 <h2 id="h2-u62C6u5206u6570u636E"><a name="拆分数据" class="reference-link"></a><span class="header-link octicon octicon-link"></span>拆分数据</h2>
 <p>现在，我们将数据融合到一起，将除了类型和年份之外的所有列转为行 - </p> 
 <pre><code class="lang-r">molten.ships &lt;- melt(ships, id = c("type","year"))
print(molten.ships)
</code></pre> 
 <p>当我们执行上述代码时，会产生以下结果 -</p> 
 <pre><code class="lang-shell">      type year  variable  value
1      A   60    period      60
2      A   60    period      75
3      A   65    period      60
4      A   65    period      75
............
............
9      B   60    period      60
10     B   60    period      75
11     B   65    period      60
12     B   65    period      75
13     B   70    period      60
...........
...........
41     A   60    service    127
42     A   60    service     63
43     A   65    service   1095
...........
...........
70     D   70    service   1208
71     D   75    service      0
72     D   75    service   2051
73     E   60    service     45
74     E   60    service      0
75     E   65    service    789
...........
...........
101    C   70    incidents    6
102    C   70    incidents    2
103    C   75    incidents    0
104    C   75    incidents    1
105    D   60    incidents    0
106    D   60    incidents    0
...........
...........
</code></pre> 
 <h2 id="h2-u91CDu6784u6570u636E"><a name="重构数据" class="reference-link"></a><span class="header-link octicon octicon-link"></span>重构数据</h2>
 <p>我们可以将拆分的数据转换为一种新形式，使用<code>cast()</code>函数创建每年每种类型的船的总和。</p> 
 <pre><code class="lang-r">recasted.ship &lt;- cast(molten.ships, type+year~variable,sum)
print(recasted.ship)
</code></pre> 
 <p>当我们执行上述代码时，会产生以下结果 -</p> 
 <pre><code class="lang-shell">     type year  period  service  incidents
1     A   60    135       190      0
2     A   65    135      2190      7
3     A   70    135      4865     24
4     A   75    135      2244     11
5     B   60    135     62058     68
6     B   65    135     48979    111
7     B   70    135     20163     56
8     B   75    135      7117     18
9     C   60    135      1731      2
10    C   65    135      1457      1
11    C   70    135      2731      8
12    C   75    135       274      1
13    D   60    135       356      0
14    D   65    135       480      0
15    D   70    135      1557     13
16    D   75    135      2051      4
17    E   60    135        45      0
18    E   65    135      1226     14
19    E   70    135      3318     17
20    E   75    135       542      1
</code></pre>
 <br>      
</div></body></html>