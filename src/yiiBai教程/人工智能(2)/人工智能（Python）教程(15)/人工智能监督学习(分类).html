<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">人工智能监督学习(分类)</h1><div style="width:100%;float:left;" class="article-content">   
 <p>在本章中，我们将重点讨论监督式学习 - <strong>分类</strong>。</p> 
 <p>分类技术或模型试图从观测值中得出一些结论。 在分类问题中，我们有分类输出，如“黑色”或“白色”或“教学”和“非教学”。 在构建分类模型时，需要有包含数据点和相应标签的训练数据集。 例如，如果想检查图像是否属于汽车。 要实现这个检查，我们将建立一个训练数据集，其中包含与“车”和“无车”相关的两个类。 然后需要使用训练样本来训练模型。 分类模型主要用于人脸识别，垃圾邮件识别等。</p> 
 <h2 id="h2--python-"><a name="在Python中构建分类器的步骤" class="reference-link"></a><span class="header-link octicon octicon-link"></span>在Python中构建分类器的步骤</h2>
 <p>为了在Python中构建分类器，将使用Python 3和Scikit-learn，这是一个用于机器学习的工具。 按照以下步骤在Python中构建分类器 -</p> 
 <p><strong>第1步</strong> - 导入Scikit-learn<br>这将是在Python中构建分类器的第一步。 在这一步中，将安装一个名为Scikit-learn的Python包，它是Python中最好的机器学习模块之一。 以下命令导入包 -</p> 
 <pre><code class="lang-python">import sklearn
</code></pre> 
 <p><strong>第2步</strong> - 导入Scikit-learn的数据集</p> 
 <p>在这一步中，我们可以开始使用机器学习模型的数据集。 在这里，将使用<a target="_blank" href="http://scikit-learn.org/stable/datasets/index.html#breast-cancer-wisconsin-diagnostic-database" title="乳腺癌威斯康星诊断数据库">乳腺癌威斯康星诊断数据库</a>。 数据集包括有关乳腺癌肿瘤的各种信息，以及恶性或良性分类标签。 该数据集在569个肿瘤上具有569个实例或数据，并且包括关于30个属性或特征(诸如肿瘤的半径，纹理，光滑度和面积)的信息。 借助以下命令，导入Scikit-learn的乳腺癌数据集 -</p> 
 <pre><code class="lang-python">from sklearn.datasets import load_breast_cancer
</code></pre> 
 <p>现在，以下命令将加载数据集。</p> 
 <pre><code class="lang-python">data = load_breast_cancer()
</code></pre> 
 <p>以下是字典键列表 -</p> 
 <ul> 
  <li>分类标签名称(target_names)</li>
  <li>实际标签(目标)</li>
  <li>属性/功能名称(feature_names)</li>
  <li>属性(数据)</li>
 </ul> 
 <p>现在，使用以下命令，可以为每个重要信息集创建新变量并分配数据。 换句话说，可以用下列命令组织数据 -</p> 
 <pre><code class="lang-python">label_names = data['target_names']
labels = data['target']
feature_names = data['feature_names']
features = data['data']
</code></pre> 
 <p>现在，为了使它更清晰，可以使用以下命令来打印类标签，第一个数据实例的标签，我们的功能名称和功能的值 -</p> 
 <pre><code class="lang-python">print(label_names)
</code></pre> 
 <p>上述命令将分别打印恶性和良性的分类名称。输出结果如下 -</p> 
 <pre><code class="lang-python">['malignant' 'benign']
</code></pre> 
 <p>现在，下面的命令将显示它们被映射到二进制值<code>0</code>和<code>1</code>。这里<code>0</code>表示恶性肿瘤，<code>1</code>表示良性癌症。得到以下输出 -</p> 
 <pre><code class="lang-python">print(labels[0])
0
</code></pre> 
 <p>下面给出的两个命令将生成功能名称和功能值。</p> 
 <pre><code class="lang-python">print(feature_names[0])
mean radius
print(features[0])
[ 1.79900000e+01 1.03800000e+01 1.22800000e+02 1.00100000e+03
  1.18400000e-01 2.77600000e-01 3.00100000e-01 1.47100000e-01
  2.41900000e-01 7.87100000e-02 1.09500000e+00 9.05300000e-01
  8.58900000e+00 1.53400000e+02 6.39900000e-03 4.90400000e-02
  5.37300000e-02 1.58700000e-02 3.00300000e-02 6.19300000e-03
  2.53800000e+01 1.73300000e+01 1.84600000e+02 2.01900000e+03
  1.62200000e-01 6.65600000e-01 7.11900000e-01 2.65400000e-01
  4.60100000e-01 1.18900000e-01]
</code></pre> 
 <p>从上面的输出中，可以看到第一个数据实例是一个半径为<code>1.7990000e + 01</code>的恶性肿瘤。</p> 
 <p><strong>第3步</strong> - 组织数据</p> 
 <p>在这一步中，将把数据分成两部分，即训练集和测试集。 将数据分割成这些集合非常重要，因为必须在未看到的数据上测试模型。要将数据分成集合，sklearn有一个叫做<code>train_test_split()</code>函数的函数。 在以下命令的帮助下，可以分割这些集合中的数据 -</p> 
 <pre><code class="lang-python">from sklearn.model_selection import train_test_split
</code></pre> 
 <p>上述命令将从<code>sklearn</code>中导入<code>train_test_split</code>函数，下面的命令将数据分解为训练和测试数据。 在下面给出的例子中，使用<code>40%</code>的数据进行测试，其余数据将用于训练模型。</p> 
 <pre><code class="lang-python">train, test, train_labels, test_labels = train_test_split(features,labels,test_size = 0.40, random_state = 42)
</code></pre> 
 <p><strong>第4步</strong> - 建立模型<br>在这一步中，我们将建立模型。使用朴素贝叶斯算法来构建模型。 以下命令可用于构建模型 -</p> 
 <pre><code class="lang-python">from sklearn.naive_bayes import GaussianNB
</code></pre> 
 <p>上述命令将导入GaussianNB模块。 现在，以下命令用来初始化模型。</p> 
 <pre><code class="lang-python">gnb = GaussianNB()
</code></pre> 
 <p>将通过使用<code>gnb.fit()</code>将它拟合到数据来训练模型。</p> 
 <pre><code class="lang-python">model = gnb.fit(train, train_labels)
</code></pre> 
 <p><strong>第5步</strong> - 评估模型及其准确性<br>在这一步中，我们将通过对测试数据进行预测来评估模型。为了做出预测，我们将使用<code>predict()</code>函数。 以下命令做到这一点 -</p> 
 <pre><code class="lang-python">preds = gnb.predict(test)
print(preds)
## -- 结果如下
[1 0 0 1 1 0 0 0 1 1 1 0 1 0 1 0 1 1 1 0 1 1 0 1 1 1 1 1 1
 0 1 1 1 1 1 1 0 1 0 1 1 0 1 1 1 1 1 1 1 1 0 0 1 1 1 1 1 0 
 0 1 1 0 0 1 1 1 0 0 1 1 0 0 1 0 1 1 1 1 1 1 0 1 1 0 0 0 0 
 0 1 1 1 1 1 1 1 1 0 0 1 0 0 1 0 0 1 1 1 0 1 1 0 1 1 0 0 0 
 1 1 1 0 0 1 1 0 1 0 0 1 1 0 0 0 1 1 1 0 1 1 0 0 1 0 1 1 0 
 1 0 0 1 1 1 1 1 1 1 0 0 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 0 
 1 1 0 1 1 1 1 1 1 0 0 0 1 1 0 1 0 1 1 1 1 0 1 1 0 1 1 1 0 
 1 0 0 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 0 0 1 1 0 1]
</code></pre> 
 <p>上述<code>0</code>和<code>1</code>系列是肿瘤类别的预测值 - 恶性和良性。</p> 
 <p>现在，通过比较两个数组即<code>test_labels</code>和<code>preds</code>，可以发现模型的准确性。使用<code>accuracy_score()</code>函数来确定准确性。 考虑下面的命令 -</p> 
 <pre><code class="lang-python">from sklearn.metrics import accuracy_score
print(accuracy_score(test_labels,preds))
0.951754385965
</code></pre> 
 <p>结果显示NaïveBayes分类器准确率为<code>95.17%</code>。</p> 
 <p>通过这种方式，借助上述步骤，我们可以使用Python构建分类器。</p> 
 <h2 id="h2--python-"><a name="在Python中构建分类器" class="reference-link"></a><span class="header-link octicon octicon-link"></span>在Python中构建分类器</h2>
 <p>在本节中，我们将学习如何在Python中构建分类器。</p> 
 <p><strong>朴素贝叶斯分类器</strong></p> 
 <p>朴素贝叶斯是一种使用贝叶斯定理建立分类器的分类技术。 假设是预测变量是独立的。 简而言之，它假设类中某个特征的存在与任何其他特征的存在无关。要构建朴素贝叶斯分类器，我们需要使用名为<em>scikit learn</em>的python库。 在scikit学习包中，有三种类型的朴素贝叶斯模型被称为Gaussian，Multinomial和Bernoulli。</p> 
 <p>要构建朴素贝叶斯机器学习分类器模型，需要以下“减号”</p> 
 <p><strong>数据集</strong></p> 
 <p>我们将使用名为<a target="_blank" href="http://scikit-learn.org/stable/datasets/index.html#breast-cancer-wisconsin-diagnostic-database" title="Breast Cancer Wisconsin Diagnostic Database数据集">Breast Cancer Wisconsin Diagnostic Database数据集</a>。 数据集包括有关乳腺癌肿瘤的各种信息，以及恶性或良性分类标签。 该数据集在569个肿瘤上具有569个实例或数据，并且包括关于30个属性或特征(诸如肿瘤的半径，纹理，光滑度和面积)的信息。可以从<code>sklearn</code>包中导入这个数据集。</p> 
 <p><strong>朴素贝叶斯模型</strong></p> 
 <p>为了构建朴素贝叶斯分类器，需要一个朴素贝叶斯模型。 如前所述，scikit学习包中有三种类型的NaïveBayes模型，分别称为Gaussian，Multinomial和Bernoulli。 在下面的例子中，将使用高斯朴素贝叶斯模型。</p> 
 <p>通过使用上述内容，我们将建立一个朴素贝叶斯机器学习模型来使用肿瘤信息来预测肿瘤是否是恶性的或良性的。</p> 
 <p>首先，我们需要安装sklearn模块。 它可以通过以下命令完成 -</p> 
 <pre><code class="lang-python">import sklearn
</code></pre> 
 <p>现在，需要导入名为Breast Cancer Wisconsin Diagnostic Database的数据集。</p> 
 <pre><code class="lang-python">from sklearn.datasets import load_breast_cancer
</code></pre> 
 <p>现在，以下命令将加载数据集。</p> 
 <pre><code class="lang-python">data = load_breast_cancer()
</code></pre> 
 <p>数据可以按如下方式组织 -</p> 
 <pre><code class="lang-python">label_names = data['target_names']
labels = data['target']
feature_names = data['feature_names']
features = data['data']
</code></pre> 
 <p>现在，为了使它更清晰，可以在以下命令的帮助下打印类标签，第一个数据实例的标签，功能名称和功能的值 -</p> 
 <pre><code class="lang-python">print(label_names)
</code></pre> 
 <p>上述命令将分别打印恶性和良性的类名。 它显示为下面的输出 -</p> 
 <pre><code class="lang-python">['malignant' 'benign']
</code></pre> 
 <p>现在，下面给出的命令将显示它们映射到二进制值<code>0</code>和<code>1</code>。这里<code>0</code>表示恶性肿瘤，<code>1</code>表示良性癌症。 它显示为下面的输出 -</p> 
 <pre><code class="lang-python">print(labels[0])
0
</code></pre> 
 <p>以下两个命令将生成功能名称和功能值。</p> 
 <pre><code class="lang-python">print(feature_names[0])
mean radius
print(features[0])

[ 1.79900000e+01 1.03800000e+01 1.22800000e+02 1.00100000e+03
  1.18400000e-01 2.77600000e-01 3.00100000e-01 1.47100000e-01
  2.41900000e-01 7.87100000e-02 1.09500000e+00 9.05300000e-01
  8.58900000e+00 1.53400000e+02 6.39900000e-03 4.90400000e-02
  5.37300000e-02 1.58700000e-02 3.00300000e-02 6.19300000e-03
  2.53800000e+01 1.73300000e+01 1.84600000e+02 2.01900000e+03
  1.62200000e-01 6.65600000e-01 7.11900000e-01 2.65400000e-01
  4.60100000e-01 1.18900000e-01]
</code></pre> 
 <p>从以上输出可以看出，第一个数据实例是一个主要半径为<code>1.7990000e + 01</code>的恶性肿瘤。</p> 
 <p>要在未看到的数据上测试模型，我们需要将数据分解为训练和测试数据。 它可以在下面的代码的帮助下完成 -</p> 
 <pre><code class="lang-python">from sklearn.model_selection import train_test_split
</code></pre> 
 <p>上述命令将从<code>sklearn</code>中导入<code>train_test_split</code>函数，下面的命令将数据分解为训练和测试数据。 在下面的例子中，使用<code>40%</code>的数据进行测试，并将提示数据用于训练模型。</p> 
 <pre><code class="lang-python">train, test, train_labels, test_labels = 
train_test_split(features,labels,test_size = 0.40, random_state = 42)
</code></pre> 
 <p>现在，使用以下命令构建模型 -</p> 
 <pre><code class="lang-python">from sklearn.naive_bayes import GaussianNB
</code></pre> 
 <p>上述命令将从sklearn中导入<code>train_test_split</code>函数，下面的命令将数据分解为训练和测试数据。 在下面的例子中，我们使用<code>40%</code>的数据进行测试，并将提示数据用于训练模型。</p> 
 <pre><code class="lang-python">train, test, train_labels, test_labels = 
train_test_split(features,labels,test_size = 0.40, random_state = 42)
</code></pre> 
 <p>现在，使用以下命令构建模型 -</p> 
 <pre><code class="lang-python">from sklearn.naive_bayes import GaussianNB
</code></pre> 
 <p>上述命令将导入GaussianNB模块。 现在，使用下面给出的命令，需要初始化模型。</p> 
 <pre><code class="lang-python">gnb = GaussianNB()
</code></pre> 
 <p>将通过使用<code>gnb.fit()</code>将它拟合到数据来训练模型。</p> 
 <pre><code class="lang-python">model = gnb.fit(train, train_labels)
</code></pre> 
 <p>现在，通过对测试数据进行预测来评估模型，并且可以按如下方式完成 -</p> 
 <pre><code class="lang-python">preds = gnb.predict(test)
print(preds)

[1 0 0 1 1 0 0 0 1 1 1 0 1 0 1 0 1 1 1 0 1 1 0 1 1 1 1 1 1
 0 1 1 1 1 1 1 0 1 0 1 1 0 1 1 1 1 1 1 1 1 0 0 1 1 1 1 1 0 
 0 1 1 0 0 1 1 1 0 0 1 1 0 0 1 0 1 1 1 1 1 1 0 1 1 0 0 0 0 
 0 1 1 1 1 1 1 1 1 0 0 1 0 0 1 0 0 1 1 1 0 1 1 0 1 1 0 0 0 
 1 1 1 0 0 1 1 0 1 0 0 1 1 0 0 0 1 1 1 0 1 1 0 0 1 0 1 1 0 
 1 0 0 1 1 1 1 1 1 1 0 0 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 0 
 1 1 0 1 1 1 1 1 1 0 0 0 1 1 0 1 0 1 1 1 1 0 1 1 0 1 1 1 0 
 1 0 0 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 0 0 1 1 0 1]
</code></pre> 
 <p>上述<code>0</code>和<code>1</code>系列是肿瘤类别的预测值，即恶性和良性。</p> 
 <p>现在，通过比较两个数组即<code>test_labels</code>和<code>preds</code>，可以看到模型的准确性。 我们将使用<code>accuracy_score()</code>函数来确定准确性。 考虑下面的命令 -</p> 
 <pre><code class="lang-python">from sklearn.metrics import accuracy_score
print(accuracy_score(test_labels,preds))
0.951754385965
</code></pre> 
 <p>结果显示NaïveBayes分类器准确率为95.17%。</p> 
 <p>这是基于NaïveBayse高斯模型的机器学习分类器。</p> 
 <p><strong>支持向量机(SVM)</strong><br>基本上，支持向量机(SVM)是一种有监督的机器学习算法，可用于回归和分类。 SVM的主要概念是将每个数据项绘制为n维空间中的一个点，每个特征的值是特定坐标的值。以下是了解SVM概念的简单图形表示 -</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201806/0406/497140615_30599.png" alt=""></p> 
 <p>在上图中，有两个特征。 因此，首先需要在二维空间中绘制这两个变量，其中每个点都有两个坐标，称为支持向量。 该行将数据分成两个不同的分类组。 这条线将是分类器。</p> 
 <p>在这里，将使用scikit-learn和iris数据集来构建SVM分类器。 Scikitlearn库具有<code>sklearn.svm</code>模块并提供<code>sklearn.svm.svc</code>进行分类。 下面显示了基于4个特征来预测虹膜植物种类的SVM分类器。</p> 
 <p><strong>数据集</strong></p> 
 <p>我们将使用包含3个类别(每个类别为50个实例)的虹膜数据集，其中每个类别指的是一类虹膜工厂。 每个实例具有四个特征，即萼片长度，萼片宽度，花瓣长度和花瓣宽度。 下面显示了基于4个特征来预测虹膜植物分类的SVM分类器。</p> 
 <p><strong>内核</strong><br>这是SVM使用的技术。 基本上这些功能采用低维输入空间并将其转换到更高维空间。 它将不可分离的问题转换成可分离的问题。 核函数可以是线性，多项式，rbf和sigmoid中的任何一种。 在这个例子中，将使用线性内核。</p> 
 <p>现在导入下列软件包 -</p> 
 <pre><code class="lang-python">import pandas as pd
import numpy as np
from sklearn import svm, datasets
import matplotlib.pyplot as plt
</code></pre> 
 <p>现在，加载输入数据 -</p> 
 <pre><code class="lang-python">iris = datasets.load_iris()
</code></pre> 
 <p>我们使用前两个功能 -</p> 
 <pre><code class="lang-python">X = iris.data[:, :2]
y = iris.target
</code></pre> 
 <p>我们将用原始数据绘制支持向量机边界，创建一个网格来绘制。</p> 
 <pre><code class="lang-python">x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1
y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1
h = (x_max / x_min)/100
xx, yy = np.meshgrid(np.arange(x_min, x_max, h),
np.arange(y_min, y_max, h))
X_plot = np.c_[xx.ravel(), yy.ravel()]
</code></pre> 
 <p>需要给出正则化参数的值。</p> 
 <pre><code class="lang-python">C = 1.0
</code></pre> 
 <p>需要创建SVM分类器对象。参考以下代码 - </p> 
 <pre><code class="lang-python">Svc_classifier = svm_classifier.SVC(kernel='linear', 
C=C, decision_function_shape = 'ovr').fit(X, y)
Z = svc_classifier.predict(X_plot)
Z = Z.reshape(xx.shape)
plt.figure(figsize = (15, 5))
plt.subplot(121)
plt.contourf(xx, yy, Z, cmap = plt.cm.tab10, alpha = 0.3)
plt.scatter(X[:, 0], X[:, 1], c = y, cmap = plt.cm.Set1)
plt.xlabel('Sepal length')
plt.ylabel('Sepal width')
plt.xlim(xx.min(), xx.max())
plt.title('SVC with linear kernel')
</code></pre> 
 <p>执行后得到以下结果 -</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201806/0406/691140623_65871.png" alt=""></p> 
 <h2 id="h2-u903Bu8F91u56DEu5F52"><a name="逻辑回归" class="reference-link"></a><span class="header-link octicon octicon-link"></span>逻辑回归</h2>
 <p>基本上，逻辑回归模型是监督分类算法族的成员之一。 Logistic回归通过使用逻辑函数估计概率来测量因变量和自变量之间的关系。</p> 
 <p>在这里，如果我们讨论依赖变量和独立变量，那么因变量就是要预测的目标类变量，另一方面，自变量是用来预测目标类的特征。</p> 
 <p>在逻辑回归中，估计概率意味着预测事件的可能性发生。例如，店主想要预测进入商店的顾客将购买游戏站(例如)或不购买。顾客将会观察到许多顾客的特征 - 性别，年龄等，以便预测可能性的发生，即购买游戏站或不购物。逻辑函数是用来构建具有各种参数的函数的S形曲线。</p> 
 <p><strong>前提条件</strong></p> 
 <p>在使用逻辑回归构建分类器之前，我们需要在系统上安装Tkinter软件包。 它可以从 <a target="_blank" href="https://docs.python.org/2/library/tkinter.html">https://docs.python.org/2/library/tkinter.html</a> 进行安装。</p> 
 <p>现在，在下面给出的代码的帮助下，可以使用逻辑回归来创建分类器 - </p> 
 <p>首先，导入一些软件包 -</p> 
 <pre><code class="lang-python">import numpy as np
from sklearn import linear_model
import matplotlib.pyplot as plt
</code></pre> 
 <p>现在，需要定义可以完成的样本数据，如下所示 -</p> 
 <pre><code class="lang-python">X = np.array([[2, 4.8], [2.9, 4.7], [2.5, 5], [3.2, 5.5], [6, 5], [7.6, 4],
              [3.2, 0.9], [2.9, 1.9],[2.4, 3.5], [0.5, 3.4], [1, 4], [0.9, 5.9]])
y = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3])
</code></pre> 
 <p>接下来，我们需要创建逻辑回归分类器，可以按如下方式完成 -</p> 
 <pre><code class="lang-python">Classifier_LR = linear_model.LogisticRegression(solver = 'liblinear', C = 75)
</code></pre> 
 <p>最后但重要的是，我们需要训练这个分类器 -</p> 
 <pre><code class="lang-python">Classifier_LR.fit(X, y)
</code></pre> 
 <p>现在，我们如何可视化输出？ 可以通过创建一个名为<code>Logistic_visualize()</code>的函数来完成 -</p> 
 <pre><code class="lang-python">Def Logistic_visualize(Classifier_LR, X, y):
   min_x, max_x = X[:, 0].min() - 1.0, X[:, 0].max() + 1.0
   min_y, max_y = X[:, 1].min() - 1.0, X[:, 1].max() + 1.0
</code></pre> 
 <p>在上面的行中，我们定义了在网格中使用的最小值和最大值<code>X</code>和<code>Y</code>。另外，还将定义绘制网格的步长。</p>   
 <pre><code class="lang-python">mesh_step_size = 0.02
</code></pre> 
 <p>下面定义<code>X</code>和<code>Y</code>值的网格，如下所示 -</p> 
 <pre><code class="lang-python">x_vals, y_vals = np.meshgrid(np.arange(min_x, max_x, mesh_step_size),
                 np.arange(min_y, max_y, mesh_step_size))
</code></pre> 
 <p>使用以下代码，可以在网格网格上运行分类器 -</p> 
 <pre><code class="lang-python">output = classifier.predict(np.c_[x_vals.ravel(), y_vals.ravel()])
output = output.reshape(x_vals.shape)
plt.figure()
plt.pcolormesh(x_vals, y_vals, output, cmap = plt.cm.gray)

plt.scatter(X[:, 0], X[:, 1], c = y, s = 75, edgecolors = 'black', 
linewidth=1, cmap = plt.cm.Paired)
</code></pre> 
 <p>以下代码行将指定图的边界 - </p> 
 <pre><code class="lang-python">plt.xlim(x_vals.min(), x_vals.max())
plt.ylim(y_vals.min(), y_vals.max())
plt.xticks((np.arange(int(X[:, 0].min() - 1), int(X[:, 0].max() + 1), 1.0)))
plt.yticks((np.arange(int(X[:, 1].min() - 1), int(X[:, 1].max() + 1), 1.0)))
plt.show()
</code></pre> 
 <p>现在，在运行代码之后，我们将得到以下输出，逻辑回归分类器 -<br><img src="http://www.yiibai.com/uploads/images/201806/0406/445060656_31191.jpg" alt=""></p> 
 <h2 id="h2-u51B3u7B56u6811u5206u7C7Bu5668"><a name="决策树分类器" class="reference-link"></a><span class="header-link octicon octicon-link"></span>　决策树分类器</h2>
 <p>决策树基本上是一个二叉树流程图，其中每个节点根据某个特征变量分割一组观察值。</p> 
 <p>在这里，我们正在构建一个用于预测男性或女性的决策树分类器。这里将采取一个非常小的数据集，有19个样本。 这些样本将包含两个特征 - “身高”和“头发长度”。</p> 
 <p><strong>前提条件</strong></p> 
 <p>为了构建以下分类器，我们需要安装<code>pydotplus</code>和<code>graphviz</code>。 基本上，graphviz是使用点文件绘制图形的工具，pydotplus是Graphviz的Dot语言模块。 它可以与包管理器或使用pip来安装。</p> 
 <p>现在，可以在以下Python代码的帮助下构建决策树分类器 - </p> 
 <p>首先，导入一些重要的库如下 -</p> 
 <pre><code class="lang-python">import pydotplus
from sklearn import tree
from sklearn.datasets import load_iris
from sklearn.metrics import classification_report
from sklearn import cross_validation
import collections
</code></pre> 
 <p>现在，提供如下数据集 -</p> 
 <pre><code class="lang-python">X = [[165,19],[175,32],[136,35],[174,65],[141,28],[176,15],[131,32],
[166,6],[128,32],[179,10],[136,34],[186,2],[126,25],[176,28],[112,38],
[169,9],[171,36],[116,25],[196,25]]

Y = ['Man','Woman','Woman','Man','Woman','Man','Woman','Man','Woman',
'Man','Woman','Man','Woman','Woman','Woman','Man','Woman','Woman','Man']
data_feature_names = ['height','length of hair']

X_train, X_test, Y_train, Y_test = cross_validation.train_test_split
(X, Y, test_size=0.40, random_state=5)
</code></pre> 
 <p>在提供数据集之后，需要拟合可以如下完成的模型 -</p> 
 <pre><code class="lang-python">clf = tree.DecisionTreeClassifier()
clf = clf.fit(X,Y)
</code></pre> 
 <p>预测可以使用以下Python代码来完成 -</p> 
 <pre><code class="lang-python">prediction = clf.predict([[133,37]])
print(prediction)
</code></pre> 
 <p>使用以下Python代码来实现可视化决策树 -</p> 
 <pre><code class="lang-python">dot_data = tree.export_graphviz(clf,feature_names = data_feature_names,
            out_file = None,filled = True,rounded = True)
graph = pydotplus.graph_from_dot_data(dot_data)
colors = ('orange', 'yellow')
edges = collections.defaultdict(list)

for edge in graph.get_edge_list():
edges[edge.get_source()].append(int(edge.get_destination()))

for edge in edges: edges[edge].sort()

for i in range(2):dest = graph.get_node(str(edges[edge][i]))[0]
dest.set_fillcolor(colors[i])
graph.write_png('Decisiontree16.png')
</code></pre> 
 <p>它会将上述代码的预测作为[‘Woman’]并创建以下决策树 -</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201806/0406/395070601_29011.jpg" alt=""></p> 
 <p>可以改变预测中的特征值来测试它。</p> 
 <h2 id="h2-u968Fu673Au68EEu6797u5206u7C7Bu5668"><a name="随机森林分类器" class="reference-link"></a><span class="header-link octicon octicon-link"></span>随机森林分类器</h2>
 <p>集成方法是将机器学习模型组合成更强大的机器学习模型的方法。 随机森林是决策树的集合，就是其中之一。 它比单一决策树好，因为在保留预测能力的同时，通过平均结果可以减少过度拟合。 在这里，我们将在scikit学习癌症数据集上实施随机森林模型。</p> 
 <p>导入必要的软件包 -</p> 
 <pre><code class="lang-python">from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.datasets import load_breast_cancer
cancer = load_breast_cancer()
import matplotlib.pyplot as plt
import numpy as np
</code></pre> 
 <p>现在，需要按照以下方式提供数据集</p> 
 <pre><code class="lang-python">cancer = load_breast_cancer()
X_train, X_test, y_train,
y_test = train_test_split(cancer.data, cancer.target, random_state = 0)
</code></pre> 
 <p>在提供数据集之后，需要拟合可以如下完成的模型 -</p> 
 <pre><code class="lang-python">forest = RandomForestClassifier(n_estimators = 50, random_state = 0)
forest.fit(X_train,y_train)
</code></pre> 
 <p>现在，获得训练以及测试子集的准确性:如果增加估计器的数量，那么测试子集的准确性也会增加。</p> 
 <pre><code class="lang-python">print('Accuracy on the training subset:(:.3f)',format(forest.score(X_train,y_train)))
print('Accuracy on the training subset:(:.3f)',format(forest.score(X_test,y_test)))
</code></pre> 
 <p>上面代码，输出结果如下所示 - </p> 
 <pre><code class="lang-python">Accuracy on the training subset:(:.3f) 1.0
Accuracy on the training subset:(:.3f) 0.965034965034965
</code></pre> 
 <p>现在，与决策树一样，随机森林具有<code>feature_importance</code>模块，它将提供比决策树更好的特征权重视图。 它可以如下绘制和可视化 -</p> 
 <pre><code class="lang-python">n_features = cancer.data.shape[1]
plt.barh(range(n_features),forest.feature_importances_, align='center')
plt.yticks(np.arange(n_features),cancer.feature_names)
plt.xlabel('Feature Importance')
plt.ylabel('Feature')
plt.show()
</code></pre> 
 <p>执行上面代码，得到以下输出结果 - </p> 
 <p><img src="http://www.yiibai.com/uploads/images/201806/0406/881070606_20974.jpg" alt=""></p> 
 <h2 id="h2-u5206u7C7Bu5668u7684u6027u80FD"><a name="分类器的性能" class="reference-link"></a><span class="header-link octicon octicon-link"></span>分类器的性能</h2>
 <p>在实现机器学习算法之后，我们需要找出模型的有效性。 衡量有效性的标准可以基于数据集和度量标准。 为了评估不同的机器学习算法，我们可以使用不同的性能指标。 例如，假设使用分类器来区分不同对象的图像，可以使用分类性能指标，如平均准确率，AUC等。从某种意义上说，我们选择评估机器学习模型的指标是非常重要的，因为指标的选择会影响机器学习算法的性能如何被测量和比较。 以下是一些指标 -</p> 
 <p><strong>混乱矩阵</strong></p> 
 <p>基本上它用于输出可以是两种或更多种类的分类问题。 这是衡量分类器性能的最简单方法。 混淆矩阵基本上是一个包含两个维度即“实际”和“预测”的表格。 这两个维度都有“真正的正面(TP)”，“真正的负面(TN)”，“错误的正面(FP)”，“错误的否定(FN)”。</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201806/0406/305070607_65599.jpg" alt=""></p> 
 <p>在上面的混淆矩阵中，<code>1</code>表示正类，<code>0</code>表示负类。<br>以下是与混淆矩阵相关的术语 -</p> 
 <ul> 
  <li>真正 - 当实际的数据点类别为1并且预测也为1时，TP就是这种情况。</li>
  <li>真负 - 当数据点的实际类别为0并且预测也为0时，TN就是这种情况。</li>
  <li>假正 - 当实际的数据点类别为0并且预测也为1时，FP就是这种情况。</li>
  <li>假负 - FN是数据点的实际类别为1且预测也为<code>0</code>的情况。</li>
 </ul> 
 <p><strong>准确性</strong></p> 
 <p>混淆矩阵本身并不是一个性能指标，但几乎所有的性能矩阵均基于混淆矩阵。 其中之一是准确性。 在分类问题中，它可能被定义为由模型对各种预测所做的正确预测的数量。 计算准确度的公式如下 -<br><img src="http://www.yiibai.com/uploads/images/201806/0406/883080646_38367.png" alt=""></p> 
 <p><strong>精确</strong><br>它主要用于文件检索。 它可能被定义为返回的文件有多少是正确的。 以下是计算精度的公式 -<br><img src="http://www.yiibai.com/uploads/images/201806/0406/879080647_61166.png" alt=""></p> 
 <p><strong>召回或灵敏度</strong><br>它可能被定义为模型返回的正数有多少。 以下是计算模型召回/灵敏度的公式 -</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201806/0406/166080647_70890.png" alt=""></p> 
 <p><strong>特异性</strong><br>它可以定义为模型返回的负数有多少。 这与召回完全相反。 以下是计算模型特异性的公式 -</p> 
 <p><img src="http://www.yiibai.com/uploads/images/201806/0406/131080648_79597.png" alt=""></p> 
 <h2 id="h2-u5206u7C7Bu5931u8861u95EEu9898"><a name="分类失衡问题" class="reference-link"></a><span class="header-link octicon octicon-link"></span>分类失衡问题</h2>
 <p>分类不平衡是属于一个类别的观察数量显着低于属于其他类别的观测数量的场景。 例如，在我们需要识别罕见疾病，银行欺诈性交易等情况下，这个问题非常突出。</p> 
 <p><strong>不平衡分类的例子</strong><br>让我们考虑一个欺诈检测数据集的例子来理解不平衡分类的概念 -</p> 
 <pre><code class="lang-python">Total observations = 5000
Fraudulent Observations = 50
Non-Fraudulent Observations = 4950
Event Rate = 1%
</code></pre> 
 <p><strong>解决</strong><br>平衡类的行为，解决不平衡的类问题。 平衡类的主要目标是增加少数类的频率或减少多数类的频率。 以下是解决失衡类问题的方法 -</p> 
 <p><strong>重采样</strong><br>重新采样是用于重建样本数据集的一系列方法 - 包括训练集和测试集。 重新抽样是为了提高模型的准确性。 以下是一些重新抽样技术 -</p> 
 <ul> 
  <li><strong>随机抽样</strong> - 这项技术旨在通过随机排除大多数类别的例子来平衡课堂分布。 这样做直到大多数和少数群体的实例得到平衡。</li>
 </ul> 
 <pre><code class="lang-python">Total observations = 5000
Fraudulent Observations = 50
Non-Fraudulent Observations = 4950
Event Rate = 1%
</code></pre> 
 <p>在这种情况下，我们将10%的样本从非欺诈实例中取而代之，然后将它们与欺诈实例相结合 -<br>随机抽样后的非欺诈性观察:4950的10% = 495<br>将他们与欺诈观察结合后的总观测值: 50 + 495 = 545</p> 
 <p>因此，现在，低采样后新数据集的事件率为: 9%</p> 
 <p>这种技术的主要优点是可以减少运行时间并改善存储。 但另一方面，它可以丢弃有用的信息，同时减少训练数据样本的数量。</p> 
 <ul> 
  <li><strong>随机抽样</strong> - 这种技术旨在通过复制少数类中的实例数量来平衡类分布。</li>
 </ul> 
 <pre><code class="lang-python">Total observations = 5000
Fraudulent Observations = 50
Non-Fraudulent Observations = 4950
Event Rate = 1%
</code></pre> 
 <p>如果复制50次欺诈性观察30次，那么在复制少数类别观察值后欺诈观察值将为1500。然后，在过采样后新数据中的总观察值将为:<code>4950 + 1500 = 6450</code>。因此，新数据集的事件率是:<code>1500/6450 = 23%</code>。</p> 
 <p>这种方法的主要优点是不会丢失有用的信息。 但另一方面，由于它复制了少数族群的事件，因此它有更多的过度机会。</p> 
 <h2 id="h2-u5408u594Fu6280u5DE7"><a name="合奏技巧" class="reference-link"></a><span class="header-link octicon octicon-link"></span>合奏技巧</h2>
 <p>这种方法基本上用于修改现有的分类算法，使其适用于不平衡的数据集。 在这种方法中，我们从原始数据中构建几个两阶段分类器，然后汇总它们的预测。 随机森林分类器是基于集合的分类器的一个例子。<br><img src="http://www.yiibai.com/uploads/images/201806/0406/733080655_12763.jpg" alt=""></p>
 <br>      
</div></body></html>