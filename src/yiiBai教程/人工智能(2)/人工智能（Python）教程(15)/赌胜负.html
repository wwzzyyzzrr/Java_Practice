<html><head><meta charset="utf-8"></meta></head><body><h1 class="article-title" style="text-align:center;">赌胜负</h1><div style="width:100%;float:left;" class="article-content">   
 <p>游戏(赌胜负)采用策略进行。 每个球员或球队在开始比赛前都会制定一个战略，他们必须根据目前的比赛情况改变或制定新的战略。</p> 
 <h2 id="h2-u641Cu7D22u7B97u6CD5"><a name="搜索算法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>搜索算法</h2>
 <p>考虑电脑游戏也采用与上述相同的策略。 请注意，搜索算法是计算电脑游戏策略的算法。</p> 
 <p><strong>怎么运行的</strong><br>搜索算法的目标是找到最优的一组移动，以便他们可以到达最终目的地并获胜。 这些算法使用胜出的一组条件，每场比赛都有所不同，以找到最佳的移动方式。</p> 
 <p>将电脑游戏形象化为树。 我们都知道树有节点。 从根开始，可以进入最终的获胜节点，但是具有最佳的移动路径。 这是搜索算法的工作。 这种树中的每个节点代表未来的状态。 搜索算法搜索这棵树，在游戏的每个步骤或节点做出决定。</p> 
 <h2 id="h2-u7EC4u5408u641Cu7D22"><a name="组合搜索" class="reference-link"></a><span class="header-link octicon octicon-link"></span>组合搜索</h2>
 <p>使用搜索算法的主要缺点是它们本质上是穷尽的，这就是为什么他们探索整个搜索空间以找到导致资源浪费的解决方案。如果这些算法需要搜索整个搜索空间以找到最终解决方案，那将更加麻烦。</p> 
 <p>要消除这样的问题，可以使用组合搜索，它使用启发式来探索搜索空间，并通过消除可能的错误动作来减小其大小。 因此，这样的算法可以节省资源。 这里讨论了一些使用启发式搜索空间并节省资源的算法 -</p> 
 <h2 id="h2-minimax-"><a name="Minimax算法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Minimax算法</h2>
 <p>这是组合搜索使用启发式策略加快搜索策略的策略。 Minimax策略的概念可以通过两个玩家游戏的例子来理解，其中每个玩家都试图预测对手的下一步行动并尝试最小化该功能。 而且，为了获胜，玩家总是会根据当前的情况尝试最大化自己的功能。</p> 
 <p>启发式在像Minimax这样的策略中扮演着重要的角色。 树的每个节点都会有一个与之相关的启发式函数。 基于这种启发式方法，它将决定向最有利于他们的节点迈进。</p> 
 <h2 id="h2-alpha-beta-"><a name="Alpha-Beta修剪" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Alpha-Beta修剪</h2>
 <p>Minimax算法的一个主要问题是它可以探索那些无关的树的部分，导致资源的浪费。 因此，必须有一个策略来决定树的哪一部分是相关的，哪一个是无关紧要的，并且将不相关的部分留给未开发的部分。 Alpha-Beta修剪就是这样一种策略。</p> 
 <p>Alpha-Beta修剪算法的主要目标是避免搜索树中没有任何解决方案的那些部分。 Alpha-Beta修剪的主要概念是使用名为Alpha的两个边界(最大下界)和Beta，即最小上界。 这两个参数是限制可能解决方案集合的值。 它将当前节点的值与alpha和beta参数的值进行比较，以便它可以移动到具有解决方案的树部分并丢弃其余部分。</p> 
 <h2 id="h2-negamax-"><a name="Negamax算法" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Negamax算法</h2>
 <p>这个算法与Minimax算法没有区别，但它具有更优雅的实现。 使用Minimax算法的主要缺点是需要定义两个不同的启发式函数。 这些启发式之间的联系是，对于一个玩家来说游戏的状态越好，对另一个玩家来说就越糟糕。 在Negamax算法中，两个启发函数的相同工作是在单个启发式函数的帮助下完成的。</p> 
 <h2 id="h2-u5EFAu8BBEu673Au5668u4EBAu73A9u6E38u620F"><a name="建设机器人玩游戏" class="reference-link"></a><span class="header-link octicon octicon-link"></span>建设机器人玩游戏</h2>
 <p>要在AI中构建机器人玩两个玩家游戏，需要安装easyAI库。 这是一个人工智能框架，提供了构建双人游戏的所有功能。 可以通过以下命令下载它 -</p> 
 <pre><code class="lang-python">pip install easyAI
</code></pre> 
 <h2 id="h2-u4E00u4E2Au673Au5668u4EBAu73A9u6700u540Eu7684u786Cu5E01"><a name="一个机器人玩最后的硬币" class="reference-link"></a><span class="header-link octicon octicon-link"></span>一个机器人玩最后的硬币</h2>
 <p>在这场比赛中，会有一堆硬币。 每个玩家必须从该堆中取出一些硬币。这场比赛的目标是避免拿下最后一枚硬币。 我们将使用继承自easyAI库的TwoPlayersGame类的LastCoinStanding类。 以下代码显示了此游戏的Python代码 - </p> 
 <p>如下所示导入所需的软件包 -</p> 
 <pre><code class="lang-python">from easyAI import TwoPlayersGame, id_solve, Human_Player, AI_Player
from easyAI.AI import TT
</code></pre> 
 <p>现在，继承TwoPlayerGame类中的类来处理游戏的所有操作 -</p> 
 <pre><code class="lang-python">class LastCoin_game(TwoPlayersGame):
    def __init__(self, players):
</code></pre> 
 <p>定义要玩家并开始游戏。</p> 
 <pre><code class="lang-python">self.players = players
self.nplayer = 1
</code></pre> 
 <p>定义游戏中的硬币数量，这里使用15个硬币进行游戏。</p> 
 <pre><code class="lang-python">self.num_coins = 15
</code></pre> 
 <p>定义玩家在移动中可以获得的最大硬币数量。</p> 
 <pre><code class="lang-python">self.max_coins = 4
</code></pre> 
 <p>现在有一些东西需要定义，如下面的代码所示。 定义可能的移动。</p> 
 <pre><code class="lang-python">def possible_moves(self):
   return [str(a) for a in range(1, self.max_coins + 1)]
</code></pre> 
 <p>定义硬币的清除 - </p> 
 <pre><code class="lang-python">def make_move(self, move):
   self.num_coins -= int(move)
</code></pre> 
 <p>定义谁拿走了最后一枚硬币。</p> 
 <pre><code class="lang-python">def win_game(self):
   return self.num_coins &lt;= 0
</code></pre> 
 <p>定义何时停止游戏，即何时有人获胜。</p> 
 <pre><code class="lang-python">def is_over(self):
   return self.win()
</code></pre> 
 <p>定义如何计算分数。</p> 
 <pre><code class="lang-python">def score(self):
   return 100 if self.win_game() else 0
</code></pre> 
 <p>定义堆中剩余的硬币数量。</p> 
 <pre><code class="lang-python">def show(self):
   print(self.num_coins, 'coins left in the pile')
if __name__ == "__main__":
   tt = TT()
   LastCoin_game.ttentry = lambda self: self.num_coins
</code></pre> 
 <p>用下面的代码块解决游戏 -</p>   
 <pre><code class="lang-python">r, d, m = id_solve(LastCoin_game,
   range(2, 20), win_score=100, tt=tt)
print(r, d, m)
</code></pre> 
 <p>决定谁将开始游戏 </p> 
 <pre><code class="lang-python">game = LastCoin_game([AI_Player(tt), Human_Player()])
game.play()
</code></pre> 
 <p>下面的输出演示这个游戏的简单玩法 -</p> 
 <pre><code class="lang-python">d:2, a:0, m:1
d:3, a:0, m:1
d:4, a:0, m:1
d:5, a:0, m:1
d:6, a:100, m:4
1 6 4
15 coins left in the pile
Move #1: player 1 plays 4 :
11 coins left in the pile
Player 2 what do you play ? 2
Move #2: player 2 plays 2 :
9 coins left in the pile
Move #3: player 1 plays 3 :
6 coins left in the pile
Player 2 what do you play ? 1
Move #4: player 2 plays 1 :
5 coins left in the pile
Move #5: player 1 plays 4 :
1 coins left in the pile
Player 2 what do you play ? 1
Move #6: player 2 plays 1 :
0 coins left in the pile
</code></pre> 
 <h2 id="h2-u673Au5668u4EBAu73A9u4E95u5B57u6E38u620F"><a name="机器人玩井字游戏" class="reference-link"></a><span class="header-link octicon octicon-link"></span>机器人玩井字游戏</h2>
 <p>Tic-Tac-Toe非常熟悉，是最受欢迎的游戏之一。我们通过使用Python中的easyAI库来创建这个游戏。 以下代码是这款游戏的Python代码 - </p> 
 <p>如下所示导入软件包 -</p> 
 <pre><code class="lang-python">from easyAI import TwoPlayersGame, AI_Player, Negamax
from easyAI.Player import Human_Player
</code></pre> 
 <p>继承<code>TwoPlayerGame</code>中的类来处理游戏的所有操作 -</p> 
 <pre><code class="lang-python">class TicTacToe_game(TwoPlayersGame):
   def __init__(self, players):
</code></pre> 
 <p>现在，定义玩家并开始游戏 -</p> 
 <pre><code class="lang-python">self.players = players
self.nplayer = 1
</code></pre> 
 <p>定义板的类型 -</p> 
 <pre><code class="lang-python">self.board = [0] * 9
</code></pre> 
 <p>定义可能的举措(动作)</p> 
 <pre><code class="lang-python">def possible_moves(self):
    return [x + 1 for x, y in enumerate(self.board) if y == 0]
</code></pre> 
 <p>定义一个玩家的举措(动作) -</p> 
 <pre><code class="lang-python">def make_move(self, move):
    self.board[int(move) - 1] = self.nplayer
</code></pre> 
 <p>定义一个玩家何时进行移动 -</p> 
 <pre><code class="lang-python">def umake_move(self, move):
   self.board[int(move) - 1] = 0
</code></pre> 
 <p>定义输条件是对手在一条线上有三个 - </p> 
 <pre><code class="lang-python">def condition_for_lose(self):
   possible_combinations = [[1,2,3], [4,5,6], [7,8,9],
      [1,4,7], [2,5,8], [3,6,9], [1,5,9], [3,5,7]]
   return any([all([(self.board[z-1] == self.nopponent)
      for z in combination]) for combination in possible_combinations])
</code></pre> 
 <p>定义游戏结束的条件 - </p> 
 <pre><code class="lang-python">def is_over(self):
   return (self.possible_moves() == []) or self.condition_for_lose()
</code></pre> 
 <p>显示玩家在游戏中的当前位置 -</p> 
 <pre><code class="lang-python">def show(self):
   print('\n'+'\n'.join([' '.join([['.', 'O', 'X'][self.board[3*j + i]]
      for i in range(3)]) for j in range(3)]))
</code></pre> 
 <p>计算分数代码 - </p> 
 <pre><code class="lang-python">def scoring(self):
   return -100 if self.condition_for_lose() else 0
</code></pre> 
 <p>定义定义算法并开始游戏的主要方法 -</p> 
 <pre><code class="lang-python">if __name__ == "__main__":
   algo = Negamax(7)
   TicTacToe_game([Human_Player(), AI_Player(algo)]).play()
</code></pre> 
 <p>可以看到下面的输出和这个游戏的简单玩法 -</p> 
 <pre><code class="lang-shell">. . .
. . .
. . .
Player 1 what do you play ? 1
Move #1: player 1 plays 1 :
O . .
. . .
. . .
Move #2: player 2 plays 5 :
O . .
. X .
121
. . .
Player 1 what do you play ? 3
Move #3: player 1 plays 3 :
O . O
. X .
. . .
Move #4: player 2 plays 2 :
O X O
. X .
. . .
Player 1 what do you play ? 4
Move #5: player 1 plays 4 :
O X O
O X .
. . .
Move #6: player 2 plays 8 :
O X O
O X .
. X .
</code></pre>
 <br>      
</div></body></html>